(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all10) => {
    for (var name in all10)
      __defProp(target, name, { get: all10[name], enumerable: true });
  };
  var __copyProps = (to2, from4, except, desc) => {
    if (from4 && typeof from4 === "object" || typeof from4 === "function") {
      for (let key2 of __getOwnPropNames(from4))
        if (!__hasOwnProp.call(to2, key2) && key2 !== except)
          __defProp(to2, key2, { get: () => from4[key2], enumerable: !(desc = __getOwnPropDesc(from4, key2)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/devlop/lib/default.js
  function deprecate(fn2) {
    return fn2;
  }
  function equal() {
  }
  function ok() {
  }
  function unreachable() {
  }
  var init_default = __esm({
    "node_modules/devlop/lib/default.js"() {
    }
  });

  // node_modules/property-information/lib/util/schema.js
  var Schema;
  var init_schema = __esm({
    "node_modules/property-information/lib/util/schema.js"() {
      Schema = class {
        /**
         * @param {SchemaType['property']} property
         *   Property.
         * @param {SchemaType['normal']} normal
         *   Normal.
         * @param {Space | undefined} [space]
         *   Space.
         * @returns
         *   Schema.
         */
        constructor(property, normal, space2) {
          this.normal = normal;
          this.property = property;
          if (space2) {
            this.space = space2;
          }
        }
      };
      Schema.prototype.normal = {};
      Schema.prototype.property = {};
      Schema.prototype.space = void 0;
    }
  });

  // node_modules/property-information/lib/util/merge.js
  function merge(definitions, space2) {
    const property = {};
    const normal = {};
    for (const definition3 of definitions) {
      Object.assign(property, definition3.property);
      Object.assign(normal, definition3.normal);
    }
    return new Schema(property, normal, space2);
  }
  var init_merge = __esm({
    "node_modules/property-information/lib/util/merge.js"() {
      init_schema();
    }
  });

  // node_modules/property-information/lib/normalize.js
  function normalize(value) {
    return value.toLowerCase();
  }
  var init_normalize = __esm({
    "node_modules/property-information/lib/normalize.js"() {
    }
  });

  // node_modules/property-information/lib/util/info.js
  var Info;
  var init_info = __esm({
    "node_modules/property-information/lib/util/info.js"() {
      Info = class {
        /**
         * @param {string} property
         *   Property.
         * @param {string} attribute
         *   Attribute.
         * @returns
         *   Info.
         */
        constructor(property, attribute) {
          this.attribute = attribute;
          this.property = property;
        }
      };
      Info.prototype.attribute = "";
      Info.prototype.booleanish = false;
      Info.prototype.boolean = false;
      Info.prototype.commaOrSpaceSeparated = false;
      Info.prototype.commaSeparated = false;
      Info.prototype.defined = false;
      Info.prototype.mustUseProperty = false;
      Info.prototype.number = false;
      Info.prototype.overloadedBoolean = false;
      Info.prototype.property = "";
      Info.prototype.spaceSeparated = false;
      Info.prototype.space = void 0;
    }
  });

  // node_modules/property-information/lib/util/types.js
  var types_exports = {};
  __export(types_exports, {
    boolean: () => boolean,
    booleanish: () => booleanish,
    commaOrSpaceSeparated: () => commaOrSpaceSeparated,
    commaSeparated: () => commaSeparated,
    number: () => number,
    overloadedBoolean: () => overloadedBoolean,
    spaceSeparated: () => spaceSeparated
  });
  function increment() {
    return 2 ** ++powers;
  }
  var powers, boolean, booleanish, overloadedBoolean, number, spaceSeparated, commaSeparated, commaOrSpaceSeparated;
  var init_types = __esm({
    "node_modules/property-information/lib/util/types.js"() {
      powers = 0;
      boolean = increment();
      booleanish = increment();
      overloadedBoolean = increment();
      number = increment();
      spaceSeparated = increment();
      commaSeparated = increment();
      commaOrSpaceSeparated = increment();
    }
  });

  // node_modules/property-information/lib/util/defined-info.js
  function mark(values, key2, value) {
    if (value) {
      values[key2] = value;
    }
  }
  var checks, DefinedInfo;
  var init_defined_info = __esm({
    "node_modules/property-information/lib/util/defined-info.js"() {
      init_info();
      init_types();
      checks = /** @type {ReadonlyArray<keyof typeof types>} */
      Object.keys(types_exports);
      DefinedInfo = class extends Info {
        /**
         * @constructor
         * @param {string} property
         *   Property.
         * @param {string} attribute
         *   Attribute.
         * @param {number | null | undefined} [mask]
         *   Mask.
         * @param {Space | undefined} [space]
         *   Space.
         * @returns
         *   Info.
         */
        constructor(property, attribute, mask, space2) {
          let index3 = -1;
          super(property, attribute);
          mark(this, "space", space2);
          if (typeof mask === "number") {
            while (++index3 < checks.length) {
              const check = checks[index3];
              mark(this, checks[index3], (mask & types_exports[check]) === types_exports[check]);
            }
          }
        }
      };
      DefinedInfo.prototype.defined = true;
    }
  });

  // node_modules/property-information/lib/util/create.js
  function create(definition3) {
    const properties = {};
    const normals = {};
    for (const [property, value] of Object.entries(definition3.properties)) {
      const info = new DefinedInfo(
        property,
        definition3.transform(definition3.attributes || {}, property),
        value,
        definition3.space
      );
      if (definition3.mustUseProperty && definition3.mustUseProperty.includes(property)) {
        info.mustUseProperty = true;
      }
      properties[property] = info;
      normals[normalize(property)] = property;
      normals[normalize(info.attribute)] = property;
    }
    return new Schema(properties, normals, definition3.space);
  }
  var init_create = __esm({
    "node_modules/property-information/lib/util/create.js"() {
      init_normalize();
      init_defined_info();
      init_schema();
    }
  });

  // node_modules/property-information/lib/aria.js
  var aria;
  var init_aria = __esm({
    "node_modules/property-information/lib/aria.js"() {
      init_create();
      init_types();
      aria = create({
        properties: {
          ariaActiveDescendant: null,
          ariaAtomic: booleanish,
          ariaAutoComplete: null,
          ariaBusy: booleanish,
          ariaChecked: booleanish,
          ariaColCount: number,
          ariaColIndex: number,
          ariaColSpan: number,
          ariaControls: spaceSeparated,
          ariaCurrent: null,
          ariaDescribedBy: spaceSeparated,
          ariaDetails: null,
          ariaDisabled: booleanish,
          ariaDropEffect: spaceSeparated,
          ariaErrorMessage: null,
          ariaExpanded: booleanish,
          ariaFlowTo: spaceSeparated,
          ariaGrabbed: booleanish,
          ariaHasPopup: null,
          ariaHidden: booleanish,
          ariaInvalid: null,
          ariaKeyShortcuts: null,
          ariaLabel: null,
          ariaLabelledBy: spaceSeparated,
          ariaLevel: number,
          ariaLive: null,
          ariaModal: booleanish,
          ariaMultiLine: booleanish,
          ariaMultiSelectable: booleanish,
          ariaOrientation: null,
          ariaOwns: spaceSeparated,
          ariaPlaceholder: null,
          ariaPosInSet: number,
          ariaPressed: booleanish,
          ariaReadOnly: booleanish,
          ariaRelevant: null,
          ariaRequired: booleanish,
          ariaRoleDescription: spaceSeparated,
          ariaRowCount: number,
          ariaRowIndex: number,
          ariaRowSpan: number,
          ariaSelected: booleanish,
          ariaSetSize: number,
          ariaSort: null,
          ariaValueMax: number,
          ariaValueMin: number,
          ariaValueNow: number,
          ariaValueText: null,
          role: null
        },
        transform(_2, property) {
          return property === "role" ? property : "aria-" + property.slice(4).toLowerCase();
        }
      });
    }
  });

  // node_modules/property-information/lib/util/case-sensitive-transform.js
  function caseSensitiveTransform(attributes, attribute) {
    return attribute in attributes ? attributes[attribute] : attribute;
  }
  var init_case_sensitive_transform = __esm({
    "node_modules/property-information/lib/util/case-sensitive-transform.js"() {
    }
  });

  // node_modules/property-information/lib/util/case-insensitive-transform.js
  function caseInsensitiveTransform(attributes, property) {
    return caseSensitiveTransform(attributes, property.toLowerCase());
  }
  var init_case_insensitive_transform = __esm({
    "node_modules/property-information/lib/util/case-insensitive-transform.js"() {
      init_case_sensitive_transform();
    }
  });

  // node_modules/property-information/lib/html.js
  var html;
  var init_html = __esm({
    "node_modules/property-information/lib/html.js"() {
      init_case_insensitive_transform();
      init_create();
      init_types();
      html = create({
        attributes: {
          acceptcharset: "accept-charset",
          classname: "class",
          htmlfor: "for",
          httpequiv: "http-equiv"
        },
        mustUseProperty: ["checked", "multiple", "muted", "selected"],
        properties: {
          // Standard Properties.
          abbr: null,
          accept: commaSeparated,
          acceptCharset: spaceSeparated,
          accessKey: spaceSeparated,
          action: null,
          allow: null,
          allowFullScreen: boolean,
          allowPaymentRequest: boolean,
          allowUserMedia: boolean,
          alt: null,
          as: null,
          async: boolean,
          autoCapitalize: null,
          autoComplete: spaceSeparated,
          autoFocus: boolean,
          autoPlay: boolean,
          blocking: spaceSeparated,
          capture: null,
          charSet: null,
          checked: boolean,
          cite: null,
          className: spaceSeparated,
          cols: number,
          colSpan: null,
          content: null,
          contentEditable: booleanish,
          controls: boolean,
          controlsList: spaceSeparated,
          coords: number | commaSeparated,
          crossOrigin: null,
          data: null,
          dateTime: null,
          decoding: null,
          default: boolean,
          defer: boolean,
          dir: null,
          dirName: null,
          disabled: boolean,
          download: overloadedBoolean,
          draggable: booleanish,
          encType: null,
          enterKeyHint: null,
          fetchPriority: null,
          form: null,
          formAction: null,
          formEncType: null,
          formMethod: null,
          formNoValidate: boolean,
          formTarget: null,
          headers: spaceSeparated,
          height: number,
          hidden: overloadedBoolean,
          high: number,
          href: null,
          hrefLang: null,
          htmlFor: spaceSeparated,
          httpEquiv: spaceSeparated,
          id: null,
          imageSizes: null,
          imageSrcSet: null,
          inert: boolean,
          inputMode: null,
          integrity: null,
          is: null,
          isMap: boolean,
          itemId: null,
          itemProp: spaceSeparated,
          itemRef: spaceSeparated,
          itemScope: boolean,
          itemType: spaceSeparated,
          kind: null,
          label: null,
          lang: null,
          language: null,
          list: null,
          loading: null,
          loop: boolean,
          low: number,
          manifest: null,
          max: null,
          maxLength: number,
          media: null,
          method: null,
          min: null,
          minLength: number,
          multiple: boolean,
          muted: boolean,
          name: null,
          nonce: null,
          noModule: boolean,
          noValidate: boolean,
          onAbort: null,
          onAfterPrint: null,
          onAuxClick: null,
          onBeforeMatch: null,
          onBeforePrint: null,
          onBeforeToggle: null,
          onBeforeUnload: null,
          onBlur: null,
          onCancel: null,
          onCanPlay: null,
          onCanPlayThrough: null,
          onChange: null,
          onClick: null,
          onClose: null,
          onContextLost: null,
          onContextMenu: null,
          onContextRestored: null,
          onCopy: null,
          onCueChange: null,
          onCut: null,
          onDblClick: null,
          onDrag: null,
          onDragEnd: null,
          onDragEnter: null,
          onDragExit: null,
          onDragLeave: null,
          onDragOver: null,
          onDragStart: null,
          onDrop: null,
          onDurationChange: null,
          onEmptied: null,
          onEnded: null,
          onError: null,
          onFocus: null,
          onFormData: null,
          onHashChange: null,
          onInput: null,
          onInvalid: null,
          onKeyDown: null,
          onKeyPress: null,
          onKeyUp: null,
          onLanguageChange: null,
          onLoad: null,
          onLoadedData: null,
          onLoadedMetadata: null,
          onLoadEnd: null,
          onLoadStart: null,
          onMessage: null,
          onMessageError: null,
          onMouseDown: null,
          onMouseEnter: null,
          onMouseLeave: null,
          onMouseMove: null,
          onMouseOut: null,
          onMouseOver: null,
          onMouseUp: null,
          onOffline: null,
          onOnline: null,
          onPageHide: null,
          onPageShow: null,
          onPaste: null,
          onPause: null,
          onPlay: null,
          onPlaying: null,
          onPopState: null,
          onProgress: null,
          onRateChange: null,
          onRejectionHandled: null,
          onReset: null,
          onResize: null,
          onScroll: null,
          onScrollEnd: null,
          onSecurityPolicyViolation: null,
          onSeeked: null,
          onSeeking: null,
          onSelect: null,
          onSlotChange: null,
          onStalled: null,
          onStorage: null,
          onSubmit: null,
          onSuspend: null,
          onTimeUpdate: null,
          onToggle: null,
          onUnhandledRejection: null,
          onUnload: null,
          onVolumeChange: null,
          onWaiting: null,
          onWheel: null,
          open: boolean,
          optimum: number,
          pattern: null,
          ping: spaceSeparated,
          placeholder: null,
          playsInline: boolean,
          popover: null,
          popoverTarget: null,
          popoverTargetAction: null,
          poster: null,
          preload: null,
          readOnly: boolean,
          referrerPolicy: null,
          rel: spaceSeparated,
          required: boolean,
          reversed: boolean,
          rows: number,
          rowSpan: number,
          sandbox: spaceSeparated,
          scope: null,
          scoped: boolean,
          seamless: boolean,
          selected: boolean,
          shadowRootClonable: boolean,
          shadowRootDelegatesFocus: boolean,
          shadowRootMode: null,
          shape: null,
          size: number,
          sizes: null,
          slot: null,
          span: number,
          spellCheck: booleanish,
          src: null,
          srcDoc: null,
          srcLang: null,
          srcSet: null,
          start: number,
          step: null,
          style: null,
          tabIndex: number,
          target: null,
          title: null,
          translate: null,
          type: null,
          typeMustMatch: boolean,
          useMap: null,
          value: booleanish,
          width: number,
          wrap: null,
          writingSuggestions: null,
          // Legacy.
          // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
          align: null,
          // Several. Use CSS `text-align` instead,
          aLink: null,
          // `<body>`. Use CSS `a:active {color}` instead
          archive: spaceSeparated,
          // `<object>`. List of URIs to archives
          axis: null,
          // `<td>` and `<th>`. Use `scope` on `<th>`
          background: null,
          // `<body>`. Use CSS `background-image` instead
          bgColor: null,
          // `<body>` and table elements. Use CSS `background-color` instead
          border: number,
          // `<table>`. Use CSS `border-width` instead,
          borderColor: null,
          // `<table>`. Use CSS `border-color` instead,
          bottomMargin: number,
          // `<body>`
          cellPadding: null,
          // `<table>`
          cellSpacing: null,
          // `<table>`
          char: null,
          // Several table elements. When `align=char`, sets the character to align on
          charOff: null,
          // Several table elements. When `char`, offsets the alignment
          classId: null,
          // `<object>`
          clear: null,
          // `<br>`. Use CSS `clear` instead
          code: null,
          // `<object>`
          codeBase: null,
          // `<object>`
          codeType: null,
          // `<object>`
          color: null,
          // `<font>` and `<hr>`. Use CSS instead
          compact: boolean,
          // Lists. Use CSS to reduce space between items instead
          declare: boolean,
          // `<object>`
          event: null,
          // `<script>`
          face: null,
          // `<font>`. Use CSS instead
          frame: null,
          // `<table>`
          frameBorder: null,
          // `<iframe>`. Use CSS `border` instead
          hSpace: number,
          // `<img>` and `<object>`
          leftMargin: number,
          // `<body>`
          link: null,
          // `<body>`. Use CSS `a:link {color: *}` instead
          longDesc: null,
          // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
          lowSrc: null,
          // `<img>`. Use a `<picture>`
          marginHeight: number,
          // `<body>`
          marginWidth: number,
          // `<body>`
          noResize: boolean,
          // `<frame>`
          noHref: boolean,
          // `<area>`. Use no href instead of an explicit `nohref`
          noShade: boolean,
          // `<hr>`. Use background-color and height instead of borders
          noWrap: boolean,
          // `<td>` and `<th>`
          object: null,
          // `<applet>`
          profile: null,
          // `<head>`
          prompt: null,
          // `<isindex>`
          rev: null,
          // `<link>`
          rightMargin: number,
          // `<body>`
          rules: null,
          // `<table>`
          scheme: null,
          // `<meta>`
          scrolling: booleanish,
          // `<frame>`. Use overflow in the child context
          standby: null,
          // `<object>`
          summary: null,
          // `<table>`
          text: null,
          // `<body>`. Use CSS `color` instead
          topMargin: number,
          // `<body>`
          valueType: null,
          // `<param>`
          version: null,
          // `<html>`. Use a doctype.
          vAlign: null,
          // Several. Use CSS `vertical-align` instead
          vLink: null,
          // `<body>`. Use CSS `a:visited {color}` instead
          vSpace: number,
          // `<img>` and `<object>`
          // Non-standard Properties.
          allowTransparency: null,
          autoCorrect: null,
          autoSave: null,
          disablePictureInPicture: boolean,
          disableRemotePlayback: boolean,
          prefix: null,
          property: null,
          results: number,
          security: null,
          unselectable: null
        },
        space: "html",
        transform: caseInsensitiveTransform
      });
    }
  });

  // node_modules/property-information/lib/svg.js
  var svg;
  var init_svg = __esm({
    "node_modules/property-information/lib/svg.js"() {
      init_case_sensitive_transform();
      init_create();
      init_types();
      svg = create({
        attributes: {
          accentHeight: "accent-height",
          alignmentBaseline: "alignment-baseline",
          arabicForm: "arabic-form",
          baselineShift: "baseline-shift",
          capHeight: "cap-height",
          className: "class",
          clipPath: "clip-path",
          clipRule: "clip-rule",
          colorInterpolation: "color-interpolation",
          colorInterpolationFilters: "color-interpolation-filters",
          colorProfile: "color-profile",
          colorRendering: "color-rendering",
          crossOrigin: "crossorigin",
          dataType: "datatype",
          dominantBaseline: "dominant-baseline",
          enableBackground: "enable-background",
          fillOpacity: "fill-opacity",
          fillRule: "fill-rule",
          floodColor: "flood-color",
          floodOpacity: "flood-opacity",
          fontFamily: "font-family",
          fontSize: "font-size",
          fontSizeAdjust: "font-size-adjust",
          fontStretch: "font-stretch",
          fontStyle: "font-style",
          fontVariant: "font-variant",
          fontWeight: "font-weight",
          glyphName: "glyph-name",
          glyphOrientationHorizontal: "glyph-orientation-horizontal",
          glyphOrientationVertical: "glyph-orientation-vertical",
          hrefLang: "hreflang",
          horizAdvX: "horiz-adv-x",
          horizOriginX: "horiz-origin-x",
          horizOriginY: "horiz-origin-y",
          imageRendering: "image-rendering",
          letterSpacing: "letter-spacing",
          lightingColor: "lighting-color",
          markerEnd: "marker-end",
          markerMid: "marker-mid",
          markerStart: "marker-start",
          navDown: "nav-down",
          navDownLeft: "nav-down-left",
          navDownRight: "nav-down-right",
          navLeft: "nav-left",
          navNext: "nav-next",
          navPrev: "nav-prev",
          navRight: "nav-right",
          navUp: "nav-up",
          navUpLeft: "nav-up-left",
          navUpRight: "nav-up-right",
          onAbort: "onabort",
          onActivate: "onactivate",
          onAfterPrint: "onafterprint",
          onBeforePrint: "onbeforeprint",
          onBegin: "onbegin",
          onCancel: "oncancel",
          onCanPlay: "oncanplay",
          onCanPlayThrough: "oncanplaythrough",
          onChange: "onchange",
          onClick: "onclick",
          onClose: "onclose",
          onCopy: "oncopy",
          onCueChange: "oncuechange",
          onCut: "oncut",
          onDblClick: "ondblclick",
          onDrag: "ondrag",
          onDragEnd: "ondragend",
          onDragEnter: "ondragenter",
          onDragExit: "ondragexit",
          onDragLeave: "ondragleave",
          onDragOver: "ondragover",
          onDragStart: "ondragstart",
          onDrop: "ondrop",
          onDurationChange: "ondurationchange",
          onEmptied: "onemptied",
          onEnd: "onend",
          onEnded: "onended",
          onError: "onerror",
          onFocus: "onfocus",
          onFocusIn: "onfocusin",
          onFocusOut: "onfocusout",
          onHashChange: "onhashchange",
          onInput: "oninput",
          onInvalid: "oninvalid",
          onKeyDown: "onkeydown",
          onKeyPress: "onkeypress",
          onKeyUp: "onkeyup",
          onLoad: "onload",
          onLoadedData: "onloadeddata",
          onLoadedMetadata: "onloadedmetadata",
          onLoadStart: "onloadstart",
          onMessage: "onmessage",
          onMouseDown: "onmousedown",
          onMouseEnter: "onmouseenter",
          onMouseLeave: "onmouseleave",
          onMouseMove: "onmousemove",
          onMouseOut: "onmouseout",
          onMouseOver: "onmouseover",
          onMouseUp: "onmouseup",
          onMouseWheel: "onmousewheel",
          onOffline: "onoffline",
          onOnline: "ononline",
          onPageHide: "onpagehide",
          onPageShow: "onpageshow",
          onPaste: "onpaste",
          onPause: "onpause",
          onPlay: "onplay",
          onPlaying: "onplaying",
          onPopState: "onpopstate",
          onProgress: "onprogress",
          onRateChange: "onratechange",
          onRepeat: "onrepeat",
          onReset: "onreset",
          onResize: "onresize",
          onScroll: "onscroll",
          onSeeked: "onseeked",
          onSeeking: "onseeking",
          onSelect: "onselect",
          onShow: "onshow",
          onStalled: "onstalled",
          onStorage: "onstorage",
          onSubmit: "onsubmit",
          onSuspend: "onsuspend",
          onTimeUpdate: "ontimeupdate",
          onToggle: "ontoggle",
          onUnload: "onunload",
          onVolumeChange: "onvolumechange",
          onWaiting: "onwaiting",
          onZoom: "onzoom",
          overlinePosition: "overline-position",
          overlineThickness: "overline-thickness",
          paintOrder: "paint-order",
          panose1: "panose-1",
          pointerEvents: "pointer-events",
          referrerPolicy: "referrerpolicy",
          renderingIntent: "rendering-intent",
          shapeRendering: "shape-rendering",
          stopColor: "stop-color",
          stopOpacity: "stop-opacity",
          strikethroughPosition: "strikethrough-position",
          strikethroughThickness: "strikethrough-thickness",
          strokeDashArray: "stroke-dasharray",
          strokeDashOffset: "stroke-dashoffset",
          strokeLineCap: "stroke-linecap",
          strokeLineJoin: "stroke-linejoin",
          strokeMiterLimit: "stroke-miterlimit",
          strokeOpacity: "stroke-opacity",
          strokeWidth: "stroke-width",
          tabIndex: "tabindex",
          textAnchor: "text-anchor",
          textDecoration: "text-decoration",
          textRendering: "text-rendering",
          transformOrigin: "transform-origin",
          typeOf: "typeof",
          underlinePosition: "underline-position",
          underlineThickness: "underline-thickness",
          unicodeBidi: "unicode-bidi",
          unicodeRange: "unicode-range",
          unitsPerEm: "units-per-em",
          vAlphabetic: "v-alphabetic",
          vHanging: "v-hanging",
          vIdeographic: "v-ideographic",
          vMathematical: "v-mathematical",
          vectorEffect: "vector-effect",
          vertAdvY: "vert-adv-y",
          vertOriginX: "vert-origin-x",
          vertOriginY: "vert-origin-y",
          wordSpacing: "word-spacing",
          writingMode: "writing-mode",
          xHeight: "x-height",
          // These were camelcased in Tiny. Now lowercased in SVG 2
          playbackOrder: "playbackorder",
          timelineBegin: "timelinebegin"
        },
        properties: {
          about: commaOrSpaceSeparated,
          accentHeight: number,
          accumulate: null,
          additive: null,
          alignmentBaseline: null,
          alphabetic: number,
          amplitude: number,
          arabicForm: null,
          ascent: number,
          attributeName: null,
          attributeType: null,
          azimuth: number,
          bandwidth: null,
          baselineShift: null,
          baseFrequency: null,
          baseProfile: null,
          bbox: null,
          begin: null,
          bias: number,
          by: null,
          calcMode: null,
          capHeight: number,
          className: spaceSeparated,
          clip: null,
          clipPath: null,
          clipPathUnits: null,
          clipRule: null,
          color: null,
          colorInterpolation: null,
          colorInterpolationFilters: null,
          colorProfile: null,
          colorRendering: null,
          content: null,
          contentScriptType: null,
          contentStyleType: null,
          crossOrigin: null,
          cursor: null,
          cx: null,
          cy: null,
          d: null,
          dataType: null,
          defaultAction: null,
          descent: number,
          diffuseConstant: number,
          direction: null,
          display: null,
          dur: null,
          divisor: number,
          dominantBaseline: null,
          download: boolean,
          dx: null,
          dy: null,
          edgeMode: null,
          editable: null,
          elevation: number,
          enableBackground: null,
          end: null,
          event: null,
          exponent: number,
          externalResourcesRequired: null,
          fill: null,
          fillOpacity: number,
          fillRule: null,
          filter: null,
          filterRes: null,
          filterUnits: null,
          floodColor: null,
          floodOpacity: null,
          focusable: null,
          focusHighlight: null,
          fontFamily: null,
          fontSize: null,
          fontSizeAdjust: null,
          fontStretch: null,
          fontStyle: null,
          fontVariant: null,
          fontWeight: null,
          format: null,
          fr: null,
          from: null,
          fx: null,
          fy: null,
          g1: commaSeparated,
          g2: commaSeparated,
          glyphName: commaSeparated,
          glyphOrientationHorizontal: null,
          glyphOrientationVertical: null,
          glyphRef: null,
          gradientTransform: null,
          gradientUnits: null,
          handler: null,
          hanging: number,
          hatchContentUnits: null,
          hatchUnits: null,
          height: null,
          href: null,
          hrefLang: null,
          horizAdvX: number,
          horizOriginX: number,
          horizOriginY: number,
          id: null,
          ideographic: number,
          imageRendering: null,
          initialVisibility: null,
          in: null,
          in2: null,
          intercept: number,
          k: number,
          k1: number,
          k2: number,
          k3: number,
          k4: number,
          kernelMatrix: commaOrSpaceSeparated,
          kernelUnitLength: null,
          keyPoints: null,
          // SEMI_COLON_SEPARATED
          keySplines: null,
          // SEMI_COLON_SEPARATED
          keyTimes: null,
          // SEMI_COLON_SEPARATED
          kerning: null,
          lang: null,
          lengthAdjust: null,
          letterSpacing: null,
          lightingColor: null,
          limitingConeAngle: number,
          local: null,
          markerEnd: null,
          markerMid: null,
          markerStart: null,
          markerHeight: null,
          markerUnits: null,
          markerWidth: null,
          mask: null,
          maskContentUnits: null,
          maskUnits: null,
          mathematical: null,
          max: null,
          media: null,
          mediaCharacterEncoding: null,
          mediaContentEncodings: null,
          mediaSize: number,
          mediaTime: null,
          method: null,
          min: null,
          mode: null,
          name: null,
          navDown: null,
          navDownLeft: null,
          navDownRight: null,
          navLeft: null,
          navNext: null,
          navPrev: null,
          navRight: null,
          navUp: null,
          navUpLeft: null,
          navUpRight: null,
          numOctaves: null,
          observer: null,
          offset: null,
          onAbort: null,
          onActivate: null,
          onAfterPrint: null,
          onBeforePrint: null,
          onBegin: null,
          onCancel: null,
          onCanPlay: null,
          onCanPlayThrough: null,
          onChange: null,
          onClick: null,
          onClose: null,
          onCopy: null,
          onCueChange: null,
          onCut: null,
          onDblClick: null,
          onDrag: null,
          onDragEnd: null,
          onDragEnter: null,
          onDragExit: null,
          onDragLeave: null,
          onDragOver: null,
          onDragStart: null,
          onDrop: null,
          onDurationChange: null,
          onEmptied: null,
          onEnd: null,
          onEnded: null,
          onError: null,
          onFocus: null,
          onFocusIn: null,
          onFocusOut: null,
          onHashChange: null,
          onInput: null,
          onInvalid: null,
          onKeyDown: null,
          onKeyPress: null,
          onKeyUp: null,
          onLoad: null,
          onLoadedData: null,
          onLoadedMetadata: null,
          onLoadStart: null,
          onMessage: null,
          onMouseDown: null,
          onMouseEnter: null,
          onMouseLeave: null,
          onMouseMove: null,
          onMouseOut: null,
          onMouseOver: null,
          onMouseUp: null,
          onMouseWheel: null,
          onOffline: null,
          onOnline: null,
          onPageHide: null,
          onPageShow: null,
          onPaste: null,
          onPause: null,
          onPlay: null,
          onPlaying: null,
          onPopState: null,
          onProgress: null,
          onRateChange: null,
          onRepeat: null,
          onReset: null,
          onResize: null,
          onScroll: null,
          onSeeked: null,
          onSeeking: null,
          onSelect: null,
          onShow: null,
          onStalled: null,
          onStorage: null,
          onSubmit: null,
          onSuspend: null,
          onTimeUpdate: null,
          onToggle: null,
          onUnload: null,
          onVolumeChange: null,
          onWaiting: null,
          onZoom: null,
          opacity: null,
          operator: null,
          order: null,
          orient: null,
          orientation: null,
          origin: null,
          overflow: null,
          overlay: null,
          overlinePosition: number,
          overlineThickness: number,
          paintOrder: null,
          panose1: null,
          path: null,
          pathLength: number,
          patternContentUnits: null,
          patternTransform: null,
          patternUnits: null,
          phase: null,
          ping: spaceSeparated,
          pitch: null,
          playbackOrder: null,
          pointerEvents: null,
          points: null,
          pointsAtX: number,
          pointsAtY: number,
          pointsAtZ: number,
          preserveAlpha: null,
          preserveAspectRatio: null,
          primitiveUnits: null,
          propagate: null,
          property: commaOrSpaceSeparated,
          r: null,
          radius: null,
          referrerPolicy: null,
          refX: null,
          refY: null,
          rel: commaOrSpaceSeparated,
          rev: commaOrSpaceSeparated,
          renderingIntent: null,
          repeatCount: null,
          repeatDur: null,
          requiredExtensions: commaOrSpaceSeparated,
          requiredFeatures: commaOrSpaceSeparated,
          requiredFonts: commaOrSpaceSeparated,
          requiredFormats: commaOrSpaceSeparated,
          resource: null,
          restart: null,
          result: null,
          rotate: null,
          rx: null,
          ry: null,
          scale: null,
          seed: null,
          shapeRendering: null,
          side: null,
          slope: null,
          snapshotTime: null,
          specularConstant: number,
          specularExponent: number,
          spreadMethod: null,
          spacing: null,
          startOffset: null,
          stdDeviation: null,
          stemh: null,
          stemv: null,
          stitchTiles: null,
          stopColor: null,
          stopOpacity: null,
          strikethroughPosition: number,
          strikethroughThickness: number,
          string: null,
          stroke: null,
          strokeDashArray: commaOrSpaceSeparated,
          strokeDashOffset: null,
          strokeLineCap: null,
          strokeLineJoin: null,
          strokeMiterLimit: number,
          strokeOpacity: number,
          strokeWidth: null,
          style: null,
          surfaceScale: number,
          syncBehavior: null,
          syncBehaviorDefault: null,
          syncMaster: null,
          syncTolerance: null,
          syncToleranceDefault: null,
          systemLanguage: commaOrSpaceSeparated,
          tabIndex: number,
          tableValues: null,
          target: null,
          targetX: number,
          targetY: number,
          textAnchor: null,
          textDecoration: null,
          textRendering: null,
          textLength: null,
          timelineBegin: null,
          title: null,
          transformBehavior: null,
          type: null,
          typeOf: commaOrSpaceSeparated,
          to: null,
          transform: null,
          transformOrigin: null,
          u1: null,
          u2: null,
          underlinePosition: number,
          underlineThickness: number,
          unicode: null,
          unicodeBidi: null,
          unicodeRange: null,
          unitsPerEm: number,
          values: null,
          vAlphabetic: number,
          vMathematical: number,
          vectorEffect: null,
          vHanging: number,
          vIdeographic: number,
          version: null,
          vertAdvY: number,
          vertOriginX: number,
          vertOriginY: number,
          viewBox: null,
          viewTarget: null,
          visibility: null,
          width: null,
          widths: null,
          wordSpacing: null,
          writingMode: null,
          x: null,
          x1: null,
          x2: null,
          xChannelSelector: null,
          xHeight: number,
          y: null,
          y1: null,
          y2: null,
          yChannelSelector: null,
          z: null,
          zoomAndPan: null
        },
        space: "svg",
        transform: caseSensitiveTransform
      });
    }
  });

  // node_modules/property-information/lib/xlink.js
  var xlink;
  var init_xlink = __esm({
    "node_modules/property-information/lib/xlink.js"() {
      init_create();
      xlink = create({
        properties: {
          xLinkActuate: null,
          xLinkArcRole: null,
          xLinkHref: null,
          xLinkRole: null,
          xLinkShow: null,
          xLinkTitle: null,
          xLinkType: null
        },
        space: "xlink",
        transform(_2, property) {
          return "xlink:" + property.slice(5).toLowerCase();
        }
      });
    }
  });

  // node_modules/property-information/lib/xmlns.js
  var xmlns;
  var init_xmlns = __esm({
    "node_modules/property-information/lib/xmlns.js"() {
      init_create();
      init_case_insensitive_transform();
      xmlns = create({
        attributes: { xmlnsxlink: "xmlns:xlink" },
        properties: { xmlnsXLink: null, xmlns: null },
        space: "xmlns",
        transform: caseInsensitiveTransform
      });
    }
  });

  // node_modules/property-information/lib/xml.js
  var xml;
  var init_xml = __esm({
    "node_modules/property-information/lib/xml.js"() {
      init_create();
      xml = create({
        properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
        space: "xml",
        transform(_2, property) {
          return "xml:" + property.slice(3).toLowerCase();
        }
      });
    }
  });

  // node_modules/property-information/lib/hast-to-react.js
  var init_hast_to_react = __esm({
    "node_modules/property-information/lib/hast-to-react.js"() {
    }
  });

  // node_modules/property-information/lib/find.js
  function find(schema, value) {
    const normal = normalize(value);
    let property = value;
    let Type = Info;
    if (normal in schema.normal) {
      return schema.property[schema.normal[normal]];
    }
    if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
      if (value.charAt(4) === "-") {
        const rest = value.slice(5).replace(dash, camelcase);
        property = "data" + rest.charAt(0).toUpperCase() + rest.slice(1);
      } else {
        const rest = value.slice(4);
        if (!dash.test(rest)) {
          let dashes = rest.replace(cap, kebab);
          if (dashes.charAt(0) !== "-") {
            dashes = "-" + dashes;
          }
          value = "data" + dashes;
        }
      }
      Type = DefinedInfo;
    }
    return new Type(property, value);
  }
  function kebab($0) {
    return "-" + $0.toLowerCase();
  }
  function camelcase($0) {
    return $0.charAt(1).toUpperCase();
  }
  var cap, dash, valid;
  var init_find = __esm({
    "node_modules/property-information/lib/find.js"() {
      init_defined_info();
      init_info();
      init_normalize();
      cap = /[A-Z]/g;
      dash = /-[a-z]/g;
      valid = /^data[-\w.:]+$/i;
    }
  });

  // node_modules/property-information/index.js
  var html2, svg2;
  var init_property_information = __esm({
    "node_modules/property-information/index.js"() {
      init_merge();
      init_aria();
      init_html();
      init_svg();
      init_xlink();
      init_xmlns();
      init_xml();
      init_hast_to_react();
      init_find();
      init_normalize();
      html2 = merge([aria, html, xlink, xmlns, xml], "html");
      svg2 = merge([aria, svg, xlink, xmlns, xml], "svg");
    }
  });

  // node_modules/comma-separated-tokens/index.js
  function parse(value) {
    const tokens = [];
    const input2 = String(value || "");
    let index3 = input2.indexOf(",");
    let start = 0;
    let end = false;
    while (!end) {
      if (index3 === -1) {
        index3 = input2.length;
        end = true;
      }
      const token = input2.slice(start, index3).trim();
      if (token || !end) {
        tokens.push(token);
      }
      start = index3 + 1;
      index3 = input2.indexOf(",", start);
    }
    return tokens;
  }
  function stringify(values, options2) {
    const settings = options2 || {};
    const input2 = values[values.length - 1] === "" ? [...values, ""] : values;
    return input2.join(
      (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
    ).trim();
  }
  var init_comma_separated_tokens = __esm({
    "node_modules/comma-separated-tokens/index.js"() {
    }
  });

  // node_modules/hast-util-parse-selector/lib/index.js
  function parseSelector(selector, defaultTagName) {
    const value = selector || "";
    const props = {};
    let start = 0;
    let previous3;
    let tagName;
    while (start < value.length) {
      search.lastIndex = start;
      const match = search.exec(value);
      const subvalue = value.slice(start, match ? match.index : value.length);
      if (subvalue) {
        if (!previous3) {
          tagName = subvalue;
        } else if (previous3 === "#") {
          props.id = subvalue;
        } else if (Array.isArray(props.className)) {
          props.className.push(subvalue);
        } else {
          props.className = [subvalue];
        }
        start += subvalue.length;
      }
      if (match) {
        previous3 = match[0];
        start++;
      }
    }
    return {
      type: "element",
      // @ts-expect-error: tag name is parsed.
      tagName: tagName || defaultTagName || "div",
      properties: props,
      children: []
    };
  }
  var search;
  var init_lib = __esm({
    "node_modules/hast-util-parse-selector/lib/index.js"() {
      search = /[#.]/g;
    }
  });

  // node_modules/hast-util-parse-selector/index.js
  var init_hast_util_parse_selector = __esm({
    "node_modules/hast-util-parse-selector/index.js"() {
      init_lib();
    }
  });

  // node_modules/space-separated-tokens/index.js
  function parse2(value) {
    const input2 = String(value || "").trim();
    return input2 ? input2.split(/[ \t\n\r\f]+/g) : [];
  }
  function stringify2(values) {
    return values.join(" ").trim();
  }
  var init_space_separated_tokens = __esm({
    "node_modules/space-separated-tokens/index.js"() {
    }
  });

  // node_modules/hastscript/lib/create-h.js
  function createH(schema, defaultTagName, caseSensitive) {
    const adjust = caseSensitive ? createAdjustMap(caseSensitive) : void 0;
    function h2(selector, properties, ...children) {
      let node2;
      if (selector === null || selector === void 0) {
        node2 = { type: "root", children: [] };
        const child = (
          /** @type {Child} */
          properties
        );
        children.unshift(child);
      } else {
        node2 = parseSelector(selector, defaultTagName);
        const lower = node2.tagName.toLowerCase();
        const adjusted = adjust ? adjust.get(lower) : void 0;
        node2.tagName = adjusted || lower;
        if (isChild(properties)) {
          children.unshift(properties);
        } else {
          for (const [key2, value] of Object.entries(properties)) {
            addProperty(schema, node2.properties, key2, value);
          }
        }
      }
      for (const child of children) {
        addChild(node2.children, child);
      }
      if (node2.type === "element" && node2.tagName === "template") {
        node2.content = { type: "root", children: node2.children };
        node2.children = [];
      }
      return node2;
    }
    return h2;
  }
  function isChild(value) {
    if (value === null || typeof value !== "object" || Array.isArray(value)) {
      return true;
    }
    if (typeof value.type !== "string") return false;
    const record = (
      /** @type {Record<string, unknown>} */
      value
    );
    const keys4 = Object.keys(value);
    for (const key2 of keys4) {
      const value2 = record[key2];
      if (value2 && typeof value2 === "object") {
        if (!Array.isArray(value2)) return true;
        const list7 = (
          /** @type {ReadonlyArray<unknown>} */
          value2
        );
        for (const item of list7) {
          if (typeof item !== "number" && typeof item !== "string") {
            return true;
          }
        }
      }
    }
    if ("children" in value && Array.isArray(value.children)) {
      return true;
    }
    return false;
  }
  function addProperty(schema, properties, key2, value) {
    const info = find(schema, key2);
    let result;
    if (value === null || value === void 0) return;
    if (typeof value === "number") {
      if (Number.isNaN(value)) return;
      result = value;
    } else if (typeof value === "boolean") {
      result = value;
    } else if (typeof value === "string") {
      if (info.spaceSeparated) {
        result = parse2(value);
      } else if (info.commaSeparated) {
        result = parse(value);
      } else if (info.commaOrSpaceSeparated) {
        result = parse2(parse(value).join(" "));
      } else {
        result = parsePrimitive(info, info.property, value);
      }
    } else if (Array.isArray(value)) {
      result = [...value];
    } else {
      result = info.property === "style" ? style(value) : String(value);
    }
    if (Array.isArray(result)) {
      const finalResult = [];
      for (const item of result) {
        finalResult.push(
          /** @type {number | string} */
          parsePrimitive(info, info.property, item)
        );
      }
      result = finalResult;
    }
    if (info.property === "className" && Array.isArray(properties.className)) {
      result = properties.className.concat(
        /** @type {Array<number | string> | number | string} */
        result
      );
    }
    properties[info.property] = result;
  }
  function addChild(nodes, value) {
    if (value === null || value === void 0) {
    } else if (typeof value === "number" || typeof value === "string") {
      nodes.push({ type: "text", value: String(value) });
    } else if (Array.isArray(value)) {
      for (const child of value) {
        addChild(nodes, child);
      }
    } else if (typeof value === "object" && "type" in value) {
      if (value.type === "root") {
        addChild(nodes, value.children);
      } else {
        nodes.push(value);
      }
    } else {
      throw new Error("Expected node, nodes, or string, got `" + value + "`");
    }
  }
  function parsePrimitive(info, name, value) {
    if (typeof value === "string") {
      if (info.number && value && !Number.isNaN(Number(value))) {
        return Number(value);
      }
      if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize(value) === normalize(name))) {
        return true;
      }
    }
    return value;
  }
  function style(styles) {
    const result = [];
    for (const [key2, value] of Object.entries(styles)) {
      result.push([key2, value].join(": "));
    }
    return result.join("; ");
  }
  function createAdjustMap(values) {
    const result = /* @__PURE__ */ new Map();
    for (const value of values) {
      result.set(value.toLowerCase(), value);
    }
    return result;
  }
  var init_create_h = __esm({
    "node_modules/hastscript/lib/create-h.js"() {
      init_comma_separated_tokens();
      init_hast_util_parse_selector();
      init_property_information();
      init_space_separated_tokens();
    }
  });

  // node_modules/hastscript/lib/svg-case-sensitive-tag-names.js
  var svgCaseSensitiveTagNames;
  var init_svg_case_sensitive_tag_names = __esm({
    "node_modules/hastscript/lib/svg-case-sensitive-tag-names.js"() {
      svgCaseSensitiveTagNames = [
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "clipPath",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "foreignObject",
        "glyphRef",
        "linearGradient",
        "radialGradient",
        "solidColor",
        "textArea",
        "textPath"
      ];
    }
  });

  // node_modules/hastscript/lib/index.js
  var h, s;
  var init_lib2 = __esm({
    "node_modules/hastscript/lib/index.js"() {
      init_property_information();
      init_create_h();
      init_svg_case_sensitive_tag_names();
      h = createH(html2, "div");
      s = createH(svg2, "g", svgCaseSensitiveTagNames);
    }
  });

  // node_modules/hastscript/index.js
  var init_hastscript = __esm({
    "node_modules/hastscript/index.js"() {
      init_lib2();
    }
  });

  // node_modules/vfile-location/lib/index.js
  function location2(file) {
    const value = String(file);
    const indices = [];
    return { toOffset, toPoint };
    function toPoint(offset) {
      if (typeof offset === "number" && offset > -1 && offset <= value.length) {
        let index3 = 0;
        while (true) {
          let end = indices[index3];
          if (end === void 0) {
            const eol2 = next(value, indices[index3 - 1]);
            end = eol2 === -1 ? value.length + 1 : eol2 + 1;
            indices[index3] = end;
          }
          if (end > offset) {
            return {
              line: index3 + 1,
              column: offset - (index3 > 0 ? indices[index3 - 1] : 0) + 1,
              offset
            };
          }
          index3++;
        }
      }
    }
    function toOffset(point5) {
      if (point5 && typeof point5.line === "number" && typeof point5.column === "number" && !Number.isNaN(point5.line) && !Number.isNaN(point5.column)) {
        while (indices.length < point5.line) {
          const from4 = indices[indices.length - 1];
          const eol2 = next(value, from4);
          const end = eol2 === -1 ? value.length + 1 : eol2 + 1;
          if (from4 === end) break;
          indices.push(end);
        }
        const offset = (point5.line > 1 ? indices[point5.line - 2] : 0) + point5.column - 1;
        if (offset < indices[point5.line - 1]) return offset;
      }
    }
  }
  function next(value, from4) {
    const cr2 = value.indexOf("\r", from4);
    const lf = value.indexOf("\n", from4);
    if (lf === -1) return cr2;
    if (cr2 === -1 || cr2 + 1 === lf) return lf;
    return cr2 < lf ? cr2 : lf;
  }
  var init_lib3 = __esm({
    "node_modules/vfile-location/lib/index.js"() {
    }
  });

  // node_modules/vfile-location/index.js
  var init_vfile_location = __esm({
    "node_modules/vfile-location/index.js"() {
      init_lib3();
    }
  });

  // node_modules/web-namespaces/index.js
  var webNamespaces;
  var init_web_namespaces = __esm({
    "node_modules/web-namespaces/index.js"() {
      webNamespaces = {
        html: "http://www.w3.org/1999/xhtml",
        mathml: "http://www.w3.org/1998/Math/MathML",
        svg: "http://www.w3.org/2000/svg",
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
      };
    }
  });

  // node_modules/hast-util-from-parse5/lib/index.js
  function fromParse5(tree, options2) {
    const settings = options2 || {};
    return one(
      {
        file: settings.file || void 0,
        location: false,
        schema: settings.space === "svg" ? svg2 : html2,
        verbose: settings.verbose || false
      },
      tree
    );
  }
  function one(state, node2) {
    let result;
    switch (node2.nodeName) {
      case "#comment": {
        const reference = (
          /** @type {DefaultTreeAdapterMap['commentNode']} */
          node2
        );
        result = { type: "comment", value: reference.data };
        patch(state, reference, result);
        return result;
      }
      case "#document":
      case "#document-fragment": {
        const reference = (
          /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
          node2
        );
        const quirksMode = "mode" in reference ? reference.mode === "quirks" || reference.mode === "limited-quirks" : false;
        result = {
          type: "root",
          children: all(state, node2.childNodes),
          data: { quirksMode }
        };
        if (state.file && state.location) {
          const document4 = String(state.file);
          const loc = location2(document4);
          const start = loc.toPoint(0);
          const end = loc.toPoint(document4.length);
          ok(start, "expected `start`");
          ok(end, "expected `end`");
          result.position = { start, end };
        }
        return result;
      }
      case "#documentType": {
        const reference = (
          /** @type {DefaultTreeAdapterMap['documentType']} */
          node2
        );
        result = { type: "doctype" };
        patch(state, reference, result);
        return result;
      }
      case "#text": {
        const reference = (
          /** @type {DefaultTreeAdapterMap['textNode']} */
          node2
        );
        result = { type: "text", value: reference.value };
        patch(state, reference, result);
        return result;
      }
      // Element.
      default: {
        const reference = (
          /** @type {DefaultTreeAdapterMap['element']} */
          node2
        );
        result = element(state, reference);
        return result;
      }
    }
  }
  function all(state, nodes) {
    let index3 = -1;
    const results = [];
    while (++index3 < nodes.length) {
      const result = (
        /** @type {RootContent} */
        one(state, nodes[index3])
      );
      results.push(result);
    }
    return results;
  }
  function element(state, node2) {
    const schema = state.schema;
    state.schema = node2.namespaceURI === webNamespaces.svg ? svg2 : html2;
    let index3 = -1;
    const properties = {};
    while (++index3 < node2.attrs.length) {
      const attribute = node2.attrs[index3];
      const name = (attribute.prefix ? attribute.prefix + ":" : "") + attribute.name;
      if (!own.call(proto, name)) {
        properties[name] = attribute.value;
      }
    }
    const x = state.schema.space === "svg" ? s : h;
    const result = x(node2.tagName, properties, all(state, node2.childNodes));
    patch(state, node2, result);
    if (result.tagName === "template") {
      const reference = (
        /** @type {DefaultTreeAdapterMap['template']} */
        node2
      );
      const pos = reference.sourceCodeLocation;
      const startTag = pos && pos.startTag && position(pos.startTag);
      const endTag = pos && pos.endTag && position(pos.endTag);
      const content5 = (
        /** @type {Root} */
        one(state, reference.content)
      );
      if (startTag && endTag && state.file) {
        content5.position = { start: startTag.end, end: endTag.start };
      }
      result.content = content5;
    }
    state.schema = schema;
    return result;
  }
  function patch(state, from4, to2) {
    if ("sourceCodeLocation" in from4 && from4.sourceCodeLocation && state.file) {
      const position4 = createLocation(state, to2, from4.sourceCodeLocation);
      if (position4) {
        state.location = true;
        to2.position = position4;
      }
    }
  }
  function createLocation(state, node2, location3) {
    const result = position(location3);
    if (node2.type === "element") {
      const tail = node2.children[node2.children.length - 1];
      if (result && !location3.endTag && tail && tail.position && tail.position.end) {
        result.end = Object.assign({}, tail.position.end);
      }
      if (state.verbose) {
        const properties = {};
        let key2;
        if (location3.attrs) {
          for (key2 in location3.attrs) {
            if (own.call(location3.attrs, key2)) {
              properties[find(state.schema, key2).property] = position(
                location3.attrs[key2]
              );
            }
          }
        }
        ok(location3.startTag, "a start tag should exist");
        const opening2 = position(location3.startTag);
        const closing2 = location3.endTag ? position(location3.endTag) : void 0;
        const data = { opening: opening2 };
        if (closing2) data.closing = closing2;
        data.properties = properties;
        node2.data = { position: data };
      }
    }
    return result;
  }
  function position(loc) {
    const start = point({
      line: loc.startLine,
      column: loc.startCol,
      offset: loc.startOffset
    });
    const end = point({
      line: loc.endLine,
      column: loc.endCol,
      offset: loc.endOffset
    });
    return start || end ? { start, end } : void 0;
  }
  function point(point5) {
    return point5.line && point5.column ? point5 : void 0;
  }
  var own, proto;
  var init_lib4 = __esm({
    "node_modules/hast-util-from-parse5/lib/index.js"() {
      init_default();
      init_hastscript();
      init_property_information();
      init_vfile_location();
      init_web_namespaces();
      own = {}.hasOwnProperty;
      proto = Object.prototype;
    }
  });

  // node_modules/hast-util-from-parse5/index.js
  var init_hast_util_from_parse5 = __esm({
    "node_modules/hast-util-from-parse5/index.js"() {
      init_lib4();
    }
  });

  // node_modules/parse5/dist/common/unicode.js
  function isSurrogate(cp) {
    return cp >= 55296 && cp <= 57343;
  }
  function isSurrogatePair(cp) {
    return cp >= 56320 && cp <= 57343;
  }
  function getSurrogatePairCodePoint(cp1, cp2) {
    return (cp1 - 55296) * 1024 + 9216 + cp2;
  }
  function isControlCodePoint(cp) {
    return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
  }
  function isUndefinedCodePoint(cp) {
    return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.has(cp);
  }
  var UNDEFINED_CODE_POINTS, REPLACEMENT_CHARACTER, CODE_POINTS, SEQUENCES;
  var init_unicode = __esm({
    "node_modules/parse5/dist/common/unicode.js"() {
      UNDEFINED_CODE_POINTS = /* @__PURE__ */ new Set([
        65534,
        65535,
        131070,
        131071,
        196606,
        196607,
        262142,
        262143,
        327678,
        327679,
        393214,
        393215,
        458750,
        458751,
        524286,
        524287,
        589822,
        589823,
        655358,
        655359,
        720894,
        720895,
        786430,
        786431,
        851966,
        851967,
        917502,
        917503,
        983038,
        983039,
        1048574,
        1048575,
        1114110,
        1114111
      ]);
      REPLACEMENT_CHARACTER = "\uFFFD";
      (function(CODE_POINTS2) {
        CODE_POINTS2[CODE_POINTS2["EOF"] = -1] = "EOF";
        CODE_POINTS2[CODE_POINTS2["NULL"] = 0] = "NULL";
        CODE_POINTS2[CODE_POINTS2["TABULATION"] = 9] = "TABULATION";
        CODE_POINTS2[CODE_POINTS2["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
        CODE_POINTS2[CODE_POINTS2["LINE_FEED"] = 10] = "LINE_FEED";
        CODE_POINTS2[CODE_POINTS2["FORM_FEED"] = 12] = "FORM_FEED";
        CODE_POINTS2[CODE_POINTS2["SPACE"] = 32] = "SPACE";
        CODE_POINTS2[CODE_POINTS2["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
        CODE_POINTS2[CODE_POINTS2["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
        CODE_POINTS2[CODE_POINTS2["AMPERSAND"] = 38] = "AMPERSAND";
        CODE_POINTS2[CODE_POINTS2["APOSTROPHE"] = 39] = "APOSTROPHE";
        CODE_POINTS2[CODE_POINTS2["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
        CODE_POINTS2[CODE_POINTS2["SOLIDUS"] = 47] = "SOLIDUS";
        CODE_POINTS2[CODE_POINTS2["DIGIT_0"] = 48] = "DIGIT_0";
        CODE_POINTS2[CODE_POINTS2["DIGIT_9"] = 57] = "DIGIT_9";
        CODE_POINTS2[CODE_POINTS2["SEMICOLON"] = 59] = "SEMICOLON";
        CODE_POINTS2[CODE_POINTS2["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
        CODE_POINTS2[CODE_POINTS2["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
        CODE_POINTS2[CODE_POINTS2["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
        CODE_POINTS2[CODE_POINTS2["QUESTION_MARK"] = 63] = "QUESTION_MARK";
        CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
        CODE_POINTS2[CODE_POINTS2["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
        CODE_POINTS2[CODE_POINTS2["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
        CODE_POINTS2[CODE_POINTS2["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
        CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
        CODE_POINTS2[CODE_POINTS2["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
      })(CODE_POINTS || (CODE_POINTS = {}));
      SEQUENCES = {
        DASH_DASH: "--",
        CDATA_START: "[CDATA[",
        DOCTYPE: "doctype",
        SCRIPT: "script",
        PUBLIC: "public",
        SYSTEM: "system"
      };
    }
  });

  // node_modules/parse5/dist/common/error-codes.js
  var ERR;
  var init_error_codes = __esm({
    "node_modules/parse5/dist/common/error-codes.js"() {
      (function(ERR2) {
        ERR2["controlCharacterInInputStream"] = "control-character-in-input-stream";
        ERR2["noncharacterInInputStream"] = "noncharacter-in-input-stream";
        ERR2["surrogateInInputStream"] = "surrogate-in-input-stream";
        ERR2["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
        ERR2["endTagWithAttributes"] = "end-tag-with-attributes";
        ERR2["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
        ERR2["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
        ERR2["unexpectedNullCharacter"] = "unexpected-null-character";
        ERR2["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
        ERR2["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
        ERR2["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
        ERR2["missingEndTagName"] = "missing-end-tag-name";
        ERR2["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
        ERR2["unknownNamedCharacterReference"] = "unknown-named-character-reference";
        ERR2["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
        ERR2["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
        ERR2["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
        ERR2["eofBeforeTagName"] = "eof-before-tag-name";
        ERR2["eofInTag"] = "eof-in-tag";
        ERR2["missingAttributeValue"] = "missing-attribute-value";
        ERR2["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
        ERR2["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
        ERR2["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
        ERR2["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
        ERR2["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
        ERR2["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
        ERR2["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
        ERR2["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
        ERR2["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
        ERR2["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
        ERR2["cdataInHtmlContent"] = "cdata-in-html-content";
        ERR2["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
        ERR2["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
        ERR2["eofInDoctype"] = "eof-in-doctype";
        ERR2["nestedComment"] = "nested-comment";
        ERR2["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
        ERR2["eofInComment"] = "eof-in-comment";
        ERR2["incorrectlyClosedComment"] = "incorrectly-closed-comment";
        ERR2["eofInCdata"] = "eof-in-cdata";
        ERR2["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
        ERR2["nullCharacterReference"] = "null-character-reference";
        ERR2["surrogateCharacterReference"] = "surrogate-character-reference";
        ERR2["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
        ERR2["controlCharacterReference"] = "control-character-reference";
        ERR2["noncharacterCharacterReference"] = "noncharacter-character-reference";
        ERR2["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
        ERR2["missingDoctypeName"] = "missing-doctype-name";
        ERR2["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
        ERR2["duplicateAttribute"] = "duplicate-attribute";
        ERR2["nonConformingDoctype"] = "non-conforming-doctype";
        ERR2["missingDoctype"] = "missing-doctype";
        ERR2["misplacedDoctype"] = "misplaced-doctype";
        ERR2["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
        ERR2["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
        ERR2["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
        ERR2["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
        ERR2["abandonedHeadElementChild"] = "abandoned-head-element-child";
        ERR2["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
        ERR2["nestedNoscriptInHead"] = "nested-noscript-in-head";
        ERR2["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
      })(ERR || (ERR = {}));
    }
  });

  // node_modules/parse5/dist/tokenizer/preprocessor.js
  var DEFAULT_BUFFER_WATERLINE, Preprocessor;
  var init_preprocessor = __esm({
    "node_modules/parse5/dist/tokenizer/preprocessor.js"() {
      init_unicode();
      init_error_codes();
      DEFAULT_BUFFER_WATERLINE = 1 << 16;
      Preprocessor = class {
        constructor(handler) {
          this.handler = handler;
          this.html = "";
          this.pos = -1;
          this.lastGapPos = -2;
          this.gapStack = [];
          this.skipNextNewLine = false;
          this.lastChunkWritten = false;
          this.endOfChunkHit = false;
          this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
          this.isEol = false;
          this.lineStartPos = 0;
          this.droppedBufferSize = 0;
          this.line = 1;
          this.lastErrOffset = -1;
        }
        /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
        get col() {
          return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
        }
        get offset() {
          return this.droppedBufferSize + this.pos;
        }
        getError(code5, cpOffset) {
          const { line, col, offset } = this;
          const startCol = col + cpOffset;
          const startOffset = offset + cpOffset;
          return {
            code: code5,
            startLine: line,
            endLine: line,
            startCol,
            endCol: startCol,
            startOffset,
            endOffset: startOffset
          };
        }
        _err(code5) {
          if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
            this.lastErrOffset = this.offset;
            this.handler.onParseError(this.getError(code5, 0));
          }
        }
        _addGap() {
          this.gapStack.push(this.lastGapPos);
          this.lastGapPos = this.pos;
        }
        _processSurrogate(cp) {
          if (this.pos !== this.html.length - 1) {
            const nextCp = this.html.charCodeAt(this.pos + 1);
            if (isSurrogatePair(nextCp)) {
              this.pos++;
              this._addGap();
              return getSurrogatePairCodePoint(cp, nextCp);
            }
          } else if (!this.lastChunkWritten) {
            this.endOfChunkHit = true;
            return CODE_POINTS.EOF;
          }
          this._err(ERR.surrogateInInputStream);
          return cp;
        }
        willDropParsedChunk() {
          return this.pos > this.bufferWaterline;
        }
        dropParsedChunk() {
          if (this.willDropParsedChunk()) {
            this.html = this.html.substring(this.pos);
            this.lineStartPos -= this.pos;
            this.droppedBufferSize += this.pos;
            this.pos = 0;
            this.lastGapPos = -2;
            this.gapStack.length = 0;
          }
        }
        write(chunk, isLastChunk) {
          if (this.html.length > 0) {
            this.html += chunk;
          } else {
            this.html = chunk;
          }
          this.endOfChunkHit = false;
          this.lastChunkWritten = isLastChunk;
        }
        insertHtmlAtCurrentPos(chunk) {
          this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
          this.endOfChunkHit = false;
        }
        startsWith(pattern, caseSensitive) {
          if (this.pos + pattern.length > this.html.length) {
            this.endOfChunkHit = !this.lastChunkWritten;
            return false;
          }
          if (caseSensitive) {
            return this.html.startsWith(pattern, this.pos);
          }
          for (let i = 0; i < pattern.length; i++) {
            const cp = this.html.charCodeAt(this.pos + i) | 32;
            if (cp !== pattern.charCodeAt(i)) {
              return false;
            }
          }
          return true;
        }
        peek(offset) {
          const pos = this.pos + offset;
          if (pos >= this.html.length) {
            this.endOfChunkHit = !this.lastChunkWritten;
            return CODE_POINTS.EOF;
          }
          const code5 = this.html.charCodeAt(pos);
          return code5 === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code5;
        }
        advance() {
          this.pos++;
          if (this.isEol) {
            this.isEol = false;
            this.line++;
            this.lineStartPos = this.pos;
          }
          if (this.pos >= this.html.length) {
            this.endOfChunkHit = !this.lastChunkWritten;
            return CODE_POINTS.EOF;
          }
          let cp = this.html.charCodeAt(this.pos);
          if (cp === CODE_POINTS.CARRIAGE_RETURN) {
            this.isEol = true;
            this.skipNextNewLine = true;
            return CODE_POINTS.LINE_FEED;
          }
          if (cp === CODE_POINTS.LINE_FEED) {
            this.isEol = true;
            if (this.skipNextNewLine) {
              this.line--;
              this.skipNextNewLine = false;
              this._addGap();
              return this.advance();
            }
          }
          this.skipNextNewLine = false;
          if (isSurrogate(cp)) {
            cp = this._processSurrogate(cp);
          }
          const isCommonValidRange = this.handler.onParseError === null || cp > 31 && cp < 127 || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.CARRIAGE_RETURN || cp > 159 && cp < 64976;
          if (!isCommonValidRange) {
            this._checkForProblematicCharacters(cp);
          }
          return cp;
        }
        _checkForProblematicCharacters(cp) {
          if (isControlCodePoint(cp)) {
            this._err(ERR.controlCharacterInInputStream);
          } else if (isUndefinedCodePoint(cp)) {
            this._err(ERR.noncharacterInInputStream);
          }
        }
        retreat(count) {
          this.pos -= count;
          while (this.pos < this.lastGapPos) {
            this.lastGapPos = this.gapStack.pop();
            this.pos--;
          }
          this.isEol = false;
        }
      };
    }
  });

  // node_modules/parse5/dist/common/token.js
  function getTokenAttr(token, attrName) {
    for (let i = token.attrs.length - 1; i >= 0; i--) {
      if (token.attrs[i].name === attrName) {
        return token.attrs[i].value;
      }
    }
    return null;
  }
  var TokenType;
  var init_token = __esm({
    "node_modules/parse5/dist/common/token.js"() {
      (function(TokenType2) {
        TokenType2[TokenType2["CHARACTER"] = 0] = "CHARACTER";
        TokenType2[TokenType2["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
        TokenType2[TokenType2["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
        TokenType2[TokenType2["START_TAG"] = 3] = "START_TAG";
        TokenType2[TokenType2["END_TAG"] = 4] = "END_TAG";
        TokenType2[TokenType2["COMMENT"] = 5] = "COMMENT";
        TokenType2[TokenType2["DOCTYPE"] = 6] = "DOCTYPE";
        TokenType2[TokenType2["EOF"] = 7] = "EOF";
        TokenType2[TokenType2["HIBERNATION"] = 8] = "HIBERNATION";
      })(TokenType || (TokenType = {}));
    }
  });

  // node_modules/parse5/node_modules/entities/dist/esm/generated/decode-data-html.js
  var htmlDecodeTree;
  var init_decode_data_html = __esm({
    "node_modules/parse5/node_modules/entities/dist/esm/generated/decode-data-html.js"() {
      htmlDecodeTree = /* @__PURE__ */ new Uint16Array(
        // prettier-ignore
        /* @__PURE__ */ '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
      );
    }
  });

  // node_modules/parse5/node_modules/entities/dist/esm/generated/decode-data-xml.js
  var xmlDecodeTree;
  var init_decode_data_xml = __esm({
    "node_modules/parse5/node_modules/entities/dist/esm/generated/decode-data-xml.js"() {
      xmlDecodeTree = /* @__PURE__ */ new Uint16Array(
        // prettier-ignore
        /* @__PURE__ */ "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
      );
    }
  });

  // node_modules/parse5/node_modules/entities/dist/esm/decode-codepoint.js
  function replaceCodePoint(codePoint) {
    var _a3;
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
      return 65533;
    }
    return (_a3 = decodeMap.get(codePoint)) !== null && _a3 !== void 0 ? _a3 : codePoint;
  }
  function decodeCodePoint(codePoint) {
    return fromCodePoint(replaceCodePoint(codePoint));
  }
  var _a, decodeMap, fromCodePoint;
  var init_decode_codepoint = __esm({
    "node_modules/parse5/node_modules/entities/dist/esm/decode-codepoint.js"() {
      decodeMap = /* @__PURE__ */ new Map([
        [0, 65533],
        // C1 Unicode control character reference replacements
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376]
      ]);
      fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, n/no-unsupported-features/es-builtins
      (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
        let output = "";
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += String.fromCharCode(codePoint);
        return output;
      };
    }
  });

  // node_modules/parse5/node_modules/entities/dist/esm/decode.js
  function isNumber(code5) {
    return code5 >= CharCodes.ZERO && code5 <= CharCodes.NINE;
  }
  function isHexadecimalCharacter(code5) {
    return code5 >= CharCodes.UPPER_A && code5 <= CharCodes.UPPER_F || code5 >= CharCodes.LOWER_A && code5 <= CharCodes.LOWER_F;
  }
  function isAsciiAlphaNumeric(code5) {
    return code5 >= CharCodes.UPPER_A && code5 <= CharCodes.UPPER_Z || code5 >= CharCodes.LOWER_A && code5 <= CharCodes.LOWER_Z || isNumber(code5);
  }
  function isEntityInAttributeInvalidEnd(code5) {
    return code5 === CharCodes.EQUALS || isAsciiAlphaNumeric(code5);
  }
  function getDecoder(decodeTree) {
    let returnValue = "";
    const decoder = new EntityDecoder(decodeTree, (data) => returnValue += fromCodePoint(data));
    return function decodeWithTrie(input2, decodeMode) {
      let lastIndex = 0;
      let offset = 0;
      while ((offset = input2.indexOf("&", offset)) >= 0) {
        returnValue += input2.slice(lastIndex, offset);
        decoder.startEntity(decodeMode);
        const length3 = decoder.write(
          input2,
          // Skip the "&"
          offset + 1
        );
        if (length3 < 0) {
          lastIndex = offset + decoder.end();
          break;
        }
        lastIndex = offset + length3;
        offset = length3 === 0 ? lastIndex + 1 : lastIndex;
      }
      const result = returnValue + input2.slice(lastIndex);
      returnValue = "";
      return result;
    };
  }
  function determineBranch(decodeTree, current, nodeIndex, char) {
    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
    if (branchCount === 0) {
      return jumpOffset !== 0 && char === jumpOffset ? nodeIndex : -1;
    }
    if (jumpOffset) {
      const value = char - jumpOffset;
      return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIndex + value] - 1;
    }
    let lo = nodeIndex;
    let hi2 = lo + branchCount - 1;
    while (lo <= hi2) {
      const mid = lo + hi2 >>> 1;
      const midValue = decodeTree[mid];
      if (midValue < char) {
        lo = mid + 1;
      } else if (midValue > char) {
        hi2 = mid - 1;
      } else {
        return decodeTree[mid + branchCount];
      }
    }
    return -1;
  }
  function decodeHTML(htmlString, mode = DecodingMode.Legacy) {
    return htmlDecoder(htmlString, mode);
  }
  function decodeHTMLAttribute(htmlAttribute) {
    return htmlDecoder(htmlAttribute, DecodingMode.Attribute);
  }
  function decodeHTMLStrict(htmlString) {
    return htmlDecoder(htmlString, DecodingMode.Strict);
  }
  function decodeXML(xmlString) {
    return xmlDecoder(xmlString, DecodingMode.Strict);
  }
  var CharCodes, TO_LOWER_BIT, BinTrieFlags, EntityDecoderState, DecodingMode, EntityDecoder, htmlDecoder, xmlDecoder;
  var init_decode = __esm({
    "node_modules/parse5/node_modules/entities/dist/esm/decode.js"() {
      init_decode_data_html();
      init_decode_data_xml();
      init_decode_codepoint();
      init_decode_data_html();
      init_decode_data_xml();
      init_decode_codepoint();
      (function(CharCodes2) {
        CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
        CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
        CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
        CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
        CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
        CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
        CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
        CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
        CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
        CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
        CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
        CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
      })(CharCodes || (CharCodes = {}));
      TO_LOWER_BIT = 32;
      (function(BinTrieFlags2) {
        BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
        BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
        BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
      })(BinTrieFlags || (BinTrieFlags = {}));
      (function(EntityDecoderState2) {
        EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
        EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
        EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
        EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
        EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
      })(EntityDecoderState || (EntityDecoderState = {}));
      (function(DecodingMode2) {
        DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
        DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
        DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
      })(DecodingMode || (DecodingMode = {}));
      EntityDecoder = class {
        constructor(decodeTree, emitCodePoint, errors2) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors2;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        /** Resets the instance to make it reusable. */
        startEntity(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        }
        /**
         * Write an entity to the decoder. This can be called multiple times with partial entities.
         * If the entity is incomplete, the decoder will return -1.
         *
         * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
         * entity is incomplete, and resume when the next string is written.
         *
         * @param input The string containing the entity (or a continuation of the entity).
         * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        write(input2, offset) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (input2.charCodeAt(offset) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(input2, offset + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(input2, offset);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(input2, offset);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(input2, offset);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(input2, offset);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(input2, offset);
            }
          }
        }
        /**
         * Switches between the numeric decimal and hexadecimal states.
         *
         * Equivalent to the `Numeric character reference state` in the HTML spec.
         *
         * @param input The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNumericStart(input2, offset) {
          if (offset >= input2.length) {
            return -1;
          }
          if ((input2.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(input2, offset + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(input2, offset);
        }
        addToNumericResult(input2, start, end, base4) {
          if (start !== end) {
            const digitCount = end - start;
            this.result = this.result * Math.pow(base4, digitCount) + Number.parseInt(input2.substr(start, digitCount), base4);
            this.consumed += digitCount;
          }
        }
        /**
         * Parses a hexadecimal numeric entity.
         *
         * Equivalent to the `Hexademical character reference state` in the HTML spec.
         *
         * @param input The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNumericHex(input2, offset) {
          const startIndex = offset;
          while (offset < input2.length) {
            const char = input2.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(input2, startIndex, offset, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(input2, startIndex, offset, 16);
          return -1;
        }
        /**
         * Parses a decimal numeric entity.
         *
         * Equivalent to the `Decimal character reference state` in the HTML spec.
         *
         * @param input The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNumericDecimal(input2, offset) {
          const startIndex = offset;
          while (offset < input2.length) {
            const char = input2.charCodeAt(offset);
            if (isNumber(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(input2, startIndex, offset, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(input2, startIndex, offset, 10);
          return -1;
        }
        /**
         * Validate and emit a numeric entity.
         *
         * Implements the logic from the `Hexademical character reference start
         * state` and `Numeric character reference end state` in the HTML spec.
         *
         * @param lastCp The last code point of the entity. Used to see if the
         *               entity was terminated with a semicolon.
         * @param expectedLength The minimum number of characters that should be
         *                       consumed. Used to validate that at least one digit
         *                       was consumed.
         * @returns The number of characters that were consumed.
         */
        emitNumericEntity(lastCp, expectedLength) {
          var _a3;
          if (this.consumed <= expectedLength) {
            (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        }
        /**
         * Parses a named entity.
         *
         * Equivalent to the `Named character reference state` in the HTML spec.
         *
         * @param input The string containing the entity (or a continuation of the entity).
         * @param offset The current offset.
         * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
         */
        stateNamedEntity(input2, offset) {
          const { decodeTree } = this;
          let current = decodeTree[this.treeIndex];
          let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset < input2.length; offset++, this.excess++) {
            const char = input2.charCodeAt(offset);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        }
        /**
         * Emit a named entity that was not terminated with a semicolon.
         *
         * @returns The number of characters consumed.
         */
        emitNotTerminatedNamedEntity() {
          var _a3;
          const { result, decodeTree } = this;
          const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.missingSemicolonAfterCharacterReference();
          return this.consumed;
        }
        /**
         * Emit a named entity.
         *
         * @param result The index of the entity in the decode tree.
         * @param valueLength The number of bytes in the entity.
         * @param consumed The number of characters consumed.
         *
         * @returns The number of characters consumed.
         */
        emitNamedEntityData(result, valueLength, consumed) {
          const { decodeTree } = this;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
        }
        /**
         * Signal to the parser that the end of the input was reached.
         *
         * Remaining data will be emitted and relevant errors will be produced.
         *
         * @returns The number of characters consumed.
         */
        end() {
          var _a3;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            // Otherwise, emit a numeric entity if we have one.
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        }
      };
      htmlDecoder = /* @__PURE__ */ getDecoder(htmlDecodeTree);
      xmlDecoder = /* @__PURE__ */ getDecoder(xmlDecodeTree);
    }
  });

  // node_modules/parse5/dist/common/html.js
  function getTagID(tagName) {
    var _a3;
    return (_a3 = TAG_NAME_TO_ID.get(tagName)) !== null && _a3 !== void 0 ? _a3 : TAG_ID.UNKNOWN;
  }
  function hasUnescapedText(tn2, scriptingEnabled) {
    return UNESCAPED_TEXT.has(tn2) || scriptingEnabled && tn2 === TAG_NAMES.NOSCRIPT;
  }
  var NS, ATTRS, DOCUMENT_MODE, TAG_NAMES, TAG_ID, TAG_NAME_TO_ID, $, SPECIAL_ELEMENTS, NUMBERED_HEADERS, UNESCAPED_TEXT;
  var init_html2 = __esm({
    "node_modules/parse5/dist/common/html.js"() {
      (function(NS2) {
        NS2["HTML"] = "http://www.w3.org/1999/xhtml";
        NS2["MATHML"] = "http://www.w3.org/1998/Math/MathML";
        NS2["SVG"] = "http://www.w3.org/2000/svg";
        NS2["XLINK"] = "http://www.w3.org/1999/xlink";
        NS2["XML"] = "http://www.w3.org/XML/1998/namespace";
        NS2["XMLNS"] = "http://www.w3.org/2000/xmlns/";
      })(NS || (NS = {}));
      (function(ATTRS2) {
        ATTRS2["TYPE"] = "type";
        ATTRS2["ACTION"] = "action";
        ATTRS2["ENCODING"] = "encoding";
        ATTRS2["PROMPT"] = "prompt";
        ATTRS2["NAME"] = "name";
        ATTRS2["COLOR"] = "color";
        ATTRS2["FACE"] = "face";
        ATTRS2["SIZE"] = "size";
      })(ATTRS || (ATTRS = {}));
      (function(DOCUMENT_MODE2) {
        DOCUMENT_MODE2["NO_QUIRKS"] = "no-quirks";
        DOCUMENT_MODE2["QUIRKS"] = "quirks";
        DOCUMENT_MODE2["LIMITED_QUIRKS"] = "limited-quirks";
      })(DOCUMENT_MODE || (DOCUMENT_MODE = {}));
      (function(TAG_NAMES2) {
        TAG_NAMES2["A"] = "a";
        TAG_NAMES2["ADDRESS"] = "address";
        TAG_NAMES2["ANNOTATION_XML"] = "annotation-xml";
        TAG_NAMES2["APPLET"] = "applet";
        TAG_NAMES2["AREA"] = "area";
        TAG_NAMES2["ARTICLE"] = "article";
        TAG_NAMES2["ASIDE"] = "aside";
        TAG_NAMES2["B"] = "b";
        TAG_NAMES2["BASE"] = "base";
        TAG_NAMES2["BASEFONT"] = "basefont";
        TAG_NAMES2["BGSOUND"] = "bgsound";
        TAG_NAMES2["BIG"] = "big";
        TAG_NAMES2["BLOCKQUOTE"] = "blockquote";
        TAG_NAMES2["BODY"] = "body";
        TAG_NAMES2["BR"] = "br";
        TAG_NAMES2["BUTTON"] = "button";
        TAG_NAMES2["CAPTION"] = "caption";
        TAG_NAMES2["CENTER"] = "center";
        TAG_NAMES2["CODE"] = "code";
        TAG_NAMES2["COL"] = "col";
        TAG_NAMES2["COLGROUP"] = "colgroup";
        TAG_NAMES2["DD"] = "dd";
        TAG_NAMES2["DESC"] = "desc";
        TAG_NAMES2["DETAILS"] = "details";
        TAG_NAMES2["DIALOG"] = "dialog";
        TAG_NAMES2["DIR"] = "dir";
        TAG_NAMES2["DIV"] = "div";
        TAG_NAMES2["DL"] = "dl";
        TAG_NAMES2["DT"] = "dt";
        TAG_NAMES2["EM"] = "em";
        TAG_NAMES2["EMBED"] = "embed";
        TAG_NAMES2["FIELDSET"] = "fieldset";
        TAG_NAMES2["FIGCAPTION"] = "figcaption";
        TAG_NAMES2["FIGURE"] = "figure";
        TAG_NAMES2["FONT"] = "font";
        TAG_NAMES2["FOOTER"] = "footer";
        TAG_NAMES2["FOREIGN_OBJECT"] = "foreignObject";
        TAG_NAMES2["FORM"] = "form";
        TAG_NAMES2["FRAME"] = "frame";
        TAG_NAMES2["FRAMESET"] = "frameset";
        TAG_NAMES2["H1"] = "h1";
        TAG_NAMES2["H2"] = "h2";
        TAG_NAMES2["H3"] = "h3";
        TAG_NAMES2["H4"] = "h4";
        TAG_NAMES2["H5"] = "h5";
        TAG_NAMES2["H6"] = "h6";
        TAG_NAMES2["HEAD"] = "head";
        TAG_NAMES2["HEADER"] = "header";
        TAG_NAMES2["HGROUP"] = "hgroup";
        TAG_NAMES2["HR"] = "hr";
        TAG_NAMES2["HTML"] = "html";
        TAG_NAMES2["I"] = "i";
        TAG_NAMES2["IMG"] = "img";
        TAG_NAMES2["IMAGE"] = "image";
        TAG_NAMES2["INPUT"] = "input";
        TAG_NAMES2["IFRAME"] = "iframe";
        TAG_NAMES2["KEYGEN"] = "keygen";
        TAG_NAMES2["LABEL"] = "label";
        TAG_NAMES2["LI"] = "li";
        TAG_NAMES2["LINK"] = "link";
        TAG_NAMES2["LISTING"] = "listing";
        TAG_NAMES2["MAIN"] = "main";
        TAG_NAMES2["MALIGNMARK"] = "malignmark";
        TAG_NAMES2["MARQUEE"] = "marquee";
        TAG_NAMES2["MATH"] = "math";
        TAG_NAMES2["MENU"] = "menu";
        TAG_NAMES2["META"] = "meta";
        TAG_NAMES2["MGLYPH"] = "mglyph";
        TAG_NAMES2["MI"] = "mi";
        TAG_NAMES2["MO"] = "mo";
        TAG_NAMES2["MN"] = "mn";
        TAG_NAMES2["MS"] = "ms";
        TAG_NAMES2["MTEXT"] = "mtext";
        TAG_NAMES2["NAV"] = "nav";
        TAG_NAMES2["NOBR"] = "nobr";
        TAG_NAMES2["NOFRAMES"] = "noframes";
        TAG_NAMES2["NOEMBED"] = "noembed";
        TAG_NAMES2["NOSCRIPT"] = "noscript";
        TAG_NAMES2["OBJECT"] = "object";
        TAG_NAMES2["OL"] = "ol";
        TAG_NAMES2["OPTGROUP"] = "optgroup";
        TAG_NAMES2["OPTION"] = "option";
        TAG_NAMES2["P"] = "p";
        TAG_NAMES2["PARAM"] = "param";
        TAG_NAMES2["PLAINTEXT"] = "plaintext";
        TAG_NAMES2["PRE"] = "pre";
        TAG_NAMES2["RB"] = "rb";
        TAG_NAMES2["RP"] = "rp";
        TAG_NAMES2["RT"] = "rt";
        TAG_NAMES2["RTC"] = "rtc";
        TAG_NAMES2["RUBY"] = "ruby";
        TAG_NAMES2["S"] = "s";
        TAG_NAMES2["SCRIPT"] = "script";
        TAG_NAMES2["SEARCH"] = "search";
        TAG_NAMES2["SECTION"] = "section";
        TAG_NAMES2["SELECT"] = "select";
        TAG_NAMES2["SOURCE"] = "source";
        TAG_NAMES2["SMALL"] = "small";
        TAG_NAMES2["SPAN"] = "span";
        TAG_NAMES2["STRIKE"] = "strike";
        TAG_NAMES2["STRONG"] = "strong";
        TAG_NAMES2["STYLE"] = "style";
        TAG_NAMES2["SUB"] = "sub";
        TAG_NAMES2["SUMMARY"] = "summary";
        TAG_NAMES2["SUP"] = "sup";
        TAG_NAMES2["TABLE"] = "table";
        TAG_NAMES2["TBODY"] = "tbody";
        TAG_NAMES2["TEMPLATE"] = "template";
        TAG_NAMES2["TEXTAREA"] = "textarea";
        TAG_NAMES2["TFOOT"] = "tfoot";
        TAG_NAMES2["TD"] = "td";
        TAG_NAMES2["TH"] = "th";
        TAG_NAMES2["THEAD"] = "thead";
        TAG_NAMES2["TITLE"] = "title";
        TAG_NAMES2["TR"] = "tr";
        TAG_NAMES2["TRACK"] = "track";
        TAG_NAMES2["TT"] = "tt";
        TAG_NAMES2["U"] = "u";
        TAG_NAMES2["UL"] = "ul";
        TAG_NAMES2["SVG"] = "svg";
        TAG_NAMES2["VAR"] = "var";
        TAG_NAMES2["WBR"] = "wbr";
        TAG_NAMES2["XMP"] = "xmp";
      })(TAG_NAMES || (TAG_NAMES = {}));
      (function(TAG_ID2) {
        TAG_ID2[TAG_ID2["UNKNOWN"] = 0] = "UNKNOWN";
        TAG_ID2[TAG_ID2["A"] = 1] = "A";
        TAG_ID2[TAG_ID2["ADDRESS"] = 2] = "ADDRESS";
        TAG_ID2[TAG_ID2["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
        TAG_ID2[TAG_ID2["APPLET"] = 4] = "APPLET";
        TAG_ID2[TAG_ID2["AREA"] = 5] = "AREA";
        TAG_ID2[TAG_ID2["ARTICLE"] = 6] = "ARTICLE";
        TAG_ID2[TAG_ID2["ASIDE"] = 7] = "ASIDE";
        TAG_ID2[TAG_ID2["B"] = 8] = "B";
        TAG_ID2[TAG_ID2["BASE"] = 9] = "BASE";
        TAG_ID2[TAG_ID2["BASEFONT"] = 10] = "BASEFONT";
        TAG_ID2[TAG_ID2["BGSOUND"] = 11] = "BGSOUND";
        TAG_ID2[TAG_ID2["BIG"] = 12] = "BIG";
        TAG_ID2[TAG_ID2["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
        TAG_ID2[TAG_ID2["BODY"] = 14] = "BODY";
        TAG_ID2[TAG_ID2["BR"] = 15] = "BR";
        TAG_ID2[TAG_ID2["BUTTON"] = 16] = "BUTTON";
        TAG_ID2[TAG_ID2["CAPTION"] = 17] = "CAPTION";
        TAG_ID2[TAG_ID2["CENTER"] = 18] = "CENTER";
        TAG_ID2[TAG_ID2["CODE"] = 19] = "CODE";
        TAG_ID2[TAG_ID2["COL"] = 20] = "COL";
        TAG_ID2[TAG_ID2["COLGROUP"] = 21] = "COLGROUP";
        TAG_ID2[TAG_ID2["DD"] = 22] = "DD";
        TAG_ID2[TAG_ID2["DESC"] = 23] = "DESC";
        TAG_ID2[TAG_ID2["DETAILS"] = 24] = "DETAILS";
        TAG_ID2[TAG_ID2["DIALOG"] = 25] = "DIALOG";
        TAG_ID2[TAG_ID2["DIR"] = 26] = "DIR";
        TAG_ID2[TAG_ID2["DIV"] = 27] = "DIV";
        TAG_ID2[TAG_ID2["DL"] = 28] = "DL";
        TAG_ID2[TAG_ID2["DT"] = 29] = "DT";
        TAG_ID2[TAG_ID2["EM"] = 30] = "EM";
        TAG_ID2[TAG_ID2["EMBED"] = 31] = "EMBED";
        TAG_ID2[TAG_ID2["FIELDSET"] = 32] = "FIELDSET";
        TAG_ID2[TAG_ID2["FIGCAPTION"] = 33] = "FIGCAPTION";
        TAG_ID2[TAG_ID2["FIGURE"] = 34] = "FIGURE";
        TAG_ID2[TAG_ID2["FONT"] = 35] = "FONT";
        TAG_ID2[TAG_ID2["FOOTER"] = 36] = "FOOTER";
        TAG_ID2[TAG_ID2["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
        TAG_ID2[TAG_ID2["FORM"] = 38] = "FORM";
        TAG_ID2[TAG_ID2["FRAME"] = 39] = "FRAME";
        TAG_ID2[TAG_ID2["FRAMESET"] = 40] = "FRAMESET";
        TAG_ID2[TAG_ID2["H1"] = 41] = "H1";
        TAG_ID2[TAG_ID2["H2"] = 42] = "H2";
        TAG_ID2[TAG_ID2["H3"] = 43] = "H3";
        TAG_ID2[TAG_ID2["H4"] = 44] = "H4";
        TAG_ID2[TAG_ID2["H5"] = 45] = "H5";
        TAG_ID2[TAG_ID2["H6"] = 46] = "H6";
        TAG_ID2[TAG_ID2["HEAD"] = 47] = "HEAD";
        TAG_ID2[TAG_ID2["HEADER"] = 48] = "HEADER";
        TAG_ID2[TAG_ID2["HGROUP"] = 49] = "HGROUP";
        TAG_ID2[TAG_ID2["HR"] = 50] = "HR";
        TAG_ID2[TAG_ID2["HTML"] = 51] = "HTML";
        TAG_ID2[TAG_ID2["I"] = 52] = "I";
        TAG_ID2[TAG_ID2["IMG"] = 53] = "IMG";
        TAG_ID2[TAG_ID2["IMAGE"] = 54] = "IMAGE";
        TAG_ID2[TAG_ID2["INPUT"] = 55] = "INPUT";
        TAG_ID2[TAG_ID2["IFRAME"] = 56] = "IFRAME";
        TAG_ID2[TAG_ID2["KEYGEN"] = 57] = "KEYGEN";
        TAG_ID2[TAG_ID2["LABEL"] = 58] = "LABEL";
        TAG_ID2[TAG_ID2["LI"] = 59] = "LI";
        TAG_ID2[TAG_ID2["LINK"] = 60] = "LINK";
        TAG_ID2[TAG_ID2["LISTING"] = 61] = "LISTING";
        TAG_ID2[TAG_ID2["MAIN"] = 62] = "MAIN";
        TAG_ID2[TAG_ID2["MALIGNMARK"] = 63] = "MALIGNMARK";
        TAG_ID2[TAG_ID2["MARQUEE"] = 64] = "MARQUEE";
        TAG_ID2[TAG_ID2["MATH"] = 65] = "MATH";
        TAG_ID2[TAG_ID2["MENU"] = 66] = "MENU";
        TAG_ID2[TAG_ID2["META"] = 67] = "META";
        TAG_ID2[TAG_ID2["MGLYPH"] = 68] = "MGLYPH";
        TAG_ID2[TAG_ID2["MI"] = 69] = "MI";
        TAG_ID2[TAG_ID2["MO"] = 70] = "MO";
        TAG_ID2[TAG_ID2["MN"] = 71] = "MN";
        TAG_ID2[TAG_ID2["MS"] = 72] = "MS";
        TAG_ID2[TAG_ID2["MTEXT"] = 73] = "MTEXT";
        TAG_ID2[TAG_ID2["NAV"] = 74] = "NAV";
        TAG_ID2[TAG_ID2["NOBR"] = 75] = "NOBR";
        TAG_ID2[TAG_ID2["NOFRAMES"] = 76] = "NOFRAMES";
        TAG_ID2[TAG_ID2["NOEMBED"] = 77] = "NOEMBED";
        TAG_ID2[TAG_ID2["NOSCRIPT"] = 78] = "NOSCRIPT";
        TAG_ID2[TAG_ID2["OBJECT"] = 79] = "OBJECT";
        TAG_ID2[TAG_ID2["OL"] = 80] = "OL";
        TAG_ID2[TAG_ID2["OPTGROUP"] = 81] = "OPTGROUP";
        TAG_ID2[TAG_ID2["OPTION"] = 82] = "OPTION";
        TAG_ID2[TAG_ID2["P"] = 83] = "P";
        TAG_ID2[TAG_ID2["PARAM"] = 84] = "PARAM";
        TAG_ID2[TAG_ID2["PLAINTEXT"] = 85] = "PLAINTEXT";
        TAG_ID2[TAG_ID2["PRE"] = 86] = "PRE";
        TAG_ID2[TAG_ID2["RB"] = 87] = "RB";
        TAG_ID2[TAG_ID2["RP"] = 88] = "RP";
        TAG_ID2[TAG_ID2["RT"] = 89] = "RT";
        TAG_ID2[TAG_ID2["RTC"] = 90] = "RTC";
        TAG_ID2[TAG_ID2["RUBY"] = 91] = "RUBY";
        TAG_ID2[TAG_ID2["S"] = 92] = "S";
        TAG_ID2[TAG_ID2["SCRIPT"] = 93] = "SCRIPT";
        TAG_ID2[TAG_ID2["SEARCH"] = 94] = "SEARCH";
        TAG_ID2[TAG_ID2["SECTION"] = 95] = "SECTION";
        TAG_ID2[TAG_ID2["SELECT"] = 96] = "SELECT";
        TAG_ID2[TAG_ID2["SOURCE"] = 97] = "SOURCE";
        TAG_ID2[TAG_ID2["SMALL"] = 98] = "SMALL";
        TAG_ID2[TAG_ID2["SPAN"] = 99] = "SPAN";
        TAG_ID2[TAG_ID2["STRIKE"] = 100] = "STRIKE";
        TAG_ID2[TAG_ID2["STRONG"] = 101] = "STRONG";
        TAG_ID2[TAG_ID2["STYLE"] = 102] = "STYLE";
        TAG_ID2[TAG_ID2["SUB"] = 103] = "SUB";
        TAG_ID2[TAG_ID2["SUMMARY"] = 104] = "SUMMARY";
        TAG_ID2[TAG_ID2["SUP"] = 105] = "SUP";
        TAG_ID2[TAG_ID2["TABLE"] = 106] = "TABLE";
        TAG_ID2[TAG_ID2["TBODY"] = 107] = "TBODY";
        TAG_ID2[TAG_ID2["TEMPLATE"] = 108] = "TEMPLATE";
        TAG_ID2[TAG_ID2["TEXTAREA"] = 109] = "TEXTAREA";
        TAG_ID2[TAG_ID2["TFOOT"] = 110] = "TFOOT";
        TAG_ID2[TAG_ID2["TD"] = 111] = "TD";
        TAG_ID2[TAG_ID2["TH"] = 112] = "TH";
        TAG_ID2[TAG_ID2["THEAD"] = 113] = "THEAD";
        TAG_ID2[TAG_ID2["TITLE"] = 114] = "TITLE";
        TAG_ID2[TAG_ID2["TR"] = 115] = "TR";
        TAG_ID2[TAG_ID2["TRACK"] = 116] = "TRACK";
        TAG_ID2[TAG_ID2["TT"] = 117] = "TT";
        TAG_ID2[TAG_ID2["U"] = 118] = "U";
        TAG_ID2[TAG_ID2["UL"] = 119] = "UL";
        TAG_ID2[TAG_ID2["SVG"] = 120] = "SVG";
        TAG_ID2[TAG_ID2["VAR"] = 121] = "VAR";
        TAG_ID2[TAG_ID2["WBR"] = 122] = "WBR";
        TAG_ID2[TAG_ID2["XMP"] = 123] = "XMP";
      })(TAG_ID || (TAG_ID = {}));
      TAG_NAME_TO_ID = /* @__PURE__ */ new Map([
        [TAG_NAMES.A, TAG_ID.A],
        [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
        [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
        [TAG_NAMES.APPLET, TAG_ID.APPLET],
        [TAG_NAMES.AREA, TAG_ID.AREA],
        [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
        [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
        [TAG_NAMES.B, TAG_ID.B],
        [TAG_NAMES.BASE, TAG_ID.BASE],
        [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
        [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
        [TAG_NAMES.BIG, TAG_ID.BIG],
        [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
        [TAG_NAMES.BODY, TAG_ID.BODY],
        [TAG_NAMES.BR, TAG_ID.BR],
        [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
        [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
        [TAG_NAMES.CENTER, TAG_ID.CENTER],
        [TAG_NAMES.CODE, TAG_ID.CODE],
        [TAG_NAMES.COL, TAG_ID.COL],
        [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
        [TAG_NAMES.DD, TAG_ID.DD],
        [TAG_NAMES.DESC, TAG_ID.DESC],
        [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
        [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
        [TAG_NAMES.DIR, TAG_ID.DIR],
        [TAG_NAMES.DIV, TAG_ID.DIV],
        [TAG_NAMES.DL, TAG_ID.DL],
        [TAG_NAMES.DT, TAG_ID.DT],
        [TAG_NAMES.EM, TAG_ID.EM],
        [TAG_NAMES.EMBED, TAG_ID.EMBED],
        [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
        [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
        [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
        [TAG_NAMES.FONT, TAG_ID.FONT],
        [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
        [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
        [TAG_NAMES.FORM, TAG_ID.FORM],
        [TAG_NAMES.FRAME, TAG_ID.FRAME],
        [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
        [TAG_NAMES.H1, TAG_ID.H1],
        [TAG_NAMES.H2, TAG_ID.H2],
        [TAG_NAMES.H3, TAG_ID.H3],
        [TAG_NAMES.H4, TAG_ID.H4],
        [TAG_NAMES.H5, TAG_ID.H5],
        [TAG_NAMES.H6, TAG_ID.H6],
        [TAG_NAMES.HEAD, TAG_ID.HEAD],
        [TAG_NAMES.HEADER, TAG_ID.HEADER],
        [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
        [TAG_NAMES.HR, TAG_ID.HR],
        [TAG_NAMES.HTML, TAG_ID.HTML],
        [TAG_NAMES.I, TAG_ID.I],
        [TAG_NAMES.IMG, TAG_ID.IMG],
        [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
        [TAG_NAMES.INPUT, TAG_ID.INPUT],
        [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
        [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
        [TAG_NAMES.LABEL, TAG_ID.LABEL],
        [TAG_NAMES.LI, TAG_ID.LI],
        [TAG_NAMES.LINK, TAG_ID.LINK],
        [TAG_NAMES.LISTING, TAG_ID.LISTING],
        [TAG_NAMES.MAIN, TAG_ID.MAIN],
        [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
        [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
        [TAG_NAMES.MATH, TAG_ID.MATH],
        [TAG_NAMES.MENU, TAG_ID.MENU],
        [TAG_NAMES.META, TAG_ID.META],
        [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
        [TAG_NAMES.MI, TAG_ID.MI],
        [TAG_NAMES.MO, TAG_ID.MO],
        [TAG_NAMES.MN, TAG_ID.MN],
        [TAG_NAMES.MS, TAG_ID.MS],
        [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
        [TAG_NAMES.NAV, TAG_ID.NAV],
        [TAG_NAMES.NOBR, TAG_ID.NOBR],
        [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
        [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
        [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
        [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
        [TAG_NAMES.OL, TAG_ID.OL],
        [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
        [TAG_NAMES.OPTION, TAG_ID.OPTION],
        [TAG_NAMES.P, TAG_ID.P],
        [TAG_NAMES.PARAM, TAG_ID.PARAM],
        [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
        [TAG_NAMES.PRE, TAG_ID.PRE],
        [TAG_NAMES.RB, TAG_ID.RB],
        [TAG_NAMES.RP, TAG_ID.RP],
        [TAG_NAMES.RT, TAG_ID.RT],
        [TAG_NAMES.RTC, TAG_ID.RTC],
        [TAG_NAMES.RUBY, TAG_ID.RUBY],
        [TAG_NAMES.S, TAG_ID.S],
        [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
        [TAG_NAMES.SEARCH, TAG_ID.SEARCH],
        [TAG_NAMES.SECTION, TAG_ID.SECTION],
        [TAG_NAMES.SELECT, TAG_ID.SELECT],
        [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
        [TAG_NAMES.SMALL, TAG_ID.SMALL],
        [TAG_NAMES.SPAN, TAG_ID.SPAN],
        [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
        [TAG_NAMES.STRONG, TAG_ID.STRONG],
        [TAG_NAMES.STYLE, TAG_ID.STYLE],
        [TAG_NAMES.SUB, TAG_ID.SUB],
        [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
        [TAG_NAMES.SUP, TAG_ID.SUP],
        [TAG_NAMES.TABLE, TAG_ID.TABLE],
        [TAG_NAMES.TBODY, TAG_ID.TBODY],
        [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
        [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
        [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
        [TAG_NAMES.TD, TAG_ID.TD],
        [TAG_NAMES.TH, TAG_ID.TH],
        [TAG_NAMES.THEAD, TAG_ID.THEAD],
        [TAG_NAMES.TITLE, TAG_ID.TITLE],
        [TAG_NAMES.TR, TAG_ID.TR],
        [TAG_NAMES.TRACK, TAG_ID.TRACK],
        [TAG_NAMES.TT, TAG_ID.TT],
        [TAG_NAMES.U, TAG_ID.U],
        [TAG_NAMES.UL, TAG_ID.UL],
        [TAG_NAMES.SVG, TAG_ID.SVG],
        [TAG_NAMES.VAR, TAG_ID.VAR],
        [TAG_NAMES.WBR, TAG_ID.WBR],
        [TAG_NAMES.XMP, TAG_ID.XMP]
      ]);
      $ = TAG_ID;
      SPECIAL_ELEMENTS = {
        [NS.HTML]: /* @__PURE__ */ new Set([
          $.ADDRESS,
          $.APPLET,
          $.AREA,
          $.ARTICLE,
          $.ASIDE,
          $.BASE,
          $.BASEFONT,
          $.BGSOUND,
          $.BLOCKQUOTE,
          $.BODY,
          $.BR,
          $.BUTTON,
          $.CAPTION,
          $.CENTER,
          $.COL,
          $.COLGROUP,
          $.DD,
          $.DETAILS,
          $.DIR,
          $.DIV,
          $.DL,
          $.DT,
          $.EMBED,
          $.FIELDSET,
          $.FIGCAPTION,
          $.FIGURE,
          $.FOOTER,
          $.FORM,
          $.FRAME,
          $.FRAMESET,
          $.H1,
          $.H2,
          $.H3,
          $.H4,
          $.H5,
          $.H6,
          $.HEAD,
          $.HEADER,
          $.HGROUP,
          $.HR,
          $.HTML,
          $.IFRAME,
          $.IMG,
          $.INPUT,
          $.LI,
          $.LINK,
          $.LISTING,
          $.MAIN,
          $.MARQUEE,
          $.MENU,
          $.META,
          $.NAV,
          $.NOEMBED,
          $.NOFRAMES,
          $.NOSCRIPT,
          $.OBJECT,
          $.OL,
          $.P,
          $.PARAM,
          $.PLAINTEXT,
          $.PRE,
          $.SCRIPT,
          $.SECTION,
          $.SELECT,
          $.SOURCE,
          $.STYLE,
          $.SUMMARY,
          $.TABLE,
          $.TBODY,
          $.TD,
          $.TEMPLATE,
          $.TEXTAREA,
          $.TFOOT,
          $.TH,
          $.THEAD,
          $.TITLE,
          $.TR,
          $.TRACK,
          $.UL,
          $.WBR,
          $.XMP
        ]),
        [NS.MATHML]: /* @__PURE__ */ new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
        [NS.SVG]: /* @__PURE__ */ new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
        [NS.XLINK]: /* @__PURE__ */ new Set(),
        [NS.XML]: /* @__PURE__ */ new Set(),
        [NS.XMLNS]: /* @__PURE__ */ new Set()
      };
      NUMBERED_HEADERS = /* @__PURE__ */ new Set([$.H1, $.H2, $.H3, $.H4, $.H5, $.H6]);
      UNESCAPED_TEXT = /* @__PURE__ */ new Set([
        TAG_NAMES.STYLE,
        TAG_NAMES.SCRIPT,
        TAG_NAMES.XMP,
        TAG_NAMES.IFRAME,
        TAG_NAMES.NOEMBED,
        TAG_NAMES.NOFRAMES,
        TAG_NAMES.PLAINTEXT
      ]);
    }
  });

  // node_modules/parse5/dist/tokenizer/index.js
  function isAsciiDigit(cp) {
    return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
  }
  function isAsciiUpper(cp) {
    return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
  }
  function isAsciiLower(cp) {
    return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
  }
  function isAsciiLetter(cp) {
    return isAsciiLower(cp) || isAsciiUpper(cp);
  }
  function isAsciiAlphaNumeric2(cp) {
    return isAsciiLetter(cp) || isAsciiDigit(cp);
  }
  function toAsciiLower(cp) {
    return cp + 32;
  }
  function isWhitespace(cp) {
    return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
  }
  function isScriptDataDoubleEscapeSequenceEnd(cp) {
    return isWhitespace(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
  }
  function getErrorForNumericCharacterReference(code5) {
    if (code5 === CODE_POINTS.NULL) {
      return ERR.nullCharacterReference;
    } else if (code5 > 1114111) {
      return ERR.characterReferenceOutsideUnicodeRange;
    } else if (isSurrogate(code5)) {
      return ERR.surrogateCharacterReference;
    } else if (isUndefinedCodePoint(code5)) {
      return ERR.noncharacterCharacterReference;
    } else if (isControlCodePoint(code5) || code5 === CODE_POINTS.CARRIAGE_RETURN) {
      return ERR.controlCharacterReference;
    }
    return null;
  }
  var State, TokenizerMode, Tokenizer;
  var init_tokenizer = __esm({
    "node_modules/parse5/dist/tokenizer/index.js"() {
      init_preprocessor();
      init_unicode();
      init_token();
      init_decode();
      init_error_codes();
      init_html2();
      (function(State3) {
        State3[State3["DATA"] = 0] = "DATA";
        State3[State3["RCDATA"] = 1] = "RCDATA";
        State3[State3["RAWTEXT"] = 2] = "RAWTEXT";
        State3[State3["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
        State3[State3["PLAINTEXT"] = 4] = "PLAINTEXT";
        State3[State3["TAG_OPEN"] = 5] = "TAG_OPEN";
        State3[State3["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
        State3[State3["TAG_NAME"] = 7] = "TAG_NAME";
        State3[State3["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
        State3[State3["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
        State3[State3["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
        State3[State3["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
        State3[State3["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
        State3[State3["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
        State3[State3["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
        State3[State3["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
        State3[State3["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
        State3[State3["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
        State3[State3["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
        State3[State3["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
        State3[State3["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
        State3[State3["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
        State3[State3["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
        State3[State3["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
        State3[State3["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
        State3[State3["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
        State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
        State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
        State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
        State3[State3["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
        State3[State3["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
        State3[State3["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
        State3[State3["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
        State3[State3["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
        State3[State3["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
        State3[State3["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
        State3[State3["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
        State3[State3["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
        State3[State3["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
        State3[State3["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
        State3[State3["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
        State3[State3["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
        State3[State3["COMMENT_START"] = 42] = "COMMENT_START";
        State3[State3["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
        State3[State3["COMMENT"] = 44] = "COMMENT";
        State3[State3["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
        State3[State3["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
        State3[State3["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
        State3[State3["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
        State3[State3["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
        State3[State3["COMMENT_END"] = 50] = "COMMENT_END";
        State3[State3["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
        State3[State3["DOCTYPE"] = 52] = "DOCTYPE";
        State3[State3["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
        State3[State3["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
        State3[State3["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
        State3[State3["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
        State3[State3["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
        State3[State3["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
        State3[State3["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
        State3[State3["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
        State3[State3["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
        State3[State3["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
        State3[State3["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
        State3[State3["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
        State3[State3["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
        State3[State3["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
        State3[State3["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
        State3[State3["CDATA_SECTION"] = 68] = "CDATA_SECTION";
        State3[State3["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
        State3[State3["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
        State3[State3["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
        State3[State3["AMBIGUOUS_AMPERSAND"] = 72] = "AMBIGUOUS_AMPERSAND";
      })(State || (State = {}));
      TokenizerMode = {
        DATA: State.DATA,
        RCDATA: State.RCDATA,
        RAWTEXT: State.RAWTEXT,
        SCRIPT_DATA: State.SCRIPT_DATA,
        PLAINTEXT: State.PLAINTEXT,
        CDATA_SECTION: State.CDATA_SECTION
      };
      Tokenizer = class {
        constructor(options2, handler) {
          this.options = options2;
          this.handler = handler;
          this.paused = false;
          this.inLoop = false;
          this.inForeignNode = false;
          this.lastStartTagName = "";
          this.active = false;
          this.state = State.DATA;
          this.returnState = State.DATA;
          this.entityStartPos = 0;
          this.consumedAfterSnapshot = -1;
          this.currentCharacterToken = null;
          this.currentToken = null;
          this.currentAttr = { name: "", value: "" };
          this.preprocessor = new Preprocessor(handler);
          this.currentLocation = this.getCurrentLocation(-1);
          this.entityDecoder = new EntityDecoder(htmlDecodeTree, (cp, consumed) => {
            this.preprocessor.pos = this.entityStartPos + consumed - 1;
            this._flushCodePointConsumedAsCharacterReference(cp);
          }, handler.onParseError ? {
            missingSemicolonAfterCharacterReference: () => {
              this._err(ERR.missingSemicolonAfterCharacterReference, 1);
            },
            absenceOfDigitsInNumericCharacterReference: (consumed) => {
              this._err(ERR.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + consumed);
            },
            validateNumericCharacterReference: (code5) => {
              const error = getErrorForNumericCharacterReference(code5);
              if (error)
                this._err(error, 1);
            }
          } : void 0);
        }
        //Errors
        _err(code5, cpOffset = 0) {
          var _a3, _b;
          (_b = (_a3 = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a3, this.preprocessor.getError(code5, cpOffset));
        }
        // NOTE: `offset` may never run across line boundaries.
        getCurrentLocation(offset) {
          if (!this.options.sourceCodeLocationInfo) {
            return null;
          }
          return {
            startLine: this.preprocessor.line,
            startCol: this.preprocessor.col - offset,
            startOffset: this.preprocessor.offset - offset,
            endLine: -1,
            endCol: -1,
            endOffset: -1
          };
        }
        _runParsingLoop() {
          if (this.inLoop)
            return;
          this.inLoop = true;
          while (this.active && !this.paused) {
            this.consumedAfterSnapshot = 0;
            const cp = this._consume();
            if (!this._ensureHibernation()) {
              this._callState(cp);
            }
          }
          this.inLoop = false;
        }
        //API
        pause() {
          this.paused = true;
        }
        resume(writeCallback) {
          if (!this.paused) {
            throw new Error("Parser was already resumed");
          }
          this.paused = false;
          if (this.inLoop)
            return;
          this._runParsingLoop();
          if (!this.paused) {
            writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
          }
        }
        write(chunk, isLastChunk, writeCallback) {
          this.active = true;
          this.preprocessor.write(chunk, isLastChunk);
          this._runParsingLoop();
          if (!this.paused) {
            writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
          }
        }
        insertHtmlAtCurrentPos(chunk) {
          this.active = true;
          this.preprocessor.insertHtmlAtCurrentPos(chunk);
          this._runParsingLoop();
        }
        //Hibernation
        _ensureHibernation() {
          if (this.preprocessor.endOfChunkHit) {
            this.preprocessor.retreat(this.consumedAfterSnapshot);
            this.consumedAfterSnapshot = 0;
            this.active = false;
            return true;
          }
          return false;
        }
        //Consumption
        _consume() {
          this.consumedAfterSnapshot++;
          return this.preprocessor.advance();
        }
        _advanceBy(count) {
          this.consumedAfterSnapshot += count;
          for (let i = 0; i < count; i++) {
            this.preprocessor.advance();
          }
        }
        _consumeSequenceIfMatch(pattern, caseSensitive) {
          if (this.preprocessor.startsWith(pattern, caseSensitive)) {
            this._advanceBy(pattern.length - 1);
            return true;
          }
          return false;
        }
        //Token creation
        _createStartTagToken() {
          this.currentToken = {
            type: TokenType.START_TAG,
            tagName: "",
            tagID: TAG_ID.UNKNOWN,
            selfClosing: false,
            ackSelfClosing: false,
            attrs: [],
            location: this.getCurrentLocation(1)
          };
        }
        _createEndTagToken() {
          this.currentToken = {
            type: TokenType.END_TAG,
            tagName: "",
            tagID: TAG_ID.UNKNOWN,
            selfClosing: false,
            ackSelfClosing: false,
            attrs: [],
            location: this.getCurrentLocation(2)
          };
        }
        _createCommentToken(offset) {
          this.currentToken = {
            type: TokenType.COMMENT,
            data: "",
            location: this.getCurrentLocation(offset)
          };
        }
        _createDoctypeToken(initialName) {
          this.currentToken = {
            type: TokenType.DOCTYPE,
            name: initialName,
            forceQuirks: false,
            publicId: null,
            systemId: null,
            location: this.currentLocation
          };
        }
        _createCharacterToken(type, chars) {
          this.currentCharacterToken = {
            type,
            chars,
            location: this.currentLocation
          };
        }
        //Tag attributes
        _createAttr(attrNameFirstCh) {
          this.currentAttr = {
            name: attrNameFirstCh,
            value: ""
          };
          this.currentLocation = this.getCurrentLocation(0);
        }
        _leaveAttrName() {
          var _a3;
          var _b;
          const token = this.currentToken;
          if (getTokenAttr(token, this.currentAttr.name) === null) {
            token.attrs.push(this.currentAttr);
            if (token.location && this.currentLocation) {
              const attrLocations = (_a3 = (_b = token.location).attrs) !== null && _a3 !== void 0 ? _a3 : _b.attrs = /* @__PURE__ */ Object.create(null);
              attrLocations[this.currentAttr.name] = this.currentLocation;
              this._leaveAttrValue();
            }
          } else {
            this._err(ERR.duplicateAttribute);
          }
        }
        _leaveAttrValue() {
          if (this.currentLocation) {
            this.currentLocation.endLine = this.preprocessor.line;
            this.currentLocation.endCol = this.preprocessor.col;
            this.currentLocation.endOffset = this.preprocessor.offset;
          }
        }
        //Token emission
        prepareToken(ct2) {
          this._emitCurrentCharacterToken(ct2.location);
          this.currentToken = null;
          if (ct2.location) {
            ct2.location.endLine = this.preprocessor.line;
            ct2.location.endCol = this.preprocessor.col + 1;
            ct2.location.endOffset = this.preprocessor.offset + 1;
          }
          this.currentLocation = this.getCurrentLocation(-1);
        }
        emitCurrentTagToken() {
          const ct2 = this.currentToken;
          this.prepareToken(ct2);
          ct2.tagID = getTagID(ct2.tagName);
          if (ct2.type === TokenType.START_TAG) {
            this.lastStartTagName = ct2.tagName;
            this.handler.onStartTag(ct2);
          } else {
            if (ct2.attrs.length > 0) {
              this._err(ERR.endTagWithAttributes);
            }
            if (ct2.selfClosing) {
              this._err(ERR.endTagWithTrailingSolidus);
            }
            this.handler.onEndTag(ct2);
          }
          this.preprocessor.dropParsedChunk();
        }
        emitCurrentComment(ct2) {
          this.prepareToken(ct2);
          this.handler.onComment(ct2);
          this.preprocessor.dropParsedChunk();
        }
        emitCurrentDoctype(ct2) {
          this.prepareToken(ct2);
          this.handler.onDoctype(ct2);
          this.preprocessor.dropParsedChunk();
        }
        _emitCurrentCharacterToken(nextLocation) {
          if (this.currentCharacterToken) {
            if (nextLocation && this.currentCharacterToken.location) {
              this.currentCharacterToken.location.endLine = nextLocation.startLine;
              this.currentCharacterToken.location.endCol = nextLocation.startCol;
              this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
            }
            switch (this.currentCharacterToken.type) {
              case TokenType.CHARACTER: {
                this.handler.onCharacter(this.currentCharacterToken);
                break;
              }
              case TokenType.NULL_CHARACTER: {
                this.handler.onNullCharacter(this.currentCharacterToken);
                break;
              }
              case TokenType.WHITESPACE_CHARACTER: {
                this.handler.onWhitespaceCharacter(this.currentCharacterToken);
                break;
              }
            }
            this.currentCharacterToken = null;
          }
        }
        _emitEOFToken() {
          const location3 = this.getCurrentLocation(0);
          if (location3) {
            location3.endLine = location3.startLine;
            location3.endCol = location3.startCol;
            location3.endOffset = location3.startOffset;
          }
          this._emitCurrentCharacterToken(location3);
          this.handler.onEof({ type: TokenType.EOF, location: location3 });
          this.active = false;
        }
        //Characters emission
        //OPTIMIZATION: The specification uses only one type of character token (one token per character).
        //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
        //If we have a sequence of characters that belong to the same group, the parser can process it
        //as a single solid character token.
        //So, there are 3 types of character tokens in parse5:
        //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
        //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
        //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
        _appendCharToCurrentCharacterToken(type, ch) {
          if (this.currentCharacterToken) {
            if (this.currentCharacterToken.type === type) {
              this.currentCharacterToken.chars += ch;
              return;
            } else {
              this.currentLocation = this.getCurrentLocation(0);
              this._emitCurrentCharacterToken(this.currentLocation);
              this.preprocessor.dropParsedChunk();
            }
          }
          this._createCharacterToken(type, ch);
        }
        _emitCodePoint(cp) {
          const type = isWhitespace(cp) ? TokenType.WHITESPACE_CHARACTER : cp === CODE_POINTS.NULL ? TokenType.NULL_CHARACTER : TokenType.CHARACTER;
          this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
        }
        //NOTE: used when we emit characters explicitly.
        //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
        _emitChars(ch) {
          this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
        }
        // Character reference helpers
        _startCharacterReference() {
          this.returnState = this.state;
          this.state = State.CHARACTER_REFERENCE;
          this.entityStartPos = this.preprocessor.pos;
          this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? DecodingMode.Attribute : DecodingMode.Legacy);
        }
        _isCharacterReferenceInAttribute() {
          return this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED;
        }
        _flushCodePointConsumedAsCharacterReference(cp) {
          if (this._isCharacterReferenceInAttribute()) {
            this.currentAttr.value += String.fromCodePoint(cp);
          } else {
            this._emitCodePoint(cp);
          }
        }
        // Calling states this way turns out to be much faster than any other approach.
        _callState(cp) {
          switch (this.state) {
            case State.DATA: {
              this._stateData(cp);
              break;
            }
            case State.RCDATA: {
              this._stateRcdata(cp);
              break;
            }
            case State.RAWTEXT: {
              this._stateRawtext(cp);
              break;
            }
            case State.SCRIPT_DATA: {
              this._stateScriptData(cp);
              break;
            }
            case State.PLAINTEXT: {
              this._statePlaintext(cp);
              break;
            }
            case State.TAG_OPEN: {
              this._stateTagOpen(cp);
              break;
            }
            case State.END_TAG_OPEN: {
              this._stateEndTagOpen(cp);
              break;
            }
            case State.TAG_NAME: {
              this._stateTagName(cp);
              break;
            }
            case State.RCDATA_LESS_THAN_SIGN: {
              this._stateRcdataLessThanSign(cp);
              break;
            }
            case State.RCDATA_END_TAG_OPEN: {
              this._stateRcdataEndTagOpen(cp);
              break;
            }
            case State.RCDATA_END_TAG_NAME: {
              this._stateRcdataEndTagName(cp);
              break;
            }
            case State.RAWTEXT_LESS_THAN_SIGN: {
              this._stateRawtextLessThanSign(cp);
              break;
            }
            case State.RAWTEXT_END_TAG_OPEN: {
              this._stateRawtextEndTagOpen(cp);
              break;
            }
            case State.RAWTEXT_END_TAG_NAME: {
              this._stateRawtextEndTagName(cp);
              break;
            }
            case State.SCRIPT_DATA_LESS_THAN_SIGN: {
              this._stateScriptDataLessThanSign(cp);
              break;
            }
            case State.SCRIPT_DATA_END_TAG_OPEN: {
              this._stateScriptDataEndTagOpen(cp);
              break;
            }
            case State.SCRIPT_DATA_END_TAG_NAME: {
              this._stateScriptDataEndTagName(cp);
              break;
            }
            case State.SCRIPT_DATA_ESCAPE_START: {
              this._stateScriptDataEscapeStart(cp);
              break;
            }
            case State.SCRIPT_DATA_ESCAPE_START_DASH: {
              this._stateScriptDataEscapeStartDash(cp);
              break;
            }
            case State.SCRIPT_DATA_ESCAPED: {
              this._stateScriptDataEscaped(cp);
              break;
            }
            case State.SCRIPT_DATA_ESCAPED_DASH: {
              this._stateScriptDataEscapedDash(cp);
              break;
            }
            case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {
              this._stateScriptDataEscapedDashDash(cp);
              break;
            }
            case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
              this._stateScriptDataEscapedLessThanSign(cp);
              break;
            }
            case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
              this._stateScriptDataEscapedEndTagOpen(cp);
              break;
            }
            case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
              this._stateScriptDataEscapedEndTagName(cp);
              break;
            }
            case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
              this._stateScriptDataDoubleEscapeStart(cp);
              break;
            }
            case State.SCRIPT_DATA_DOUBLE_ESCAPED: {
              this._stateScriptDataDoubleEscaped(cp);
              break;
            }
            case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
              this._stateScriptDataDoubleEscapedDash(cp);
              break;
            }
            case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
              this._stateScriptDataDoubleEscapedDashDash(cp);
              break;
            }
            case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
              this._stateScriptDataDoubleEscapedLessThanSign(cp);
              break;
            }
            case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
              this._stateScriptDataDoubleEscapeEnd(cp);
              break;
            }
            case State.BEFORE_ATTRIBUTE_NAME: {
              this._stateBeforeAttributeName(cp);
              break;
            }
            case State.ATTRIBUTE_NAME: {
              this._stateAttributeName(cp);
              break;
            }
            case State.AFTER_ATTRIBUTE_NAME: {
              this._stateAfterAttributeName(cp);
              break;
            }
            case State.BEFORE_ATTRIBUTE_VALUE: {
              this._stateBeforeAttributeValue(cp);
              break;
            }
            case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
              this._stateAttributeValueDoubleQuoted(cp);
              break;
            }
            case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
              this._stateAttributeValueSingleQuoted(cp);
              break;
            }
            case State.ATTRIBUTE_VALUE_UNQUOTED: {
              this._stateAttributeValueUnquoted(cp);
              break;
            }
            case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {
              this._stateAfterAttributeValueQuoted(cp);
              break;
            }
            case State.SELF_CLOSING_START_TAG: {
              this._stateSelfClosingStartTag(cp);
              break;
            }
            case State.BOGUS_COMMENT: {
              this._stateBogusComment(cp);
              break;
            }
            case State.MARKUP_DECLARATION_OPEN: {
              this._stateMarkupDeclarationOpen(cp);
              break;
            }
            case State.COMMENT_START: {
              this._stateCommentStart(cp);
              break;
            }
            case State.COMMENT_START_DASH: {
              this._stateCommentStartDash(cp);
              break;
            }
            case State.COMMENT: {
              this._stateComment(cp);
              break;
            }
            case State.COMMENT_LESS_THAN_SIGN: {
              this._stateCommentLessThanSign(cp);
              break;
            }
            case State.COMMENT_LESS_THAN_SIGN_BANG: {
              this._stateCommentLessThanSignBang(cp);
              break;
            }
            case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
              this._stateCommentLessThanSignBangDash(cp);
              break;
            }
            case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
              this._stateCommentLessThanSignBangDashDash(cp);
              break;
            }
            case State.COMMENT_END_DASH: {
              this._stateCommentEndDash(cp);
              break;
            }
            case State.COMMENT_END: {
              this._stateCommentEnd(cp);
              break;
            }
            case State.COMMENT_END_BANG: {
              this._stateCommentEndBang(cp);
              break;
            }
            case State.DOCTYPE: {
              this._stateDoctype(cp);
              break;
            }
            case State.BEFORE_DOCTYPE_NAME: {
              this._stateBeforeDoctypeName(cp);
              break;
            }
            case State.DOCTYPE_NAME: {
              this._stateDoctypeName(cp);
              break;
            }
            case State.AFTER_DOCTYPE_NAME: {
              this._stateAfterDoctypeName(cp);
              break;
            }
            case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
              this._stateAfterDoctypePublicKeyword(cp);
              break;
            }
            case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
              this._stateBeforeDoctypePublicIdentifier(cp);
              break;
            }
            case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
              this._stateDoctypePublicIdentifierDoubleQuoted(cp);
              break;
            }
            case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
              this._stateDoctypePublicIdentifierSingleQuoted(cp);
              break;
            }
            case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
              this._stateAfterDoctypePublicIdentifier(cp);
              break;
            }
            case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
              this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
              break;
            }
            case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
              this._stateAfterDoctypeSystemKeyword(cp);
              break;
            }
            case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
              this._stateBeforeDoctypeSystemIdentifier(cp);
              break;
            }
            case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
              this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
              break;
            }
            case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
              this._stateDoctypeSystemIdentifierSingleQuoted(cp);
              break;
            }
            case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
              this._stateAfterDoctypeSystemIdentifier(cp);
              break;
            }
            case State.BOGUS_DOCTYPE: {
              this._stateBogusDoctype(cp);
              break;
            }
            case State.CDATA_SECTION: {
              this._stateCdataSection(cp);
              break;
            }
            case State.CDATA_SECTION_BRACKET: {
              this._stateCdataSectionBracket(cp);
              break;
            }
            case State.CDATA_SECTION_END: {
              this._stateCdataSectionEnd(cp);
              break;
            }
            case State.CHARACTER_REFERENCE: {
              this._stateCharacterReference();
              break;
            }
            case State.AMBIGUOUS_AMPERSAND: {
              this._stateAmbiguousAmpersand(cp);
              break;
            }
            default: {
              throw new Error("Unknown state");
            }
          }
        }
        // State machine
        // Data state
        //------------------------------------------------------------------
        _stateData(cp) {
          switch (cp) {
            case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.TAG_OPEN;
              break;
            }
            case CODE_POINTS.AMPERSAND: {
              this._startCharacterReference();
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitCodePoint(cp);
              break;
            }
            case CODE_POINTS.EOF: {
              this._emitEOFToken();
              break;
            }
            default: {
              this._emitCodePoint(cp);
            }
          }
        }
        //  RCDATA state
        //------------------------------------------------------------------
        _stateRcdata(cp) {
          switch (cp) {
            case CODE_POINTS.AMPERSAND: {
              this._startCharacterReference();
              break;
            }
            case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.RCDATA_LESS_THAN_SIGN;
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
            case CODE_POINTS.EOF: {
              this._emitEOFToken();
              break;
            }
            default: {
              this._emitCodePoint(cp);
            }
          }
        }
        // RAWTEXT state
        //------------------------------------------------------------------
        _stateRawtext(cp) {
          switch (cp) {
            case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.RAWTEXT_LESS_THAN_SIGN;
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
            case CODE_POINTS.EOF: {
              this._emitEOFToken();
              break;
            }
            default: {
              this._emitCodePoint(cp);
            }
          }
        }
        // Script data state
        //------------------------------------------------------------------
        _stateScriptData(cp) {
          switch (cp) {
            case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
            case CODE_POINTS.EOF: {
              this._emitEOFToken();
              break;
            }
            default: {
              this._emitCodePoint(cp);
            }
          }
        }
        // PLAINTEXT state
        //------------------------------------------------------------------
        _statePlaintext(cp) {
          switch (cp) {
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
            case CODE_POINTS.EOF: {
              this._emitEOFToken();
              break;
            }
            default: {
              this._emitCodePoint(cp);
            }
          }
        }
        // Tag open state
        //------------------------------------------------------------------
        _stateTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this._createStartTagToken();
            this.state = State.TAG_NAME;
            this._stateTagName(cp);
          } else
            switch (cp) {
              case CODE_POINTS.EXCLAMATION_MARK: {
                this.state = State.MARKUP_DECLARATION_OPEN;
                break;
              }
              case CODE_POINTS.SOLIDUS: {
                this.state = State.END_TAG_OPEN;
                break;
              }
              case CODE_POINTS.QUESTION_MARK: {
                this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
                this._createCommentToken(1);
                this.state = State.BOGUS_COMMENT;
                this._stateBogusComment(cp);
                break;
              }
              case CODE_POINTS.EOF: {
                this._err(ERR.eofBeforeTagName);
                this._emitChars("<");
                this._emitEOFToken();
                break;
              }
              default: {
                this._err(ERR.invalidFirstCharacterOfTagName);
                this._emitChars("<");
                this.state = State.DATA;
                this._stateData(cp);
              }
            }
        }
        // End tag open state
        //------------------------------------------------------------------
        _stateEndTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this._createEndTagToken();
            this.state = State.TAG_NAME;
            this._stateTagName(cp);
          } else
            switch (cp) {
              case CODE_POINTS.GREATER_THAN_SIGN: {
                this._err(ERR.missingEndTagName);
                this.state = State.DATA;
                break;
              }
              case CODE_POINTS.EOF: {
                this._err(ERR.eofBeforeTagName);
                this._emitChars("</");
                this._emitEOFToken();
                break;
              }
              default: {
                this._err(ERR.invalidFirstCharacterOfTagName);
                this._createCommentToken(2);
                this.state = State.BOGUS_COMMENT;
                this._stateBogusComment(cp);
              }
            }
        }
        // Tag name state
        //------------------------------------------------------------------
        _stateTagName(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              break;
            }
            case CODE_POINTS.SOLIDUS: {
              this.state = State.SELF_CLOSING_START_TAG;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.tagName += REPLACEMENT_CHARACTER;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
            default: {
              token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
            }
          }
        }
        // RCDATA less-than sign state
        //------------------------------------------------------------------
        _stateRcdataLessThanSign(cp) {
          if (cp === CODE_POINTS.SOLIDUS) {
            this.state = State.RCDATA_END_TAG_OPEN;
          } else {
            this._emitChars("<");
            this.state = State.RCDATA;
            this._stateRcdata(cp);
          }
        }
        // RCDATA end tag open state
        //------------------------------------------------------------------
        _stateRcdataEndTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this.state = State.RCDATA_END_TAG_NAME;
            this._stateRcdataEndTagName(cp);
          } else {
            this._emitChars("</");
            this.state = State.RCDATA;
            this._stateRcdata(cp);
          }
        }
        handleSpecialEndTag(_cp) {
          if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
            return !this._ensureHibernation();
          }
          this._createEndTagToken();
          const token = this.currentToken;
          token.tagName = this.lastStartTagName;
          const cp = this.preprocessor.peek(this.lastStartTagName.length);
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              this._advanceBy(this.lastStartTagName.length);
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              return false;
            }
            case CODE_POINTS.SOLIDUS: {
              this._advanceBy(this.lastStartTagName.length);
              this.state = State.SELF_CLOSING_START_TAG;
              return false;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._advanceBy(this.lastStartTagName.length);
              this.emitCurrentTagToken();
              this.state = State.DATA;
              return false;
            }
            default: {
              return !this._ensureHibernation();
            }
          }
        }
        // RCDATA end tag name state
        //------------------------------------------------------------------
        _stateRcdataEndTagName(cp) {
          if (this.handleSpecialEndTag(cp)) {
            this._emitChars("</");
            this.state = State.RCDATA;
            this._stateRcdata(cp);
          }
        }
        // RAWTEXT less-than sign state
        //------------------------------------------------------------------
        _stateRawtextLessThanSign(cp) {
          if (cp === CODE_POINTS.SOLIDUS) {
            this.state = State.RAWTEXT_END_TAG_OPEN;
          } else {
            this._emitChars("<");
            this.state = State.RAWTEXT;
            this._stateRawtext(cp);
          }
        }
        // RAWTEXT end tag open state
        //------------------------------------------------------------------
        _stateRawtextEndTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this.state = State.RAWTEXT_END_TAG_NAME;
            this._stateRawtextEndTagName(cp);
          } else {
            this._emitChars("</");
            this.state = State.RAWTEXT;
            this._stateRawtext(cp);
          }
        }
        // RAWTEXT end tag name state
        //------------------------------------------------------------------
        _stateRawtextEndTagName(cp) {
          if (this.handleSpecialEndTag(cp)) {
            this._emitChars("</");
            this.state = State.RAWTEXT;
            this._stateRawtext(cp);
          }
        }
        // Script data less-than sign state
        //------------------------------------------------------------------
        _stateScriptDataLessThanSign(cp) {
          switch (cp) {
            case CODE_POINTS.SOLIDUS: {
              this.state = State.SCRIPT_DATA_END_TAG_OPEN;
              break;
            }
            case CODE_POINTS.EXCLAMATION_MARK: {
              this.state = State.SCRIPT_DATA_ESCAPE_START;
              this._emitChars("<!");
              break;
            }
            default: {
              this._emitChars("<");
              this.state = State.SCRIPT_DATA;
              this._stateScriptData(cp);
            }
          }
        }
        // Script data end tag open state
        //------------------------------------------------------------------
        _stateScriptDataEndTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this.state = State.SCRIPT_DATA_END_TAG_NAME;
            this._stateScriptDataEndTagName(cp);
          } else {
            this._emitChars("</");
            this.state = State.SCRIPT_DATA;
            this._stateScriptData(cp);
          }
        }
        // Script data end tag name state
        //------------------------------------------------------------------
        _stateScriptDataEndTagName(cp) {
          if (this.handleSpecialEndTag(cp)) {
            this._emitChars("</");
            this.state = State.SCRIPT_DATA;
            this._stateScriptData(cp);
          }
        }
        // Script data escape start state
        //------------------------------------------------------------------
        _stateScriptDataEscapeStart(cp) {
          if (cp === CODE_POINTS.HYPHEN_MINUS) {
            this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;
            this._emitChars("-");
          } else {
            this.state = State.SCRIPT_DATA;
            this._stateScriptData(cp);
          }
        }
        // Script data escape start dash state
        //------------------------------------------------------------------
        _stateScriptDataEscapeStartDash(cp) {
          if (cp === CODE_POINTS.HYPHEN_MINUS) {
            this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
            this._emitChars("-");
          } else {
            this.state = State.SCRIPT_DATA;
            this._stateScriptData(cp);
          }
        }
        // Script data escaped state
        //------------------------------------------------------------------
        _stateScriptDataEscaped(cp) {
          switch (cp) {
            case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.SCRIPT_DATA_ESCAPED_DASH;
              this._emitChars("-");
              break;
            }
            case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
            default: {
              this._emitCodePoint(cp);
            }
          }
        }
        // Script data escaped dash state
        //------------------------------------------------------------------
        _stateScriptDataEscapedDash(cp) {
          switch (cp) {
            case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;
              this._emitChars("-");
              break;
            }
            case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.state = State.SCRIPT_DATA_ESCAPED;
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
            default: {
              this.state = State.SCRIPT_DATA_ESCAPED;
              this._emitCodePoint(cp);
            }
          }
        }
        // Script data escaped dash dash state
        //------------------------------------------------------------------
        _stateScriptDataEscapedDashDash(cp) {
          switch (cp) {
            case CODE_POINTS.HYPHEN_MINUS: {
              this._emitChars("-");
              break;
            }
            case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.SCRIPT_DATA;
              this._emitChars(">");
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.state = State.SCRIPT_DATA_ESCAPED;
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
            default: {
              this.state = State.SCRIPT_DATA_ESCAPED;
              this._emitCodePoint(cp);
            }
          }
        }
        // Script data escaped less-than sign state
        //------------------------------------------------------------------
        _stateScriptDataEscapedLessThanSign(cp) {
          if (cp === CODE_POINTS.SOLIDUS) {
            this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
          } else if (isAsciiLetter(cp)) {
            this._emitChars("<");
            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;
            this._stateScriptDataDoubleEscapeStart(cp);
          } else {
            this._emitChars("<");
            this.state = State.SCRIPT_DATA_ESCAPED;
            this._stateScriptDataEscaped(cp);
          }
        }
        // Script data escaped end tag open state
        //------------------------------------------------------------------
        _stateScriptDataEscapedEndTagOpen(cp) {
          if (isAsciiLetter(cp)) {
            this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
            this._stateScriptDataEscapedEndTagName(cp);
          } else {
            this._emitChars("</");
            this.state = State.SCRIPT_DATA_ESCAPED;
            this._stateScriptDataEscaped(cp);
          }
        }
        // Script data escaped end tag name state
        //------------------------------------------------------------------
        _stateScriptDataEscapedEndTagName(cp) {
          if (this.handleSpecialEndTag(cp)) {
            this._emitChars("</");
            this.state = State.SCRIPT_DATA_ESCAPED;
            this._stateScriptDataEscaped(cp);
          }
        }
        // Script data double escape start state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscapeStart(cp) {
          if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
            this._emitCodePoint(cp);
            for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
              this._emitCodePoint(this._consume());
            }
            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
          } else if (!this._ensureHibernation()) {
            this.state = State.SCRIPT_DATA_ESCAPED;
            this._stateScriptDataEscaped(cp);
          }
        }
        // Script data double escaped state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscaped(cp) {
          switch (cp) {
            case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
              this._emitChars("-");
              break;
            }
            case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
              this._emitChars("<");
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
            default: {
              this._emitCodePoint(cp);
            }
          }
        }
        // Script data double escaped dash state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscapedDash(cp) {
          switch (cp) {
            case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
              this._emitChars("-");
              break;
            }
            case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
              this._emitChars("<");
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
            default: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
              this._emitCodePoint(cp);
            }
          }
        }
        // Script data double escaped dash dash state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscapedDashDash(cp) {
          switch (cp) {
            case CODE_POINTS.HYPHEN_MINUS: {
              this._emitChars("-");
              break;
            }
            case CODE_POINTS.LESS_THAN_SIGN: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
              this._emitChars("<");
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.SCRIPT_DATA;
              this._emitChars(">");
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
              this._emitChars(REPLACEMENT_CHARACTER);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInScriptHtmlCommentLikeText);
              this._emitEOFToken();
              break;
            }
            default: {
              this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
              this._emitCodePoint(cp);
            }
          }
        }
        // Script data double escaped less-than sign state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscapedLessThanSign(cp) {
          if (cp === CODE_POINTS.SOLIDUS) {
            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;
            this._emitChars("/");
          } else {
            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
            this._stateScriptDataDoubleEscaped(cp);
          }
        }
        // Script data double escape end state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscapeEnd(cp) {
          if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) && isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
            this._emitCodePoint(cp);
            for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
              this._emitCodePoint(this._consume());
            }
            this.state = State.SCRIPT_DATA_ESCAPED;
          } else if (!this._ensureHibernation()) {
            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;
            this._stateScriptDataDoubleEscaped(cp);
          }
        }
        // Before attribute name state
        //------------------------------------------------------------------
        _stateBeforeAttributeName(cp) {
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              break;
            }
            case CODE_POINTS.SOLIDUS:
            case CODE_POINTS.GREATER_THAN_SIGN:
            case CODE_POINTS.EOF: {
              this.state = State.AFTER_ATTRIBUTE_NAME;
              this._stateAfterAttributeName(cp);
              break;
            }
            case CODE_POINTS.EQUALS_SIGN: {
              this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
              this._createAttr("=");
              this.state = State.ATTRIBUTE_NAME;
              break;
            }
            default: {
              this._createAttr("");
              this.state = State.ATTRIBUTE_NAME;
              this._stateAttributeName(cp);
            }
          }
        }
        // Attribute name state
        //------------------------------------------------------------------
        _stateAttributeName(cp) {
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED:
            case CODE_POINTS.SOLIDUS:
            case CODE_POINTS.GREATER_THAN_SIGN:
            case CODE_POINTS.EOF: {
              this._leaveAttrName();
              this.state = State.AFTER_ATTRIBUTE_NAME;
              this._stateAfterAttributeName(cp);
              break;
            }
            case CODE_POINTS.EQUALS_SIGN: {
              this._leaveAttrName();
              this.state = State.BEFORE_ATTRIBUTE_VALUE;
              break;
            }
            case CODE_POINTS.QUOTATION_MARK:
            case CODE_POINTS.APOSTROPHE:
            case CODE_POINTS.LESS_THAN_SIGN: {
              this._err(ERR.unexpectedCharacterInAttributeName);
              this.currentAttr.name += String.fromCodePoint(cp);
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.currentAttr.name += REPLACEMENT_CHARACTER;
              break;
            }
            default: {
              this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
            }
          }
        }
        // After attribute name state
        //------------------------------------------------------------------
        _stateAfterAttributeName(cp) {
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              break;
            }
            case CODE_POINTS.SOLIDUS: {
              this.state = State.SELF_CLOSING_START_TAG;
              break;
            }
            case CODE_POINTS.EQUALS_SIGN: {
              this.state = State.BEFORE_ATTRIBUTE_VALUE;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
            default: {
              this._createAttr("");
              this.state = State.ATTRIBUTE_NAME;
              this._stateAttributeName(cp);
            }
          }
        }
        // Before attribute value state
        //------------------------------------------------------------------
        _stateBeforeAttributeValue(cp) {
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              break;
            }
            case CODE_POINTS.QUOTATION_MARK: {
              this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
              break;
            }
            case CODE_POINTS.APOSTROPHE: {
              this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.missingAttributeValue);
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
            default: {
              this.state = State.ATTRIBUTE_VALUE_UNQUOTED;
              this._stateAttributeValueUnquoted(cp);
            }
          }
        }
        // Attribute value (double-quoted) state
        //------------------------------------------------------------------
        _stateAttributeValueDoubleQuoted(cp) {
          switch (cp) {
            case CODE_POINTS.QUOTATION_MARK: {
              this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
              break;
            }
            case CODE_POINTS.AMPERSAND: {
              this._startCharacterReference();
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.currentAttr.value += REPLACEMENT_CHARACTER;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
            default: {
              this.currentAttr.value += String.fromCodePoint(cp);
            }
          }
        }
        // Attribute value (single-quoted) state
        //------------------------------------------------------------------
        _stateAttributeValueSingleQuoted(cp) {
          switch (cp) {
            case CODE_POINTS.APOSTROPHE: {
              this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;
              break;
            }
            case CODE_POINTS.AMPERSAND: {
              this._startCharacterReference();
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.currentAttr.value += REPLACEMENT_CHARACTER;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
            default: {
              this.currentAttr.value += String.fromCodePoint(cp);
            }
          }
        }
        // Attribute value (unquoted) state
        //------------------------------------------------------------------
        _stateAttributeValueUnquoted(cp) {
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              this._leaveAttrValue();
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              break;
            }
            case CODE_POINTS.AMPERSAND: {
              this._startCharacterReference();
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._leaveAttrValue();
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              this.currentAttr.value += REPLACEMENT_CHARACTER;
              break;
            }
            case CODE_POINTS.QUOTATION_MARK:
            case CODE_POINTS.APOSTROPHE:
            case CODE_POINTS.LESS_THAN_SIGN:
            case CODE_POINTS.EQUALS_SIGN:
            case CODE_POINTS.GRAVE_ACCENT: {
              this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
              this.currentAttr.value += String.fromCodePoint(cp);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
            default: {
              this.currentAttr.value += String.fromCodePoint(cp);
            }
          }
        }
        // After attribute value (quoted) state
        //------------------------------------------------------------------
        _stateAfterAttributeValueQuoted(cp) {
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              this._leaveAttrValue();
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              break;
            }
            case CODE_POINTS.SOLIDUS: {
              this._leaveAttrValue();
              this.state = State.SELF_CLOSING_START_TAG;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._leaveAttrValue();
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(ERR.missingWhitespaceBetweenAttributes);
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              this._stateBeforeAttributeName(cp);
            }
          }
        }
        // Self-closing start tag state
        //------------------------------------------------------------------
        _stateSelfClosingStartTag(cp) {
          switch (cp) {
            case CODE_POINTS.GREATER_THAN_SIGN: {
              const token = this.currentToken;
              token.selfClosing = true;
              this.state = State.DATA;
              this.emitCurrentTagToken();
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInTag);
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(ERR.unexpectedSolidusInTag);
              this.state = State.BEFORE_ATTRIBUTE_NAME;
              this._stateBeforeAttributeName(cp);
            }
          }
        }
        // Bogus comment state
        //------------------------------------------------------------------
        _stateBogusComment(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentComment(token);
              break;
            }
            case CODE_POINTS.EOF: {
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.data += REPLACEMENT_CHARACTER;
              break;
            }
            default: {
              token.data += String.fromCodePoint(cp);
            }
          }
        }
        // Markup declaration open state
        //------------------------------------------------------------------
        _stateMarkupDeclarationOpen(cp) {
          if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
            this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
            this.state = State.COMMENT_START;
          } else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
            this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
            this.state = State.DOCTYPE;
          } else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
            if (this.inForeignNode) {
              this.state = State.CDATA_SECTION;
            } else {
              this._err(ERR.cdataInHtmlContent);
              this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
              this.currentToken.data = "[CDATA[";
              this.state = State.BOGUS_COMMENT;
            }
          } else if (!this._ensureHibernation()) {
            this._err(ERR.incorrectlyOpenedComment);
            this._createCommentToken(2);
            this.state = State.BOGUS_COMMENT;
            this._stateBogusComment(cp);
          }
        }
        // Comment start state
        //------------------------------------------------------------------
        _stateCommentStart(cp) {
          switch (cp) {
            case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.COMMENT_START_DASH;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptClosingOfEmptyComment);
              this.state = State.DATA;
              const token = this.currentToken;
              this.emitCurrentComment(token);
              break;
            }
            default: {
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        // Comment start dash state
        //------------------------------------------------------------------
        _stateCommentStartDash(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.COMMENT_END;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptClosingOfEmptyComment);
              this.state = State.DATA;
              this.emitCurrentComment(token);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInComment);
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
            default: {
              token.data += "-";
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        // Comment state
        //------------------------------------------------------------------
        _stateComment(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.COMMENT_END_DASH;
              break;
            }
            case CODE_POINTS.LESS_THAN_SIGN: {
              token.data += "<";
              this.state = State.COMMENT_LESS_THAN_SIGN;
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.data += REPLACEMENT_CHARACTER;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInComment);
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
            default: {
              token.data += String.fromCodePoint(cp);
            }
          }
        }
        // Comment less-than sign state
        //------------------------------------------------------------------
        _stateCommentLessThanSign(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.EXCLAMATION_MARK: {
              token.data += "!";
              this.state = State.COMMENT_LESS_THAN_SIGN_BANG;
              break;
            }
            case CODE_POINTS.LESS_THAN_SIGN: {
              token.data += "<";
              break;
            }
            default: {
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        // Comment less-than sign bang state
        //------------------------------------------------------------------
        _stateCommentLessThanSignBang(cp) {
          if (cp === CODE_POINTS.HYPHEN_MINUS) {
            this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;
          } else {
            this.state = State.COMMENT;
            this._stateComment(cp);
          }
        }
        // Comment less-than sign bang dash state
        //------------------------------------------------------------------
        _stateCommentLessThanSignBangDash(cp) {
          if (cp === CODE_POINTS.HYPHEN_MINUS) {
            this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
          } else {
            this.state = State.COMMENT_END_DASH;
            this._stateCommentEndDash(cp);
          }
        }
        // Comment less-than sign bang dash dash state
        //------------------------------------------------------------------
        _stateCommentLessThanSignBangDashDash(cp) {
          if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
            this._err(ERR.nestedComment);
          }
          this.state = State.COMMENT_END;
          this._stateCommentEnd(cp);
        }
        // Comment end dash state
        //------------------------------------------------------------------
        _stateCommentEndDash(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.HYPHEN_MINUS: {
              this.state = State.COMMENT_END;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInComment);
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
            default: {
              token.data += "-";
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        // Comment end state
        //------------------------------------------------------------------
        _stateCommentEnd(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentComment(token);
              break;
            }
            case CODE_POINTS.EXCLAMATION_MARK: {
              this.state = State.COMMENT_END_BANG;
              break;
            }
            case CODE_POINTS.HYPHEN_MINUS: {
              token.data += "-";
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInComment);
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
            default: {
              token.data += "--";
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        // Comment end bang state
        //------------------------------------------------------------------
        _stateCommentEndBang(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.HYPHEN_MINUS: {
              token.data += "--!";
              this.state = State.COMMENT_END_DASH;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.incorrectlyClosedComment);
              this.state = State.DATA;
              this.emitCurrentComment(token);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInComment);
              this.emitCurrentComment(token);
              this._emitEOFToken();
              break;
            }
            default: {
              token.data += "--!";
              this.state = State.COMMENT;
              this._stateComment(cp);
            }
          }
        }
        // DOCTYPE state
        //------------------------------------------------------------------
        _stateDoctype(cp) {
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              this.state = State.BEFORE_DOCTYPE_NAME;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.BEFORE_DOCTYPE_NAME;
              this._stateBeforeDoctypeName(cp);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              this._createDoctypeToken(null);
              const token = this.currentToken;
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(ERR.missingWhitespaceBeforeDoctypeName);
              this.state = State.BEFORE_DOCTYPE_NAME;
              this._stateBeforeDoctypeName(cp);
            }
          }
        }
        // Before DOCTYPE name state
        //------------------------------------------------------------------
        _stateBeforeDoctypeName(cp) {
          if (isAsciiUpper(cp)) {
            this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
            this.state = State.DOCTYPE_NAME;
          } else
            switch (cp) {
              case CODE_POINTS.SPACE:
              case CODE_POINTS.LINE_FEED:
              case CODE_POINTS.TABULATION:
              case CODE_POINTS.FORM_FEED: {
                break;
              }
              case CODE_POINTS.NULL: {
                this._err(ERR.unexpectedNullCharacter);
                this._createDoctypeToken(REPLACEMENT_CHARACTER);
                this.state = State.DOCTYPE_NAME;
                break;
              }
              case CODE_POINTS.GREATER_THAN_SIGN: {
                this._err(ERR.missingDoctypeName);
                this._createDoctypeToken(null);
                const token = this.currentToken;
                token.forceQuirks = true;
                this.emitCurrentDoctype(token);
                this.state = State.DATA;
                break;
              }
              case CODE_POINTS.EOF: {
                this._err(ERR.eofInDoctype);
                this._createDoctypeToken(null);
                const token = this.currentToken;
                token.forceQuirks = true;
                this.emitCurrentDoctype(token);
                this._emitEOFToken();
                break;
              }
              default: {
                this._createDoctypeToken(String.fromCodePoint(cp));
                this.state = State.DOCTYPE_NAME;
              }
            }
        }
        // DOCTYPE name state
        //------------------------------------------------------------------
        _stateDoctypeName(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              this.state = State.AFTER_DOCTYPE_NAME;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.name += REPLACEMENT_CHARACTER;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
            }
          }
        }
        // After DOCTYPE name state
        //------------------------------------------------------------------
        _stateAfterDoctypeName(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
                this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;
              } else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
                this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;
              } else if (!this._ensureHibernation()) {
                this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
                token.forceQuirks = true;
                this.state = State.BOGUS_DOCTYPE;
                this._stateBogusDoctype(cp);
              }
            }
          }
        }
        // After DOCTYPE public keyword state
        //------------------------------------------------------------------
        _stateAfterDoctypePublicKeyword(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
              break;
            }
            case CODE_POINTS.QUOTATION_MARK: {
              this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
              token.publicId = "";
              this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
            case CODE_POINTS.APOSTROPHE: {
              this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
              token.publicId = "";
              this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.missingDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        // Before DOCTYPE public identifier state
        //------------------------------------------------------------------
        _stateBeforeDoctypePublicIdentifier(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              break;
            }
            case CODE_POINTS.QUOTATION_MARK: {
              token.publicId = "";
              this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
            case CODE_POINTS.APOSTROPHE: {
              token.publicId = "";
              this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.missingDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        // DOCTYPE public identifier (double-quoted) state
        //------------------------------------------------------------------
        _stateDoctypePublicIdentifierDoubleQuoted(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.QUOTATION_MARK: {
              this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.publicId += REPLACEMENT_CHARACTER;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              token.publicId += String.fromCodePoint(cp);
            }
          }
        }
        // DOCTYPE public identifier (single-quoted) state
        //------------------------------------------------------------------
        _stateDoctypePublicIdentifierSingleQuoted(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.APOSTROPHE: {
              this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.publicId += REPLACEMENT_CHARACTER;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptDoctypePublicIdentifier);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              token.publicId += String.fromCodePoint(cp);
            }
          }
        }
        // After DOCTYPE public identifier state
        //------------------------------------------------------------------
        _stateAfterDoctypePublicIdentifier(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
            case CODE_POINTS.QUOTATION_MARK: {
              this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
            case CODE_POINTS.APOSTROPHE: {
              this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        // Between DOCTYPE public and system identifiers state
        //------------------------------------------------------------------
        _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
            case CODE_POINTS.QUOTATION_MARK: {
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
            case CODE_POINTS.APOSTROPHE: {
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        // After DOCTYPE system keyword state
        //------------------------------------------------------------------
        _stateAfterDoctypeSystemKeyword(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
              break;
            }
            case CODE_POINTS.QUOTATION_MARK: {
              this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
            case CODE_POINTS.APOSTROPHE: {
              this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.missingDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        // Before DOCTYPE system identifier state
        //------------------------------------------------------------------
        _stateBeforeDoctypeSystemIdentifier(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              break;
            }
            case CODE_POINTS.QUOTATION_MARK: {
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
              break;
            }
            case CODE_POINTS.APOSTROPHE: {
              token.systemId = "";
              this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.missingDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.DATA;
              this.emitCurrentDoctype(token);
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        // DOCTYPE system identifier (double-quoted) state
        //------------------------------------------------------------------
        _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.QUOTATION_MARK: {
              this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.systemId += REPLACEMENT_CHARACTER;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              token.systemId += String.fromCodePoint(cp);
            }
          }
        }
        // DOCTYPE system identifier (single-quoted) state
        //------------------------------------------------------------------
        _stateDoctypeSystemIdentifierSingleQuoted(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.APOSTROPHE: {
              this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              token.systemId += REPLACEMENT_CHARACTER;
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this._err(ERR.abruptDoctypeSystemIdentifier);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              token.systemId += String.fromCodePoint(cp);
            }
          }
        }
        // After DOCTYPE system identifier state
        //------------------------------------------------------------------
        _stateAfterDoctypeSystemIdentifier(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.SPACE:
            case CODE_POINTS.LINE_FEED:
            case CODE_POINTS.TABULATION:
            case CODE_POINTS.FORM_FEED: {
              break;
            }
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInDoctype);
              token.forceQuirks = true;
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default: {
              this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
              this.state = State.BOGUS_DOCTYPE;
              this._stateBogusDoctype(cp);
            }
          }
        }
        // Bogus DOCTYPE state
        //------------------------------------------------------------------
        _stateBogusDoctype(cp) {
          const token = this.currentToken;
          switch (cp) {
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.emitCurrentDoctype(token);
              this.state = State.DATA;
              break;
            }
            case CODE_POINTS.NULL: {
              this._err(ERR.unexpectedNullCharacter);
              break;
            }
            case CODE_POINTS.EOF: {
              this.emitCurrentDoctype(token);
              this._emitEOFToken();
              break;
            }
            default:
          }
        }
        // CDATA section state
        //------------------------------------------------------------------
        _stateCdataSection(cp) {
          switch (cp) {
            case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
              this.state = State.CDATA_SECTION_BRACKET;
              break;
            }
            case CODE_POINTS.EOF: {
              this._err(ERR.eofInCdata);
              this._emitEOFToken();
              break;
            }
            default: {
              this._emitCodePoint(cp);
            }
          }
        }
        // CDATA section bracket state
        //------------------------------------------------------------------
        _stateCdataSectionBracket(cp) {
          if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
            this.state = State.CDATA_SECTION_END;
          } else {
            this._emitChars("]");
            this.state = State.CDATA_SECTION;
            this._stateCdataSection(cp);
          }
        }
        // CDATA section end state
        //------------------------------------------------------------------
        _stateCdataSectionEnd(cp) {
          switch (cp) {
            case CODE_POINTS.GREATER_THAN_SIGN: {
              this.state = State.DATA;
              break;
            }
            case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
              this._emitChars("]");
              break;
            }
            default: {
              this._emitChars("]]");
              this.state = State.CDATA_SECTION;
              this._stateCdataSection(cp);
            }
          }
        }
        // Character reference state
        //------------------------------------------------------------------
        _stateCharacterReference() {
          let length3 = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
          if (length3 < 0) {
            if (this.preprocessor.lastChunkWritten) {
              length3 = this.entityDecoder.end();
            } else {
              this.active = false;
              this.preprocessor.pos = this.preprocessor.html.length - 1;
              this.consumedAfterSnapshot = 0;
              this.preprocessor.endOfChunkHit = true;
              return;
            }
          }
          if (length3 === 0) {
            this.preprocessor.pos = this.entityStartPos;
            this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
            this.state = !this._isCharacterReferenceInAttribute() && isAsciiAlphaNumeric2(this.preprocessor.peek(1)) ? State.AMBIGUOUS_AMPERSAND : this.returnState;
          } else {
            this.state = this.returnState;
          }
        }
        // Ambiguos ampersand state
        //------------------------------------------------------------------
        _stateAmbiguousAmpersand(cp) {
          if (isAsciiAlphaNumeric2(cp)) {
            this._flushCodePointConsumedAsCharacterReference(cp);
          } else {
            if (cp === CODE_POINTS.SEMICOLON) {
              this._err(ERR.unknownNamedCharacterReference);
            }
            this.state = this.returnState;
            this._callState(cp);
          }
        }
      };
    }
  });

  // node_modules/parse5/dist/parser/open-element-stack.js
  var IMPLICIT_END_TAG_REQUIRED, IMPLICIT_END_TAG_REQUIRED_THOROUGHLY, SCOPING_ELEMENTS_HTML, SCOPING_ELEMENTS_HTML_LIST, SCOPING_ELEMENTS_HTML_BUTTON, SCOPING_ELEMENTS_MATHML, SCOPING_ELEMENTS_SVG, TABLE_ROW_CONTEXT, TABLE_BODY_CONTEXT, TABLE_CONTEXT, TABLE_CELLS, OpenElementStack;
  var init_open_element_stack = __esm({
    "node_modules/parse5/dist/parser/open-element-stack.js"() {
      init_html2();
      IMPLICIT_END_TAG_REQUIRED = /* @__PURE__ */ new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]);
      IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = /* @__PURE__ */ new Set([
        ...IMPLICIT_END_TAG_REQUIRED,
        TAG_ID.CAPTION,
        TAG_ID.COLGROUP,
        TAG_ID.TBODY,
        TAG_ID.TD,
        TAG_ID.TFOOT,
        TAG_ID.TH,
        TAG_ID.THEAD,
        TAG_ID.TR
      ]);
      SCOPING_ELEMENTS_HTML = /* @__PURE__ */ new Set([
        TAG_ID.APPLET,
        TAG_ID.CAPTION,
        TAG_ID.HTML,
        TAG_ID.MARQUEE,
        TAG_ID.OBJECT,
        TAG_ID.TABLE,
        TAG_ID.TD,
        TAG_ID.TEMPLATE,
        TAG_ID.TH
      ]);
      SCOPING_ELEMENTS_HTML_LIST = /* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.OL, TAG_ID.UL]);
      SCOPING_ELEMENTS_HTML_BUTTON = /* @__PURE__ */ new Set([...SCOPING_ELEMENTS_HTML, TAG_ID.BUTTON]);
      SCOPING_ELEMENTS_MATHML = /* @__PURE__ */ new Set([TAG_ID.ANNOTATION_XML, TAG_ID.MI, TAG_ID.MN, TAG_ID.MO, TAG_ID.MS, TAG_ID.MTEXT]);
      SCOPING_ELEMENTS_SVG = /* @__PURE__ */ new Set([TAG_ID.DESC, TAG_ID.FOREIGN_OBJECT, TAG_ID.TITLE]);
      TABLE_ROW_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML]);
      TABLE_BODY_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML]);
      TABLE_CONTEXT = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML]);
      TABLE_CELLS = /* @__PURE__ */ new Set([TAG_ID.TD, TAG_ID.TH]);
      OpenElementStack = class {
        get currentTmplContentOrNode() {
          return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
        }
        constructor(document4, treeAdapter, handler) {
          this.treeAdapter = treeAdapter;
          this.handler = handler;
          this.items = [];
          this.tagIDs = [];
          this.stackTop = -1;
          this.tmplCount = 0;
          this.currentTagId = TAG_ID.UNKNOWN;
          this.current = document4;
        }
        //Index of element
        _indexOf(element7) {
          return this.items.lastIndexOf(element7, this.stackTop);
        }
        //Update current element
        _isInTemplate() {
          return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
        }
        _updateCurrentElement() {
          this.current = this.items[this.stackTop];
          this.currentTagId = this.tagIDs[this.stackTop];
        }
        //Mutations
        push(element7, tagID) {
          this.stackTop++;
          this.items[this.stackTop] = element7;
          this.current = element7;
          this.tagIDs[this.stackTop] = tagID;
          this.currentTagId = tagID;
          if (this._isInTemplate()) {
            this.tmplCount++;
          }
          this.handler.onItemPush(element7, tagID, true);
        }
        pop() {
          const popped = this.current;
          if (this.tmplCount > 0 && this._isInTemplate()) {
            this.tmplCount--;
          }
          this.stackTop--;
          this._updateCurrentElement();
          this.handler.onItemPop(popped, true);
        }
        replace(oldElement, newElement) {
          const idx = this._indexOf(oldElement);
          this.items[idx] = newElement;
          if (idx === this.stackTop) {
            this.current = newElement;
          }
        }
        insertAfter(referenceElement, newElement, newElementID) {
          const insertionIdx = this._indexOf(referenceElement) + 1;
          this.items.splice(insertionIdx, 0, newElement);
          this.tagIDs.splice(insertionIdx, 0, newElementID);
          this.stackTop++;
          if (insertionIdx === this.stackTop) {
            this._updateCurrentElement();
          }
          if (this.current && this.currentTagId !== void 0) {
            this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
          }
        }
        popUntilTagNamePopped(tagName) {
          let targetIdx = this.stackTop + 1;
          do {
            targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
          } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
          this.shortenToLength(Math.max(targetIdx, 0));
        }
        shortenToLength(idx) {
          while (this.stackTop >= idx) {
            const popped = this.current;
            if (this.tmplCount > 0 && this._isInTemplate()) {
              this.tmplCount -= 1;
            }
            this.stackTop--;
            this._updateCurrentElement();
            this.handler.onItemPop(popped, this.stackTop < idx);
          }
        }
        popUntilElementPopped(element7) {
          const idx = this._indexOf(element7);
          this.shortenToLength(Math.max(idx, 0));
        }
        popUntilPopped(tagNames, targetNS) {
          const idx = this._indexOfTagNames(tagNames, targetNS);
          this.shortenToLength(Math.max(idx, 0));
        }
        popUntilNumberedHeaderPopped() {
          this.popUntilPopped(NUMBERED_HEADERS, NS.HTML);
        }
        popUntilTableCellPopped() {
          this.popUntilPopped(TABLE_CELLS, NS.HTML);
        }
        popAllUpToHtmlElement() {
          this.tmplCount = 0;
          this.shortenToLength(1);
        }
        _indexOfTagNames(tagNames, namespace) {
          for (let i = this.stackTop; i >= 0; i--) {
            if (tagNames.has(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
              return i;
            }
          }
          return -1;
        }
        clearBackTo(tagNames, targetNS) {
          const idx = this._indexOfTagNames(tagNames, targetNS);
          this.shortenToLength(idx + 1);
        }
        clearBackToTableContext() {
          this.clearBackTo(TABLE_CONTEXT, NS.HTML);
        }
        clearBackToTableBodyContext() {
          this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
        }
        clearBackToTableRowContext() {
          this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
        }
        remove(element7) {
          const idx = this._indexOf(element7);
          if (idx >= 0) {
            if (idx === this.stackTop) {
              this.pop();
            } else {
              this.items.splice(idx, 1);
              this.tagIDs.splice(idx, 1);
              this.stackTop--;
              this._updateCurrentElement();
              this.handler.onItemPop(element7, false);
            }
          }
        }
        //Search
        tryPeekProperlyNestedBodyElement() {
          return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
        }
        contains(element7) {
          return this._indexOf(element7) > -1;
        }
        getCommonAncestor(element7) {
          const elementIdx = this._indexOf(element7) - 1;
          return elementIdx >= 0 ? this.items[elementIdx] : null;
        }
        isRootHtmlElementCurrent() {
          return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
        }
        //Element in scope
        hasInDynamicScope(tagName, htmlScope) {
          for (let i = this.stackTop; i >= 0; i--) {
            const tn2 = this.tagIDs[i];
            switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
              case NS.HTML: {
                if (tn2 === tagName)
                  return true;
                if (htmlScope.has(tn2))
                  return false;
                break;
              }
              case NS.SVG: {
                if (SCOPING_ELEMENTS_SVG.has(tn2))
                  return false;
                break;
              }
              case NS.MATHML: {
                if (SCOPING_ELEMENTS_MATHML.has(tn2))
                  return false;
                break;
              }
            }
          }
          return true;
        }
        hasInScope(tagName) {
          return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML);
        }
        hasInListItemScope(tagName) {
          return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_LIST);
        }
        hasInButtonScope(tagName) {
          return this.hasInDynamicScope(tagName, SCOPING_ELEMENTS_HTML_BUTTON);
        }
        hasNumberedHeaderInScope() {
          for (let i = this.stackTop; i >= 0; i--) {
            const tn2 = this.tagIDs[i];
            switch (this.treeAdapter.getNamespaceURI(this.items[i])) {
              case NS.HTML: {
                if (NUMBERED_HEADERS.has(tn2))
                  return true;
                if (SCOPING_ELEMENTS_HTML.has(tn2))
                  return false;
                break;
              }
              case NS.SVG: {
                if (SCOPING_ELEMENTS_SVG.has(tn2))
                  return false;
                break;
              }
              case NS.MATHML: {
                if (SCOPING_ELEMENTS_MATHML.has(tn2))
                  return false;
                break;
              }
            }
          }
          return true;
        }
        hasInTableScope(tagName) {
          for (let i = this.stackTop; i >= 0; i--) {
            if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {
              continue;
            }
            switch (this.tagIDs[i]) {
              case tagName: {
                return true;
              }
              case TAG_ID.TABLE:
              case TAG_ID.HTML: {
                return false;
              }
            }
          }
          return true;
        }
        hasTableBodyContextInTableScope() {
          for (let i = this.stackTop; i >= 0; i--) {
            if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {
              continue;
            }
            switch (this.tagIDs[i]) {
              case TAG_ID.TBODY:
              case TAG_ID.THEAD:
              case TAG_ID.TFOOT: {
                return true;
              }
              case TAG_ID.TABLE:
              case TAG_ID.HTML: {
                return false;
              }
            }
          }
          return true;
        }
        hasInSelectScope(tagName) {
          for (let i = this.stackTop; i >= 0; i--) {
            if (this.treeAdapter.getNamespaceURI(this.items[i]) !== NS.HTML) {
              continue;
            }
            switch (this.tagIDs[i]) {
              case tagName: {
                return true;
              }
              case TAG_ID.OPTION:
              case TAG_ID.OPTGROUP: {
                break;
              }
              default: {
                return false;
              }
            }
          }
          return true;
        }
        //Implied end tags
        generateImpliedEndTags() {
          while (this.currentTagId !== void 0 && IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
            this.pop();
          }
        }
        generateImpliedEndTagsThoroughly() {
          while (this.currentTagId !== void 0 && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
            this.pop();
          }
        }
        generateImpliedEndTagsWithExclusion(exclusionId) {
          while (this.currentTagId !== void 0 && this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
            this.pop();
          }
        }
      };
    }
  });

  // node_modules/parse5/dist/parser/formatting-element-list.js
  var NOAH_ARK_CAPACITY, EntryType, MARKER, FormattingElementList;
  var init_formatting_element_list = __esm({
    "node_modules/parse5/dist/parser/formatting-element-list.js"() {
      NOAH_ARK_CAPACITY = 3;
      (function(EntryType2) {
        EntryType2[EntryType2["Marker"] = 0] = "Marker";
        EntryType2[EntryType2["Element"] = 1] = "Element";
      })(EntryType || (EntryType = {}));
      MARKER = { type: EntryType.Marker };
      FormattingElementList = class {
        constructor(treeAdapter) {
          this.treeAdapter = treeAdapter;
          this.entries = [];
          this.bookmark = null;
        }
        //Noah Ark's condition
        //OPTIMIZATION: at first we try to find possible candidates for exclusion using
        //lightweight heuristics without thorough attributes check.
        _getNoahArkConditionCandidates(newElement, neAttrs) {
          const candidates = [];
          const neAttrsLength = neAttrs.length;
          const neTagName = this.treeAdapter.getTagName(newElement);
          const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
          for (let i = 0; i < this.entries.length; i++) {
            const entry = this.entries[i];
            if (entry.type === EntryType.Marker) {
              break;
            }
            const { element: element7 } = entry;
            if (this.treeAdapter.getTagName(element7) === neTagName && this.treeAdapter.getNamespaceURI(element7) === neNamespaceURI) {
              const elementAttrs = this.treeAdapter.getAttrList(element7);
              if (elementAttrs.length === neAttrsLength) {
                candidates.push({ idx: i, attrs: elementAttrs });
              }
            }
          }
          return candidates;
        }
        _ensureNoahArkCondition(newElement) {
          if (this.entries.length < NOAH_ARK_CAPACITY)
            return;
          const neAttrs = this.treeAdapter.getAttrList(newElement);
          const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
          if (candidates.length < NOAH_ARK_CAPACITY)
            return;
          const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
          let validCandidates = 0;
          for (let i = 0; i < candidates.length; i++) {
            const candidate = candidates[i];
            if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
              validCandidates += 1;
              if (validCandidates >= NOAH_ARK_CAPACITY) {
                this.entries.splice(candidate.idx, 1);
              }
            }
          }
        }
        //Mutations
        insertMarker() {
          this.entries.unshift(MARKER);
        }
        pushElement(element7, token) {
          this._ensureNoahArkCondition(element7);
          this.entries.unshift({
            type: EntryType.Element,
            element: element7,
            token
          });
        }
        insertElementAfterBookmark(element7, token) {
          const bookmarkIdx = this.entries.indexOf(this.bookmark);
          this.entries.splice(bookmarkIdx, 0, {
            type: EntryType.Element,
            element: element7,
            token
          });
        }
        removeEntry(entry) {
          const entryIndex = this.entries.indexOf(entry);
          if (entryIndex !== -1) {
            this.entries.splice(entryIndex, 1);
          }
        }
        /**
         * Clears the list of formatting elements up to the last marker.
         *
         * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
         */
        clearToLastMarker() {
          const markerIdx = this.entries.indexOf(MARKER);
          if (markerIdx === -1) {
            this.entries.length = 0;
          } else {
            this.entries.splice(0, markerIdx + 1);
          }
        }
        //Search
        getElementEntryInScopeWithTagName(tagName) {
          const entry = this.entries.find((entry2) => entry2.type === EntryType.Marker || this.treeAdapter.getTagName(entry2.element) === tagName);
          return entry && entry.type === EntryType.Element ? entry : null;
        }
        getElementEntry(element7) {
          return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element7);
        }
      };
    }
  });

  // node_modules/parse5/dist/tree-adapters/default.js
  var defaultTreeAdapter;
  var init_default2 = __esm({
    "node_modules/parse5/dist/tree-adapters/default.js"() {
      init_html2();
      defaultTreeAdapter = {
        //Node construction
        createDocument() {
          return {
            nodeName: "#document",
            mode: DOCUMENT_MODE.NO_QUIRKS,
            childNodes: []
          };
        },
        createDocumentFragment() {
          return {
            nodeName: "#document-fragment",
            childNodes: []
          };
        },
        createElement(tagName, namespaceURI, attrs) {
          return {
            nodeName: tagName,
            tagName,
            attrs,
            namespaceURI,
            childNodes: [],
            parentNode: null
          };
        },
        createCommentNode(data) {
          return {
            nodeName: "#comment",
            data,
            parentNode: null
          };
        },
        createTextNode(value) {
          return {
            nodeName: "#text",
            value,
            parentNode: null
          };
        },
        //Tree mutation
        appendChild(parentNode2, newNode) {
          parentNode2.childNodes.push(newNode);
          newNode.parentNode = parentNode2;
        },
        insertBefore(parentNode2, newNode, referenceNode) {
          const insertionIdx = parentNode2.childNodes.indexOf(referenceNode);
          parentNode2.childNodes.splice(insertionIdx, 0, newNode);
          newNode.parentNode = parentNode2;
        },
        setTemplateContent(templateElement, contentElement) {
          templateElement.content = contentElement;
        },
        getTemplateContent(templateElement) {
          return templateElement.content;
        },
        setDocumentType(document4, name, publicId, systemId) {
          const doctypeNode = document4.childNodes.find((node2) => node2.nodeName === "#documentType");
          if (doctypeNode) {
            doctypeNode.name = name;
            doctypeNode.publicId = publicId;
            doctypeNode.systemId = systemId;
          } else {
            const node2 = {
              nodeName: "#documentType",
              name,
              publicId,
              systemId,
              parentNode: null
            };
            defaultTreeAdapter.appendChild(document4, node2);
          }
        },
        setDocumentMode(document4, mode) {
          document4.mode = mode;
        },
        getDocumentMode(document4) {
          return document4.mode;
        },
        detachNode(node2) {
          if (node2.parentNode) {
            const idx = node2.parentNode.childNodes.indexOf(node2);
            node2.parentNode.childNodes.splice(idx, 1);
            node2.parentNode = null;
          }
        },
        insertText(parentNode2, text10) {
          if (parentNode2.childNodes.length > 0) {
            const prevNode = parentNode2.childNodes[parentNode2.childNodes.length - 1];
            if (defaultTreeAdapter.isTextNode(prevNode)) {
              prevNode.value += text10;
              return;
            }
          }
          defaultTreeAdapter.appendChild(parentNode2, defaultTreeAdapter.createTextNode(text10));
        },
        insertTextBefore(parentNode2, text10, referenceNode) {
          const prevNode = parentNode2.childNodes[parentNode2.childNodes.indexOf(referenceNode) - 1];
          if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
            prevNode.value += text10;
          } else {
            defaultTreeAdapter.insertBefore(parentNode2, defaultTreeAdapter.createTextNode(text10), referenceNode);
          }
        },
        adoptAttributes(recipient, attrs) {
          const recipientAttrsMap = new Set(recipient.attrs.map((attr) => attr.name));
          for (let j2 = 0; j2 < attrs.length; j2++) {
            if (!recipientAttrsMap.has(attrs[j2].name)) {
              recipient.attrs.push(attrs[j2]);
            }
          }
        },
        //Tree traversing
        getFirstChild(node2) {
          return node2.childNodes[0];
        },
        getChildNodes(node2) {
          return node2.childNodes;
        },
        getParentNode(node2) {
          return node2.parentNode;
        },
        getAttrList(element7) {
          return element7.attrs;
        },
        //Node data
        getTagName(element7) {
          return element7.tagName;
        },
        getNamespaceURI(element7) {
          return element7.namespaceURI;
        },
        getTextNodeContent(textNode) {
          return textNode.value;
        },
        getCommentNodeContent(commentNode) {
          return commentNode.data;
        },
        getDocumentTypeNodeName(doctypeNode) {
          return doctypeNode.name;
        },
        getDocumentTypeNodePublicId(doctypeNode) {
          return doctypeNode.publicId;
        },
        getDocumentTypeNodeSystemId(doctypeNode) {
          return doctypeNode.systemId;
        },
        //Node types
        isTextNode(node2) {
          return node2.nodeName === "#text";
        },
        isCommentNode(node2) {
          return node2.nodeName === "#comment";
        },
        isDocumentTypeNode(node2) {
          return node2.nodeName === "#documentType";
        },
        isElementNode(node2) {
          return Object.prototype.hasOwnProperty.call(node2, "tagName");
        },
        // Source code location
        setNodeSourceCodeLocation(node2, location3) {
          node2.sourceCodeLocation = location3;
        },
        getNodeSourceCodeLocation(node2) {
          return node2.sourceCodeLocation;
        },
        updateNodeSourceCodeLocation(node2, endLocation) {
          node2.sourceCodeLocation = { ...node2.sourceCodeLocation, ...endLocation };
        }
      };
    }
  });

  // node_modules/parse5/dist/common/doctype.js
  function hasPrefix(publicId, prefixes) {
    return prefixes.some((prefix3) => publicId.startsWith(prefix3));
  }
  function isConforming(token) {
    return token.name === VALID_DOCTYPE_NAME && token.publicId === null && (token.systemId === null || token.systemId === VALID_SYSTEM_ID);
  }
  function getDocumentMode(token) {
    if (token.name !== VALID_DOCTYPE_NAME) {
      return DOCUMENT_MODE.QUIRKS;
    }
    const { systemId } = token;
    if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
      return DOCUMENT_MODE.QUIRKS;
    }
    let { publicId } = token;
    if (publicId !== null) {
      publicId = publicId.toLowerCase();
      if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
        return DOCUMENT_MODE.QUIRKS;
      }
      let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
      if (hasPrefix(publicId, prefixes)) {
        return DOCUMENT_MODE.QUIRKS;
      }
      prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
      if (hasPrefix(publicId, prefixes)) {
        return DOCUMENT_MODE.LIMITED_QUIRKS;
      }
    }
    return DOCUMENT_MODE.NO_QUIRKS;
  }
  var VALID_DOCTYPE_NAME, VALID_SYSTEM_ID, QUIRKS_MODE_SYSTEM_ID, QUIRKS_MODE_PUBLIC_ID_PREFIXES, QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES, QUIRKS_MODE_PUBLIC_IDS, LIMITED_QUIRKS_PUBLIC_ID_PREFIXES, LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
  var init_doctype = __esm({
    "node_modules/parse5/dist/common/doctype.js"() {
      init_html2();
      VALID_DOCTYPE_NAME = "html";
      VALID_SYSTEM_ID = "about:legacy-compat";
      QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
      QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
        "+//silmaril//dtd html pro v0r11 19970101//",
        "-//as//dtd html 3.0 aswedit + extensions//",
        "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
        "-//ietf//dtd html 2.0 level 1//",
        "-//ietf//dtd html 2.0 level 2//",
        "-//ietf//dtd html 2.0 strict level 1//",
        "-//ietf//dtd html 2.0 strict level 2//",
        "-//ietf//dtd html 2.0 strict//",
        "-//ietf//dtd html 2.0//",
        "-//ietf//dtd html 2.1e//",
        "-//ietf//dtd html 3.0//",
        "-//ietf//dtd html 3.2 final//",
        "-//ietf//dtd html 3.2//",
        "-//ietf//dtd html 3//",
        "-//ietf//dtd html level 0//",
        "-//ietf//dtd html level 1//",
        "-//ietf//dtd html level 2//",
        "-//ietf//dtd html level 3//",
        "-//ietf//dtd html strict level 0//",
        "-//ietf//dtd html strict level 1//",
        "-//ietf//dtd html strict level 2//",
        "-//ietf//dtd html strict level 3//",
        "-//ietf//dtd html strict//",
        "-//ietf//dtd html//",
        "-//metrius//dtd metrius presentational//",
        "-//microsoft//dtd internet explorer 2.0 html strict//",
        "-//microsoft//dtd internet explorer 2.0 html//",
        "-//microsoft//dtd internet explorer 2.0 tables//",
        "-//microsoft//dtd internet explorer 3.0 html strict//",
        "-//microsoft//dtd internet explorer 3.0 html//",
        "-//microsoft//dtd internet explorer 3.0 tables//",
        "-//netscape comm. corp.//dtd html//",
        "-//netscape comm. corp.//dtd strict html//",
        "-//o'reilly and associates//dtd html 2.0//",
        "-//o'reilly and associates//dtd html extended 1.0//",
        "-//o'reilly and associates//dtd html extended relaxed 1.0//",
        "-//sq//dtd html 2.0 hotmetal + extensions//",
        "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
        "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
        "-//spyglass//dtd html 2.0 extended//",
        "-//sun microsystems corp.//dtd hotjava html//",
        "-//sun microsystems corp.//dtd hotjava strict html//",
        "-//w3c//dtd html 3 1995-03-24//",
        "-//w3c//dtd html 3.2 draft//",
        "-//w3c//dtd html 3.2 final//",
        "-//w3c//dtd html 3.2//",
        "-//w3c//dtd html 3.2s draft//",
        "-//w3c//dtd html 4.0 frameset//",
        "-//w3c//dtd html 4.0 transitional//",
        "-//w3c//dtd html experimental 19960712//",
        "-//w3c//dtd html experimental 970421//",
        "-//w3c//dtd w3 html//",
        "-//w3o//dtd w3 html 3.0//",
        "-//webtechs//dtd mozilla html 2.0//",
        "-//webtechs//dtd mozilla html//"
      ];
      QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
        ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
        "-//w3c//dtd html 4.01 frameset//",
        "-//w3c//dtd html 4.01 transitional//"
      ];
      QUIRKS_MODE_PUBLIC_IDS = /* @__PURE__ */ new Set([
        "-//w3o//dtd w3 html strict 3.0//en//",
        "-/w3c/dtd html 4.0 transitional/en",
        "html"
      ]);
      LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
      LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
        ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
        "-//w3c//dtd html 4.01 frameset//",
        "-//w3c//dtd html 4.01 transitional//"
      ];
    }
  });

  // node_modules/parse5/dist/common/foreign-content.js
  function causesExit(startTagToken) {
    const tn2 = startTagToken.tagID;
    const isFontWithAttrs = tn2 === TAG_ID.FONT && startTagToken.attrs.some(({ name }) => name === ATTRS.COLOR || name === ATTRS.SIZE || name === ATTRS.FACE);
    return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn2);
  }
  function adjustTokenMathMLAttrs(token) {
    for (let i = 0; i < token.attrs.length; i++) {
      if (token.attrs[i].name === DEFINITION_URL_ATTR) {
        token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
        break;
      }
    }
  }
  function adjustTokenSVGAttrs(token) {
    for (let i = 0; i < token.attrs.length; i++) {
      const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
      if (adjustedAttrName != null) {
        token.attrs[i].name = adjustedAttrName;
      }
    }
  }
  function adjustTokenXMLAttrs(token) {
    for (let i = 0; i < token.attrs.length; i++) {
      const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
      if (adjustedAttrEntry) {
        token.attrs[i].prefix = adjustedAttrEntry.prefix;
        token.attrs[i].name = adjustedAttrEntry.name;
        token.attrs[i].namespace = adjustedAttrEntry.namespace;
      }
    }
  }
  function adjustTokenSVGTagName(token) {
    const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
    if (adjustedTagName != null) {
      token.tagName = adjustedTagName;
      token.tagID = getTagID(token.tagName);
    }
  }
  function isMathMLTextIntegrationPoint(tn2, ns2) {
    return ns2 === NS.MATHML && (tn2 === TAG_ID.MI || tn2 === TAG_ID.MO || tn2 === TAG_ID.MN || tn2 === TAG_ID.MS || tn2 === TAG_ID.MTEXT);
  }
  function isHtmlIntegrationPoint(tn2, ns2, attrs) {
    if (ns2 === NS.MATHML && tn2 === TAG_ID.ANNOTATION_XML) {
      for (let i = 0; i < attrs.length; i++) {
        if (attrs[i].name === ATTRS.ENCODING) {
          const value = attrs[i].value.toLowerCase();
          return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
        }
      }
    }
    return ns2 === NS.SVG && (tn2 === TAG_ID.FOREIGN_OBJECT || tn2 === TAG_ID.DESC || tn2 === TAG_ID.TITLE);
  }
  function isIntegrationPoint(tn2, ns2, attrs, foreignNS) {
    return (!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn2, ns2, attrs) || (!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn2, ns2);
  }
  var MIME_TYPES, DEFINITION_URL_ATTR, ADJUSTED_DEFINITION_URL_ATTR, SVG_ATTRS_ADJUSTMENT_MAP, XML_ATTRS_ADJUSTMENT_MAP, SVG_TAG_NAMES_ADJUSTMENT_MAP, EXITS_FOREIGN_CONTENT;
  var init_foreign_content = __esm({
    "node_modules/parse5/dist/common/foreign-content.js"() {
      init_html2();
      MIME_TYPES = {
        TEXT_HTML: "text/html",
        APPLICATION_XML: "application/xhtml+xml"
      };
      DEFINITION_URL_ATTR = "definitionurl";
      ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
      SVG_ATTRS_ADJUSTMENT_MAP = new Map([
        "attributeName",
        "attributeType",
        "baseFrequency",
        "baseProfile",
        "calcMode",
        "clipPathUnits",
        "diffuseConstant",
        "edgeMode",
        "filterUnits",
        "glyphRef",
        "gradientTransform",
        "gradientUnits",
        "kernelMatrix",
        "kernelUnitLength",
        "keyPoints",
        "keySplines",
        "keyTimes",
        "lengthAdjust",
        "limitingConeAngle",
        "markerHeight",
        "markerUnits",
        "markerWidth",
        "maskContentUnits",
        "maskUnits",
        "numOctaves",
        "pathLength",
        "patternContentUnits",
        "patternTransform",
        "patternUnits",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "preserveAlpha",
        "preserveAspectRatio",
        "primitiveUnits",
        "refX",
        "refY",
        "repeatCount",
        "repeatDur",
        "requiredExtensions",
        "requiredFeatures",
        "specularConstant",
        "specularExponent",
        "spreadMethod",
        "startOffset",
        "stdDeviation",
        "stitchTiles",
        "surfaceScale",
        "systemLanguage",
        "tableValues",
        "targetX",
        "targetY",
        "textLength",
        "viewBox",
        "viewTarget",
        "xChannelSelector",
        "yChannelSelector",
        "zoomAndPan"
      ].map((attr) => [attr.toLowerCase(), attr]));
      XML_ATTRS_ADJUSTMENT_MAP = /* @__PURE__ */ new Map([
        ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: NS.XLINK }],
        ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: NS.XLINK }],
        ["xlink:href", { prefix: "xlink", name: "href", namespace: NS.XLINK }],
        ["xlink:role", { prefix: "xlink", name: "role", namespace: NS.XLINK }],
        ["xlink:show", { prefix: "xlink", name: "show", namespace: NS.XLINK }],
        ["xlink:title", { prefix: "xlink", name: "title", namespace: NS.XLINK }],
        ["xlink:type", { prefix: "xlink", name: "type", namespace: NS.XLINK }],
        ["xml:lang", { prefix: "xml", name: "lang", namespace: NS.XML }],
        ["xml:space", { prefix: "xml", name: "space", namespace: NS.XML }],
        ["xmlns", { prefix: "", name: "xmlns", namespace: NS.XMLNS }],
        ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: NS.XMLNS }]
      ]);
      SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "clipPath",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "foreignObject",
        "glyphRef",
        "linearGradient",
        "radialGradient",
        "textPath"
      ].map((tn2) => [tn2.toLowerCase(), tn2]));
      EXITS_FOREIGN_CONTENT = /* @__PURE__ */ new Set([
        TAG_ID.B,
        TAG_ID.BIG,
        TAG_ID.BLOCKQUOTE,
        TAG_ID.BODY,
        TAG_ID.BR,
        TAG_ID.CENTER,
        TAG_ID.CODE,
        TAG_ID.DD,
        TAG_ID.DIV,
        TAG_ID.DL,
        TAG_ID.DT,
        TAG_ID.EM,
        TAG_ID.EMBED,
        TAG_ID.H1,
        TAG_ID.H2,
        TAG_ID.H3,
        TAG_ID.H4,
        TAG_ID.H5,
        TAG_ID.H6,
        TAG_ID.HEAD,
        TAG_ID.HR,
        TAG_ID.I,
        TAG_ID.IMG,
        TAG_ID.LI,
        TAG_ID.LISTING,
        TAG_ID.MENU,
        TAG_ID.META,
        TAG_ID.NOBR,
        TAG_ID.OL,
        TAG_ID.P,
        TAG_ID.PRE,
        TAG_ID.RUBY,
        TAG_ID.S,
        TAG_ID.SMALL,
        TAG_ID.SPAN,
        TAG_ID.STRONG,
        TAG_ID.STRIKE,
        TAG_ID.SUB,
        TAG_ID.SUP,
        TAG_ID.TABLE,
        TAG_ID.TT,
        TAG_ID.U,
        TAG_ID.UL,
        TAG_ID.VAR
      ]);
    }
  });

  // node_modules/parse5/dist/parser/index.js
  function aaObtainFormattingElementEntry(p5, token) {
    let formattingElementEntry = p5.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
    if (formattingElementEntry) {
      if (!p5.openElements.contains(formattingElementEntry.element)) {
        p5.activeFormattingElements.removeEntry(formattingElementEntry);
        formattingElementEntry = null;
      } else if (!p5.openElements.hasInScope(token.tagID)) {
        formattingElementEntry = null;
      }
    } else {
      genericEndTagInBody(p5, token);
    }
    return formattingElementEntry;
  }
  function aaObtainFurthestBlock(p5, formattingElementEntry) {
    let furthestBlock = null;
    let idx = p5.openElements.stackTop;
    for (; idx >= 0; idx--) {
      const element7 = p5.openElements.items[idx];
      if (element7 === formattingElementEntry.element) {
        break;
      }
      if (p5._isSpecialElement(element7, p5.openElements.tagIDs[idx])) {
        furthestBlock = element7;
      }
    }
    if (!furthestBlock) {
      p5.openElements.shortenToLength(Math.max(idx, 0));
      p5.activeFormattingElements.removeEntry(formattingElementEntry);
    }
    return furthestBlock;
  }
  function aaInnerLoop(p5, furthestBlock, formattingElement) {
    let lastElement = furthestBlock;
    let nextElement = p5.openElements.getCommonAncestor(furthestBlock);
    for (let i = 0, element7 = nextElement; element7 !== formattingElement; i++, element7 = nextElement) {
      nextElement = p5.openElements.getCommonAncestor(element7);
      const elementEntry = p5.activeFormattingElements.getElementEntry(element7);
      const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
      const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
      if (shouldRemoveFromOpenElements) {
        if (counterOverflow) {
          p5.activeFormattingElements.removeEntry(elementEntry);
        }
        p5.openElements.remove(element7);
      } else {
        element7 = aaRecreateElementFromEntry(p5, elementEntry);
        if (lastElement === furthestBlock) {
          p5.activeFormattingElements.bookmark = elementEntry;
        }
        p5.treeAdapter.detachNode(lastElement);
        p5.treeAdapter.appendChild(element7, lastElement);
        lastElement = element7;
      }
    }
    return lastElement;
  }
  function aaRecreateElementFromEntry(p5, elementEntry) {
    const ns2 = p5.treeAdapter.getNamespaceURI(elementEntry.element);
    const newElement = p5.treeAdapter.createElement(elementEntry.token.tagName, ns2, elementEntry.token.attrs);
    p5.openElements.replace(elementEntry.element, newElement);
    elementEntry.element = newElement;
    return newElement;
  }
  function aaInsertLastNodeInCommonAncestor(p5, commonAncestor, lastElement) {
    const tn2 = p5.treeAdapter.getTagName(commonAncestor);
    const tid = getTagID(tn2);
    if (p5._isElementCausesFosterParenting(tid)) {
      p5._fosterParentElement(lastElement);
    } else {
      const ns2 = p5.treeAdapter.getNamespaceURI(commonAncestor);
      if (tid === TAG_ID.TEMPLATE && ns2 === NS.HTML) {
        commonAncestor = p5.treeAdapter.getTemplateContent(commonAncestor);
      }
      p5.treeAdapter.appendChild(commonAncestor, lastElement);
    }
  }
  function aaReplaceFormattingElement(p5, furthestBlock, formattingElementEntry) {
    const ns2 = p5.treeAdapter.getNamespaceURI(formattingElementEntry.element);
    const { token } = formattingElementEntry;
    const newElement = p5.treeAdapter.createElement(token.tagName, ns2, token.attrs);
    p5._adoptNodes(furthestBlock, newElement);
    p5.treeAdapter.appendChild(furthestBlock, newElement);
    p5.activeFormattingElements.insertElementAfterBookmark(newElement, token);
    p5.activeFormattingElements.removeEntry(formattingElementEntry);
    p5.openElements.remove(formattingElementEntry.element);
    p5.openElements.insertAfter(furthestBlock, newElement, token.tagID);
  }
  function callAdoptionAgency(p5, token) {
    for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
      const formattingElementEntry = aaObtainFormattingElementEntry(p5, token);
      if (!formattingElementEntry) {
        break;
      }
      const furthestBlock = aaObtainFurthestBlock(p5, formattingElementEntry);
      if (!furthestBlock) {
        break;
      }
      p5.activeFormattingElements.bookmark = formattingElementEntry;
      const lastElement = aaInnerLoop(p5, furthestBlock, formattingElementEntry.element);
      const commonAncestor = p5.openElements.getCommonAncestor(formattingElementEntry.element);
      p5.treeAdapter.detachNode(lastElement);
      if (commonAncestor)
        aaInsertLastNodeInCommonAncestor(p5, commonAncestor, lastElement);
      aaReplaceFormattingElement(p5, furthestBlock, formattingElementEntry);
    }
  }
  function appendComment(p5, token) {
    p5._appendCommentNode(token, p5.openElements.currentTmplContentOrNode);
  }
  function appendCommentToRootHtmlElement(p5, token) {
    p5._appendCommentNode(token, p5.openElements.items[0]);
  }
  function appendCommentToDocument(p5, token) {
    p5._appendCommentNode(token, p5.document);
  }
  function stopParsing(p5, token) {
    p5.stopped = true;
    if (token.location) {
      const target = p5.fragmentContext ? 0 : 2;
      for (let i = p5.openElements.stackTop; i >= target; i--) {
        p5._setEndLocation(p5.openElements.items[i], token);
      }
      if (!p5.fragmentContext && p5.openElements.stackTop >= 0) {
        const htmlElement = p5.openElements.items[0];
        const htmlLocation = p5.treeAdapter.getNodeSourceCodeLocation(htmlElement);
        if (htmlLocation && !htmlLocation.endTag) {
          p5._setEndLocation(htmlElement, token);
          if (p5.openElements.stackTop >= 1) {
            const bodyElement = p5.openElements.items[1];
            const bodyLocation = p5.treeAdapter.getNodeSourceCodeLocation(bodyElement);
            if (bodyLocation && !bodyLocation.endTag) {
              p5._setEndLocation(bodyElement, token);
            }
          }
        }
      }
    }
  }
  function doctypeInInitialMode(p5, token) {
    p5._setDocumentType(token);
    const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
    if (!isConforming(token)) {
      p5._err(token, ERR.nonConformingDoctype);
    }
    p5.treeAdapter.setDocumentMode(p5.document, mode);
    p5.insertionMode = InsertionMode.BEFORE_HTML;
  }
  function tokenInInitialMode(p5, token) {
    p5._err(token, ERR.missingDoctype, true);
    p5.treeAdapter.setDocumentMode(p5.document, DOCUMENT_MODE.QUIRKS);
    p5.insertionMode = InsertionMode.BEFORE_HTML;
    p5._processToken(token);
  }
  function startTagBeforeHtml(p5, token) {
    if (token.tagID === TAG_ID.HTML) {
      p5._insertElement(token, NS.HTML);
      p5.insertionMode = InsertionMode.BEFORE_HEAD;
    } else {
      tokenBeforeHtml(p5, token);
    }
  }
  function endTagBeforeHtml(p5, token) {
    const tn2 = token.tagID;
    if (tn2 === TAG_ID.HTML || tn2 === TAG_ID.HEAD || tn2 === TAG_ID.BODY || tn2 === TAG_ID.BR) {
      tokenBeforeHtml(p5, token);
    }
  }
  function tokenBeforeHtml(p5, token) {
    p5._insertFakeRootElement();
    p5.insertionMode = InsertionMode.BEFORE_HEAD;
    p5._processToken(token);
  }
  function startTagBeforeHead(p5, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p5, token);
        break;
      }
      case TAG_ID.HEAD: {
        p5._insertElement(token, NS.HTML);
        p5.headElement = p5.openElements.current;
        p5.insertionMode = InsertionMode.IN_HEAD;
        break;
      }
      default: {
        tokenBeforeHead(p5, token);
      }
    }
  }
  function endTagBeforeHead(p5, token) {
    const tn2 = token.tagID;
    if (tn2 === TAG_ID.HEAD || tn2 === TAG_ID.BODY || tn2 === TAG_ID.HTML || tn2 === TAG_ID.BR) {
      tokenBeforeHead(p5, token);
    } else {
      p5._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenBeforeHead(p5, token) {
    p5._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
    p5.headElement = p5.openElements.current;
    p5.insertionMode = InsertionMode.IN_HEAD;
    p5._processToken(token);
  }
  function startTagInHead(p5, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p5, token);
        break;
      }
      case TAG_ID.BASE:
      case TAG_ID.BASEFONT:
      case TAG_ID.BGSOUND:
      case TAG_ID.LINK:
      case TAG_ID.META: {
        p5._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
        break;
      }
      case TAG_ID.TITLE: {
        p5._switchToTextParsing(token, TokenizerMode.RCDATA);
        break;
      }
      case TAG_ID.NOSCRIPT: {
        if (p5.options.scriptingEnabled) {
          p5._switchToTextParsing(token, TokenizerMode.RAWTEXT);
        } else {
          p5._insertElement(token, NS.HTML);
          p5.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
        }
        break;
      }
      case TAG_ID.NOFRAMES:
      case TAG_ID.STYLE: {
        p5._switchToTextParsing(token, TokenizerMode.RAWTEXT);
        break;
      }
      case TAG_ID.SCRIPT: {
        p5._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
        break;
      }
      case TAG_ID.TEMPLATE: {
        p5._insertTemplate(token);
        p5.activeFormattingElements.insertMarker();
        p5.framesetOk = false;
        p5.insertionMode = InsertionMode.IN_TEMPLATE;
        p5.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
        break;
      }
      case TAG_ID.HEAD: {
        p5._err(token, ERR.misplacedStartTagForHeadElement);
        break;
      }
      default: {
        tokenInHead(p5, token);
      }
    }
  }
  function endTagInHead(p5, token) {
    switch (token.tagID) {
      case TAG_ID.HEAD: {
        p5.openElements.pop();
        p5.insertionMode = InsertionMode.AFTER_HEAD;
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.BR:
      case TAG_ID.HTML: {
        tokenInHead(p5, token);
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p5, token);
        break;
      }
      default: {
        p5._err(token, ERR.endTagWithoutMatchingOpenElement);
      }
    }
  }
  function templateEndTagInHead(p5, token) {
    if (p5.openElements.tmplCount > 0) {
      p5.openElements.generateImpliedEndTagsThoroughly();
      if (p5.openElements.currentTagId !== TAG_ID.TEMPLATE) {
        p5._err(token, ERR.closingOfElementWithOpenChildElements);
      }
      p5.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
      p5.activeFormattingElements.clearToLastMarker();
      p5.tmplInsertionModeStack.shift();
      p5._resetInsertionMode();
    } else {
      p5._err(token, ERR.endTagWithoutMatchingOpenElement);
    }
  }
  function tokenInHead(p5, token) {
    p5.openElements.pop();
    p5.insertionMode = InsertionMode.AFTER_HEAD;
    p5._processToken(token);
  }
  function startTagInHeadNoScript(p5, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p5, token);
        break;
      }
      case TAG_ID.BASEFONT:
      case TAG_ID.BGSOUND:
      case TAG_ID.HEAD:
      case TAG_ID.LINK:
      case TAG_ID.META:
      case TAG_ID.NOFRAMES:
      case TAG_ID.STYLE: {
        startTagInHead(p5, token);
        break;
      }
      case TAG_ID.NOSCRIPT: {
        p5._err(token, ERR.nestedNoscriptInHead);
        break;
      }
      default: {
        tokenInHeadNoScript(p5, token);
      }
    }
  }
  function endTagInHeadNoScript(p5, token) {
    switch (token.tagID) {
      case TAG_ID.NOSCRIPT: {
        p5.openElements.pop();
        p5.insertionMode = InsertionMode.IN_HEAD;
        break;
      }
      case TAG_ID.BR: {
        tokenInHeadNoScript(p5, token);
        break;
      }
      default: {
        p5._err(token, ERR.endTagWithoutMatchingOpenElement);
      }
    }
  }
  function tokenInHeadNoScript(p5, token) {
    const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
    p5._err(token, errCode);
    p5.openElements.pop();
    p5.insertionMode = InsertionMode.IN_HEAD;
    p5._processToken(token);
  }
  function startTagAfterHead(p5, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p5, token);
        break;
      }
      case TAG_ID.BODY: {
        p5._insertElement(token, NS.HTML);
        p5.framesetOk = false;
        p5.insertionMode = InsertionMode.IN_BODY;
        break;
      }
      case TAG_ID.FRAMESET: {
        p5._insertElement(token, NS.HTML);
        p5.insertionMode = InsertionMode.IN_FRAMESET;
        break;
      }
      case TAG_ID.BASE:
      case TAG_ID.BASEFONT:
      case TAG_ID.BGSOUND:
      case TAG_ID.LINK:
      case TAG_ID.META:
      case TAG_ID.NOFRAMES:
      case TAG_ID.SCRIPT:
      case TAG_ID.STYLE:
      case TAG_ID.TEMPLATE:
      case TAG_ID.TITLE: {
        p5._err(token, ERR.abandonedHeadElementChild);
        p5.openElements.push(p5.headElement, TAG_ID.HEAD);
        startTagInHead(p5, token);
        p5.openElements.remove(p5.headElement);
        break;
      }
      case TAG_ID.HEAD: {
        p5._err(token, ERR.misplacedStartTagForHeadElement);
        break;
      }
      default: {
        tokenAfterHead(p5, token);
      }
    }
  }
  function endTagAfterHead(p5, token) {
    switch (token.tagID) {
      case TAG_ID.BODY:
      case TAG_ID.HTML:
      case TAG_ID.BR: {
        tokenAfterHead(p5, token);
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p5, token);
        break;
      }
      default: {
        p5._err(token, ERR.endTagWithoutMatchingOpenElement);
      }
    }
  }
  function tokenAfterHead(p5, token) {
    p5._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
    p5.insertionMode = InsertionMode.IN_BODY;
    modeInBody(p5, token);
  }
  function modeInBody(p5, token) {
    switch (token.type) {
      case TokenType.CHARACTER: {
        characterInBody(p5, token);
        break;
      }
      case TokenType.WHITESPACE_CHARACTER: {
        whitespaceCharacterInBody(p5, token);
        break;
      }
      case TokenType.COMMENT: {
        appendComment(p5, token);
        break;
      }
      case TokenType.START_TAG: {
        startTagInBody(p5, token);
        break;
      }
      case TokenType.END_TAG: {
        endTagInBody(p5, token);
        break;
      }
      case TokenType.EOF: {
        eofInBody(p5, token);
        break;
      }
      default:
    }
  }
  function whitespaceCharacterInBody(p5, token) {
    p5._reconstructActiveFormattingElements();
    p5._insertCharacters(token);
  }
  function characterInBody(p5, token) {
    p5._reconstructActiveFormattingElements();
    p5._insertCharacters(token);
    p5.framesetOk = false;
  }
  function htmlStartTagInBody(p5, token) {
    if (p5.openElements.tmplCount === 0) {
      p5.treeAdapter.adoptAttributes(p5.openElements.items[0], token.attrs);
    }
  }
  function bodyStartTagInBody(p5, token) {
    const bodyElement = p5.openElements.tryPeekProperlyNestedBodyElement();
    if (bodyElement && p5.openElements.tmplCount === 0) {
      p5.framesetOk = false;
      p5.treeAdapter.adoptAttributes(bodyElement, token.attrs);
    }
  }
  function framesetStartTagInBody(p5, token) {
    const bodyElement = p5.openElements.tryPeekProperlyNestedBodyElement();
    if (p5.framesetOk && bodyElement) {
      p5.treeAdapter.detachNode(bodyElement);
      p5.openElements.popAllUpToHtmlElement();
      p5._insertElement(token, NS.HTML);
      p5.insertionMode = InsertionMode.IN_FRAMESET;
    }
  }
  function addressStartTagInBody(p5, token) {
    if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
      p5._closePElement();
    }
    p5._insertElement(token, NS.HTML);
  }
  function numberedHeaderStartTagInBody(p5, token) {
    if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
      p5._closePElement();
    }
    if (p5.openElements.currentTagId !== void 0 && NUMBERED_HEADERS.has(p5.openElements.currentTagId)) {
      p5.openElements.pop();
    }
    p5._insertElement(token, NS.HTML);
  }
  function preStartTagInBody(p5, token) {
    if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
      p5._closePElement();
    }
    p5._insertElement(token, NS.HTML);
    p5.skipNextNewLine = true;
    p5.framesetOk = false;
  }
  function formStartTagInBody(p5, token) {
    const inTemplate = p5.openElements.tmplCount > 0;
    if (!p5.formElement || inTemplate) {
      if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
        p5._closePElement();
      }
      p5._insertElement(token, NS.HTML);
      if (!inTemplate) {
        p5.formElement = p5.openElements.current;
      }
    }
  }
  function listItemStartTagInBody(p5, token) {
    p5.framesetOk = false;
    const tn2 = token.tagID;
    for (let i = p5.openElements.stackTop; i >= 0; i--) {
      const elementId = p5.openElements.tagIDs[i];
      if (tn2 === TAG_ID.LI && elementId === TAG_ID.LI || (tn2 === TAG_ID.DD || tn2 === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT)) {
        p5.openElements.generateImpliedEndTagsWithExclusion(elementId);
        p5.openElements.popUntilTagNamePopped(elementId);
        break;
      }
      if (elementId !== TAG_ID.ADDRESS && elementId !== TAG_ID.DIV && elementId !== TAG_ID.P && p5._isSpecialElement(p5.openElements.items[i], elementId)) {
        break;
      }
    }
    if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
      p5._closePElement();
    }
    p5._insertElement(token, NS.HTML);
  }
  function plaintextStartTagInBody(p5, token) {
    if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
      p5._closePElement();
    }
    p5._insertElement(token, NS.HTML);
    p5.tokenizer.state = TokenizerMode.PLAINTEXT;
  }
  function buttonStartTagInBody(p5, token) {
    if (p5.openElements.hasInScope(TAG_ID.BUTTON)) {
      p5.openElements.generateImpliedEndTags();
      p5.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
    }
    p5._reconstructActiveFormattingElements();
    p5._insertElement(token, NS.HTML);
    p5.framesetOk = false;
  }
  function aStartTagInBody(p5, token) {
    const activeElementEntry = p5.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
    if (activeElementEntry) {
      callAdoptionAgency(p5, token);
      p5.openElements.remove(activeElementEntry.element);
      p5.activeFormattingElements.removeEntry(activeElementEntry);
    }
    p5._reconstructActiveFormattingElements();
    p5._insertElement(token, NS.HTML);
    p5.activeFormattingElements.pushElement(p5.openElements.current, token);
  }
  function bStartTagInBody(p5, token) {
    p5._reconstructActiveFormattingElements();
    p5._insertElement(token, NS.HTML);
    p5.activeFormattingElements.pushElement(p5.openElements.current, token);
  }
  function nobrStartTagInBody(p5, token) {
    p5._reconstructActiveFormattingElements();
    if (p5.openElements.hasInScope(TAG_ID.NOBR)) {
      callAdoptionAgency(p5, token);
      p5._reconstructActiveFormattingElements();
    }
    p5._insertElement(token, NS.HTML);
    p5.activeFormattingElements.pushElement(p5.openElements.current, token);
  }
  function appletStartTagInBody(p5, token) {
    p5._reconstructActiveFormattingElements();
    p5._insertElement(token, NS.HTML);
    p5.activeFormattingElements.insertMarker();
    p5.framesetOk = false;
  }
  function tableStartTagInBody(p5, token) {
    if (p5.treeAdapter.getDocumentMode(p5.document) !== DOCUMENT_MODE.QUIRKS && p5.openElements.hasInButtonScope(TAG_ID.P)) {
      p5._closePElement();
    }
    p5._insertElement(token, NS.HTML);
    p5.framesetOk = false;
    p5.insertionMode = InsertionMode.IN_TABLE;
  }
  function areaStartTagInBody(p5, token) {
    p5._reconstructActiveFormattingElements();
    p5._appendElement(token, NS.HTML);
    p5.framesetOk = false;
    token.ackSelfClosing = true;
  }
  function isHiddenInput(token) {
    const inputType = getTokenAttr(token, ATTRS.TYPE);
    return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
  }
  function inputStartTagInBody(p5, token) {
    p5._reconstructActiveFormattingElements();
    p5._appendElement(token, NS.HTML);
    if (!isHiddenInput(token)) {
      p5.framesetOk = false;
    }
    token.ackSelfClosing = true;
  }
  function paramStartTagInBody(p5, token) {
    p5._appendElement(token, NS.HTML);
    token.ackSelfClosing = true;
  }
  function hrStartTagInBody(p5, token) {
    if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
      p5._closePElement();
    }
    p5._appendElement(token, NS.HTML);
    p5.framesetOk = false;
    token.ackSelfClosing = true;
  }
  function imageStartTagInBody(p5, token) {
    token.tagName = TAG_NAMES.IMG;
    token.tagID = TAG_ID.IMG;
    areaStartTagInBody(p5, token);
  }
  function textareaStartTagInBody(p5, token) {
    p5._insertElement(token, NS.HTML);
    p5.skipNextNewLine = true;
    p5.tokenizer.state = TokenizerMode.RCDATA;
    p5.originalInsertionMode = p5.insertionMode;
    p5.framesetOk = false;
    p5.insertionMode = InsertionMode.TEXT;
  }
  function xmpStartTagInBody(p5, token) {
    if (p5.openElements.hasInButtonScope(TAG_ID.P)) {
      p5._closePElement();
    }
    p5._reconstructActiveFormattingElements();
    p5.framesetOk = false;
    p5._switchToTextParsing(token, TokenizerMode.RAWTEXT);
  }
  function iframeStartTagInBody(p5, token) {
    p5.framesetOk = false;
    p5._switchToTextParsing(token, TokenizerMode.RAWTEXT);
  }
  function rawTextStartTagInBody(p5, token) {
    p5._switchToTextParsing(token, TokenizerMode.RAWTEXT);
  }
  function selectStartTagInBody(p5, token) {
    p5._reconstructActiveFormattingElements();
    p5._insertElement(token, NS.HTML);
    p5.framesetOk = false;
    p5.insertionMode = p5.insertionMode === InsertionMode.IN_TABLE || p5.insertionMode === InsertionMode.IN_CAPTION || p5.insertionMode === InsertionMode.IN_TABLE_BODY || p5.insertionMode === InsertionMode.IN_ROW || p5.insertionMode === InsertionMode.IN_CELL ? InsertionMode.IN_SELECT_IN_TABLE : InsertionMode.IN_SELECT;
  }
  function optgroupStartTagInBody(p5, token) {
    if (p5.openElements.currentTagId === TAG_ID.OPTION) {
      p5.openElements.pop();
    }
    p5._reconstructActiveFormattingElements();
    p5._insertElement(token, NS.HTML);
  }
  function rbStartTagInBody(p5, token) {
    if (p5.openElements.hasInScope(TAG_ID.RUBY)) {
      p5.openElements.generateImpliedEndTags();
    }
    p5._insertElement(token, NS.HTML);
  }
  function rtStartTagInBody(p5, token) {
    if (p5.openElements.hasInScope(TAG_ID.RUBY)) {
      p5.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
    }
    p5._insertElement(token, NS.HTML);
  }
  function mathStartTagInBody(p5, token) {
    p5._reconstructActiveFormattingElements();
    adjustTokenMathMLAttrs(token);
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p5._appendElement(token, NS.MATHML);
    } else {
      p5._insertElement(token, NS.MATHML);
    }
    token.ackSelfClosing = true;
  }
  function svgStartTagInBody(p5, token) {
    p5._reconstructActiveFormattingElements();
    adjustTokenSVGAttrs(token);
    adjustTokenXMLAttrs(token);
    if (token.selfClosing) {
      p5._appendElement(token, NS.SVG);
    } else {
      p5._insertElement(token, NS.SVG);
    }
    token.ackSelfClosing = true;
  }
  function genericStartTagInBody(p5, token) {
    p5._reconstructActiveFormattingElements();
    p5._insertElement(token, NS.HTML);
  }
  function startTagInBody(p5, token) {
    switch (token.tagID) {
      case TAG_ID.I:
      case TAG_ID.S:
      case TAG_ID.B:
      case TAG_ID.U:
      case TAG_ID.EM:
      case TAG_ID.TT:
      case TAG_ID.BIG:
      case TAG_ID.CODE:
      case TAG_ID.FONT:
      case TAG_ID.SMALL:
      case TAG_ID.STRIKE:
      case TAG_ID.STRONG: {
        bStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.A: {
        aStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.H1:
      case TAG_ID.H2:
      case TAG_ID.H3:
      case TAG_ID.H4:
      case TAG_ID.H5:
      case TAG_ID.H6: {
        numberedHeaderStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.P:
      case TAG_ID.DL:
      case TAG_ID.OL:
      case TAG_ID.UL:
      case TAG_ID.DIV:
      case TAG_ID.DIR:
      case TAG_ID.NAV:
      case TAG_ID.MAIN:
      case TAG_ID.MENU:
      case TAG_ID.ASIDE:
      case TAG_ID.CENTER:
      case TAG_ID.FIGURE:
      case TAG_ID.FOOTER:
      case TAG_ID.HEADER:
      case TAG_ID.HGROUP:
      case TAG_ID.DIALOG:
      case TAG_ID.DETAILS:
      case TAG_ID.ADDRESS:
      case TAG_ID.ARTICLE:
      case TAG_ID.SEARCH:
      case TAG_ID.SECTION:
      case TAG_ID.SUMMARY:
      case TAG_ID.FIELDSET:
      case TAG_ID.BLOCKQUOTE:
      case TAG_ID.FIGCAPTION: {
        addressStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.LI:
      case TAG_ID.DD:
      case TAG_ID.DT: {
        listItemStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.BR:
      case TAG_ID.IMG:
      case TAG_ID.WBR:
      case TAG_ID.AREA:
      case TAG_ID.EMBED:
      case TAG_ID.KEYGEN: {
        areaStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.HR: {
        hrStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.RB:
      case TAG_ID.RTC: {
        rbStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.RT:
      case TAG_ID.RP: {
        rtStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.PRE:
      case TAG_ID.LISTING: {
        preStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.XMP: {
        xmpStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.SVG: {
        svgStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.HTML: {
        htmlStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.BASE:
      case TAG_ID.LINK:
      case TAG_ID.META:
      case TAG_ID.STYLE:
      case TAG_ID.TITLE:
      case TAG_ID.SCRIPT:
      case TAG_ID.BGSOUND:
      case TAG_ID.BASEFONT:
      case TAG_ID.TEMPLATE: {
        startTagInHead(p5, token);
        break;
      }
      case TAG_ID.BODY: {
        bodyStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.FORM: {
        formStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.NOBR: {
        nobrStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.MATH: {
        mathStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.TABLE: {
        tableStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.INPUT: {
        inputStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.PARAM:
      case TAG_ID.TRACK:
      case TAG_ID.SOURCE: {
        paramStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.IMAGE: {
        imageStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.BUTTON: {
        buttonStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.APPLET:
      case TAG_ID.OBJECT:
      case TAG_ID.MARQUEE: {
        appletStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.IFRAME: {
        iframeStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.SELECT: {
        selectStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.OPTION:
      case TAG_ID.OPTGROUP: {
        optgroupStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.NOEMBED:
      case TAG_ID.NOFRAMES: {
        rawTextStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.FRAMESET: {
        framesetStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.TEXTAREA: {
        textareaStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.NOSCRIPT: {
        if (p5.options.scriptingEnabled) {
          rawTextStartTagInBody(p5, token);
        } else {
          genericStartTagInBody(p5, token);
        }
        break;
      }
      case TAG_ID.PLAINTEXT: {
        plaintextStartTagInBody(p5, token);
        break;
      }
      case TAG_ID.COL:
      case TAG_ID.TH:
      case TAG_ID.TD:
      case TAG_ID.TR:
      case TAG_ID.HEAD:
      case TAG_ID.FRAME:
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD:
      case TAG_ID.CAPTION:
      case TAG_ID.COLGROUP: {
        break;
      }
      default: {
        genericStartTagInBody(p5, token);
      }
    }
  }
  function bodyEndTagInBody(p5, token) {
    if (p5.openElements.hasInScope(TAG_ID.BODY)) {
      p5.insertionMode = InsertionMode.AFTER_BODY;
      if (p5.options.sourceCodeLocationInfo) {
        const bodyElement = p5.openElements.tryPeekProperlyNestedBodyElement();
        if (bodyElement) {
          p5._setEndLocation(bodyElement, token);
        }
      }
    }
  }
  function htmlEndTagInBody(p5, token) {
    if (p5.openElements.hasInScope(TAG_ID.BODY)) {
      p5.insertionMode = InsertionMode.AFTER_BODY;
      endTagAfterBody(p5, token);
    }
  }
  function addressEndTagInBody(p5, token) {
    const tn2 = token.tagID;
    if (p5.openElements.hasInScope(tn2)) {
      p5.openElements.generateImpliedEndTags();
      p5.openElements.popUntilTagNamePopped(tn2);
    }
  }
  function formEndTagInBody(p5) {
    const inTemplate = p5.openElements.tmplCount > 0;
    const { formElement } = p5;
    if (!inTemplate) {
      p5.formElement = null;
    }
    if ((formElement || inTemplate) && p5.openElements.hasInScope(TAG_ID.FORM)) {
      p5.openElements.generateImpliedEndTags();
      if (inTemplate) {
        p5.openElements.popUntilTagNamePopped(TAG_ID.FORM);
      } else if (formElement) {
        p5.openElements.remove(formElement);
      }
    }
  }
  function pEndTagInBody(p5) {
    if (!p5.openElements.hasInButtonScope(TAG_ID.P)) {
      p5._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
    }
    p5._closePElement();
  }
  function liEndTagInBody(p5) {
    if (p5.openElements.hasInListItemScope(TAG_ID.LI)) {
      p5.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
      p5.openElements.popUntilTagNamePopped(TAG_ID.LI);
    }
  }
  function ddEndTagInBody(p5, token) {
    const tn2 = token.tagID;
    if (p5.openElements.hasInScope(tn2)) {
      p5.openElements.generateImpliedEndTagsWithExclusion(tn2);
      p5.openElements.popUntilTagNamePopped(tn2);
    }
  }
  function numberedHeaderEndTagInBody(p5) {
    if (p5.openElements.hasNumberedHeaderInScope()) {
      p5.openElements.generateImpliedEndTags();
      p5.openElements.popUntilNumberedHeaderPopped();
    }
  }
  function appletEndTagInBody(p5, token) {
    const tn2 = token.tagID;
    if (p5.openElements.hasInScope(tn2)) {
      p5.openElements.generateImpliedEndTags();
      p5.openElements.popUntilTagNamePopped(tn2);
      p5.activeFormattingElements.clearToLastMarker();
    }
  }
  function brEndTagInBody(p5) {
    p5._reconstructActiveFormattingElements();
    p5._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
    p5.openElements.pop();
    p5.framesetOk = false;
  }
  function genericEndTagInBody(p5, token) {
    const tn2 = token.tagName;
    const tid = token.tagID;
    for (let i = p5.openElements.stackTop; i > 0; i--) {
      const element7 = p5.openElements.items[i];
      const elementId = p5.openElements.tagIDs[i];
      if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p5.treeAdapter.getTagName(element7) === tn2)) {
        p5.openElements.generateImpliedEndTagsWithExclusion(tid);
        if (p5.openElements.stackTop >= i)
          p5.openElements.shortenToLength(i);
        break;
      }
      if (p5._isSpecialElement(element7, elementId)) {
        break;
      }
    }
  }
  function endTagInBody(p5, token) {
    switch (token.tagID) {
      case TAG_ID.A:
      case TAG_ID.B:
      case TAG_ID.I:
      case TAG_ID.S:
      case TAG_ID.U:
      case TAG_ID.EM:
      case TAG_ID.TT:
      case TAG_ID.BIG:
      case TAG_ID.CODE:
      case TAG_ID.FONT:
      case TAG_ID.NOBR:
      case TAG_ID.SMALL:
      case TAG_ID.STRIKE:
      case TAG_ID.STRONG: {
        callAdoptionAgency(p5, token);
        break;
      }
      case TAG_ID.P: {
        pEndTagInBody(p5);
        break;
      }
      case TAG_ID.DL:
      case TAG_ID.UL:
      case TAG_ID.OL:
      case TAG_ID.DIR:
      case TAG_ID.DIV:
      case TAG_ID.NAV:
      case TAG_ID.PRE:
      case TAG_ID.MAIN:
      case TAG_ID.MENU:
      case TAG_ID.ASIDE:
      case TAG_ID.BUTTON:
      case TAG_ID.CENTER:
      case TAG_ID.FIGURE:
      case TAG_ID.FOOTER:
      case TAG_ID.HEADER:
      case TAG_ID.HGROUP:
      case TAG_ID.DIALOG:
      case TAG_ID.ADDRESS:
      case TAG_ID.ARTICLE:
      case TAG_ID.DETAILS:
      case TAG_ID.SEARCH:
      case TAG_ID.SECTION:
      case TAG_ID.SUMMARY:
      case TAG_ID.LISTING:
      case TAG_ID.FIELDSET:
      case TAG_ID.BLOCKQUOTE:
      case TAG_ID.FIGCAPTION: {
        addressEndTagInBody(p5, token);
        break;
      }
      case TAG_ID.LI: {
        liEndTagInBody(p5);
        break;
      }
      case TAG_ID.DD:
      case TAG_ID.DT: {
        ddEndTagInBody(p5, token);
        break;
      }
      case TAG_ID.H1:
      case TAG_ID.H2:
      case TAG_ID.H3:
      case TAG_ID.H4:
      case TAG_ID.H5:
      case TAG_ID.H6: {
        numberedHeaderEndTagInBody(p5);
        break;
      }
      case TAG_ID.BR: {
        brEndTagInBody(p5);
        break;
      }
      case TAG_ID.BODY: {
        bodyEndTagInBody(p5, token);
        break;
      }
      case TAG_ID.HTML: {
        htmlEndTagInBody(p5, token);
        break;
      }
      case TAG_ID.FORM: {
        formEndTagInBody(p5);
        break;
      }
      case TAG_ID.APPLET:
      case TAG_ID.OBJECT:
      case TAG_ID.MARQUEE: {
        appletEndTagInBody(p5, token);
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p5, token);
        break;
      }
      default: {
        genericEndTagInBody(p5, token);
      }
    }
  }
  function eofInBody(p5, token) {
    if (p5.tmplInsertionModeStack.length > 0) {
      eofInTemplate(p5, token);
    } else {
      stopParsing(p5, token);
    }
  }
  function endTagInText(p5, token) {
    var _a3;
    if (token.tagID === TAG_ID.SCRIPT) {
      (_a3 = p5.scriptHandler) === null || _a3 === void 0 ? void 0 : _a3.call(p5, p5.openElements.current);
    }
    p5.openElements.pop();
    p5.insertionMode = p5.originalInsertionMode;
  }
  function eofInText(p5, token) {
    p5._err(token, ERR.eofInElementThatCanContainOnlyText);
    p5.openElements.pop();
    p5.insertionMode = p5.originalInsertionMode;
    p5.onEof(token);
  }
  function characterInTable(p5, token) {
    if (p5.openElements.currentTagId !== void 0 && TABLE_STRUCTURE_TAGS.has(p5.openElements.currentTagId)) {
      p5.pendingCharacterTokens.length = 0;
      p5.hasNonWhitespacePendingCharacterToken = false;
      p5.originalInsertionMode = p5.insertionMode;
      p5.insertionMode = InsertionMode.IN_TABLE_TEXT;
      switch (token.type) {
        case TokenType.CHARACTER: {
          characterInTableText(p5, token);
          break;
        }
        case TokenType.WHITESPACE_CHARACTER: {
          whitespaceCharacterInTableText(p5, token);
          break;
        }
      }
    } else {
      tokenInTable(p5, token);
    }
  }
  function captionStartTagInTable(p5, token) {
    p5.openElements.clearBackToTableContext();
    p5.activeFormattingElements.insertMarker();
    p5._insertElement(token, NS.HTML);
    p5.insertionMode = InsertionMode.IN_CAPTION;
  }
  function colgroupStartTagInTable(p5, token) {
    p5.openElements.clearBackToTableContext();
    p5._insertElement(token, NS.HTML);
    p5.insertionMode = InsertionMode.IN_COLUMN_GROUP;
  }
  function colStartTagInTable(p5, token) {
    p5.openElements.clearBackToTableContext();
    p5._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
    p5.insertionMode = InsertionMode.IN_COLUMN_GROUP;
    startTagInColumnGroup(p5, token);
  }
  function tbodyStartTagInTable(p5, token) {
    p5.openElements.clearBackToTableContext();
    p5._insertElement(token, NS.HTML);
    p5.insertionMode = InsertionMode.IN_TABLE_BODY;
  }
  function tdStartTagInTable(p5, token) {
    p5.openElements.clearBackToTableContext();
    p5._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
    p5.insertionMode = InsertionMode.IN_TABLE_BODY;
    startTagInTableBody(p5, token);
  }
  function tableStartTagInTable(p5, token) {
    if (p5.openElements.hasInTableScope(TAG_ID.TABLE)) {
      p5.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
      p5._resetInsertionMode();
      p5._processStartTag(token);
    }
  }
  function inputStartTagInTable(p5, token) {
    if (isHiddenInput(token)) {
      p5._appendElement(token, NS.HTML);
    } else {
      tokenInTable(p5, token);
    }
    token.ackSelfClosing = true;
  }
  function formStartTagInTable(p5, token) {
    if (!p5.formElement && p5.openElements.tmplCount === 0) {
      p5._insertElement(token, NS.HTML);
      p5.formElement = p5.openElements.current;
      p5.openElements.pop();
    }
  }
  function startTagInTable(p5, token) {
    switch (token.tagID) {
      case TAG_ID.TD:
      case TAG_ID.TH:
      case TAG_ID.TR: {
        tdStartTagInTable(p5, token);
        break;
      }
      case TAG_ID.STYLE:
      case TAG_ID.SCRIPT:
      case TAG_ID.TEMPLATE: {
        startTagInHead(p5, token);
        break;
      }
      case TAG_ID.COL: {
        colStartTagInTable(p5, token);
        break;
      }
      case TAG_ID.FORM: {
        formStartTagInTable(p5, token);
        break;
      }
      case TAG_ID.TABLE: {
        tableStartTagInTable(p5, token);
        break;
      }
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD: {
        tbodyStartTagInTable(p5, token);
        break;
      }
      case TAG_ID.INPUT: {
        inputStartTagInTable(p5, token);
        break;
      }
      case TAG_ID.CAPTION: {
        captionStartTagInTable(p5, token);
        break;
      }
      case TAG_ID.COLGROUP: {
        colgroupStartTagInTable(p5, token);
        break;
      }
      default: {
        tokenInTable(p5, token);
      }
    }
  }
  function endTagInTable(p5, token) {
    switch (token.tagID) {
      case TAG_ID.TABLE: {
        if (p5.openElements.hasInTableScope(TAG_ID.TABLE)) {
          p5.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
          p5._resetInsertionMode();
        }
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p5, token);
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.HTML:
      case TAG_ID.TBODY:
      case TAG_ID.TD:
      case TAG_ID.TFOOT:
      case TAG_ID.TH:
      case TAG_ID.THEAD:
      case TAG_ID.TR: {
        break;
      }
      default: {
        tokenInTable(p5, token);
      }
    }
  }
  function tokenInTable(p5, token) {
    const savedFosterParentingState = p5.fosterParentingEnabled;
    p5.fosterParentingEnabled = true;
    modeInBody(p5, token);
    p5.fosterParentingEnabled = savedFosterParentingState;
  }
  function whitespaceCharacterInTableText(p5, token) {
    p5.pendingCharacterTokens.push(token);
  }
  function characterInTableText(p5, token) {
    p5.pendingCharacterTokens.push(token);
    p5.hasNonWhitespacePendingCharacterToken = true;
  }
  function tokenInTableText(p5, token) {
    let i = 0;
    if (p5.hasNonWhitespacePendingCharacterToken) {
      for (; i < p5.pendingCharacterTokens.length; i++) {
        tokenInTable(p5, p5.pendingCharacterTokens[i]);
      }
    } else {
      for (; i < p5.pendingCharacterTokens.length; i++) {
        p5._insertCharacters(p5.pendingCharacterTokens[i]);
      }
    }
    p5.insertionMode = p5.originalInsertionMode;
    p5._processToken(token);
  }
  function startTagInCaption(p5, token) {
    const tn2 = token.tagID;
    if (TABLE_VOID_ELEMENTS.has(tn2)) {
      if (p5.openElements.hasInTableScope(TAG_ID.CAPTION)) {
        p5.openElements.generateImpliedEndTags();
        p5.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
        p5.activeFormattingElements.clearToLastMarker();
        p5.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p5, token);
      }
    } else {
      startTagInBody(p5, token);
    }
  }
  function endTagInCaption(p5, token) {
    const tn2 = token.tagID;
    switch (tn2) {
      case TAG_ID.CAPTION:
      case TAG_ID.TABLE: {
        if (p5.openElements.hasInTableScope(TAG_ID.CAPTION)) {
          p5.openElements.generateImpliedEndTags();
          p5.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
          p5.activeFormattingElements.clearToLastMarker();
          p5.insertionMode = InsertionMode.IN_TABLE;
          if (tn2 === TAG_ID.TABLE) {
            endTagInTable(p5, token);
          }
        }
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.HTML:
      case TAG_ID.TBODY:
      case TAG_ID.TD:
      case TAG_ID.TFOOT:
      case TAG_ID.TH:
      case TAG_ID.THEAD:
      case TAG_ID.TR: {
        break;
      }
      default: {
        endTagInBody(p5, token);
      }
    }
  }
  function startTagInColumnGroup(p5, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p5, token);
        break;
      }
      case TAG_ID.COL: {
        p5._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
        break;
      }
      case TAG_ID.TEMPLATE: {
        startTagInHead(p5, token);
        break;
      }
      default: {
        tokenInColumnGroup(p5, token);
      }
    }
  }
  function endTagInColumnGroup(p5, token) {
    switch (token.tagID) {
      case TAG_ID.COLGROUP: {
        if (p5.openElements.currentTagId === TAG_ID.COLGROUP) {
          p5.openElements.pop();
          p5.insertionMode = InsertionMode.IN_TABLE;
        }
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p5, token);
        break;
      }
      case TAG_ID.COL: {
        break;
      }
      default: {
        tokenInColumnGroup(p5, token);
      }
    }
  }
  function tokenInColumnGroup(p5, token) {
    if (p5.openElements.currentTagId === TAG_ID.COLGROUP) {
      p5.openElements.pop();
      p5.insertionMode = InsertionMode.IN_TABLE;
      p5._processToken(token);
    }
  }
  function startTagInTableBody(p5, token) {
    switch (token.tagID) {
      case TAG_ID.TR: {
        p5.openElements.clearBackToTableBodyContext();
        p5._insertElement(token, NS.HTML);
        p5.insertionMode = InsertionMode.IN_ROW;
        break;
      }
      case TAG_ID.TH:
      case TAG_ID.TD: {
        p5.openElements.clearBackToTableBodyContext();
        p5._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
        p5.insertionMode = InsertionMode.IN_ROW;
        startTagInRow(p5, token);
        break;
      }
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD: {
        if (p5.openElements.hasTableBodyContextInTableScope()) {
          p5.openElements.clearBackToTableBodyContext();
          p5.openElements.pop();
          p5.insertionMode = InsertionMode.IN_TABLE;
          startTagInTable(p5, token);
        }
        break;
      }
      default: {
        startTagInTable(p5, token);
      }
    }
  }
  function endTagInTableBody(p5, token) {
    const tn2 = token.tagID;
    switch (token.tagID) {
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD: {
        if (p5.openElements.hasInTableScope(tn2)) {
          p5.openElements.clearBackToTableBodyContext();
          p5.openElements.pop();
          p5.insertionMode = InsertionMode.IN_TABLE;
        }
        break;
      }
      case TAG_ID.TABLE: {
        if (p5.openElements.hasTableBodyContextInTableScope()) {
          p5.openElements.clearBackToTableBodyContext();
          p5.openElements.pop();
          p5.insertionMode = InsertionMode.IN_TABLE;
          endTagInTable(p5, token);
        }
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.HTML:
      case TAG_ID.TD:
      case TAG_ID.TH:
      case TAG_ID.TR: {
        break;
      }
      default: {
        endTagInTable(p5, token);
      }
    }
  }
  function startTagInRow(p5, token) {
    switch (token.tagID) {
      case TAG_ID.TH:
      case TAG_ID.TD: {
        p5.openElements.clearBackToTableRowContext();
        p5._insertElement(token, NS.HTML);
        p5.insertionMode = InsertionMode.IN_CELL;
        p5.activeFormattingElements.insertMarker();
        break;
      }
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD:
      case TAG_ID.TR: {
        if (p5.openElements.hasInTableScope(TAG_ID.TR)) {
          p5.openElements.clearBackToTableRowContext();
          p5.openElements.pop();
          p5.insertionMode = InsertionMode.IN_TABLE_BODY;
          startTagInTableBody(p5, token);
        }
        break;
      }
      default: {
        startTagInTable(p5, token);
      }
    }
  }
  function endTagInRow(p5, token) {
    switch (token.tagID) {
      case TAG_ID.TR: {
        if (p5.openElements.hasInTableScope(TAG_ID.TR)) {
          p5.openElements.clearBackToTableRowContext();
          p5.openElements.pop();
          p5.insertionMode = InsertionMode.IN_TABLE_BODY;
        }
        break;
      }
      case TAG_ID.TABLE: {
        if (p5.openElements.hasInTableScope(TAG_ID.TR)) {
          p5.openElements.clearBackToTableRowContext();
          p5.openElements.pop();
          p5.insertionMode = InsertionMode.IN_TABLE_BODY;
          endTagInTableBody(p5, token);
        }
        break;
      }
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD: {
        if (p5.openElements.hasInTableScope(token.tagID) || p5.openElements.hasInTableScope(TAG_ID.TR)) {
          p5.openElements.clearBackToTableRowContext();
          p5.openElements.pop();
          p5.insertionMode = InsertionMode.IN_TABLE_BODY;
          endTagInTableBody(p5, token);
        }
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.HTML:
      case TAG_ID.TD:
      case TAG_ID.TH: {
        break;
      }
      default: {
        endTagInTable(p5, token);
      }
    }
  }
  function startTagInCell(p5, token) {
    const tn2 = token.tagID;
    if (TABLE_VOID_ELEMENTS.has(tn2)) {
      if (p5.openElements.hasInTableScope(TAG_ID.TD) || p5.openElements.hasInTableScope(TAG_ID.TH)) {
        p5._closeTableCell();
        startTagInRow(p5, token);
      }
    } else {
      startTagInBody(p5, token);
    }
  }
  function endTagInCell(p5, token) {
    const tn2 = token.tagID;
    switch (tn2) {
      case TAG_ID.TD:
      case TAG_ID.TH: {
        if (p5.openElements.hasInTableScope(tn2)) {
          p5.openElements.generateImpliedEndTags();
          p5.openElements.popUntilTagNamePopped(tn2);
          p5.activeFormattingElements.clearToLastMarker();
          p5.insertionMode = InsertionMode.IN_ROW;
        }
        break;
      }
      case TAG_ID.TABLE:
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD:
      case TAG_ID.TR: {
        if (p5.openElements.hasInTableScope(tn2)) {
          p5._closeTableCell();
          endTagInRow(p5, token);
        }
        break;
      }
      case TAG_ID.BODY:
      case TAG_ID.CAPTION:
      case TAG_ID.COL:
      case TAG_ID.COLGROUP:
      case TAG_ID.HTML: {
        break;
      }
      default: {
        endTagInBody(p5, token);
      }
    }
  }
  function startTagInSelect(p5, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p5, token);
        break;
      }
      case TAG_ID.OPTION: {
        if (p5.openElements.currentTagId === TAG_ID.OPTION) {
          p5.openElements.pop();
        }
        p5._insertElement(token, NS.HTML);
        break;
      }
      case TAG_ID.OPTGROUP: {
        if (p5.openElements.currentTagId === TAG_ID.OPTION) {
          p5.openElements.pop();
        }
        if (p5.openElements.currentTagId === TAG_ID.OPTGROUP) {
          p5.openElements.pop();
        }
        p5._insertElement(token, NS.HTML);
        break;
      }
      case TAG_ID.HR: {
        if (p5.openElements.currentTagId === TAG_ID.OPTION) {
          p5.openElements.pop();
        }
        if (p5.openElements.currentTagId === TAG_ID.OPTGROUP) {
          p5.openElements.pop();
        }
        p5._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
        break;
      }
      case TAG_ID.INPUT:
      case TAG_ID.KEYGEN:
      case TAG_ID.TEXTAREA:
      case TAG_ID.SELECT: {
        if (p5.openElements.hasInSelectScope(TAG_ID.SELECT)) {
          p5.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
          p5._resetInsertionMode();
          if (token.tagID !== TAG_ID.SELECT) {
            p5._processStartTag(token);
          }
        }
        break;
      }
      case TAG_ID.SCRIPT:
      case TAG_ID.TEMPLATE: {
        startTagInHead(p5, token);
        break;
      }
      default:
    }
  }
  function endTagInSelect(p5, token) {
    switch (token.tagID) {
      case TAG_ID.OPTGROUP: {
        if (p5.openElements.stackTop > 0 && p5.openElements.currentTagId === TAG_ID.OPTION && p5.openElements.tagIDs[p5.openElements.stackTop - 1] === TAG_ID.OPTGROUP) {
          p5.openElements.pop();
        }
        if (p5.openElements.currentTagId === TAG_ID.OPTGROUP) {
          p5.openElements.pop();
        }
        break;
      }
      case TAG_ID.OPTION: {
        if (p5.openElements.currentTagId === TAG_ID.OPTION) {
          p5.openElements.pop();
        }
        break;
      }
      case TAG_ID.SELECT: {
        if (p5.openElements.hasInSelectScope(TAG_ID.SELECT)) {
          p5.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
          p5._resetInsertionMode();
        }
        break;
      }
      case TAG_ID.TEMPLATE: {
        templateEndTagInHead(p5, token);
        break;
      }
      default:
    }
  }
  function startTagInSelectInTable(p5, token) {
    const tn2 = token.tagID;
    if (tn2 === TAG_ID.CAPTION || tn2 === TAG_ID.TABLE || tn2 === TAG_ID.TBODY || tn2 === TAG_ID.TFOOT || tn2 === TAG_ID.THEAD || tn2 === TAG_ID.TR || tn2 === TAG_ID.TD || tn2 === TAG_ID.TH) {
      p5.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
      p5._resetInsertionMode();
      p5._processStartTag(token);
    } else {
      startTagInSelect(p5, token);
    }
  }
  function endTagInSelectInTable(p5, token) {
    const tn2 = token.tagID;
    if (tn2 === TAG_ID.CAPTION || tn2 === TAG_ID.TABLE || tn2 === TAG_ID.TBODY || tn2 === TAG_ID.TFOOT || tn2 === TAG_ID.THEAD || tn2 === TAG_ID.TR || tn2 === TAG_ID.TD || tn2 === TAG_ID.TH) {
      if (p5.openElements.hasInTableScope(tn2)) {
        p5.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
        p5._resetInsertionMode();
        p5.onEndTag(token);
      }
    } else {
      endTagInSelect(p5, token);
    }
  }
  function startTagInTemplate(p5, token) {
    switch (token.tagID) {
      // First, handle tags that can start without a mode change
      case TAG_ID.BASE:
      case TAG_ID.BASEFONT:
      case TAG_ID.BGSOUND:
      case TAG_ID.LINK:
      case TAG_ID.META:
      case TAG_ID.NOFRAMES:
      case TAG_ID.SCRIPT:
      case TAG_ID.STYLE:
      case TAG_ID.TEMPLATE:
      case TAG_ID.TITLE: {
        startTagInHead(p5, token);
        break;
      }
      // Re-process the token in the appropriate mode
      case TAG_ID.CAPTION:
      case TAG_ID.COLGROUP:
      case TAG_ID.TBODY:
      case TAG_ID.TFOOT:
      case TAG_ID.THEAD: {
        p5.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
        p5.insertionMode = InsertionMode.IN_TABLE;
        startTagInTable(p5, token);
        break;
      }
      case TAG_ID.COL: {
        p5.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
        p5.insertionMode = InsertionMode.IN_COLUMN_GROUP;
        startTagInColumnGroup(p5, token);
        break;
      }
      case TAG_ID.TR: {
        p5.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
        p5.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p5, token);
        break;
      }
      case TAG_ID.TD:
      case TAG_ID.TH: {
        p5.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
        p5.insertionMode = InsertionMode.IN_ROW;
        startTagInRow(p5, token);
        break;
      }
      default: {
        p5.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
        p5.insertionMode = InsertionMode.IN_BODY;
        startTagInBody(p5, token);
      }
    }
  }
  function endTagInTemplate(p5, token) {
    if (token.tagID === TAG_ID.TEMPLATE) {
      templateEndTagInHead(p5, token);
    }
  }
  function eofInTemplate(p5, token) {
    if (p5.openElements.tmplCount > 0) {
      p5.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
      p5.activeFormattingElements.clearToLastMarker();
      p5.tmplInsertionModeStack.shift();
      p5._resetInsertionMode();
      p5.onEof(token);
    } else {
      stopParsing(p5, token);
    }
  }
  function startTagAfterBody(p5, token) {
    if (token.tagID === TAG_ID.HTML) {
      startTagInBody(p5, token);
    } else {
      tokenAfterBody(p5, token);
    }
  }
  function endTagAfterBody(p5, token) {
    var _a3;
    if (token.tagID === TAG_ID.HTML) {
      if (!p5.fragmentContext) {
        p5.insertionMode = InsertionMode.AFTER_AFTER_BODY;
      }
      if (p5.options.sourceCodeLocationInfo && p5.openElements.tagIDs[0] === TAG_ID.HTML) {
        p5._setEndLocation(p5.openElements.items[0], token);
        const bodyElement = p5.openElements.items[1];
        if (bodyElement && !((_a3 = p5.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a3 === void 0 ? void 0 : _a3.endTag)) {
          p5._setEndLocation(bodyElement, token);
        }
      }
    } else {
      tokenAfterBody(p5, token);
    }
  }
  function tokenAfterBody(p5, token) {
    p5.insertionMode = InsertionMode.IN_BODY;
    modeInBody(p5, token);
  }
  function startTagInFrameset(p5, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p5, token);
        break;
      }
      case TAG_ID.FRAMESET: {
        p5._insertElement(token, NS.HTML);
        break;
      }
      case TAG_ID.FRAME: {
        p5._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
        break;
      }
      case TAG_ID.NOFRAMES: {
        startTagInHead(p5, token);
        break;
      }
      default:
    }
  }
  function endTagInFrameset(p5, token) {
    if (token.tagID === TAG_ID.FRAMESET && !p5.openElements.isRootHtmlElementCurrent()) {
      p5.openElements.pop();
      if (!p5.fragmentContext && p5.openElements.currentTagId !== TAG_ID.FRAMESET) {
        p5.insertionMode = InsertionMode.AFTER_FRAMESET;
      }
    }
  }
  function startTagAfterFrameset(p5, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p5, token);
        break;
      }
      case TAG_ID.NOFRAMES: {
        startTagInHead(p5, token);
        break;
      }
      default:
    }
  }
  function endTagAfterFrameset(p5, token) {
    if (token.tagID === TAG_ID.HTML) {
      p5.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
    }
  }
  function startTagAfterAfterBody(p5, token) {
    if (token.tagID === TAG_ID.HTML) {
      startTagInBody(p5, token);
    } else {
      tokenAfterAfterBody(p5, token);
    }
  }
  function tokenAfterAfterBody(p5, token) {
    p5.insertionMode = InsertionMode.IN_BODY;
    modeInBody(p5, token);
  }
  function startTagAfterAfterFrameset(p5, token) {
    switch (token.tagID) {
      case TAG_ID.HTML: {
        startTagInBody(p5, token);
        break;
      }
      case TAG_ID.NOFRAMES: {
        startTagInHead(p5, token);
        break;
      }
      default:
    }
  }
  function nullCharacterInForeignContent(p5, token) {
    token.chars = REPLACEMENT_CHARACTER;
    p5._insertCharacters(token);
  }
  function characterInForeignContent(p5, token) {
    p5._insertCharacters(token);
    p5.framesetOk = false;
  }
  function popUntilHtmlOrIntegrationPoint(p5) {
    while (p5.treeAdapter.getNamespaceURI(p5.openElements.current) !== NS.HTML && p5.openElements.currentTagId !== void 0 && !p5._isIntegrationPoint(p5.openElements.currentTagId, p5.openElements.current)) {
      p5.openElements.pop();
    }
  }
  function startTagInForeignContent(p5, token) {
    if (causesExit(token)) {
      popUntilHtmlOrIntegrationPoint(p5);
      p5._startTagOutsideForeignContent(token);
    } else {
      const current = p5._getAdjustedCurrentElement();
      const currentNs = p5.treeAdapter.getNamespaceURI(current);
      if (currentNs === NS.MATHML) {
        adjustTokenMathMLAttrs(token);
      } else if (currentNs === NS.SVG) {
        adjustTokenSVGTagName(token);
        adjustTokenSVGAttrs(token);
      }
      adjustTokenXMLAttrs(token);
      if (token.selfClosing) {
        p5._appendElement(token, currentNs);
      } else {
        p5._insertElement(token, currentNs);
      }
      token.ackSelfClosing = true;
    }
  }
  function endTagInForeignContent(p5, token) {
    if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
      popUntilHtmlOrIntegrationPoint(p5);
      p5._endTagOutsideForeignContent(token);
      return;
    }
    for (let i = p5.openElements.stackTop; i > 0; i--) {
      const element7 = p5.openElements.items[i];
      if (p5.treeAdapter.getNamespaceURI(element7) === NS.HTML) {
        p5._endTagOutsideForeignContent(token);
        break;
      }
      const tagName = p5.treeAdapter.getTagName(element7);
      if (tagName.toLowerCase() === token.tagName) {
        token.tagName = tagName;
        p5.openElements.shortenToLength(i);
        break;
      }
    }
  }
  var HIDDEN_INPUT_TYPE, AA_OUTER_LOOP_ITER, AA_INNER_LOOP_ITER, InsertionMode, BASE_LOC, TABLE_STRUCTURE_TAGS, defaultParserOptions, Parser, TABLE_VOID_ELEMENTS;
  var init_parser = __esm({
    "node_modules/parse5/dist/parser/index.js"() {
      init_tokenizer();
      init_open_element_stack();
      init_formatting_element_list();
      init_default2();
      init_doctype();
      init_foreign_content();
      init_error_codes();
      init_unicode();
      init_html2();
      init_token();
      HIDDEN_INPUT_TYPE = "hidden";
      AA_OUTER_LOOP_ITER = 8;
      AA_INNER_LOOP_ITER = 3;
      (function(InsertionMode2) {
        InsertionMode2[InsertionMode2["INITIAL"] = 0] = "INITIAL";
        InsertionMode2[InsertionMode2["BEFORE_HTML"] = 1] = "BEFORE_HTML";
        InsertionMode2[InsertionMode2["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
        InsertionMode2[InsertionMode2["IN_HEAD"] = 3] = "IN_HEAD";
        InsertionMode2[InsertionMode2["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
        InsertionMode2[InsertionMode2["AFTER_HEAD"] = 5] = "AFTER_HEAD";
        InsertionMode2[InsertionMode2["IN_BODY"] = 6] = "IN_BODY";
        InsertionMode2[InsertionMode2["TEXT"] = 7] = "TEXT";
        InsertionMode2[InsertionMode2["IN_TABLE"] = 8] = "IN_TABLE";
        InsertionMode2[InsertionMode2["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
        InsertionMode2[InsertionMode2["IN_CAPTION"] = 10] = "IN_CAPTION";
        InsertionMode2[InsertionMode2["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
        InsertionMode2[InsertionMode2["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
        InsertionMode2[InsertionMode2["IN_ROW"] = 13] = "IN_ROW";
        InsertionMode2[InsertionMode2["IN_CELL"] = 14] = "IN_CELL";
        InsertionMode2[InsertionMode2["IN_SELECT"] = 15] = "IN_SELECT";
        InsertionMode2[InsertionMode2["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
        InsertionMode2[InsertionMode2["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
        InsertionMode2[InsertionMode2["AFTER_BODY"] = 18] = "AFTER_BODY";
        InsertionMode2[InsertionMode2["IN_FRAMESET"] = 19] = "IN_FRAMESET";
        InsertionMode2[InsertionMode2["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
        InsertionMode2[InsertionMode2["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
        InsertionMode2[InsertionMode2["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
      })(InsertionMode || (InsertionMode = {}));
      BASE_LOC = {
        startLine: -1,
        startCol: -1,
        startOffset: -1,
        endLine: -1,
        endCol: -1,
        endOffset: -1
      };
      TABLE_STRUCTURE_TAGS = /* @__PURE__ */ new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
      defaultParserOptions = {
        scriptingEnabled: true,
        sourceCodeLocationInfo: false,
        treeAdapter: defaultTreeAdapter,
        onParseError: null
      };
      Parser = class {
        constructor(options2, document4, fragmentContext = null, scriptHandler = null) {
          this.fragmentContext = fragmentContext;
          this.scriptHandler = scriptHandler;
          this.currentToken = null;
          this.stopped = false;
          this.insertionMode = InsertionMode.INITIAL;
          this.originalInsertionMode = InsertionMode.INITIAL;
          this.headElement = null;
          this.formElement = null;
          this.currentNotInHTML = false;
          this.tmplInsertionModeStack = [];
          this.pendingCharacterTokens = [];
          this.hasNonWhitespacePendingCharacterToken = false;
          this.framesetOk = true;
          this.skipNextNewLine = false;
          this.fosterParentingEnabled = false;
          this.options = {
            ...defaultParserOptions,
            ...options2
          };
          this.treeAdapter = this.options.treeAdapter;
          this.onParseError = this.options.onParseError;
          if (this.onParseError) {
            this.options.sourceCodeLocationInfo = true;
          }
          this.document = document4 !== null && document4 !== void 0 ? document4 : this.treeAdapter.createDocument();
          this.tokenizer = new Tokenizer(this.options, this);
          this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
          this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
          this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
          this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
        }
        // API
        static parse(html7, options2) {
          const parser = new this(options2);
          parser.tokenizer.write(html7, true);
          return parser.document;
        }
        static getFragmentParser(fragmentContext, options2) {
          const opts = {
            ...defaultParserOptions,
            ...options2
          };
          fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []);
          const documentMock = opts.treeAdapter.createElement("documentmock", NS.HTML, []);
          const parser = new this(opts, documentMock, fragmentContext);
          if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
            parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
          }
          parser._initTokenizerForFragmentParsing();
          parser._insertFakeRootElement();
          parser._resetInsertionMode();
          parser._findFormInFragmentContext();
          return parser;
        }
        getFragment() {
          const rootElement = this.treeAdapter.getFirstChild(this.document);
          const fragment2 = this.treeAdapter.createDocumentFragment();
          this._adoptNodes(rootElement, fragment2);
          return fragment2;
        }
        //Errors
        /** @internal */
        _err(token, code5, beforeToken) {
          var _a3;
          if (!this.onParseError)
            return;
          const loc = (_a3 = token.location) !== null && _a3 !== void 0 ? _a3 : BASE_LOC;
          const err = {
            code: code5,
            startLine: loc.startLine,
            startCol: loc.startCol,
            startOffset: loc.startOffset,
            endLine: beforeToken ? loc.startLine : loc.endLine,
            endCol: beforeToken ? loc.startCol : loc.endCol,
            endOffset: beforeToken ? loc.startOffset : loc.endOffset
          };
          this.onParseError(err);
        }
        //Stack events
        /** @internal */
        onItemPush(node2, tid, isTop) {
          var _a3, _b;
          (_b = (_a3 = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a3, node2);
          if (isTop && this.openElements.stackTop > 0)
            this._setContextModes(node2, tid);
        }
        /** @internal */
        onItemPop(node2, isTop) {
          var _a3, _b;
          if (this.options.sourceCodeLocationInfo) {
            this._setEndLocation(node2, this.currentToken);
          }
          (_b = (_a3 = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a3, node2, this.openElements.current);
          if (isTop) {
            let current;
            let currentTagId;
            if (this.openElements.stackTop === 0 && this.fragmentContext) {
              current = this.fragmentContext;
              currentTagId = this.fragmentContextID;
            } else {
              ({ current, currentTagId } = this.openElements);
            }
            this._setContextModes(current, currentTagId);
          }
        }
        _setContextModes(current, tid) {
          const isHTML = current === this.document || current && this.treeAdapter.getNamespaceURI(current) === NS.HTML;
          this.currentNotInHTML = !isHTML;
          this.tokenizer.inForeignNode = !isHTML && current !== void 0 && tid !== void 0 && !this._isIntegrationPoint(tid, current);
        }
        /** @protected */
        _switchToTextParsing(currentToken, nextTokenizerState) {
          this._insertElement(currentToken, NS.HTML);
          this.tokenizer.state = nextTokenizerState;
          this.originalInsertionMode = this.insertionMode;
          this.insertionMode = InsertionMode.TEXT;
        }
        switchToPlaintextParsing() {
          this.insertionMode = InsertionMode.TEXT;
          this.originalInsertionMode = InsertionMode.IN_BODY;
          this.tokenizer.state = TokenizerMode.PLAINTEXT;
        }
        //Fragment parsing
        /** @protected */
        _getAdjustedCurrentElement() {
          return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
        }
        /** @protected */
        _findFormInFragmentContext() {
          let node2 = this.fragmentContext;
          while (node2) {
            if (this.treeAdapter.getTagName(node2) === TAG_NAMES.FORM) {
              this.formElement = node2;
              break;
            }
            node2 = this.treeAdapter.getParentNode(node2);
          }
        }
        _initTokenizerForFragmentParsing() {
          if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) {
            return;
          }
          switch (this.fragmentContextID) {
            case TAG_ID.TITLE:
            case TAG_ID.TEXTAREA: {
              this.tokenizer.state = TokenizerMode.RCDATA;
              break;
            }
            case TAG_ID.STYLE:
            case TAG_ID.XMP:
            case TAG_ID.IFRAME:
            case TAG_ID.NOEMBED:
            case TAG_ID.NOFRAMES:
            case TAG_ID.NOSCRIPT: {
              this.tokenizer.state = TokenizerMode.RAWTEXT;
              break;
            }
            case TAG_ID.SCRIPT: {
              this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
              break;
            }
            case TAG_ID.PLAINTEXT: {
              this.tokenizer.state = TokenizerMode.PLAINTEXT;
              break;
            }
            default:
          }
        }
        //Tree mutation
        /** @protected */
        _setDocumentType(token) {
          const name = token.name || "";
          const publicId = token.publicId || "";
          const systemId = token.systemId || "";
          this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
          if (token.location) {
            const documentChildren = this.treeAdapter.getChildNodes(this.document);
            const docTypeNode = documentChildren.find((node2) => this.treeAdapter.isDocumentTypeNode(node2));
            if (docTypeNode) {
              this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
            }
          }
        }
        /** @protected */
        _attachElementToTree(element7, location3) {
          if (this.options.sourceCodeLocationInfo) {
            const loc = location3 && {
              ...location3,
              startTag: location3
            };
            this.treeAdapter.setNodeSourceCodeLocation(element7, loc);
          }
          if (this._shouldFosterParentOnInsertion()) {
            this._fosterParentElement(element7);
          } else {
            const parent = this.openElements.currentTmplContentOrNode;
            this.treeAdapter.appendChild(parent !== null && parent !== void 0 ? parent : this.document, element7);
          }
        }
        /**
         * For self-closing tags. Add an element to the tree, but skip adding it
         * to the stack.
         */
        /** @protected */
        _appendElement(token, namespaceURI) {
          const element7 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
          this._attachElementToTree(element7, token.location);
        }
        /** @protected */
        _insertElement(token, namespaceURI) {
          const element7 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
          this._attachElementToTree(element7, token.location);
          this.openElements.push(element7, token.tagID);
        }
        /** @protected */
        _insertFakeElement(tagName, tagID) {
          const element7 = this.treeAdapter.createElement(tagName, NS.HTML, []);
          this._attachElementToTree(element7, null);
          this.openElements.push(element7, tagID);
        }
        /** @protected */
        _insertTemplate(token) {
          const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
          const content5 = this.treeAdapter.createDocumentFragment();
          this.treeAdapter.setTemplateContent(tmpl, content5);
          this._attachElementToTree(tmpl, token.location);
          this.openElements.push(tmpl, token.tagID);
          if (this.options.sourceCodeLocationInfo)
            this.treeAdapter.setNodeSourceCodeLocation(content5, null);
        }
        /** @protected */
        _insertFakeRootElement() {
          const element7 = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
          if (this.options.sourceCodeLocationInfo)
            this.treeAdapter.setNodeSourceCodeLocation(element7, null);
          this.treeAdapter.appendChild(this.openElements.current, element7);
          this.openElements.push(element7, TAG_ID.HTML);
        }
        /** @protected */
        _appendCommentNode(token, parent) {
          const commentNode = this.treeAdapter.createCommentNode(token.data);
          this.treeAdapter.appendChild(parent, commentNode);
          if (this.options.sourceCodeLocationInfo) {
            this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
          }
        }
        /** @protected */
        _insertCharacters(token) {
          let parent;
          let beforeElement;
          if (this._shouldFosterParentOnInsertion()) {
            ({ parent, beforeElement } = this._findFosterParentingLocation());
            if (beforeElement) {
              this.treeAdapter.insertTextBefore(parent, token.chars, beforeElement);
            } else {
              this.treeAdapter.insertText(parent, token.chars);
            }
          } else {
            parent = this.openElements.currentTmplContentOrNode;
            this.treeAdapter.insertText(parent, token.chars);
          }
          if (!token.location)
            return;
          const siblings2 = this.treeAdapter.getChildNodes(parent);
          const textNodeIdx = beforeElement ? siblings2.lastIndexOf(beforeElement) : siblings2.length;
          const textNode = siblings2[textNodeIdx - 1];
          const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
          if (tnLoc) {
            const { endLine, endCol, endOffset } = token.location;
            this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
          } else if (this.options.sourceCodeLocationInfo) {
            this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
          }
        }
        /** @protected */
        _adoptNodes(donor, recipient) {
          for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
            this.treeAdapter.detachNode(child);
            this.treeAdapter.appendChild(recipient, child);
          }
        }
        /** @protected */
        _setEndLocation(element7, closingToken) {
          if (this.treeAdapter.getNodeSourceCodeLocation(element7) && closingToken.location) {
            const ctLoc = closingToken.location;
            const tn2 = this.treeAdapter.getTagName(element7);
            const endLoc = (
              // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
              // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
              closingToken.type === TokenType.END_TAG && tn2 === closingToken.tagName ? {
                endTag: { ...ctLoc },
                endLine: ctLoc.endLine,
                endCol: ctLoc.endCol,
                endOffset: ctLoc.endOffset
              } : {
                endLine: ctLoc.startLine,
                endCol: ctLoc.startCol,
                endOffset: ctLoc.startOffset
              }
            );
            this.treeAdapter.updateNodeSourceCodeLocation(element7, endLoc);
          }
        }
        //Token processing
        shouldProcessStartTagTokenInForeignContent(token) {
          if (!this.currentNotInHTML)
            return false;
          let current;
          let currentTagId;
          if (this.openElements.stackTop === 0 && this.fragmentContext) {
            current = this.fragmentContext;
            currentTagId = this.fragmentContextID;
          } else {
            ({ current, currentTagId } = this.openElements);
          }
          if (token.tagID === TAG_ID.SVG && this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(current) === NS.MATHML) {
            return false;
          }
          return (
            // Check that `current` is not an integration point for HTML or MathML elements.
            this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
            // integration point.
            (token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) && currentTagId !== void 0 && !this._isIntegrationPoint(currentTagId, current, NS.HTML)
          );
        }
        /** @protected */
        _processToken(token) {
          switch (token.type) {
            case TokenType.CHARACTER: {
              this.onCharacter(token);
              break;
            }
            case TokenType.NULL_CHARACTER: {
              this.onNullCharacter(token);
              break;
            }
            case TokenType.COMMENT: {
              this.onComment(token);
              break;
            }
            case TokenType.DOCTYPE: {
              this.onDoctype(token);
              break;
            }
            case TokenType.START_TAG: {
              this._processStartTag(token);
              break;
            }
            case TokenType.END_TAG: {
              this.onEndTag(token);
              break;
            }
            case TokenType.EOF: {
              this.onEof(token);
              break;
            }
            case TokenType.WHITESPACE_CHARACTER: {
              this.onWhitespaceCharacter(token);
              break;
            }
          }
        }
        //Integration points
        /** @protected */
        _isIntegrationPoint(tid, element7, foreignNS) {
          const ns2 = this.treeAdapter.getNamespaceURI(element7);
          const attrs = this.treeAdapter.getAttrList(element7);
          return isIntegrationPoint(tid, ns2, attrs, foreignNS);
        }
        //Active formatting elements reconstruction
        /** @protected */
        _reconstructActiveFormattingElements() {
          const listLength = this.activeFormattingElements.entries.length;
          if (listLength) {
            const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
            const unopenIdx = endIndex === -1 ? listLength - 1 : endIndex - 1;
            for (let i = unopenIdx; i >= 0; i--) {
              const entry = this.activeFormattingElements.entries[i];
              this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
              entry.element = this.openElements.current;
            }
          }
        }
        //Close elements
        /** @protected */
        _closeTableCell() {
          this.openElements.generateImpliedEndTags();
          this.openElements.popUntilTableCellPopped();
          this.activeFormattingElements.clearToLastMarker();
          this.insertionMode = InsertionMode.IN_ROW;
        }
        /** @protected */
        _closePElement() {
          this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
          this.openElements.popUntilTagNamePopped(TAG_ID.P);
        }
        //Insertion modes
        /** @protected */
        _resetInsertionMode() {
          for (let i = this.openElements.stackTop; i >= 0; i--) {
            switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
              case TAG_ID.TR: {
                this.insertionMode = InsertionMode.IN_ROW;
                return;
              }
              case TAG_ID.TBODY:
              case TAG_ID.THEAD:
              case TAG_ID.TFOOT: {
                this.insertionMode = InsertionMode.IN_TABLE_BODY;
                return;
              }
              case TAG_ID.CAPTION: {
                this.insertionMode = InsertionMode.IN_CAPTION;
                return;
              }
              case TAG_ID.COLGROUP: {
                this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
                return;
              }
              case TAG_ID.TABLE: {
                this.insertionMode = InsertionMode.IN_TABLE;
                return;
              }
              case TAG_ID.BODY: {
                this.insertionMode = InsertionMode.IN_BODY;
                return;
              }
              case TAG_ID.FRAMESET: {
                this.insertionMode = InsertionMode.IN_FRAMESET;
                return;
              }
              case TAG_ID.SELECT: {
                this._resetInsertionModeForSelect(i);
                return;
              }
              case TAG_ID.TEMPLATE: {
                this.insertionMode = this.tmplInsertionModeStack[0];
                return;
              }
              case TAG_ID.HTML: {
                this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
                return;
              }
              case TAG_ID.TD:
              case TAG_ID.TH: {
                if (i > 0) {
                  this.insertionMode = InsertionMode.IN_CELL;
                  return;
                }
                break;
              }
              case TAG_ID.HEAD: {
                if (i > 0) {
                  this.insertionMode = InsertionMode.IN_HEAD;
                  return;
                }
                break;
              }
            }
          }
          this.insertionMode = InsertionMode.IN_BODY;
        }
        /** @protected */
        _resetInsertionModeForSelect(selectIdx) {
          if (selectIdx > 0) {
            for (let i = selectIdx - 1; i > 0; i--) {
              const tn2 = this.openElements.tagIDs[i];
              if (tn2 === TAG_ID.TEMPLATE) {
                break;
              } else if (tn2 === TAG_ID.TABLE) {
                this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
                return;
              }
            }
          }
          this.insertionMode = InsertionMode.IN_SELECT;
        }
        //Foster parenting
        /** @protected */
        _isElementCausesFosterParenting(tn2) {
          return TABLE_STRUCTURE_TAGS.has(tn2);
        }
        /** @protected */
        _shouldFosterParentOnInsertion() {
          return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId);
        }
        /** @protected */
        _findFosterParentingLocation() {
          for (let i = this.openElements.stackTop; i >= 0; i--) {
            const openElement = this.openElements.items[i];
            switch (this.openElements.tagIDs[i]) {
              case TAG_ID.TEMPLATE: {
                if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
                  return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
                }
                break;
              }
              case TAG_ID.TABLE: {
                const parent = this.treeAdapter.getParentNode(openElement);
                if (parent) {
                  return { parent, beforeElement: openElement };
                }
                return { parent: this.openElements.items[i - 1], beforeElement: null };
              }
              default:
            }
          }
          return { parent: this.openElements.items[0], beforeElement: null };
        }
        /** @protected */
        _fosterParentElement(element7) {
          const location3 = this._findFosterParentingLocation();
          if (location3.beforeElement) {
            this.treeAdapter.insertBefore(location3.parent, element7, location3.beforeElement);
          } else {
            this.treeAdapter.appendChild(location3.parent, element7);
          }
        }
        //Special elements
        /** @protected */
        _isSpecialElement(element7, id2) {
          const ns2 = this.treeAdapter.getNamespaceURI(element7);
          return SPECIAL_ELEMENTS[ns2].has(id2);
        }
        /** @internal */
        onCharacter(token) {
          this.skipNextNewLine = false;
          if (this.tokenizer.inForeignNode) {
            characterInForeignContent(this, token);
            return;
          }
          switch (this.insertionMode) {
            case InsertionMode.INITIAL: {
              tokenInInitialMode(this, token);
              break;
            }
            case InsertionMode.BEFORE_HTML: {
              tokenBeforeHtml(this, token);
              break;
            }
            case InsertionMode.BEFORE_HEAD: {
              tokenBeforeHead(this, token);
              break;
            }
            case InsertionMode.IN_HEAD: {
              tokenInHead(this, token);
              break;
            }
            case InsertionMode.IN_HEAD_NO_SCRIPT: {
              tokenInHeadNoScript(this, token);
              break;
            }
            case InsertionMode.AFTER_HEAD: {
              tokenAfterHead(this, token);
              break;
            }
            case InsertionMode.IN_BODY:
            case InsertionMode.IN_CAPTION:
            case InsertionMode.IN_CELL:
            case InsertionMode.IN_TEMPLATE: {
              characterInBody(this, token);
              break;
            }
            case InsertionMode.TEXT:
            case InsertionMode.IN_SELECT:
            case InsertionMode.IN_SELECT_IN_TABLE: {
              this._insertCharacters(token);
              break;
            }
            case InsertionMode.IN_TABLE:
            case InsertionMode.IN_TABLE_BODY:
            case InsertionMode.IN_ROW: {
              characterInTable(this, token);
              break;
            }
            case InsertionMode.IN_TABLE_TEXT: {
              characterInTableText(this, token);
              break;
            }
            case InsertionMode.IN_COLUMN_GROUP: {
              tokenInColumnGroup(this, token);
              break;
            }
            case InsertionMode.AFTER_BODY: {
              tokenAfterBody(this, token);
              break;
            }
            case InsertionMode.AFTER_AFTER_BODY: {
              tokenAfterAfterBody(this, token);
              break;
            }
            default:
          }
        }
        /** @internal */
        onNullCharacter(token) {
          this.skipNextNewLine = false;
          if (this.tokenizer.inForeignNode) {
            nullCharacterInForeignContent(this, token);
            return;
          }
          switch (this.insertionMode) {
            case InsertionMode.INITIAL: {
              tokenInInitialMode(this, token);
              break;
            }
            case InsertionMode.BEFORE_HTML: {
              tokenBeforeHtml(this, token);
              break;
            }
            case InsertionMode.BEFORE_HEAD: {
              tokenBeforeHead(this, token);
              break;
            }
            case InsertionMode.IN_HEAD: {
              tokenInHead(this, token);
              break;
            }
            case InsertionMode.IN_HEAD_NO_SCRIPT: {
              tokenInHeadNoScript(this, token);
              break;
            }
            case InsertionMode.AFTER_HEAD: {
              tokenAfterHead(this, token);
              break;
            }
            case InsertionMode.TEXT: {
              this._insertCharacters(token);
              break;
            }
            case InsertionMode.IN_TABLE:
            case InsertionMode.IN_TABLE_BODY:
            case InsertionMode.IN_ROW: {
              characterInTable(this, token);
              break;
            }
            case InsertionMode.IN_COLUMN_GROUP: {
              tokenInColumnGroup(this, token);
              break;
            }
            case InsertionMode.AFTER_BODY: {
              tokenAfterBody(this, token);
              break;
            }
            case InsertionMode.AFTER_AFTER_BODY: {
              tokenAfterAfterBody(this, token);
              break;
            }
            default:
          }
        }
        /** @internal */
        onComment(token) {
          this.skipNextNewLine = false;
          if (this.currentNotInHTML) {
            appendComment(this, token);
            return;
          }
          switch (this.insertionMode) {
            case InsertionMode.INITIAL:
            case InsertionMode.BEFORE_HTML:
            case InsertionMode.BEFORE_HEAD:
            case InsertionMode.IN_HEAD:
            case InsertionMode.IN_HEAD_NO_SCRIPT:
            case InsertionMode.AFTER_HEAD:
            case InsertionMode.IN_BODY:
            case InsertionMode.IN_TABLE:
            case InsertionMode.IN_CAPTION:
            case InsertionMode.IN_COLUMN_GROUP:
            case InsertionMode.IN_TABLE_BODY:
            case InsertionMode.IN_ROW:
            case InsertionMode.IN_CELL:
            case InsertionMode.IN_SELECT:
            case InsertionMode.IN_SELECT_IN_TABLE:
            case InsertionMode.IN_TEMPLATE:
            case InsertionMode.IN_FRAMESET:
            case InsertionMode.AFTER_FRAMESET: {
              appendComment(this, token);
              break;
            }
            case InsertionMode.IN_TABLE_TEXT: {
              tokenInTableText(this, token);
              break;
            }
            case InsertionMode.AFTER_BODY: {
              appendCommentToRootHtmlElement(this, token);
              break;
            }
            case InsertionMode.AFTER_AFTER_BODY:
            case InsertionMode.AFTER_AFTER_FRAMESET: {
              appendCommentToDocument(this, token);
              break;
            }
            default:
          }
        }
        /** @internal */
        onDoctype(token) {
          this.skipNextNewLine = false;
          switch (this.insertionMode) {
            case InsertionMode.INITIAL: {
              doctypeInInitialMode(this, token);
              break;
            }
            case InsertionMode.BEFORE_HEAD:
            case InsertionMode.IN_HEAD:
            case InsertionMode.IN_HEAD_NO_SCRIPT:
            case InsertionMode.AFTER_HEAD: {
              this._err(token, ERR.misplacedDoctype);
              break;
            }
            case InsertionMode.IN_TABLE_TEXT: {
              tokenInTableText(this, token);
              break;
            }
            default:
          }
        }
        /** @internal */
        onStartTag(token) {
          this.skipNextNewLine = false;
          this.currentToken = token;
          this._processStartTag(token);
          if (token.selfClosing && !token.ackSelfClosing) {
            this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
          }
        }
        /**
         * Processes a given start tag.
         *
         * `onStartTag` checks if a self-closing tag was recognized. When a token
         * is moved inbetween multiple insertion modes, this check for self-closing
         * could lead to false positives. To avoid this, `_processStartTag` is used
         * for nested calls.
         *
         * @param token The token to process.
         * @protected
         */
        _processStartTag(token) {
          if (this.shouldProcessStartTagTokenInForeignContent(token)) {
            startTagInForeignContent(this, token);
          } else {
            this._startTagOutsideForeignContent(token);
          }
        }
        /** @protected */
        _startTagOutsideForeignContent(token) {
          switch (this.insertionMode) {
            case InsertionMode.INITIAL: {
              tokenInInitialMode(this, token);
              break;
            }
            case InsertionMode.BEFORE_HTML: {
              startTagBeforeHtml(this, token);
              break;
            }
            case InsertionMode.BEFORE_HEAD: {
              startTagBeforeHead(this, token);
              break;
            }
            case InsertionMode.IN_HEAD: {
              startTagInHead(this, token);
              break;
            }
            case InsertionMode.IN_HEAD_NO_SCRIPT: {
              startTagInHeadNoScript(this, token);
              break;
            }
            case InsertionMode.AFTER_HEAD: {
              startTagAfterHead(this, token);
              break;
            }
            case InsertionMode.IN_BODY: {
              startTagInBody(this, token);
              break;
            }
            case InsertionMode.IN_TABLE: {
              startTagInTable(this, token);
              break;
            }
            case InsertionMode.IN_TABLE_TEXT: {
              tokenInTableText(this, token);
              break;
            }
            case InsertionMode.IN_CAPTION: {
              startTagInCaption(this, token);
              break;
            }
            case InsertionMode.IN_COLUMN_GROUP: {
              startTagInColumnGroup(this, token);
              break;
            }
            case InsertionMode.IN_TABLE_BODY: {
              startTagInTableBody(this, token);
              break;
            }
            case InsertionMode.IN_ROW: {
              startTagInRow(this, token);
              break;
            }
            case InsertionMode.IN_CELL: {
              startTagInCell(this, token);
              break;
            }
            case InsertionMode.IN_SELECT: {
              startTagInSelect(this, token);
              break;
            }
            case InsertionMode.IN_SELECT_IN_TABLE: {
              startTagInSelectInTable(this, token);
              break;
            }
            case InsertionMode.IN_TEMPLATE: {
              startTagInTemplate(this, token);
              break;
            }
            case InsertionMode.AFTER_BODY: {
              startTagAfterBody(this, token);
              break;
            }
            case InsertionMode.IN_FRAMESET: {
              startTagInFrameset(this, token);
              break;
            }
            case InsertionMode.AFTER_FRAMESET: {
              startTagAfterFrameset(this, token);
              break;
            }
            case InsertionMode.AFTER_AFTER_BODY: {
              startTagAfterAfterBody(this, token);
              break;
            }
            case InsertionMode.AFTER_AFTER_FRAMESET: {
              startTagAfterAfterFrameset(this, token);
              break;
            }
            default:
          }
        }
        /** @internal */
        onEndTag(token) {
          this.skipNextNewLine = false;
          this.currentToken = token;
          if (this.currentNotInHTML) {
            endTagInForeignContent(this, token);
          } else {
            this._endTagOutsideForeignContent(token);
          }
        }
        /** @protected */
        _endTagOutsideForeignContent(token) {
          switch (this.insertionMode) {
            case InsertionMode.INITIAL: {
              tokenInInitialMode(this, token);
              break;
            }
            case InsertionMode.BEFORE_HTML: {
              endTagBeforeHtml(this, token);
              break;
            }
            case InsertionMode.BEFORE_HEAD: {
              endTagBeforeHead(this, token);
              break;
            }
            case InsertionMode.IN_HEAD: {
              endTagInHead(this, token);
              break;
            }
            case InsertionMode.IN_HEAD_NO_SCRIPT: {
              endTagInHeadNoScript(this, token);
              break;
            }
            case InsertionMode.AFTER_HEAD: {
              endTagAfterHead(this, token);
              break;
            }
            case InsertionMode.IN_BODY: {
              endTagInBody(this, token);
              break;
            }
            case InsertionMode.TEXT: {
              endTagInText(this, token);
              break;
            }
            case InsertionMode.IN_TABLE: {
              endTagInTable(this, token);
              break;
            }
            case InsertionMode.IN_TABLE_TEXT: {
              tokenInTableText(this, token);
              break;
            }
            case InsertionMode.IN_CAPTION: {
              endTagInCaption(this, token);
              break;
            }
            case InsertionMode.IN_COLUMN_GROUP: {
              endTagInColumnGroup(this, token);
              break;
            }
            case InsertionMode.IN_TABLE_BODY: {
              endTagInTableBody(this, token);
              break;
            }
            case InsertionMode.IN_ROW: {
              endTagInRow(this, token);
              break;
            }
            case InsertionMode.IN_CELL: {
              endTagInCell(this, token);
              break;
            }
            case InsertionMode.IN_SELECT: {
              endTagInSelect(this, token);
              break;
            }
            case InsertionMode.IN_SELECT_IN_TABLE: {
              endTagInSelectInTable(this, token);
              break;
            }
            case InsertionMode.IN_TEMPLATE: {
              endTagInTemplate(this, token);
              break;
            }
            case InsertionMode.AFTER_BODY: {
              endTagAfterBody(this, token);
              break;
            }
            case InsertionMode.IN_FRAMESET: {
              endTagInFrameset(this, token);
              break;
            }
            case InsertionMode.AFTER_FRAMESET: {
              endTagAfterFrameset(this, token);
              break;
            }
            case InsertionMode.AFTER_AFTER_BODY: {
              tokenAfterAfterBody(this, token);
              break;
            }
            default:
          }
        }
        /** @internal */
        onEof(token) {
          switch (this.insertionMode) {
            case InsertionMode.INITIAL: {
              tokenInInitialMode(this, token);
              break;
            }
            case InsertionMode.BEFORE_HTML: {
              tokenBeforeHtml(this, token);
              break;
            }
            case InsertionMode.BEFORE_HEAD: {
              tokenBeforeHead(this, token);
              break;
            }
            case InsertionMode.IN_HEAD: {
              tokenInHead(this, token);
              break;
            }
            case InsertionMode.IN_HEAD_NO_SCRIPT: {
              tokenInHeadNoScript(this, token);
              break;
            }
            case InsertionMode.AFTER_HEAD: {
              tokenAfterHead(this, token);
              break;
            }
            case InsertionMode.IN_BODY:
            case InsertionMode.IN_TABLE:
            case InsertionMode.IN_CAPTION:
            case InsertionMode.IN_COLUMN_GROUP:
            case InsertionMode.IN_TABLE_BODY:
            case InsertionMode.IN_ROW:
            case InsertionMode.IN_CELL:
            case InsertionMode.IN_SELECT:
            case InsertionMode.IN_SELECT_IN_TABLE: {
              eofInBody(this, token);
              break;
            }
            case InsertionMode.TEXT: {
              eofInText(this, token);
              break;
            }
            case InsertionMode.IN_TABLE_TEXT: {
              tokenInTableText(this, token);
              break;
            }
            case InsertionMode.IN_TEMPLATE: {
              eofInTemplate(this, token);
              break;
            }
            case InsertionMode.AFTER_BODY:
            case InsertionMode.IN_FRAMESET:
            case InsertionMode.AFTER_FRAMESET:
            case InsertionMode.AFTER_AFTER_BODY:
            case InsertionMode.AFTER_AFTER_FRAMESET: {
              stopParsing(this, token);
              break;
            }
            default:
          }
        }
        /** @internal */
        onWhitespaceCharacter(token) {
          if (this.skipNextNewLine) {
            this.skipNextNewLine = false;
            if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
              if (token.chars.length === 1) {
                return;
              }
              token.chars = token.chars.substr(1);
            }
          }
          if (this.tokenizer.inForeignNode) {
            this._insertCharacters(token);
            return;
          }
          switch (this.insertionMode) {
            case InsertionMode.IN_HEAD:
            case InsertionMode.IN_HEAD_NO_SCRIPT:
            case InsertionMode.AFTER_HEAD:
            case InsertionMode.TEXT:
            case InsertionMode.IN_COLUMN_GROUP:
            case InsertionMode.IN_SELECT:
            case InsertionMode.IN_SELECT_IN_TABLE:
            case InsertionMode.IN_FRAMESET:
            case InsertionMode.AFTER_FRAMESET: {
              this._insertCharacters(token);
              break;
            }
            case InsertionMode.IN_BODY:
            case InsertionMode.IN_CAPTION:
            case InsertionMode.IN_CELL:
            case InsertionMode.IN_TEMPLATE:
            case InsertionMode.AFTER_BODY:
            case InsertionMode.AFTER_AFTER_BODY:
            case InsertionMode.AFTER_AFTER_FRAMESET: {
              whitespaceCharacterInBody(this, token);
              break;
            }
            case InsertionMode.IN_TABLE:
            case InsertionMode.IN_TABLE_BODY:
            case InsertionMode.IN_ROW: {
              characterInTable(this, token);
              break;
            }
            case InsertionMode.IN_TABLE_TEXT: {
              whitespaceCharacterInTableText(this, token);
              break;
            }
            default:
          }
        }
      };
      TABLE_VOID_ELEMENTS = /* @__PURE__ */ new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
    }
  });

  // node_modules/parse5/node_modules/entities/dist/esm/escape.js
  function encodeXML(input2) {
    let returnValue = "";
    let lastIndex = 0;
    let match;
    while ((match = xmlReplacer.exec(input2)) !== null) {
      const { index: index3 } = match;
      const char = input2.charCodeAt(index3);
      const next2 = xmlCodeMap.get(char);
      if (next2 === void 0) {
        returnValue += `${input2.substring(lastIndex, index3)}&#x${getCodePoint(input2, index3).toString(16)};`;
        lastIndex = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
      } else {
        returnValue += input2.substring(lastIndex, index3) + next2;
        lastIndex = index3 + 1;
      }
    }
    return returnValue + input2.substr(lastIndex);
  }
  function getEscaper(regex, map9) {
    return function escape3(data) {
      let match;
      let lastIndex = 0;
      let result = "";
      while (match = regex.exec(data)) {
        if (lastIndex !== match.index) {
          result += data.substring(lastIndex, match.index);
        }
        result += map9.get(match[0].charCodeAt(0));
        lastIndex = match.index + 1;
      }
      return result + data.substring(lastIndex);
    };
  }
  var xmlReplacer, xmlCodeMap, getCodePoint, escape2, escapeUTF8, escapeAttribute, escapeText;
  var init_escape = __esm({
    "node_modules/parse5/node_modules/entities/dist/esm/escape.js"() {
      xmlReplacer = /["$&'<>\u0080-\uFFFF]/g;
      xmlCodeMap = /* @__PURE__ */ new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [39, "&apos;"],
        [60, "&lt;"],
        [62, "&gt;"]
      ]);
      getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt == null ? (c, index3) => (c.charCodeAt(index3) & 64512) === 55296 ? (c.charCodeAt(index3) - 55296) * 1024 + c.charCodeAt(index3 + 1) - 56320 + 65536 : c.charCodeAt(index3) : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        (input2, index3) => input2.codePointAt(index3)
      );
      escape2 = encodeXML;
      escapeUTF8 = /* @__PURE__ */ getEscaper(/["&'<>]/g, xmlCodeMap);
      escapeAttribute = /* @__PURE__ */ getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [160, "&nbsp;"]
      ]));
      escapeText = /* @__PURE__ */ getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
        [38, "&amp;"],
        [60, "&lt;"],
        [62, "&gt;"],
        [160, "&nbsp;"]
      ]));
    }
  });

  // node_modules/parse5/dist/serializer/index.js
  function isVoidElement(node2, options2) {
    return options2.treeAdapter.isElementNode(node2) && options2.treeAdapter.getNamespaceURI(node2) === NS.HTML && VOID_ELEMENTS.has(options2.treeAdapter.getTagName(node2));
  }
  function serialize(node2, options2) {
    const opts = { ...defaultOpts, ...options2 };
    if (isVoidElement(node2, opts)) {
      return "";
    }
    return serializeChildNodes(node2, opts);
  }
  function serializeOuter(node2, options2) {
    const opts = { ...defaultOpts, ...options2 };
    return serializeNode(node2, opts);
  }
  function serializeChildNodes(parentNode2, options2) {
    let html7 = "";
    const container = options2.treeAdapter.isElementNode(parentNode2) && options2.treeAdapter.getTagName(parentNode2) === TAG_NAMES.TEMPLATE && options2.treeAdapter.getNamespaceURI(parentNode2) === NS.HTML ? options2.treeAdapter.getTemplateContent(parentNode2) : parentNode2;
    const childNodes = options2.treeAdapter.getChildNodes(container);
    if (childNodes) {
      for (const currentNode of childNodes) {
        html7 += serializeNode(currentNode, options2);
      }
    }
    return html7;
  }
  function serializeNode(node2, options2) {
    if (options2.treeAdapter.isElementNode(node2)) {
      return serializeElement(node2, options2);
    }
    if (options2.treeAdapter.isTextNode(node2)) {
      return serializeTextNode(node2, options2);
    }
    if (options2.treeAdapter.isCommentNode(node2)) {
      return serializeCommentNode(node2, options2);
    }
    if (options2.treeAdapter.isDocumentTypeNode(node2)) {
      return serializeDocumentTypeNode(node2, options2);
    }
    return "";
  }
  function serializeElement(node2, options2) {
    const tn2 = options2.treeAdapter.getTagName(node2);
    return `<${tn2}${serializeAttributes(node2, options2)}>${isVoidElement(node2, options2) ? "" : `${serializeChildNodes(node2, options2)}</${tn2}>`}`;
  }
  function serializeAttributes(node2, { treeAdapter }) {
    let html7 = "";
    for (const attr of treeAdapter.getAttrList(node2)) {
      html7 += " ";
      if (attr.namespace) {
        switch (attr.namespace) {
          case NS.XML: {
            html7 += `xml:${attr.name}`;
            break;
          }
          case NS.XMLNS: {
            if (attr.name !== "xmlns") {
              html7 += "xmlns:";
            }
            html7 += attr.name;
            break;
          }
          case NS.XLINK: {
            html7 += `xlink:${attr.name}`;
            break;
          }
          default: {
            html7 += `${attr.prefix}:${attr.name}`;
          }
        }
      } else {
        html7 += attr.name;
      }
      html7 += `="${escapeAttribute(attr.value)}"`;
    }
    return html7;
  }
  function serializeTextNode(node2, options2) {
    const { treeAdapter } = options2;
    const content5 = treeAdapter.getTextNodeContent(node2);
    const parent = treeAdapter.getParentNode(node2);
    const parentTn = parent && treeAdapter.isElementNode(parent) && treeAdapter.getTagName(parent);
    return parentTn && treeAdapter.getNamespaceURI(parent) === NS.HTML && hasUnescapedText(parentTn, options2.scriptingEnabled) ? content5 : escapeText(content5);
  }
  function serializeCommentNode(node2, { treeAdapter }) {
    return `<!--${treeAdapter.getCommentNodeContent(node2)}-->`;
  }
  function serializeDocumentTypeNode(node2, { treeAdapter }) {
    return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node2)}>`;
  }
  var VOID_ELEMENTS, defaultOpts;
  var init_serializer = __esm({
    "node_modules/parse5/dist/serializer/index.js"() {
      init_html2();
      init_escape();
      init_default2();
      VOID_ELEMENTS = /* @__PURE__ */ new Set([
        TAG_NAMES.AREA,
        TAG_NAMES.BASE,
        TAG_NAMES.BASEFONT,
        TAG_NAMES.BGSOUND,
        TAG_NAMES.BR,
        TAG_NAMES.COL,
        TAG_NAMES.EMBED,
        TAG_NAMES.FRAME,
        TAG_NAMES.HR,
        TAG_NAMES.IMG,
        TAG_NAMES.INPUT,
        TAG_NAMES.KEYGEN,
        TAG_NAMES.LINK,
        TAG_NAMES.META,
        TAG_NAMES.PARAM,
        TAG_NAMES.SOURCE,
        TAG_NAMES.TRACK,
        TAG_NAMES.WBR
      ]);
      defaultOpts = { treeAdapter: defaultTreeAdapter, scriptingEnabled: true };
    }
  });

  // node_modules/parse5/dist/index.js
  function parse3(html7, options2) {
    return Parser.parse(html7, options2);
  }
  function parseFragment(fragmentContext, html7, options2) {
    if (typeof fragmentContext === "string") {
      options2 = html7;
      html7 = fragmentContext;
      fragmentContext = null;
    }
    const parser = Parser.getFragmentParser(fragmentContext, options2);
    parser.tokenizer.write(html7, true);
    return parser.getFragment();
  }
  var init_dist = __esm({
    "node_modules/parse5/dist/index.js"() {
      init_parser();
      init_default2();
      init_parser();
      init_serializer();
      init_error_codes();
      init_foreign_content();
      init_html2();
      init_token();
      init_tokenizer();
    }
  });

  // node_modules/unist-util-stringify-position/lib/index.js
  function stringifyPosition(value) {
    if (!value || typeof value !== "object") {
      return "";
    }
    if ("position" in value || "type" in value) {
      return position2(value.position);
    }
    if ("start" in value || "end" in value) {
      return position2(value);
    }
    if ("line" in value || "column" in value) {
      return point2(value);
    }
    return "";
  }
  function point2(point5) {
    return index(point5 && point5.line) + ":" + index(point5 && point5.column);
  }
  function position2(pos) {
    return point2(pos && pos.start) + "-" + point2(pos && pos.end);
  }
  function index(value) {
    return value && typeof value === "number" ? value : 1;
  }
  var init_lib5 = __esm({
    "node_modules/unist-util-stringify-position/lib/index.js"() {
    }
  });

  // node_modules/unist-util-stringify-position/index.js
  var init_unist_util_stringify_position = __esm({
    "node_modules/unist-util-stringify-position/index.js"() {
      init_lib5();
    }
  });

  // node_modules/vfile-message/lib/index.js
  var VFileMessage;
  var init_lib6 = __esm({
    "node_modules/vfile-message/lib/index.js"() {
      init_unist_util_stringify_position();
      VFileMessage = class extends Error {
        /**
         * Create a message for `reason`.
         *
         * >  **Note**: also has obsolete signatures.
         *
         * @overload
         * @param {string} reason
         * @param {Options | null | undefined} [options]
         * @returns
         *
         * @overload
         * @param {string} reason
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @overload
         * @param {string} reason
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @overload
         * @param {string} reason
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {string | null | undefined} [origin]
         * @returns
         *
         * @param {Error | VFileMessage | string} causeOrReason
         *   Reason for message, should use markdown.
         * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
         *   Configuration (optional).
         * @param {string | null | undefined} [origin]
         *   Place in code where the message originates (example:
         *   `'my-package:my-rule'` or `'my-rule'`).
         * @returns
         *   Instance of `VFileMessage`.
         */
        // eslint-disable-next-line complexity
        constructor(causeOrReason, optionsOrParentOrPlace, origin) {
          super();
          if (typeof optionsOrParentOrPlace === "string") {
            origin = optionsOrParentOrPlace;
            optionsOrParentOrPlace = void 0;
          }
          let reason = "";
          let options2 = {};
          let legacyCause = false;
          if (optionsOrParentOrPlace) {
            if ("line" in optionsOrParentOrPlace && "column" in optionsOrParentOrPlace) {
              options2 = { place: optionsOrParentOrPlace };
            } else if ("start" in optionsOrParentOrPlace && "end" in optionsOrParentOrPlace) {
              options2 = { place: optionsOrParentOrPlace };
            } else if ("type" in optionsOrParentOrPlace) {
              options2 = {
                ancestors: [optionsOrParentOrPlace],
                place: optionsOrParentOrPlace.position
              };
            } else {
              options2 = { ...optionsOrParentOrPlace };
            }
          }
          if (typeof causeOrReason === "string") {
            reason = causeOrReason;
          } else if (!options2.cause && causeOrReason) {
            legacyCause = true;
            reason = causeOrReason.message;
            options2.cause = causeOrReason;
          }
          if (!options2.ruleId && !options2.source && typeof origin === "string") {
            const index3 = origin.indexOf(":");
            if (index3 === -1) {
              options2.ruleId = origin;
            } else {
              options2.source = origin.slice(0, index3);
              options2.ruleId = origin.slice(index3 + 1);
            }
          }
          if (!options2.place && options2.ancestors && options2.ancestors) {
            const parent = options2.ancestors[options2.ancestors.length - 1];
            if (parent) {
              options2.place = parent.position;
            }
          }
          const start = options2.place && "start" in options2.place ? options2.place.start : options2.place;
          this.ancestors = options2.ancestors || void 0;
          this.cause = options2.cause || void 0;
          this.column = start ? start.column : void 0;
          this.fatal = void 0;
          this.file;
          this.message = reason;
          this.line = start ? start.line : void 0;
          this.name = stringifyPosition(options2.place) || "1:1";
          this.place = options2.place || void 0;
          this.reason = this.message;
          this.ruleId = options2.ruleId || void 0;
          this.source = options2.source || void 0;
          this.stack = legacyCause && options2.cause && typeof options2.cause.stack === "string" ? options2.cause.stack : "";
          this.actual;
          this.expected;
          this.note;
          this.url;
        }
      };
      VFileMessage.prototype.file = "";
      VFileMessage.prototype.name = "";
      VFileMessage.prototype.reason = "";
      VFileMessage.prototype.message = "";
      VFileMessage.prototype.stack = "";
      VFileMessage.prototype.column = void 0;
      VFileMessage.prototype.line = void 0;
      VFileMessage.prototype.ancestors = void 0;
      VFileMessage.prototype.cause = void 0;
      VFileMessage.prototype.fatal = void 0;
      VFileMessage.prototype.place = void 0;
      VFileMessage.prototype.ruleId = void 0;
      VFileMessage.prototype.source = void 0;
    }
  });

  // node_modules/vfile-message/index.js
  var init_vfile_message = __esm({
    "node_modules/vfile-message/index.js"() {
      init_lib6();
    }
  });

  // node_modules/vfile/lib/minpath.browser.js
  function basename(path2, extname2) {
    if (extname2 !== void 0 && typeof extname2 !== "string") {
      throw new TypeError('"ext" argument must be a string');
    }
    assertPath(path2);
    let start = 0;
    let end = -1;
    let index3 = path2.length;
    let seenNonSlash;
    if (extname2 === void 0 || extname2.length === 0 || extname2.length > path2.length) {
      while (index3--) {
        if (path2.codePointAt(index3) === 47) {
          if (seenNonSlash) {
            start = index3 + 1;
            break;
          }
        } else if (end < 0) {
          seenNonSlash = true;
          end = index3 + 1;
        }
      }
      return end < 0 ? "" : path2.slice(start, end);
    }
    if (extname2 === path2) {
      return "";
    }
    let firstNonSlashEnd = -1;
    let extnameIndex = extname2.length - 1;
    while (index3--) {
      if (path2.codePointAt(index3) === 47) {
        if (seenNonSlash) {
          start = index3 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd < 0) {
          seenNonSlash = true;
          firstNonSlashEnd = index3 + 1;
        }
        if (extnameIndex > -1) {
          if (path2.codePointAt(index3) === extname2.codePointAt(extnameIndex--)) {
            if (extnameIndex < 0) {
              end = index3;
            }
          } else {
            extnameIndex = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end) {
      end = firstNonSlashEnd;
    } else if (end < 0) {
      end = path2.length;
    }
    return path2.slice(start, end);
  }
  function dirname(path2) {
    assertPath(path2);
    if (path2.length === 0) {
      return ".";
    }
    let end = -1;
    let index3 = path2.length;
    let unmatchedSlash;
    while (--index3) {
      if (path2.codePointAt(index3) === 47) {
        if (unmatchedSlash) {
          end = index3;
          break;
        }
      } else if (!unmatchedSlash) {
        unmatchedSlash = true;
      }
    }
    return end < 0 ? path2.codePointAt(0) === 47 ? "/" : "." : end === 1 && path2.codePointAt(0) === 47 ? "//" : path2.slice(0, end);
  }
  function extname(path2) {
    assertPath(path2);
    let index3 = path2.length;
    let end = -1;
    let startPart = 0;
    let startDot = -1;
    let preDotState = 0;
    let unmatchedSlash;
    while (index3--) {
      const code5 = path2.codePointAt(index3);
      if (code5 === 47) {
        if (unmatchedSlash) {
          startPart = index3 + 1;
          break;
        }
        continue;
      }
      if (end < 0) {
        unmatchedSlash = true;
        end = index3 + 1;
      }
      if (code5 === 46) {
        if (startDot < 0) {
          startDot = index3;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot > -1) {
        preDotState = -1;
      }
    }
    if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
    preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  }
  function join(...segments) {
    let index3 = -1;
    let joined;
    while (++index3 < segments.length) {
      assertPath(segments[index3]);
      if (segments[index3]) {
        joined = joined === void 0 ? segments[index3] : joined + "/" + segments[index3];
      }
    }
    return joined === void 0 ? "." : normalize2(joined);
  }
  function normalize2(path2) {
    assertPath(path2);
    const absolute = path2.codePointAt(0) === 47;
    let value = normalizeString(path2, !absolute);
    if (value.length === 0 && !absolute) {
      value = ".";
    }
    if (value.length > 0 && path2.codePointAt(path2.length - 1) === 47) {
      value += "/";
    }
    return absolute ? "/" + value : value;
  }
  function normalizeString(path2, allowAboveRoot) {
    let result = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let index3 = -1;
    let code5;
    let lastSlashIndex;
    while (++index3 <= path2.length) {
      if (index3 < path2.length) {
        code5 = path2.codePointAt(index3);
      } else if (code5 === 47) {
        break;
      } else {
        code5 = 47;
      }
      if (code5 === 47) {
        if (lastSlash === index3 - 1 || dots === 1) {
        } else if (lastSlash !== index3 - 1 && dots === 2) {
          if (result.length < 2 || lastSegmentLength !== 2 || result.codePointAt(result.length - 1) !== 46 || result.codePointAt(result.length - 2) !== 46) {
            if (result.length > 2) {
              lastSlashIndex = result.lastIndexOf("/");
              if (lastSlashIndex !== result.length - 1) {
                if (lastSlashIndex < 0) {
                  result = "";
                  lastSegmentLength = 0;
                } else {
                  result = result.slice(0, lastSlashIndex);
                  lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                }
                lastSlash = index3;
                dots = 0;
                continue;
              }
            } else if (result.length > 0) {
              result = "";
              lastSegmentLength = 0;
              lastSlash = index3;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            result = result.length > 0 ? result + "/.." : "..";
            lastSegmentLength = 2;
          }
        } else {
          if (result.length > 0) {
            result += "/" + path2.slice(lastSlash + 1, index3);
          } else {
            result = path2.slice(lastSlash + 1, index3);
          }
          lastSegmentLength = index3 - lastSlash - 1;
        }
        lastSlash = index3;
        dots = 0;
      } else if (code5 === 46 && dots > -1) {
        dots++;
      } else {
        dots = -1;
      }
    }
    return result;
  }
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(path2)
      );
    }
  }
  var minpath;
  var init_minpath_browser = __esm({
    "node_modules/vfile/lib/minpath.browser.js"() {
      minpath = { basename, dirname, extname, join, sep: "/" };
    }
  });

  // node_modules/vfile/lib/minproc.browser.js
  function cwd() {
    return "/";
  }
  var minproc;
  var init_minproc_browser = __esm({
    "node_modules/vfile/lib/minproc.browser.js"() {
      minproc = { cwd };
    }
  });

  // node_modules/vfile/lib/minurl.shared.js
  function isUrl(fileUrlOrPath) {
    return Boolean(
      fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && "href" in fileUrlOrPath && fileUrlOrPath.href && "protocol" in fileUrlOrPath && fileUrlOrPath.protocol && // @ts-expect-error: indexing is fine.
      fileUrlOrPath.auth === void 0
    );
  }
  var init_minurl_shared = __esm({
    "node_modules/vfile/lib/minurl.shared.js"() {
    }
  });

  // node_modules/vfile/lib/minurl.browser.js
  function urlToPath(path2) {
    if (typeof path2 === "string") {
      path2 = new URL(path2);
    } else if (!isUrl(path2)) {
      const error = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
      );
      error.code = "ERR_INVALID_ARG_TYPE";
      throw error;
    }
    if (path2.protocol !== "file:") {
      const error = new TypeError("The URL must be of scheme file");
      error.code = "ERR_INVALID_URL_SCHEME";
      throw error;
    }
    return getPathFromURLPosix(path2);
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      const error = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      error.code = "ERR_INVALID_FILE_URL_HOST";
      throw error;
    }
    const pathname = url.pathname;
    let index3 = -1;
    while (++index3 < pathname.length) {
      if (pathname.codePointAt(index3) === 37 && pathname.codePointAt(index3 + 1) === 50) {
        const third = pathname.codePointAt(index3 + 2);
        if (third === 70 || third === 102) {
          const error = new TypeError(
            "File URL path must not include encoded / characters"
          );
          error.code = "ERR_INVALID_FILE_URL_PATH";
          throw error;
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  var init_minurl_browser = __esm({
    "node_modules/vfile/lib/minurl.browser.js"() {
      init_minurl_shared();
      init_minurl_shared();
    }
  });

  // node_modules/vfile/lib/index.js
  function assertPart(part, name) {
    if (part && part.includes(minpath.sep)) {
      throw new Error(
        "`" + name + "` cannot be a path: did not expect `" + minpath.sep + "`"
      );
    }
  }
  function assertNonEmpty(part, name) {
    if (!part) {
      throw new Error("`" + name + "` cannot be empty");
    }
  }
  function assertPath2(path2, name) {
    if (!path2) {
      throw new Error("Setting `" + name + "` requires `path` to be set too");
    }
  }
  function isUint8Array(value) {
    return Boolean(
      value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
    );
  }
  var order, VFile;
  var init_lib7 = __esm({
    "node_modules/vfile/lib/index.js"() {
      init_vfile_message();
      init_minpath_browser();
      init_minproc_browser();
      init_minurl_browser();
      order = /** @type {const} */
      [
        "history",
        "path",
        "basename",
        "stem",
        "extname",
        "dirname"
      ];
      VFile = class {
        /**
         * Create a new virtual file.
         *
         * `options` is treated as:
         *
         * *   `string` or `Uint8Array`  `{value: options}`
         * *   `URL`  `{path: options}`
         * *   `VFile`  shallow copies its data over to the new file
         * *   `object`  all fields are shallow copied over to the new file
         *
         * Path related fields are set in the following order (least specific to
         * most specific): `history`, `path`, `basename`, `stem`, `extname`,
         * `dirname`.
         *
         * You cannot set `dirname` or `extname` without setting either `history`,
         * `path`, `basename`, or `stem` too.
         *
         * @param {Compatible | null | undefined} [value]
         *   File value.
         * @returns
         *   New instance.
         */
        constructor(value) {
          let options2;
          if (!value) {
            options2 = {};
          } else if (isUrl(value)) {
            options2 = { path: value };
          } else if (typeof value === "string" || isUint8Array(value)) {
            options2 = { value };
          } else {
            options2 = value;
          }
          this.cwd = "cwd" in options2 ? "" : minproc.cwd();
          this.data = {};
          this.history = [];
          this.messages = [];
          this.value;
          this.map;
          this.result;
          this.stored;
          let index3 = -1;
          while (++index3 < order.length) {
            const field2 = order[index3];
            if (field2 in options2 && options2[field2] !== void 0 && options2[field2] !== null) {
              this[field2] = field2 === "history" ? [...options2[field2]] : options2[field2];
            }
          }
          let field;
          for (field in options2) {
            if (!order.includes(field)) {
              this[field] = options2[field];
            }
          }
        }
        /**
         * Get the basename (including extname) (example: `'index.min.js'`).
         *
         * @returns {string | undefined}
         *   Basename.
         */
        get basename() {
          return typeof this.path === "string" ? minpath.basename(this.path) : void 0;
        }
        /**
         * Set basename (including extname) (`'index.min.js'`).
         *
         * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
         * on windows).
         * Cannot be nullified (use `file.path = file.dirname` instead).
         *
         * @param {string} basename
         *   Basename.
         * @returns {undefined}
         *   Nothing.
         */
        set basename(basename2) {
          assertNonEmpty(basename2, "basename");
          assertPart(basename2, "basename");
          this.path = minpath.join(this.dirname || "", basename2);
        }
        /**
         * Get the parent path (example: `'~'`).
         *
         * @returns {string | undefined}
         *   Dirname.
         */
        get dirname() {
          return typeof this.path === "string" ? minpath.dirname(this.path) : void 0;
        }
        /**
         * Set the parent path (example: `'~'`).
         *
         * Cannot be set if theres no `path` yet.
         *
         * @param {string | undefined} dirname
         *   Dirname.
         * @returns {undefined}
         *   Nothing.
         */
        set dirname(dirname2) {
          assertPath2(this.basename, "dirname");
          this.path = minpath.join(dirname2 || "", this.basename);
        }
        /**
         * Get the extname (including dot) (example: `'.js'`).
         *
         * @returns {string | undefined}
         *   Extname.
         */
        get extname() {
          return typeof this.path === "string" ? minpath.extname(this.path) : void 0;
        }
        /**
         * Set the extname (including dot) (example: `'.js'`).
         *
         * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
         * on windows).
         * Cannot be set if theres no `path` yet.
         *
         * @param {string | undefined} extname
         *   Extname.
         * @returns {undefined}
         *   Nothing.
         */
        set extname(extname2) {
          assertPart(extname2, "extname");
          assertPath2(this.dirname, "extname");
          if (extname2) {
            if (extname2.codePointAt(0) !== 46) {
              throw new Error("`extname` must start with `.`");
            }
            if (extname2.includes(".", 1)) {
              throw new Error("`extname` cannot contain multiple dots");
            }
          }
          this.path = minpath.join(this.dirname, this.stem + (extname2 || ""));
        }
        /**
         * Get the full path (example: `'~/index.min.js'`).
         *
         * @returns {string}
         *   Path.
         */
        get path() {
          return this.history[this.history.length - 1];
        }
        /**
         * Set the full path (example: `'~/index.min.js'`).
         *
         * Cannot be nullified.
         * You can set a file URL (a `URL` object with a `file:` protocol) which will
         * be turned into a path with `url.fileURLToPath`.
         *
         * @param {URL | string} path
         *   Path.
         * @returns {undefined}
         *   Nothing.
         */
        set path(path2) {
          if (isUrl(path2)) {
            path2 = urlToPath(path2);
          }
          assertNonEmpty(path2, "path");
          if (this.path !== path2) {
            this.history.push(path2);
          }
        }
        /**
         * Get the stem (basename w/o extname) (example: `'index.min'`).
         *
         * @returns {string | undefined}
         *   Stem.
         */
        get stem() {
          return typeof this.path === "string" ? minpath.basename(this.path, this.extname) : void 0;
        }
        /**
         * Set the stem (basename w/o extname) (example: `'index.min'`).
         *
         * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
         * on windows).
         * Cannot be nullified (use `file.path = file.dirname` instead).
         *
         * @param {string} stem
         *   Stem.
         * @returns {undefined}
         *   Nothing.
         */
        set stem(stem) {
          assertNonEmpty(stem, "stem");
          assertPart(stem, "stem");
          this.path = minpath.join(this.dirname || "", stem + (this.extname || ""));
        }
        // Normal prototypal methods.
        /**
         * Create a fatal message for `reason` associated with the file.
         *
         * The `fatal` field of the message is set to `true` (error; file not usable)
         * and the `file` field is set to the current file path.
         * The message is added to the `messages` field on `file`.
         *
         * >  **Note**: also has obsolete signatures.
         *
         * @overload
         * @param {string} reason
         * @param {MessageOptions | null | undefined} [options]
         * @returns {never}
         *
         * @overload
         * @param {string} reason
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @overload
         * @param {string} reason
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @overload
         * @param {string} reason
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {string | null | undefined} [origin]
         * @returns {never}
         *
         * @param {Error | VFileMessage | string} causeOrReason
         *   Reason for message, should use markdown.
         * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
         *   Configuration (optional).
         * @param {string | null | undefined} [origin]
         *   Place in code where the message originates (example:
         *   `'my-package:my-rule'` or `'my-rule'`).
         * @returns {never}
         *   Never.
         * @throws {VFileMessage}
         *   Message.
         */
        fail(causeOrReason, optionsOrParentOrPlace, origin) {
          const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
          message.fatal = true;
          throw message;
        }
        /**
         * Create an info message for `reason` associated with the file.
         *
         * The `fatal` field of the message is set to `undefined` (info; change
         * likely not needed) and the `file` field is set to the current file path.
         * The message is added to the `messages` field on `file`.
         *
         * >  **Note**: also has obsolete signatures.
         *
         * @overload
         * @param {string} reason
         * @param {MessageOptions | null | undefined} [options]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @param {Error | VFileMessage | string} causeOrReason
         *   Reason for message, should use markdown.
         * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
         *   Configuration (optional).
         * @param {string | null | undefined} [origin]
         *   Place in code where the message originates (example:
         *   `'my-package:my-rule'` or `'my-rule'`).
         * @returns {VFileMessage}
         *   Message.
         */
        info(causeOrReason, optionsOrParentOrPlace, origin) {
          const message = this.message(causeOrReason, optionsOrParentOrPlace, origin);
          message.fatal = void 0;
          return message;
        }
        /**
         * Create a message for `reason` associated with the file.
         *
         * The `fatal` field of the message is set to `false` (warning; change may be
         * needed) and the `file` field is set to the current file path.
         * The message is added to the `messages` field on `file`.
         *
         * >  **Note**: also has obsolete signatures.
         *
         * @overload
         * @param {string} reason
         * @param {MessageOptions | null | undefined} [options]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {string} reason
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Node | NodeLike | null | undefined} parent
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {Point | Position | null | undefined} place
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @overload
         * @param {Error | VFileMessage} cause
         * @param {string | null | undefined} [origin]
         * @returns {VFileMessage}
         *
         * @param {Error | VFileMessage | string} causeOrReason
         *   Reason for message, should use markdown.
         * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
         *   Configuration (optional).
         * @param {string | null | undefined} [origin]
         *   Place in code where the message originates (example:
         *   `'my-package:my-rule'` or `'my-rule'`).
         * @returns {VFileMessage}
         *   Message.
         */
        message(causeOrReason, optionsOrParentOrPlace, origin) {
          const message = new VFileMessage(
            // @ts-expect-error: the overloads are fine.
            causeOrReason,
            optionsOrParentOrPlace,
            origin
          );
          if (this.path) {
            message.name = this.path + ":" + message.name;
            message.file = this.path;
          }
          message.fatal = false;
          this.messages.push(message);
          return message;
        }
        /**
         * Serialize the file.
         *
         * > **Note**: which encodings are supported depends on the engine.
         * > For info on Node.js, see:
         * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
         *
         * @param {string | null | undefined} [encoding='utf8']
         *   Character encoding to understand `value` as when its a `Uint8Array`
         *   (default: `'utf-8'`).
         * @returns {string}
         *   Serialized file.
         */
        toString(encoding) {
          if (this.value === void 0) {
            return "";
          }
          if (typeof this.value === "string") {
            return this.value;
          }
          const decoder = new TextDecoder(encoding || void 0);
          return decoder.decode(this.value);
        }
      };
    }
  });

  // node_modules/vfile/index.js
  var init_vfile = __esm({
    "node_modules/vfile/index.js"() {
      init_lib7();
    }
  });

  // node_modules/hast-util-from-html/lib/errors.js
  var errors;
  var init_errors = __esm({
    "node_modules/hast-util-from-html/lib/errors.js"() {
      errors = {
        /** @type {ErrorInfo} */
        abandonedHeadElementChild: {
          reason: "Unexpected metadata element after head",
          description: "Unexpected element after head. Expected the element before `</head>`",
          url: false
        },
        /** @type {ErrorInfo} */
        abruptClosingOfEmptyComment: {
          reason: "Unexpected abruptly closed empty comment",
          description: "Unexpected `>` or `->`. Expected `-->` to close comments"
        },
        /** @type {ErrorInfo} */
        abruptDoctypePublicIdentifier: {
          reason: "Unexpected abruptly closed public identifier",
          description: "Unexpected `>`. Expected a closing `\"` or `'` after the public identifier"
        },
        /** @type {ErrorInfo} */
        abruptDoctypeSystemIdentifier: {
          reason: "Unexpected abruptly closed system identifier",
          description: "Unexpected `>`. Expected a closing `\"` or `'` after the identifier identifier"
        },
        /** @type {ErrorInfo} */
        absenceOfDigitsInNumericCharacterReference: {
          reason: "Unexpected non-digit at start of numeric character reference",
          description: "Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references"
        },
        /** @type {ErrorInfo} */
        cdataInHtmlContent: {
          reason: "Unexpected CDATA section in HTML",
          description: "Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead"
        },
        /** @type {ErrorInfo} */
        characterReferenceOutsideUnicodeRange: {
          reason: "Unexpected too big numeric character reference",
          description: "Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)"
        },
        /** @type {ErrorInfo} */
        closingOfElementWithOpenChildElements: {
          reason: "Unexpected closing tag with open child elements",
          description: "Unexpectedly closing tag. Expected other tags to be closed first",
          url: false
        },
        /** @type {ErrorInfo} */
        controlCharacterInInputStream: {
          reason: "Unexpected control character",
          description: "Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace"
        },
        /** @type {ErrorInfo} */
        controlCharacterReference: {
          reason: "Unexpected control character reference",
          description: "Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace"
        },
        /** @type {ErrorInfo} */
        disallowedContentInNoscriptInHead: {
          reason: "Disallowed content inside `<noscript>` in `<head>`",
          description: "Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`",
          url: false
        },
        /** @type {ErrorInfo} */
        duplicateAttribute: {
          reason: "Unexpected duplicate attribute",
          description: "Unexpectedly double attribute. Expected attributes to occur only once"
        },
        /** @type {ErrorInfo} */
        endTagWithAttributes: {
          reason: "Unexpected attribute on closing tag",
          description: "Unexpected attribute. Expected `>` instead"
        },
        /** @type {ErrorInfo} */
        endTagWithTrailingSolidus: {
          reason: "Unexpected slash at end of closing tag",
          description: "Unexpected `%c-1`. Expected `>` instead"
        },
        /** @type {ErrorInfo} */
        endTagWithoutMatchingOpenElement: {
          reason: "Unexpected unopened end tag",
          description: "Unexpected end tag. Expected no end tag or another end tag",
          url: false
        },
        /** @type {ErrorInfo} */
        eofBeforeTagName: {
          reason: "Unexpected end of file",
          description: "Unexpected end of file. Expected tag name instead"
        },
        /** @type {ErrorInfo} */
        eofInCdata: {
          reason: "Unexpected end of file in CDATA",
          description: "Unexpected end of file. Expected `]]>` to close the CDATA"
        },
        /** @type {ErrorInfo} */
        eofInComment: {
          reason: "Unexpected end of file in comment",
          description: "Unexpected end of file. Expected `-->` to close the comment"
        },
        /** @type {ErrorInfo} */
        eofInDoctype: {
          reason: "Unexpected end of file in doctype",
          description: "Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)"
        },
        /** @type {ErrorInfo} */
        eofInElementThatCanContainOnlyText: {
          reason: "Unexpected end of file in element that can only contain text",
          description: "Unexpected end of file. Expected text or a closing tag",
          url: false
        },
        /** @type {ErrorInfo} */
        eofInScriptHtmlCommentLikeText: {
          reason: "Unexpected end of file in comment inside script",
          description: "Unexpected end of file. Expected `-->` to close the comment"
        },
        /** @type {ErrorInfo} */
        eofInTag: {
          reason: "Unexpected end of file in tag",
          description: "Unexpected end of file. Expected `>` to close the tag"
        },
        /** @type {ErrorInfo} */
        incorrectlyClosedComment: {
          reason: "Incorrectly closed comment",
          description: "Unexpected `%c-1`. Expected `-->` to close the comment"
        },
        /** @type {ErrorInfo} */
        incorrectlyOpenedComment: {
          reason: "Incorrectly opened comment",
          description: "Unexpected `%c`. Expected `<!--` to open the comment"
        },
        /** @type {ErrorInfo} */
        invalidCharacterSequenceAfterDoctypeName: {
          reason: "Invalid sequence after doctype name",
          description: "Unexpected sequence at `%c`. Expected `public` or `system`"
        },
        /** @type {ErrorInfo} */
        invalidFirstCharacterOfTagName: {
          reason: "Invalid first character in tag name",
          description: "Unexpected `%c`. Expected an ASCII letter instead"
        },
        /** @type {ErrorInfo} */
        misplacedDoctype: {
          reason: "Misplaced doctype",
          description: "Unexpected doctype. Expected doctype before head",
          url: false
        },
        /** @type {ErrorInfo} */
        misplacedStartTagForHeadElement: {
          reason: "Misplaced `<head>` start tag",
          description: "Unexpected start tag `<head>`. Expected `<head>` directly after doctype",
          url: false
        },
        /** @type {ErrorInfo} */
        missingAttributeValue: {
          reason: "Missing attribute value",
          description: "Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead"
        },
        /** @type {ErrorInfo} */
        missingDoctype: {
          reason: "Missing doctype before other content",
          description: "Expected a `<!doctype html>` before anything else",
          url: false
        },
        /** @type {ErrorInfo} */
        missingDoctypeName: {
          reason: "Missing doctype name",
          description: "Unexpected doctype end at `%c`. Expected `html` instead"
        },
        /** @type {ErrorInfo} */
        missingDoctypePublicIdentifier: {
          reason: "Missing public identifier in doctype",
          description: "Unexpected `%c`. Expected identifier for `public` instead"
        },
        /** @type {ErrorInfo} */
        missingDoctypeSystemIdentifier: {
          reason: "Missing system identifier in doctype",
          description: 'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)'
        },
        /** @type {ErrorInfo} */
        missingEndTagName: {
          reason: "Missing name in end tag",
          description: "Unexpected `%c`. Expected an ASCII letter instead"
        },
        /** @type {ErrorInfo} */
        missingQuoteBeforeDoctypePublicIdentifier: {
          reason: "Missing quote before public identifier in doctype",
          description: "Unexpected `%c`. Expected `\"` or `'` instead"
        },
        /** @type {ErrorInfo} */
        missingQuoteBeforeDoctypeSystemIdentifier: {
          reason: "Missing quote before system identifier in doctype",
          description: "Unexpected `%c`. Expected `\"` or `'` instead"
        },
        /** @type {ErrorInfo} */
        missingSemicolonAfterCharacterReference: {
          reason: "Missing semicolon after character reference",
          description: "Unexpected `%c`. Expected `;` instead"
        },
        /** @type {ErrorInfo} */
        missingWhitespaceAfterDoctypePublicKeyword: {
          reason: "Missing whitespace after public identifier in doctype",
          description: "Unexpected `%c`. Expected ASCII whitespace instead"
        },
        /** @type {ErrorInfo} */
        missingWhitespaceAfterDoctypeSystemKeyword: {
          reason: "Missing whitespace after system identifier in doctype",
          description: "Unexpected `%c`. Expected ASCII whitespace instead"
        },
        /** @type {ErrorInfo} */
        missingWhitespaceBeforeDoctypeName: {
          reason: "Missing whitespace before doctype name",
          description: "Unexpected `%c`. Expected ASCII whitespace instead"
        },
        /** @type {ErrorInfo} */
        missingWhitespaceBetweenAttributes: {
          reason: "Missing whitespace between attributes",
          description: "Unexpected `%c`. Expected ASCII whitespace instead"
        },
        /** @type {ErrorInfo} */
        missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
          reason: "Missing whitespace between public and system identifiers in doctype",
          description: "Unexpected `%c`. Expected ASCII whitespace instead"
        },
        /** @type {ErrorInfo} */
        nestedComment: {
          reason: "Unexpected nested comment",
          description: "Unexpected `<!--`. Expected `-->`"
        },
        /** @type {ErrorInfo} */
        nestedNoscriptInHead: {
          reason: "Unexpected nested `<noscript>` in `<head>`",
          description: "Unexpected `<noscript>`. Expected a closing tag or a meta element",
          url: false
        },
        /** @type {ErrorInfo} */
        nonConformingDoctype: {
          reason: "Unexpected non-conforming doctype declaration",
          description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
          url: false
        },
        /** @type {ErrorInfo} */
        nonVoidHtmlElementStartTagWithTrailingSolidus: {
          reason: "Unexpected trailing slash on start tag of non-void element",
          description: "Unexpected `/`. Expected `>` instead"
        },
        /** @type {ErrorInfo} */
        noncharacterCharacterReference: {
          reason: "Unexpected noncharacter code point referenced by character reference",
          description: "Unexpected code point. Do not use noncharacters in HTML"
        },
        /** @type {ErrorInfo} */
        noncharacterInInputStream: {
          reason: "Unexpected noncharacter character",
          description: "Unexpected code point `%x`. Do not use noncharacters in HTML"
        },
        /** @type {ErrorInfo} */
        nullCharacterReference: {
          reason: "Unexpected NULL character referenced by character reference",
          description: "Unexpected code point. Do not use NULL characters in HTML"
        },
        /** @type {ErrorInfo} */
        openElementsLeftAfterEof: {
          reason: "Unexpected end of file",
          description: "Unexpected end of file. Expected closing tag instead",
          url: false
        },
        /** @type {ErrorInfo} */
        surrogateCharacterReference: {
          reason: "Unexpected surrogate character referenced by character reference",
          description: "Unexpected code point. Do not use lone surrogate characters in HTML"
        },
        /** @type {ErrorInfo} */
        surrogateInInputStream: {
          reason: "Unexpected surrogate character",
          description: "Unexpected code point `%x`. Do not use lone surrogate characters in HTML"
        },
        /** @type {ErrorInfo} */
        unexpectedCharacterAfterDoctypeSystemIdentifier: {
          reason: "Invalid character after system identifier in doctype",
          description: "Unexpected character at `%c`. Expected `>`"
        },
        /** @type {ErrorInfo} */
        unexpectedCharacterInAttributeName: {
          reason: "Unexpected character in attribute name",
          description: "Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter"
        },
        /** @type {ErrorInfo} */
        unexpectedCharacterInUnquotedAttributeValue: {
          reason: "Unexpected character in unquoted attribute value",
          description: "Unexpected `%c`. Quote the attribute value to include it"
        },
        /** @type {ErrorInfo} */
        unexpectedEqualsSignBeforeAttributeName: {
          reason: "Unexpected equals sign before attribute name",
          description: "Unexpected `%c`. Add an attribute name before it"
        },
        /** @type {ErrorInfo} */
        unexpectedNullCharacter: {
          reason: "Unexpected NULL character",
          description: "Unexpected code point `%x`. Do not use NULL characters in HTML"
        },
        /** @type {ErrorInfo} */
        unexpectedQuestionMarkInsteadOfTagName: {
          reason: "Unexpected question mark instead of tag name",
          description: "Unexpected `%c`. Expected an ASCII letter instead"
        },
        /** @type {ErrorInfo} */
        unexpectedSolidusInTag: {
          reason: "Unexpected slash in tag",
          description: "Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value"
        },
        /** @type {ErrorInfo} */
        unknownNamedCharacterReference: {
          reason: "Unexpected unknown named character reference",
          description: "Unexpected character reference. Expected known named character references"
        }
      };
    }
  });

  // node_modules/hast-util-from-html/lib/index.js
  function fromHtml(value, options2) {
    const settings = options2 || emptyOptions;
    const onerror = settings.onerror;
    const file = value instanceof VFile ? value : new VFile(value);
    const parseFunction = settings.fragment ? parseFragment : parse3;
    const document4 = String(file);
    const p5Document = parseFunction(document4, {
      sourceCodeLocationInfo: true,
      // Note `parse5` types currently do not allow `undefined`.
      onParseError: settings.onerror ? internalOnerror : null,
      scriptingEnabled: false
    });
    return (
      /** @type {Root} */
      fromParse5(p5Document, {
        file,
        space: settings.space,
        verbose: settings.verbose
      })
    );
    function internalOnerror(error) {
      const code5 = error.code;
      const name = camelcase2(code5);
      const setting = settings[name];
      const config = setting === null || setting === void 0 ? true : setting;
      const level = typeof config === "number" ? config : config ? 1 : 0;
      if (level) {
        const info = errors[name];
        ok(info, "expected known error from `parse5`");
        const message = new VFileMessage(format2(info.reason), {
          place: {
            start: {
              line: error.startLine,
              column: error.startCol,
              offset: error.startOffset
            },
            end: {
              line: error.endLine,
              column: error.endCol,
              offset: error.endOffset
            }
          },
          ruleId: code5,
          source: "hast-util-from-html"
        });
        if (file.path) {
          message.file = file.path;
          message.name = file.path + ":" + message.name;
        }
        message.fatal = fatalities[level];
        message.note = format2(info.description);
        message.url = info.url === false ? void 0 : base + code5;
        ok(onerror, "`internalOnerror` is not passed if `onerror` is not set");
        onerror(message);
      }
      function format2(value2) {
        return value2.replace(formatCRe, formatC).replace(formatXRe, formatX);
        function formatC(_2, $1, $2) {
          const offset = ($2 ? Number.parseInt($2, 10) : 0) * ($1 === "-" ? -1 : 1);
          const char = document4.charAt(error.startOffset + offset);
          return visualizeCharacter(char);
        }
        function formatX() {
          return visualizeCharacterCode(document4.charCodeAt(error.startOffset));
        }
      }
    }
  }
  function camelcase2(value) {
    return (
      /** @type {ErrorCode} */
      value.replace(dashToCamelRe, dashToCamel)
    );
  }
  function dashToCamel($0) {
    return $0.charAt(1).toUpperCase();
  }
  function visualizeCharacter(char) {
    return char === "`" ? "` ` `" : char;
  }
  function visualizeCharacterCode(charCode) {
    return "0x" + charCode.toString(16).toUpperCase();
  }
  var base, dashToCamelRe, formatCRe, formatXRe, fatalities, emptyOptions;
  var init_lib8 = __esm({
    "node_modules/hast-util-from-html/lib/index.js"() {
      init_default();
      init_hast_util_from_parse5();
      init_dist();
      init_vfile();
      init_vfile_message();
      init_errors();
      base = "https://html.spec.whatwg.org/multipage/parsing.html#parse-error-";
      dashToCamelRe = /-[a-z]/g;
      formatCRe = /%c(?:([-+])(\d+))?/g;
      formatXRe = /%x/g;
      fatalities = { 2: true, 1: false, 0: null };
      emptyOptions = {};
    }
  });

  // node_modules/hast-util-from-html/index.js
  var init_hast_util_from_html = __esm({
    "node_modules/hast-util-from-html/index.js"() {
      init_lib8();
    }
  });

  // node_modules/rehype-parse/lib/index.js
  function rehypeParse(options2) {
    const self2 = this;
    const { emitParseErrors, ...settings } = { ...self2.data("settings"), ...options2 };
    self2.parser = parser;
    function parser(document4, file) {
      return fromHtml(document4, {
        ...settings,
        onerror: emitParseErrors ? function(message) {
          if (file.path) {
            message.name = file.path + ":" + message.name;
            message.file = file.path;
          }
          file.messages.push(message);
        } : void 0
      });
    }
  }
  var init_lib9 = __esm({
    "node_modules/rehype-parse/lib/index.js"() {
      init_hast_util_from_html();
    }
  });

  // node_modules/rehype-parse/index.js
  var rehype_parse_exports = {};
  __export(rehype_parse_exports, {
    default: () => rehypeParse
  });
  var init_rehype_parse = __esm({
    "node_modules/rehype-parse/index.js"() {
      init_lib9();
    }
  });

  // node_modules/html-void-elements/index.js
  var htmlVoidElements;
  var init_html_void_elements = __esm({
    "node_modules/html-void-elements/index.js"() {
      htmlVoidElements = [
        "area",
        "base",
        "basefont",
        "bgsound",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "image",
        "img",
        "input",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ];
    }
  });

  // node_modules/zwitch/index.js
  function zwitch(key2, options2) {
    const settings = options2 || {};
    function one6(value, ...parameters) {
      let fn2 = one6.invalid;
      const handlers4 = one6.handlers;
      if (value && own2.call(value, key2)) {
        const id2 = String(value[key2]);
        fn2 = own2.call(handlers4, id2) ? handlers4[id2] : one6.unknown;
      }
      if (fn2) {
        return fn2.call(this, value, ...parameters);
      }
    }
    one6.handlers = settings.handlers || {};
    one6.invalid = settings.invalid;
    one6.unknown = settings.unknown;
    return one6;
  }
  var own2;
  var init_zwitch = __esm({
    "node_modules/zwitch/index.js"() {
      own2 = {}.hasOwnProperty;
    }
  });

  // node_modules/stringify-entities/lib/core.js
  function core(value, options2) {
    value = value.replace(
      options2.subset ? charactersToExpressionCached(options2.subset) : defaultSubsetRegex,
      basic2
    );
    if (options2.subset || options2.escapeOnly) {
      return value;
    }
    return value.replace(surrogatePairsRegex, surrogate).replace(controlCharactersRegex, basic2);
    function surrogate(pair, index3, all10) {
      return options2.format(
        (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
        all10.charCodeAt(index3 + 2),
        options2
      );
    }
    function basic2(character, index3, all10) {
      return options2.format(
        character.charCodeAt(0),
        all10.charCodeAt(index3 + 1),
        options2
      );
    }
  }
  function charactersToExpressionCached(subset) {
    let cached = subsetToRegexCache.get(subset);
    if (!cached) {
      cached = charactersToExpression(subset);
      subsetToRegexCache.set(subset, cached);
    }
    return cached;
  }
  function charactersToExpression(subset) {
    const groups = [];
    let index3 = -1;
    while (++index3 < subset.length) {
      groups.push(subset[index3].replace(regexEscapeRegex, "\\$&"));
    }
    return new RegExp("(?:" + groups.join("|") + ")", "g");
  }
  var defaultSubsetRegex, surrogatePairsRegex, controlCharactersRegex, regexEscapeRegex, subsetToRegexCache;
  var init_core = __esm({
    "node_modules/stringify-entities/lib/core.js"() {
      defaultSubsetRegex = /["&'<>`]/g;
      surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      controlCharactersRegex = // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
      /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g;
      subsetToRegexCache = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/stringify-entities/lib/util/to-hexadecimal.js
  function toHexadecimal(code5, next2, omit) {
    const value = "&#x" + code5.toString(16).toUpperCase();
    return omit && next2 && !hexadecimalRegex.test(String.fromCharCode(next2)) ? value : value + ";";
  }
  var hexadecimalRegex;
  var init_to_hexadecimal = __esm({
    "node_modules/stringify-entities/lib/util/to-hexadecimal.js"() {
      hexadecimalRegex = /[\dA-Fa-f]/;
    }
  });

  // node_modules/stringify-entities/lib/util/to-decimal.js
  function toDecimal(code5, next2, omit) {
    const value = "&#" + String(code5);
    return omit && next2 && !decimalRegex.test(String.fromCharCode(next2)) ? value : value + ";";
  }
  var decimalRegex;
  var init_to_decimal = __esm({
    "node_modules/stringify-entities/lib/util/to-decimal.js"() {
      decimalRegex = /\d/;
    }
  });

  // node_modules/character-entities-legacy/index.js
  var characterEntitiesLegacy;
  var init_character_entities_legacy = __esm({
    "node_modules/character-entities-legacy/index.js"() {
      characterEntitiesLegacy = [
        "AElig",
        "AMP",
        "Aacute",
        "Acirc",
        "Agrave",
        "Aring",
        "Atilde",
        "Auml",
        "COPY",
        "Ccedil",
        "ETH",
        "Eacute",
        "Ecirc",
        "Egrave",
        "Euml",
        "GT",
        "Iacute",
        "Icirc",
        "Igrave",
        "Iuml",
        "LT",
        "Ntilde",
        "Oacute",
        "Ocirc",
        "Ograve",
        "Oslash",
        "Otilde",
        "Ouml",
        "QUOT",
        "REG",
        "THORN",
        "Uacute",
        "Ucirc",
        "Ugrave",
        "Uuml",
        "Yacute",
        "aacute",
        "acirc",
        "acute",
        "aelig",
        "agrave",
        "amp",
        "aring",
        "atilde",
        "auml",
        "brvbar",
        "ccedil",
        "cedil",
        "cent",
        "copy",
        "curren",
        "deg",
        "divide",
        "eacute",
        "ecirc",
        "egrave",
        "eth",
        "euml",
        "frac12",
        "frac14",
        "frac34",
        "gt",
        "iacute",
        "icirc",
        "iexcl",
        "igrave",
        "iquest",
        "iuml",
        "laquo",
        "lt",
        "macr",
        "micro",
        "middot",
        "nbsp",
        "not",
        "ntilde",
        "oacute",
        "ocirc",
        "ograve",
        "ordf",
        "ordm",
        "oslash",
        "otilde",
        "ouml",
        "para",
        "plusmn",
        "pound",
        "quot",
        "raquo",
        "reg",
        "sect",
        "shy",
        "sup1",
        "sup2",
        "sup3",
        "szlig",
        "thorn",
        "times",
        "uacute",
        "ucirc",
        "ugrave",
        "uml",
        "uuml",
        "yacute",
        "yen",
        "yuml"
      ];
    }
  });

  // node_modules/character-entities-html4/index.js
  var characterEntitiesHtml4;
  var init_character_entities_html4 = __esm({
    "node_modules/character-entities-html4/index.js"() {
      characterEntitiesHtml4 = {
        nbsp: "\xA0",
        iexcl: "\xA1",
        cent: "\xA2",
        pound: "\xA3",
        curren: "\xA4",
        yen: "\xA5",
        brvbar: "\xA6",
        sect: "\xA7",
        uml: "\xA8",
        copy: "\xA9",
        ordf: "\xAA",
        laquo: "\xAB",
        not: "\xAC",
        shy: "\xAD",
        reg: "\xAE",
        macr: "\xAF",
        deg: "\xB0",
        plusmn: "\xB1",
        sup2: "\xB2",
        sup3: "\xB3",
        acute: "\xB4",
        micro: "\xB5",
        para: "\xB6",
        middot: "\xB7",
        cedil: "\xB8",
        sup1: "\xB9",
        ordm: "\xBA",
        raquo: "\xBB",
        frac14: "\xBC",
        frac12: "\xBD",
        frac34: "\xBE",
        iquest: "\xBF",
        Agrave: "\xC0",
        Aacute: "\xC1",
        Acirc: "\xC2",
        Atilde: "\xC3",
        Auml: "\xC4",
        Aring: "\xC5",
        AElig: "\xC6",
        Ccedil: "\xC7",
        Egrave: "\xC8",
        Eacute: "\xC9",
        Ecirc: "\xCA",
        Euml: "\xCB",
        Igrave: "\xCC",
        Iacute: "\xCD",
        Icirc: "\xCE",
        Iuml: "\xCF",
        ETH: "\xD0",
        Ntilde: "\xD1",
        Ograve: "\xD2",
        Oacute: "\xD3",
        Ocirc: "\xD4",
        Otilde: "\xD5",
        Ouml: "\xD6",
        times: "\xD7",
        Oslash: "\xD8",
        Ugrave: "\xD9",
        Uacute: "\xDA",
        Ucirc: "\xDB",
        Uuml: "\xDC",
        Yacute: "\xDD",
        THORN: "\xDE",
        szlig: "\xDF",
        agrave: "\xE0",
        aacute: "\xE1",
        acirc: "\xE2",
        atilde: "\xE3",
        auml: "\xE4",
        aring: "\xE5",
        aelig: "\xE6",
        ccedil: "\xE7",
        egrave: "\xE8",
        eacute: "\xE9",
        ecirc: "\xEA",
        euml: "\xEB",
        igrave: "\xEC",
        iacute: "\xED",
        icirc: "\xEE",
        iuml: "\xEF",
        eth: "\xF0",
        ntilde: "\xF1",
        ograve: "\xF2",
        oacute: "\xF3",
        ocirc: "\xF4",
        otilde: "\xF5",
        ouml: "\xF6",
        divide: "\xF7",
        oslash: "\xF8",
        ugrave: "\xF9",
        uacute: "\xFA",
        ucirc: "\xFB",
        uuml: "\xFC",
        yacute: "\xFD",
        thorn: "\xFE",
        yuml: "\xFF",
        fnof: "\u0192",
        Alpha: "\u0391",
        Beta: "\u0392",
        Gamma: "\u0393",
        Delta: "\u0394",
        Epsilon: "\u0395",
        Zeta: "\u0396",
        Eta: "\u0397",
        Theta: "\u0398",
        Iota: "\u0399",
        Kappa: "\u039A",
        Lambda: "\u039B",
        Mu: "\u039C",
        Nu: "\u039D",
        Xi: "\u039E",
        Omicron: "\u039F",
        Pi: "\u03A0",
        Rho: "\u03A1",
        Sigma: "\u03A3",
        Tau: "\u03A4",
        Upsilon: "\u03A5",
        Phi: "\u03A6",
        Chi: "\u03A7",
        Psi: "\u03A8",
        Omega: "\u03A9",
        alpha: "\u03B1",
        beta: "\u03B2",
        gamma: "\u03B3",
        delta: "\u03B4",
        epsilon: "\u03B5",
        zeta: "\u03B6",
        eta: "\u03B7",
        theta: "\u03B8",
        iota: "\u03B9",
        kappa: "\u03BA",
        lambda: "\u03BB",
        mu: "\u03BC",
        nu: "\u03BD",
        xi: "\u03BE",
        omicron: "\u03BF",
        pi: "\u03C0",
        rho: "\u03C1",
        sigmaf: "\u03C2",
        sigma: "\u03C3",
        tau: "\u03C4",
        upsilon: "\u03C5",
        phi: "\u03C6",
        chi: "\u03C7",
        psi: "\u03C8",
        omega: "\u03C9",
        thetasym: "\u03D1",
        upsih: "\u03D2",
        piv: "\u03D6",
        bull: "\u2022",
        hellip: "\u2026",
        prime: "\u2032",
        Prime: "\u2033",
        oline: "\u203E",
        frasl: "\u2044",
        weierp: "\u2118",
        image: "\u2111",
        real: "\u211C",
        trade: "\u2122",
        alefsym: "\u2135",
        larr: "\u2190",
        uarr: "\u2191",
        rarr: "\u2192",
        darr: "\u2193",
        harr: "\u2194",
        crarr: "\u21B5",
        lArr: "\u21D0",
        uArr: "\u21D1",
        rArr: "\u21D2",
        dArr: "\u21D3",
        hArr: "\u21D4",
        forall: "\u2200",
        part: "\u2202",
        exist: "\u2203",
        empty: "\u2205",
        nabla: "\u2207",
        isin: "\u2208",
        notin: "\u2209",
        ni: "\u220B",
        prod: "\u220F",
        sum: "\u2211",
        minus: "\u2212",
        lowast: "\u2217",
        radic: "\u221A",
        prop: "\u221D",
        infin: "\u221E",
        ang: "\u2220",
        and: "\u2227",
        or: "\u2228",
        cap: "\u2229",
        cup: "\u222A",
        int: "\u222B",
        there4: "\u2234",
        sim: "\u223C",
        cong: "\u2245",
        asymp: "\u2248",
        ne: "\u2260",
        equiv: "\u2261",
        le: "\u2264",
        ge: "\u2265",
        sub: "\u2282",
        sup: "\u2283",
        nsub: "\u2284",
        sube: "\u2286",
        supe: "\u2287",
        oplus: "\u2295",
        otimes: "\u2297",
        perp: "\u22A5",
        sdot: "\u22C5",
        lceil: "\u2308",
        rceil: "\u2309",
        lfloor: "\u230A",
        rfloor: "\u230B",
        lang: "\u2329",
        rang: "\u232A",
        loz: "\u25CA",
        spades: "\u2660",
        clubs: "\u2663",
        hearts: "\u2665",
        diams: "\u2666",
        quot: '"',
        amp: "&",
        lt: "<",
        gt: ">",
        OElig: "\u0152",
        oelig: "\u0153",
        Scaron: "\u0160",
        scaron: "\u0161",
        Yuml: "\u0178",
        circ: "\u02C6",
        tilde: "\u02DC",
        ensp: "\u2002",
        emsp: "\u2003",
        thinsp: "\u2009",
        zwnj: "\u200C",
        zwj: "\u200D",
        lrm: "\u200E",
        rlm: "\u200F",
        ndash: "\u2013",
        mdash: "\u2014",
        lsquo: "\u2018",
        rsquo: "\u2019",
        sbquo: "\u201A",
        ldquo: "\u201C",
        rdquo: "\u201D",
        bdquo: "\u201E",
        dagger: "\u2020",
        Dagger: "\u2021",
        permil: "\u2030",
        lsaquo: "\u2039",
        rsaquo: "\u203A",
        euro: "\u20AC"
      };
    }
  });

  // node_modules/stringify-entities/lib/constant/dangerous.js
  var dangerous;
  var init_dangerous = __esm({
    "node_modules/stringify-entities/lib/constant/dangerous.js"() {
      dangerous = [
        "cent",
        "copy",
        "divide",
        "gt",
        "lt",
        "not",
        "para",
        "times"
      ];
    }
  });

  // node_modules/stringify-entities/lib/util/to-named.js
  function toNamed(code5, next2, omit, attribute) {
    const character = String.fromCharCode(code5);
    if (own3.call(characters, character)) {
      const name = characters[character];
      const value = "&" + name;
      if (omit && characterEntitiesLegacy.includes(name) && !dangerous.includes(name) && (!attribute || next2 && next2 !== 61 && notAlphanumericRegex.test(String.fromCharCode(next2)))) {
        return value;
      }
      return value + ";";
    }
    return "";
  }
  var own3, characters, key, notAlphanumericRegex;
  var init_to_named = __esm({
    "node_modules/stringify-entities/lib/util/to-named.js"() {
      init_character_entities_legacy();
      init_character_entities_html4();
      init_dangerous();
      own3 = {}.hasOwnProperty;
      characters = {};
      for (key in characterEntitiesHtml4) {
        if (own3.call(characterEntitiesHtml4, key)) {
          characters[characterEntitiesHtml4[key]] = key;
        }
      }
      notAlphanumericRegex = /[^\dA-Za-z]/;
    }
  });

  // node_modules/stringify-entities/lib/util/format-smart.js
  function formatSmart(code5, next2, options2) {
    let numeric2 = toHexadecimal(code5, next2, options2.omitOptionalSemicolons);
    let named;
    if (options2.useNamedReferences || options2.useShortestReferences) {
      named = toNamed(
        code5,
        next2,
        options2.omitOptionalSemicolons,
        options2.attribute
      );
    }
    if ((options2.useShortestReferences || !named) && options2.useShortestReferences) {
      const decimal = toDecimal(code5, next2, options2.omitOptionalSemicolons);
      if (decimal.length < numeric2.length) {
        numeric2 = decimal;
      }
    }
    return named && (!options2.useShortestReferences || named.length < numeric2.length) ? named : numeric2;
  }
  var init_format_smart = __esm({
    "node_modules/stringify-entities/lib/util/format-smart.js"() {
      init_to_hexadecimal();
      init_to_decimal();
      init_to_named();
    }
  });

  // node_modules/stringify-entities/lib/util/format-basic.js
  function formatBasic(code5) {
    return "&#x" + code5.toString(16).toUpperCase() + ";";
  }
  var init_format_basic = __esm({
    "node_modules/stringify-entities/lib/util/format-basic.js"() {
    }
  });

  // node_modules/stringify-entities/lib/index.js
  function stringifyEntities(value, options2) {
    return core(value, Object.assign({ format: formatSmart }, options2));
  }
  function stringifyEntitiesLight(value, options2) {
    return core(value, Object.assign({ format: formatBasic }, options2));
  }
  var init_lib10 = __esm({
    "node_modules/stringify-entities/lib/index.js"() {
      init_core();
      init_format_smart();
      init_format_basic();
    }
  });

  // node_modules/stringify-entities/index.js
  var init_stringify_entities = __esm({
    "node_modules/stringify-entities/index.js"() {
      init_lib10();
    }
  });

  // node_modules/hast-util-to-html/lib/handle/comment.js
  function comment(node2, _1, _2, state) {
    return state.settings.bogusComments ? "<?" + stringifyEntities(
      node2.value,
      Object.assign({}, state.settings.characterReferences, {
        subset: bogusCommentEntitySubset
      })
    ) + ">" : "<!--" + node2.value.replace(htmlCommentRegex, encode3) + "-->";
    function encode3($0) {
      return stringifyEntities(
        $0,
        Object.assign({}, state.settings.characterReferences, {
          subset: commentEntitySubset
        })
      );
    }
  }
  var htmlCommentRegex, bogusCommentEntitySubset, commentEntitySubset;
  var init_comment = __esm({
    "node_modules/hast-util-to-html/lib/handle/comment.js"() {
      init_stringify_entities();
      htmlCommentRegex = /^>|^->|<!--|-->|--!>|<!-$/g;
      bogusCommentEntitySubset = [">"];
      commentEntitySubset = ["<", ">"];
    }
  });

  // node_modules/hast-util-to-html/lib/handle/doctype.js
  function doctype(_1, _2, _3, state) {
    return "<!" + (state.settings.upperDoctype ? "DOCTYPE" : "doctype") + (state.settings.tightDoctype ? "" : " ") + "html>";
  }
  var init_doctype2 = __esm({
    "node_modules/hast-util-to-html/lib/handle/doctype.js"() {
    }
  });

  // node_modules/ccount/index.js
  function ccount(value, character) {
    const source = String(value);
    if (typeof character !== "string") {
      throw new TypeError("Expected character");
    }
    let count = 0;
    let index3 = source.indexOf(character);
    while (index3 !== -1) {
      count++;
      index3 = source.indexOf(character, index3 + character.length);
    }
    return count;
  }
  var init_ccount = __esm({
    "node_modules/ccount/index.js"() {
    }
  });

  // node_modules/hast-util-whitespace/lib/index.js
  function whitespace(thing) {
    return typeof thing === "object" ? thing.type === "text" ? empty(thing.value) : false : empty(thing);
  }
  function empty(value) {
    return value.replace(re, "") === "";
  }
  var re;
  var init_lib11 = __esm({
    "node_modules/hast-util-whitespace/lib/index.js"() {
      re = /[ \t\n\f\r]/g;
    }
  });

  // node_modules/hast-util-whitespace/index.js
  var init_hast_util_whitespace = __esm({
    "node_modules/hast-util-whitespace/index.js"() {
      init_lib11();
    }
  });

  // node_modules/hast-util-to-html/lib/omission/util/siblings.js
  function siblings(increment2) {
    return sibling;
    function sibling(parent, index3, includeWhitespace) {
      const siblings2 = parent ? parent.children : emptyChildren;
      let offset = (index3 || 0) + increment2;
      let next2 = siblings2[offset];
      if (!includeWhitespace) {
        while (next2 && whitespace(next2)) {
          offset += increment2;
          next2 = siblings2[offset];
        }
      }
      return next2;
    }
  }
  var siblingAfter, siblingBefore, emptyChildren;
  var init_siblings = __esm({
    "node_modules/hast-util-to-html/lib/omission/util/siblings.js"() {
      init_hast_util_whitespace();
      siblingAfter = siblings(1);
      siblingBefore = siblings(-1);
      emptyChildren = [];
    }
  });

  // node_modules/hast-util-to-html/lib/omission/omission.js
  function omission(handlers4) {
    return omit;
    function omit(node2, index3, parent) {
      return own4.call(handlers4, node2.tagName) && handlers4[node2.tagName](node2, index3, parent);
    }
  }
  var own4;
  var init_omission = __esm({
    "node_modules/hast-util-to-html/lib/omission/omission.js"() {
      own4 = {}.hasOwnProperty;
    }
  });

  // node_modules/hast-util-to-html/lib/omission/closing.js
  function headOrColgroupOrCaption(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3, true);
    return !next2 || next2.type !== "comment" && !(next2.type === "text" && whitespace(next2.value.charAt(0)));
  }
  function html3(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return !next2 || next2.type !== "comment";
  }
  function body(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return !next2 || next2.type !== "comment";
  }
  function p(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return next2 ? next2.type === "element" && (next2.tagName === "address" || next2.tagName === "article" || next2.tagName === "aside" || next2.tagName === "blockquote" || next2.tagName === "details" || next2.tagName === "div" || next2.tagName === "dl" || next2.tagName === "fieldset" || next2.tagName === "figcaption" || next2.tagName === "figure" || next2.tagName === "footer" || next2.tagName === "form" || next2.tagName === "h1" || next2.tagName === "h2" || next2.tagName === "h3" || next2.tagName === "h4" || next2.tagName === "h5" || next2.tagName === "h6" || next2.tagName === "header" || next2.tagName === "hgroup" || next2.tagName === "hr" || next2.tagName === "main" || next2.tagName === "menu" || next2.tagName === "nav" || next2.tagName === "ol" || next2.tagName === "p" || next2.tagName === "pre" || next2.tagName === "section" || next2.tagName === "table" || next2.tagName === "ul") : !parent || // Confusing parent.
    !(parent.type === "element" && (parent.tagName === "a" || parent.tagName === "audio" || parent.tagName === "del" || parent.tagName === "ins" || parent.tagName === "map" || parent.tagName === "noscript" || parent.tagName === "video"));
  }
  function li(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return !next2 || next2.type === "element" && next2.tagName === "li";
  }
  function dt(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return Boolean(
      next2 && next2.type === "element" && (next2.tagName === "dt" || next2.tagName === "dd")
    );
  }
  function dd(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return !next2 || next2.type === "element" && (next2.tagName === "dt" || next2.tagName === "dd");
  }
  function rubyElement(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return !next2 || next2.type === "element" && (next2.tagName === "rp" || next2.tagName === "rt");
  }
  function optgroup(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return !next2 || next2.type === "element" && next2.tagName === "optgroup";
  }
  function option(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return !next2 || next2.type === "element" && (next2.tagName === "option" || next2.tagName === "optgroup");
  }
  function thead(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return Boolean(
      next2 && next2.type === "element" && (next2.tagName === "tbody" || next2.tagName === "tfoot")
    );
  }
  function tbody(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return !next2 || next2.type === "element" && (next2.tagName === "tbody" || next2.tagName === "tfoot");
  }
  function tfoot(_2, index3, parent) {
    return !siblingAfter(parent, index3);
  }
  function tr(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return !next2 || next2.type === "element" && next2.tagName === "tr";
  }
  function cells(_2, index3, parent) {
    const next2 = siblingAfter(parent, index3);
    return !next2 || next2.type === "element" && (next2.tagName === "td" || next2.tagName === "th");
  }
  var closing;
  var init_closing = __esm({
    "node_modules/hast-util-to-html/lib/omission/closing.js"() {
      init_hast_util_whitespace();
      init_siblings();
      init_omission();
      closing = omission({
        body,
        caption: headOrColgroupOrCaption,
        colgroup: headOrColgroupOrCaption,
        dd,
        dt,
        head: headOrColgroupOrCaption,
        html: html3,
        li,
        optgroup,
        option,
        p,
        rp: rubyElement,
        rt: rubyElement,
        tbody,
        td: cells,
        tfoot,
        th: cells,
        thead,
        tr
      });
    }
  });

  // node_modules/hast-util-to-html/lib/omission/opening.js
  function html4(node2) {
    const head2 = siblingAfter(node2, -1);
    return !head2 || head2.type !== "comment";
  }
  function head(node2) {
    const seen = /* @__PURE__ */ new Set();
    for (const child2 of node2.children) {
      if (child2.type === "element" && (child2.tagName === "base" || child2.tagName === "title")) {
        if (seen.has(child2.tagName)) return false;
        seen.add(child2.tagName);
      }
    }
    const child = node2.children[0];
    return !child || child.type === "element";
  }
  function body2(node2) {
    const head2 = siblingAfter(node2, -1, true);
    return !head2 || head2.type !== "comment" && !(head2.type === "text" && whitespace(head2.value.charAt(0))) && !(head2.type === "element" && (head2.tagName === "meta" || head2.tagName === "link" || head2.tagName === "script" || head2.tagName === "style" || head2.tagName === "template"));
  }
  function colgroup(node2, index3, parent) {
    const previous3 = siblingBefore(parent, index3);
    const head2 = siblingAfter(node2, -1, true);
    if (parent && previous3 && previous3.type === "element" && previous3.tagName === "colgroup" && closing(previous3, parent.children.indexOf(previous3), parent)) {
      return false;
    }
    return Boolean(head2 && head2.type === "element" && head2.tagName === "col");
  }
  function tbody2(node2, index3, parent) {
    const previous3 = siblingBefore(parent, index3);
    const head2 = siblingAfter(node2, -1);
    if (parent && previous3 && previous3.type === "element" && (previous3.tagName === "thead" || previous3.tagName === "tbody") && closing(previous3, parent.children.indexOf(previous3), parent)) {
      return false;
    }
    return Boolean(head2 && head2.type === "element" && head2.tagName === "tr");
  }
  var opening;
  var init_opening = __esm({
    "node_modules/hast-util-to-html/lib/omission/opening.js"() {
      init_hast_util_whitespace();
      init_siblings();
      init_closing();
      init_omission();
      opening = omission({
        body: body2,
        colgroup,
        head,
        html: html4,
        tbody: tbody2
      });
    }
  });

  // node_modules/hast-util-to-html/lib/handle/element.js
  function element2(node2, index3, parent, state) {
    const schema = state.schema;
    const omit = schema.space === "svg" ? false : state.settings.omitOptionalTags;
    let selfClosing = schema.space === "svg" ? state.settings.closeEmptyElements : state.settings.voids.includes(node2.tagName.toLowerCase());
    const parts = [];
    let last2;
    if (schema.space === "html" && node2.tagName === "svg") {
      state.schema = svg2;
    }
    const attributes = serializeAttributes2(state, node2.properties);
    const content5 = state.all(
      schema.space === "html" && node2.tagName === "template" ? node2.content : node2
    );
    state.schema = schema;
    if (content5) selfClosing = false;
    if (attributes || !omit || !opening(node2, index3, parent)) {
      parts.push("<", node2.tagName, attributes ? " " + attributes : "");
      if (selfClosing && (schema.space === "svg" || state.settings.closeSelfClosing)) {
        last2 = attributes.charAt(attributes.length - 1);
        if (!state.settings.tightSelfClosing || last2 === "/" || last2 && last2 !== '"' && last2 !== "'") {
          parts.push(" ");
        }
        parts.push("/");
      }
      parts.push(">");
    }
    parts.push(content5);
    if (!selfClosing && (!omit || !closing(node2, index3, parent))) {
      parts.push("</" + node2.tagName + ">");
    }
    return parts.join("");
  }
  function serializeAttributes2(state, properties) {
    const values = [];
    let index3 = -1;
    let key2;
    if (properties) {
      for (key2 in properties) {
        if (properties[key2] !== null && properties[key2] !== void 0) {
          const value = serializeAttribute(state, key2, properties[key2]);
          if (value) values.push(value);
        }
      }
    }
    while (++index3 < values.length) {
      const last2 = state.settings.tightAttributes ? values[index3].charAt(values[index3].length - 1) : void 0;
      if (index3 !== values.length - 1 && last2 !== '"' && last2 !== "'") {
        values[index3] += " ";
      }
    }
    return values.join("");
  }
  function serializeAttribute(state, key2, value) {
    const info = find(state.schema, key2);
    const x = state.settings.allowParseErrors && state.schema.space === "html" ? 0 : 1;
    const y = state.settings.allowDangerousCharacters ? 0 : 1;
    let quote = state.quote;
    let result;
    if (info.overloadedBoolean && (value === info.attribute || value === "")) {
      value = true;
    } else if ((info.boolean || info.overloadedBoolean) && (typeof value !== "string" || value === info.attribute || value === "")) {
      value = Boolean(value);
    }
    if (value === null || value === void 0 || value === false || typeof value === "number" && Number.isNaN(value)) {
      return "";
    }
    const name = stringifyEntities(
      info.attribute,
      Object.assign({}, state.settings.characterReferences, {
        // Always encode without parse errors in non-HTML.
        subset: constants.name[x][y]
      })
    );
    if (value === true) return name;
    value = Array.isArray(value) ? (info.commaSeparated ? stringify : stringify2)(value, {
      padLeft: !state.settings.tightCommaSeparatedLists
    }) : String(value);
    if (state.settings.collapseEmptyAttributes && !value) return name;
    if (state.settings.preferUnquoted) {
      result = stringifyEntities(
        value,
        Object.assign({}, state.settings.characterReferences, {
          attribute: true,
          subset: constants.unquoted[x][y]
        })
      );
    }
    if (result !== value) {
      if (state.settings.quoteSmart && ccount(value, quote) > ccount(value, state.alternative)) {
        quote = state.alternative;
      }
      result = quote + stringifyEntities(
        value,
        Object.assign({}, state.settings.characterReferences, {
          // Always encode without parse errors in non-HTML.
          subset: (quote === "'" ? constants.single : constants.double)[x][y],
          attribute: true
        })
      ) + quote;
    }
    return name + (result ? "=" + result : result);
  }
  var constants;
  var init_element = __esm({
    "node_modules/hast-util-to-html/lib/handle/element.js"() {
      init_ccount();
      init_comma_separated_tokens();
      init_property_information();
      init_space_separated_tokens();
      init_stringify_entities();
      init_closing();
      init_opening();
      constants = {
        // See: <https://html.spec.whatwg.org/#attribute-name-state>.
        name: [
          ["	\n\f\r &/=>".split(""), "	\n\f\r \"&'/=>`".split("")],
          [`\0	
\f\r "&'/<=>`.split(""), "\0	\n\f\r \"&'/<=>`".split("")]
        ],
        // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
        unquoted: [
          ["	\n\f\r &>".split(""), "\0	\n\f\r \"&'<=>`".split("")],
          ["\0	\n\f\r \"&'<=>`".split(""), "\0	\n\f\r \"&'<=>`".split("")]
        ],
        // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
        single: [
          ["&'".split(""), "\"&'`".split("")],
          ["\0&'".split(""), "\0\"&'`".split("")]
        ],
        // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
        double: [
          ['"&'.split(""), "\"&'`".split("")],
          ['\0"&'.split(""), "\0\"&'`".split("")]
        ]
      };
    }
  });

  // node_modules/hast-util-to-html/lib/handle/text.js
  function text(node2, _2, parent, state) {
    return parent && parent.type === "element" && (parent.tagName === "script" || parent.tagName === "style") ? node2.value : stringifyEntities(
      node2.value,
      Object.assign({}, state.settings.characterReferences, {
        subset: textEntitySubset
      })
    );
  }
  var textEntitySubset;
  var init_text = __esm({
    "node_modules/hast-util-to-html/lib/handle/text.js"() {
      init_stringify_entities();
      textEntitySubset = ["<", "&"];
    }
  });

  // node_modules/hast-util-to-html/lib/handle/raw.js
  function raw(node2, index3, parent, state) {
    return state.settings.allowDangerousHtml ? node2.value : text(node2, index3, parent, state);
  }
  var init_raw = __esm({
    "node_modules/hast-util-to-html/lib/handle/raw.js"() {
      init_text();
    }
  });

  // node_modules/hast-util-to-html/lib/handle/root.js
  function root(node2, _1, _2, state) {
    return state.all(node2);
  }
  var init_root = __esm({
    "node_modules/hast-util-to-html/lib/handle/root.js"() {
    }
  });

  // node_modules/hast-util-to-html/lib/handle/index.js
  function invalid(node2) {
    throw new Error("Expected node, not `" + node2 + "`");
  }
  function unknown(node_) {
    const node2 = (
      /** @type {Nodes} */
      node_
    );
    throw new Error("Cannot compile unknown node `" + node2.type + "`");
  }
  var handle;
  var init_handle = __esm({
    "node_modules/hast-util-to-html/lib/handle/index.js"() {
      init_zwitch();
      init_comment();
      init_doctype2();
      init_element();
      init_raw();
      init_root();
      init_text();
      handle = zwitch("type", {
        invalid,
        unknown,
        handlers: { comment, doctype, element: element2, raw, root, text }
      });
    }
  });

  // node_modules/hast-util-to-html/lib/index.js
  function toHtml(tree, options2) {
    const options_ = options2 || emptyOptions2;
    const quote = options_.quote || '"';
    const alternative = quote === '"' ? "'" : '"';
    if (quote !== '"' && quote !== "'") {
      throw new Error("Invalid quote `" + quote + "`, expected `'` or `\"`");
    }
    const state = {
      one: one2,
      all: all2,
      settings: {
        omitOptionalTags: options_.omitOptionalTags || false,
        allowParseErrors: options_.allowParseErrors || false,
        allowDangerousCharacters: options_.allowDangerousCharacters || false,
        quoteSmart: options_.quoteSmart || false,
        preferUnquoted: options_.preferUnquoted || false,
        tightAttributes: options_.tightAttributes || false,
        upperDoctype: options_.upperDoctype || false,
        tightDoctype: options_.tightDoctype || false,
        bogusComments: options_.bogusComments || false,
        tightCommaSeparatedLists: options_.tightCommaSeparatedLists || false,
        tightSelfClosing: options_.tightSelfClosing || false,
        collapseEmptyAttributes: options_.collapseEmptyAttributes || false,
        allowDangerousHtml: options_.allowDangerousHtml || false,
        voids: options_.voids || htmlVoidElements,
        characterReferences: options_.characterReferences || emptyCharacterReferences,
        closeSelfClosing: options_.closeSelfClosing || false,
        closeEmptyElements: options_.closeEmptyElements || false
      },
      schema: options_.space === "svg" ? svg2 : html2,
      quote,
      alternative
    };
    return state.one(
      Array.isArray(tree) ? { type: "root", children: tree } : tree,
      void 0,
      void 0
    );
  }
  function one2(node2, index3, parent) {
    return handle(node2, index3, parent, this);
  }
  function all2(parent) {
    const results = [];
    const children = parent && parent.children || emptyChildren2;
    let index3 = -1;
    while (++index3 < children.length) {
      results[index3] = this.one(children[index3], index3, parent);
    }
    return results.join("");
  }
  var emptyOptions2, emptyCharacterReferences, emptyChildren2;
  var init_lib12 = __esm({
    "node_modules/hast-util-to-html/lib/index.js"() {
      init_html_void_elements();
      init_property_information();
      init_handle();
      emptyOptions2 = {};
      emptyCharacterReferences = {};
      emptyChildren2 = [];
    }
  });

  // node_modules/hast-util-to-html/index.js
  var init_hast_util_to_html = __esm({
    "node_modules/hast-util-to-html/index.js"() {
      init_lib12();
    }
  });

  // node_modules/rehype-stringify/lib/index.js
  function rehypeStringify(options2) {
    const self2 = this;
    const settings = { ...self2.data("settings"), ...options2 };
    self2.compiler = compiler2;
    function compiler2(tree) {
      return toHtml(tree, settings);
    }
  }
  var init_lib13 = __esm({
    "node_modules/rehype-stringify/lib/index.js"() {
      init_hast_util_to_html();
    }
  });

  // node_modules/rehype-stringify/index.js
  var rehype_stringify_exports = {};
  __export(rehype_stringify_exports, {
    default: () => rehypeStringify
  });
  var init_rehype_stringify = __esm({
    "node_modules/rehype-stringify/index.js"() {
      init_lib13();
    }
  });

  // node_modules/bail/index.js
  function bail(error) {
    if (error) {
      throw error;
    }
  }
  var init_bail = __esm({
    "node_modules/bail/index.js"() {
    }
  });

  // node_modules/extend/index.js
  var require_extend = __commonJS({
    "node_modules/extend/index.js"(exports, module) {
      "use strict";
      var hasOwn = Object.prototype.hasOwnProperty;
      var toStr = Object.prototype.toString;
      var defineProperty = Object.defineProperty;
      var gOPD = Object.getOwnPropertyDescriptor;
      var isArray3 = function isArray4(arr) {
        if (typeof Array.isArray === "function") {
          return Array.isArray(arr);
        }
        return toStr.call(arr) === "[object Array]";
      };
      var isPlainObject3 = function isPlainObject4(obj) {
        if (!obj || toStr.call(obj) !== "[object Object]") {
          return false;
        }
        var hasOwnConstructor = hasOwn.call(obj, "constructor");
        var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
        if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
          return false;
        }
        var key2;
        for (key2 in obj) {
        }
        return typeof key2 === "undefined" || hasOwn.call(obj, key2);
      };
      var setProperty = function setProperty2(target, options2) {
        if (defineProperty && options2.name === "__proto__") {
          defineProperty(target, options2.name, {
            enumerable: true,
            configurable: true,
            value: options2.newValue,
            writable: true
          });
        } else {
          target[options2.name] = options2.newValue;
        }
      };
      var getProperty = function getProperty2(obj, name) {
        if (name === "__proto__") {
          if (!hasOwn.call(obj, name)) {
            return void 0;
          } else if (gOPD) {
            return gOPD(obj, name).value;
          }
        }
        return obj[name];
      };
      module.exports = function extend2() {
        var options2, name, src, copy4, copyIsArray, clone2;
        var target = arguments[0];
        var i = 1;
        var length3 = arguments.length;
        var deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[1] || {};
          i = 2;
        }
        if (target == null || typeof target !== "object" && typeof target !== "function") {
          target = {};
        }
        for (; i < length3; ++i) {
          options2 = arguments[i];
          if (options2 != null) {
            for (name in options2) {
              src = getProperty(target, name);
              copy4 = getProperty(options2, name);
              if (target !== copy4) {
                if (deep && copy4 && (isPlainObject3(copy4) || (copyIsArray = isArray3(copy4)))) {
                  if (copyIsArray) {
                    copyIsArray = false;
                    clone2 = src && isArray3(src) ? src : [];
                  } else {
                    clone2 = src && isPlainObject3(src) ? src : {};
                  }
                  setProperty(target, { name, newValue: extend2(deep, clone2, copy4) });
                } else if (typeof copy4 !== "undefined") {
                  setProperty(target, { name, newValue: copy4 });
                }
              }
            }
          }
        }
        return target;
      };
    }
  });

  // node_modules/is-plain-obj/index.js
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  }
  var init_is_plain_obj = __esm({
    "node_modules/is-plain-obj/index.js"() {
    }
  });

  // node_modules/trough/lib/index.js
  function trough() {
    const fns = [];
    const pipeline = { run: run3, use };
    return pipeline;
    function run3(...values) {
      let middlewareIndex = -1;
      const callback = values.pop();
      if (typeof callback !== "function") {
        throw new TypeError("Expected function as last argument, not " + callback);
      }
      next2(null, ...values);
      function next2(error, ...output) {
        const fn2 = fns[++middlewareIndex];
        let index3 = -1;
        if (error) {
          callback(error);
          return;
        }
        while (++index3 < values.length) {
          if (output[index3] === null || output[index3] === void 0) {
            output[index3] = values[index3];
          }
        }
        values = output;
        if (fn2) {
          wrap(fn2, next2)(...output);
        } else {
          callback(null, ...output);
        }
      }
    }
    function use(middelware) {
      if (typeof middelware !== "function") {
        throw new TypeError(
          "Expected `middelware` to be a function, not " + middelware
        );
      }
      fns.push(middelware);
      return pipeline;
    }
  }
  function wrap(middleware, callback) {
    let called;
    return wrapped;
    function wrapped(...parameters) {
      const fnExpectsCallback = middleware.length > parameters.length;
      let result;
      if (fnExpectsCallback) {
        parameters.push(done);
      }
      try {
        result = middleware.apply(this, parameters);
      } catch (error) {
        const exception = (
          /** @type {Error} */
          error
        );
        if (fnExpectsCallback && called) {
          throw exception;
        }
        return done(exception);
      }
      if (!fnExpectsCallback) {
        if (result && result.then && typeof result.then === "function") {
          result.then(then, done);
        } else if (result instanceof Error) {
          done(result);
        } else {
          then(result);
        }
      }
    }
    function done(error, ...output) {
      if (!called) {
        called = true;
        callback(error, ...output);
      }
    }
    function then(value) {
      done(null, value);
    }
  }
  var init_lib14 = __esm({
    "node_modules/trough/lib/index.js"() {
    }
  });

  // node_modules/trough/index.js
  var init_trough = __esm({
    "node_modules/trough/index.js"() {
      init_lib14();
    }
  });

  // node_modules/unified/lib/callable-instance.js
  var CallableInstance;
  var init_callable_instance = __esm({
    "node_modules/unified/lib/callable-instance.js"() {
      CallableInstance = /**
       * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
       */
      /** @type {unknown} */
      /**
       * @this {Function}
       * @param {string | symbol} property
       * @returns {(...parameters: Array<unknown>) => unknown}
       */
      function(property) {
        const self2 = this;
        const constr = self2.constructor;
        const proto2 = (
          /** @type {Record<string | symbol, Function>} */
          // Prototypes do exist.
          // type-coverage:ignore-next-line
          constr.prototype
        );
        const value = proto2[property];
        const apply3 = function() {
          return value.apply(apply3, arguments);
        };
        Object.setPrototypeOf(apply3, proto2);
        return apply3;
      };
    }
  });

  // node_modules/unified/lib/index.js
  function assertParser(name, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name + "` without `parser`");
    }
  }
  function assertCompiler(name, value) {
    if (typeof value !== "function") {
      throw new TypeError("Cannot `" + name + "` without `compiler`");
    }
  }
  function assertUnfrozen(name, frozen) {
    if (frozen) {
      throw new Error(
        "Cannot call `" + name + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
      );
    }
  }
  function assertNode(node2) {
    if (!isPlainObject(node2) || typeof node2.type !== "string") {
      throw new TypeError("Expected node, got `" + node2 + "`");
    }
  }
  function assertDone(name, asyncName, complete) {
    if (!complete) {
      throw new Error(
        "`" + name + "` finished async. Use `" + asyncName + "` instead"
      );
    }
  }
  function vfile(value) {
    return looksLikeAVFile(value) ? value : new VFile(value);
  }
  function looksLikeAVFile(value) {
    return Boolean(
      value && typeof value === "object" && "message" in value && "messages" in value
    );
  }
  function looksLikeAValue(value) {
    return typeof value === "string" || isUint8Array2(value);
  }
  function isUint8Array2(value) {
    return Boolean(
      value && typeof value === "object" && "byteLength" in value && "byteOffset" in value
    );
  }
  var import_extend, own5, Processor, unified;
  var init_lib15 = __esm({
    "node_modules/unified/lib/index.js"() {
      init_bail();
      import_extend = __toESM(require_extend(), 1);
      init_default();
      init_is_plain_obj();
      init_trough();
      init_vfile();
      init_callable_instance();
      own5 = {}.hasOwnProperty;
      Processor = class _Processor extends CallableInstance {
        /**
         * Create a processor.
         */
        constructor() {
          super("copy");
          this.Compiler = void 0;
          this.Parser = void 0;
          this.attachers = [];
          this.compiler = void 0;
          this.freezeIndex = -1;
          this.frozen = void 0;
          this.namespace = {};
          this.parser = void 0;
          this.transformers = trough();
        }
        /**
         * Copy a processor.
         *
         * @deprecated
         *   This is a private internal method and should not be used.
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *   New *unfrozen* processor ({@linkcode Processor}) that is
         *   configured to work the same as its ancestor.
         *   When the descendant processor is configured in the future it does not
         *   affect the ancestral processor.
         */
        copy() {
          const destination = (
            /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
            new _Processor()
          );
          let index3 = -1;
          while (++index3 < this.attachers.length) {
            const attacher = this.attachers[index3];
            destination.use(...attacher);
          }
          destination.data((0, import_extend.default)(true, {}, this.namespace));
          return destination;
        }
        /**
         * Configure the processor with info available to all plugins.
         * Information is stored in an object.
         *
         * Typically, options can be given to a specific plugin, but sometimes it
         * makes sense to have information shared with several plugins.
         * For example, a list of HTML elements that are self-closing, which is
         * needed during all phases.
         *
         * > **Note**: setting information cannot occur on *frozen* processors.
         * > Call the processor first to create a new unfrozen processor.
         *
         * > **Note**: to register custom data in TypeScript, augment the
         * > {@linkcode Data} interface.
         *
         * @example
         *   This example show how to get and set info:
         *
         *   ```js
         *   import {unified} from 'unified'
         *
         *   const processor = unified().data('alpha', 'bravo')
         *
         *   processor.data('alpha') // => 'bravo'
         *
         *   processor.data() // => {alpha: 'bravo'}
         *
         *   processor.data({charlie: 'delta'})
         *
         *   processor.data() // => {charlie: 'delta'}
         *   ```
         *
         * @template {keyof Data} Key
         *
         * @overload
         * @returns {Data}
         *
         * @overload
         * @param {Data} dataset
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *
         * @overload
         * @param {Key} key
         * @returns {Data[Key]}
         *
         * @overload
         * @param {Key} key
         * @param {Data[Key]} value
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *
         * @param {Data | Key} [key]
         *   Key to get or set, or entire dataset to set, or nothing to get the
         *   entire dataset (optional).
         * @param {Data[Key]} [value]
         *   Value to set (optional).
         * @returns {unknown}
         *   The current processor when setting, the value at `key` when getting, or
         *   the entire dataset when getting without key.
         */
        data(key2, value) {
          if (typeof key2 === "string") {
            if (arguments.length === 2) {
              assertUnfrozen("data", this.frozen);
              this.namespace[key2] = value;
              return this;
            }
            return own5.call(this.namespace, key2) && this.namespace[key2] || void 0;
          }
          if (key2) {
            assertUnfrozen("data", this.frozen);
            this.namespace = key2;
            return this;
          }
          return this.namespace;
        }
        /**
         * Freeze a processor.
         *
         * Frozen processors are meant to be extended and not to be configured
         * directly.
         *
         * When a processor is frozen it cannot be unfrozen.
         * New processors working the same way can be created by calling the
         * processor.
         *
         * Its possible to freeze processors explicitly by calling `.freeze()`.
         * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
         * `.stringify()`, `.process()`, or `.processSync()` are called.
         *
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *   The current processor.
         */
        freeze() {
          if (this.frozen) {
            return this;
          }
          const self2 = (
            /** @type {Processor} */
            /** @type {unknown} */
            this
          );
          while (++this.freezeIndex < this.attachers.length) {
            const [attacher, ...options2] = this.attachers[this.freezeIndex];
            if (options2[0] === false) {
              continue;
            }
            if (options2[0] === true) {
              options2[0] = void 0;
            }
            const transformer = attacher.call(self2, ...options2);
            if (typeof transformer === "function") {
              this.transformers.use(transformer);
            }
          }
          this.frozen = true;
          this.freezeIndex = Number.POSITIVE_INFINITY;
          return this;
        }
        /**
         * Parse text to a syntax tree.
         *
         * > **Note**: `parse` freezes the processor if not already *frozen*.
         *
         * > **Note**: `parse` performs the parse phase, not the run phase or other
         * > phases.
         *
         * @param {Compatible | undefined} [file]
         *   file to parse (optional); typically `string` or `VFile`; any value
         *   accepted as `x` in `new VFile(x)`.
         * @returns {ParseTree extends undefined ? Node : ParseTree}
         *   Syntax tree representing `file`.
         */
        parse(file) {
          this.freeze();
          const realFile = vfile(file);
          const parser = this.parser || this.Parser;
          assertParser("parse", parser);
          return parser(String(realFile), realFile);
        }
        /**
         * Process the given file as configured on the processor.
         *
         * > **Note**: `process` freezes the processor if not already *frozen*.
         *
         * > **Note**: `process` performs the parse, run, and stringify phases.
         *
         * @overload
         * @param {Compatible | undefined} file
         * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
         * @returns {undefined}
         *
         * @overload
         * @param {Compatible | undefined} [file]
         * @returns {Promise<VFileWithOutput<CompileResult>>}
         *
         * @param {Compatible | undefined} [file]
         *   File (optional); typically `string` or `VFile`]; any value accepted as
         *   `x` in `new VFile(x)`.
         * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
         *   Callback (optional).
         * @returns {Promise<VFile> | undefined}
         *   Nothing if `done` is given.
         *   Otherwise a promise, rejected with a fatal error or resolved with the
         *   processed file.
         *
         *   The parsed, transformed, and compiled value is available at
         *   `file.value` (see note).
         *
         *   > **Note**: unified typically compiles by serializing: most
         *   > compilers return `string` (or `Uint8Array`).
         *   > Some compilers, such as the one configured with
         *   > [`rehype-react`][rehype-react], return other values (in this case, a
         *   > React tree).
         *   > If youre using a compiler that doesnt serialize, expect different
         *   > result values.
         *   >
         *   > To register custom results in TypeScript, add them to
         *   > {@linkcode CompileResultMap}.
         *
         *   [rehype-react]: https://github.com/rehypejs/rehype-react
         */
        process(file, done) {
          const self2 = this;
          this.freeze();
          assertParser("process", this.parser || this.Parser);
          assertCompiler("process", this.compiler || this.Compiler);
          return done ? executor(void 0, done) : new Promise(executor);
          function executor(resolve3, reject2) {
            const realFile = vfile(file);
            const parseTree = (
              /** @type {HeadTree extends undefined ? Node : HeadTree} */
              /** @type {unknown} */
              self2.parse(realFile)
            );
            self2.run(parseTree, realFile, function(error, tree, file2) {
              if (error || !tree || !file2) {
                return realDone(error);
              }
              const compileTree = (
                /** @type {CompileTree extends undefined ? Node : CompileTree} */
                /** @type {unknown} */
                tree
              );
              const compileResult = self2.stringify(compileTree, file2);
              if (looksLikeAValue(compileResult)) {
                file2.value = compileResult;
              } else {
                file2.result = compileResult;
              }
              realDone(
                error,
                /** @type {VFileWithOutput<CompileResult>} */
                file2
              );
            });
            function realDone(error, file2) {
              if (error || !file2) {
                reject2(error);
              } else if (resolve3) {
                resolve3(file2);
              } else {
                ok(done, "`done` is defined if `resolve` is not");
                done(void 0, file2);
              }
            }
          }
        }
        /**
         * Process the given file as configured on the processor.
         *
         * An error is thrown if asynchronous transforms are configured.
         *
         * > **Note**: `processSync` freezes the processor if not already *frozen*.
         *
         * > **Note**: `processSync` performs the parse, run, and stringify phases.
         *
         * @param {Compatible | undefined} [file]
         *   File (optional); typically `string` or `VFile`; any value accepted as
         *   `x` in `new VFile(x)`.
         * @returns {VFileWithOutput<CompileResult>}
         *   The processed file.
         *
         *   The parsed, transformed, and compiled value is available at
         *   `file.value` (see note).
         *
         *   > **Note**: unified typically compiles by serializing: most
         *   > compilers return `string` (or `Uint8Array`).
         *   > Some compilers, such as the one configured with
         *   > [`rehype-react`][rehype-react], return other values (in this case, a
         *   > React tree).
         *   > If youre using a compiler that doesnt serialize, expect different
         *   > result values.
         *   >
         *   > To register custom results in TypeScript, add them to
         *   > {@linkcode CompileResultMap}.
         *
         *   [rehype-react]: https://github.com/rehypejs/rehype-react
         */
        processSync(file) {
          let complete = false;
          let result;
          this.freeze();
          assertParser("processSync", this.parser || this.Parser);
          assertCompiler("processSync", this.compiler || this.Compiler);
          this.process(file, realDone);
          assertDone("processSync", "process", complete);
          ok(result, "we either bailed on an error or have a tree");
          return result;
          function realDone(error, file2) {
            complete = true;
            bail(error);
            result = file2;
          }
        }
        /**
         * Run *transformers* on a syntax tree.
         *
         * > **Note**: `run` freezes the processor if not already *frozen*.
         *
         * > **Note**: `run` performs the run phase, not other phases.
         *
         * @overload
         * @param {HeadTree extends undefined ? Node : HeadTree} tree
         * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
         * @returns {undefined}
         *
         * @overload
         * @param {HeadTree extends undefined ? Node : HeadTree} tree
         * @param {Compatible | undefined} file
         * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
         * @returns {undefined}
         *
         * @overload
         * @param {HeadTree extends undefined ? Node : HeadTree} tree
         * @param {Compatible | undefined} [file]
         * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
         *
         * @param {HeadTree extends undefined ? Node : HeadTree} tree
         *   Tree to transform and inspect.
         * @param {(
         *   RunCallback<TailTree extends undefined ? Node : TailTree> |
         *   Compatible
         * )} [file]
         *   File associated with `node` (optional); any value accepted as `x` in
         *   `new VFile(x)`.
         * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
         *   Callback (optional).
         * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
         *   Nothing if `done` is given.
         *   Otherwise, a promise rejected with a fatal error or resolved with the
         *   transformed tree.
         */
        run(tree, file, done) {
          assertNode(tree);
          this.freeze();
          const transformers = this.transformers;
          if (!done && typeof file === "function") {
            done = file;
            file = void 0;
          }
          return done ? executor(void 0, done) : new Promise(executor);
          function executor(resolve3, reject2) {
            ok(
              typeof file !== "function",
              "`file` can\u2019t be a `done` anymore, we checked"
            );
            const realFile = vfile(file);
            transformers.run(tree, realFile, realDone);
            function realDone(error, outputTree, file2) {
              const resultingTree = (
                /** @type {TailTree extends undefined ? Node : TailTree} */
                outputTree || tree
              );
              if (error) {
                reject2(error);
              } else if (resolve3) {
                resolve3(resultingTree);
              } else {
                ok(done, "`done` is defined if `resolve` is not");
                done(void 0, resultingTree, file2);
              }
            }
          }
        }
        /**
         * Run *transformers* on a syntax tree.
         *
         * An error is thrown if asynchronous transforms are configured.
         *
         * > **Note**: `runSync` freezes the processor if not already *frozen*.
         *
         * > **Note**: `runSync` performs the run phase, not other phases.
         *
         * @param {HeadTree extends undefined ? Node : HeadTree} tree
         *   Tree to transform and inspect.
         * @param {Compatible | undefined} [file]
         *   File associated with `node` (optional); any value accepted as `x` in
         *   `new VFile(x)`.
         * @returns {TailTree extends undefined ? Node : TailTree}
         *   Transformed tree.
         */
        runSync(tree, file) {
          let complete = false;
          let result;
          this.run(tree, file, realDone);
          assertDone("runSync", "run", complete);
          ok(result, "we either bailed on an error or have a tree");
          return result;
          function realDone(error, tree2) {
            bail(error);
            result = tree2;
            complete = true;
          }
        }
        /**
         * Compile a syntax tree.
         *
         * > **Note**: `stringify` freezes the processor if not already *frozen*.
         *
         * > **Note**: `stringify` performs the stringify phase, not the run phase
         * > or other phases.
         *
         * @param {CompileTree extends undefined ? Node : CompileTree} tree
         *   Tree to compile.
         * @param {Compatible | undefined} [file]
         *   File associated with `node` (optional); any value accepted as `x` in
         *   `new VFile(x)`.
         * @returns {CompileResult extends undefined ? Value : CompileResult}
         *   Textual representation of the tree (see note).
         *
         *   > **Note**: unified typically compiles by serializing: most compilers
         *   > return `string` (or `Uint8Array`).
         *   > Some compilers, such as the one configured with
         *   > [`rehype-react`][rehype-react], return other values (in this case, a
         *   > React tree).
         *   > If youre using a compiler that doesnt serialize, expect different
         *   > result values.
         *   >
         *   > To register custom results in TypeScript, add them to
         *   > {@linkcode CompileResultMap}.
         *
         *   [rehype-react]: https://github.com/rehypejs/rehype-react
         */
        stringify(tree, file) {
          this.freeze();
          const realFile = vfile(file);
          const compiler2 = this.compiler || this.Compiler;
          assertCompiler("stringify", compiler2);
          assertNode(tree);
          return compiler2(tree, realFile);
        }
        /**
         * Configure the processor to use a plugin, a list of usable values, or a
         * preset.
         *
         * If the processor is already using a plugin, the previous plugin
         * configuration is changed based on the options that are passed in.
         * In other words, the plugin is not added a second time.
         *
         * > **Note**: `use` cannot be called on *frozen* processors.
         * > Call the processor first to create a new unfrozen processor.
         *
         * @example
         *   There are many ways to pass plugins to `.use()`.
         *   This example gives an overview:
         *
         *   ```js
         *   import {unified} from 'unified'
         *
         *   unified()
         *     // Plugin with options:
         *     .use(pluginA, {x: true, y: true})
         *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
         *     .use(pluginA, {y: false, z: true})
         *     // Plugins:
         *     .use([pluginB, pluginC])
         *     // Two plugins, the second with options:
         *     .use([pluginD, [pluginE, {}]])
         *     // Preset with plugins and settings:
         *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
         *     // Settings only:
         *     .use({settings: {position: false}})
         *   ```
         *
         * @template {Array<unknown>} [Parameters=[]]
         * @template {Node | string | undefined} [Input=undefined]
         * @template [Output=Input]
         *
         * @overload
         * @param {Preset | null | undefined} [preset]
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *
         * @overload
         * @param {PluggableList} list
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *
         * @overload
         * @param {Plugin<Parameters, Input, Output>} plugin
         * @param {...(Parameters | [boolean])} parameters
         * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
         *
         * @param {PluggableList | Plugin | Preset | null | undefined} value
         *   Usable value.
         * @param {...unknown} parameters
         *   Parameters, when a plugin is given as a usable value.
         * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
         *   Current processor.
         */
        use(value, ...parameters) {
          const attachers = this.attachers;
          const namespace = this.namespace;
          assertUnfrozen("use", this.frozen);
          if (value === null || value === void 0) {
          } else if (typeof value === "function") {
            addPlugin(value, parameters);
          } else if (typeof value === "object") {
            if (Array.isArray(value)) {
              addList(value);
            } else {
              addPreset(value);
            }
          } else {
            throw new TypeError("Expected usable value, not `" + value + "`");
          }
          return this;
          function add3(value2) {
            if (typeof value2 === "function") {
              addPlugin(value2, []);
            } else if (typeof value2 === "object") {
              if (Array.isArray(value2)) {
                const [plugin, ...parameters2] = (
                  /** @type {PluginTuple<Array<unknown>>} */
                  value2
                );
                addPlugin(plugin, parameters2);
              } else {
                addPreset(value2);
              }
            } else {
              throw new TypeError("Expected usable value, not `" + value2 + "`");
            }
          }
          function addPreset(result) {
            if (!("plugins" in result) && !("settings" in result)) {
              throw new Error(
                "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
              );
            }
            addList(result.plugins);
            if (result.settings) {
              namespace.settings = (0, import_extend.default)(true, namespace.settings, result.settings);
            }
          }
          function addList(plugins) {
            let index3 = -1;
            if (plugins === null || plugins === void 0) {
            } else if (Array.isArray(plugins)) {
              while (++index3 < plugins.length) {
                const thing = plugins[index3];
                add3(thing);
              }
            } else {
              throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
            }
          }
          function addPlugin(plugin, parameters2) {
            let index3 = -1;
            let entryIndex = -1;
            while (++index3 < attachers.length) {
              if (attachers[index3][0] === plugin) {
                entryIndex = index3;
                break;
              }
            }
            if (entryIndex === -1) {
              attachers.push([plugin, ...parameters2]);
            } else if (parameters2.length > 0) {
              let [primary, ...rest] = parameters2;
              const currentPrimary = attachers[entryIndex][1];
              if (isPlainObject(currentPrimary) && isPlainObject(primary)) {
                primary = (0, import_extend.default)(true, currentPrimary, primary);
              }
              attachers[entryIndex] = [plugin, primary, ...rest];
            }
          }
        }
      };
      unified = new Processor().freeze();
    }
  });

  // node_modules/unified/index.js
  var unified_exports = {};
  __export(unified_exports, {
    unified: () => unified
  });
  var init_unified = __esm({
    "node_modules/unified/index.js"() {
      init_lib15();
    }
  });

  // node_modules/hast-util-from-dom/lib/index.js
  function fromDom(tree, options2) {
    return transform(tree, options2 || {}) || { type: "root", children: [] };
  }
  function transform(node2, options2) {
    const transformed = one3(node2, options2);
    if (transformed && options2.afterTransform)
      options2.afterTransform(node2, transformed);
    return transformed;
  }
  function one3(node2, options2) {
    switch (node2.nodeType) {
      case 1: {
        const domNode = (
          /** @type {Element} */
          node2
        );
        return element3(domNode, options2);
      }
      // Ignore: Attr (2).
      case 3: {
        const domNode = (
          /** @type {Text} */
          node2
        );
        return text2(domNode);
      }
      // Ignore: CDATA (4).
      // Removed: Entity reference (5)
      // Removed: Entity (6)
      // Ignore: Processing instruction (7).
      case 8: {
        const domNode = (
          /** @type {Comment} */
          node2
        );
        return comment2(domNode);
      }
      case 9: {
        const domNode = (
          /** @type {Document} */
          node2
        );
        return root2(domNode, options2);
      }
      case 10: {
        return doctype2();
      }
      case 11: {
        const domNode = (
          /** @type {DocumentFragment} */
          node2
        );
        return root2(domNode, options2);
      }
      default: {
        return void 0;
      }
    }
  }
  function root2(node2, options2) {
    return { type: "root", children: all3(node2, options2) };
  }
  function doctype2() {
    return { type: "doctype" };
  }
  function text2(node2) {
    return { type: "text", value: node2.nodeValue || "" };
  }
  function comment2(node2) {
    return { type: "comment", value: node2.nodeValue || "" };
  }
  function element3(node2, options2) {
    const space2 = node2.namespaceURI;
    const x = space2 === webNamespaces.svg ? s : h;
    const tagName = space2 === webNamespaces.html ? node2.tagName.toLowerCase() : node2.tagName;
    const content5 = (
      // @ts-expect-error: DOM types are wrong, content can exist.
      space2 === webNamespaces.html && tagName === "template" ? node2.content : node2
    );
    const attributes = node2.getAttributeNames();
    const properties = {};
    let index3 = -1;
    while (++index3 < attributes.length) {
      properties[attributes[index3]] = node2.getAttribute(attributes[index3]) || "";
    }
    return x(tagName, properties, all3(content5, options2));
  }
  function all3(node2, options2) {
    const nodes = node2.childNodes;
    const children = [];
    let index3 = -1;
    while (++index3 < nodes.length) {
      const child = transform(nodes[index3], options2);
      if (child !== void 0) {
        children.push(child);
      }
    }
    return children;
  }
  var init_lib16 = __esm({
    "node_modules/hast-util-from-dom/lib/index.js"() {
      init_hastscript();
      init_web_namespaces();
    }
  });

  // node_modules/hast-util-from-dom/index.js
  var hast_util_from_dom_exports = {};
  __export(hast_util_from_dom_exports, {
    fromDom: () => fromDom
  });
  var init_hast_util_from_dom = __esm({
    "node_modules/hast-util-from-dom/index.js"() {
      init_lib16();
    }
  });

  // node_modules/@ungap/structured-clone/esm/types.js
  var VOID, PRIMITIVE, ARRAY, OBJECT, DATE, REGEXP, MAP, SET, ERROR, BIGINT;
  var init_types2 = __esm({
    "node_modules/@ungap/structured-clone/esm/types.js"() {
      VOID = -1;
      PRIMITIVE = 0;
      ARRAY = 1;
      OBJECT = 2;
      DATE = 3;
      REGEXP = 4;
      MAP = 5;
      SET = 6;
      ERROR = 7;
      BIGINT = 8;
    }
  });

  // node_modules/@ungap/structured-clone/esm/deserialize.js
  var env, deserializer, deserialize;
  var init_deserialize = __esm({
    "node_modules/@ungap/structured-clone/esm/deserialize.js"() {
      init_types2();
      env = typeof self === "object" ? self : globalThis;
      deserializer = ($2, _2) => {
        const as2 = (out, index3) => {
          $2.set(index3, out);
          return out;
        };
        const unpair = (index3) => {
          if ($2.has(index3))
            return $2.get(index3);
          const [type, value] = _2[index3];
          switch (type) {
            case PRIMITIVE:
            case VOID:
              return as2(value, index3);
            case ARRAY: {
              const arr = as2([], index3);
              for (const index4 of value)
                arr.push(unpair(index4));
              return arr;
            }
            case OBJECT: {
              const object = as2({}, index3);
              for (const [key2, index4] of value)
                object[unpair(key2)] = unpair(index4);
              return object;
            }
            case DATE:
              return as2(new Date(value), index3);
            case REGEXP: {
              const { source, flags } = value;
              return as2(new RegExp(source, flags), index3);
            }
            case MAP: {
              const map9 = as2(/* @__PURE__ */ new Map(), index3);
              for (const [key2, index4] of value)
                map9.set(unpair(key2), unpair(index4));
              return map9;
            }
            case SET: {
              const set2 = as2(/* @__PURE__ */ new Set(), index3);
              for (const index4 of value)
                set2.add(unpair(index4));
              return set2;
            }
            case ERROR: {
              const { name, message } = value;
              return as2(new env[name](message), index3);
            }
            case BIGINT:
              return as2(BigInt(value), index3);
            case "BigInt":
              return as2(Object(BigInt(value)), index3);
            case "ArrayBuffer":
              return as2(new Uint8Array(value).buffer, value);
            case "DataView": {
              const { buffer } = new Uint8Array(value);
              return as2(new DataView(buffer), value);
            }
          }
          return as2(new env[type](value), index3);
        };
        return unpair;
      };
      deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);
    }
  });

  // node_modules/@ungap/structured-clone/esm/serialize.js
  var EMPTY, toString, keys, typeOf, shouldSkip, serializer, serialize2;
  var init_serialize = __esm({
    "node_modules/@ungap/structured-clone/esm/serialize.js"() {
      init_types2();
      EMPTY = "";
      ({ toString } = {});
      ({ keys } = Object);
      typeOf = (value) => {
        const type = typeof value;
        if (type !== "object" || !value)
          return [PRIMITIVE, type];
        const asString = toString.call(value).slice(8, -1);
        switch (asString) {
          case "Array":
            return [ARRAY, EMPTY];
          case "Object":
            return [OBJECT, EMPTY];
          case "Date":
            return [DATE, EMPTY];
          case "RegExp":
            return [REGEXP, EMPTY];
          case "Map":
            return [MAP, EMPTY];
          case "Set":
            return [SET, EMPTY];
          case "DataView":
            return [ARRAY, asString];
        }
        if (asString.includes("Array"))
          return [ARRAY, asString];
        if (asString.includes("Error"))
          return [ERROR, asString];
        return [OBJECT, asString];
      };
      shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === "function" || type === "symbol");
      serializer = (strict, json, $2, _2) => {
        const as2 = (out, value) => {
          const index3 = _2.push(out) - 1;
          $2.set(value, index3);
          return index3;
        };
        const pair = (value) => {
          if ($2.has(value))
            return $2.get(value);
          let [TYPE, type] = typeOf(value);
          switch (TYPE) {
            case PRIMITIVE: {
              let entry = value;
              switch (type) {
                case "bigint":
                  TYPE = BIGINT;
                  entry = value.toString();
                  break;
                case "function":
                case "symbol":
                  if (strict)
                    throw new TypeError("unable to serialize " + type);
                  entry = null;
                  break;
                case "undefined":
                  return as2([VOID], value);
              }
              return as2([TYPE, entry], value);
            }
            case ARRAY: {
              if (type) {
                let spread = value;
                if (type === "DataView") {
                  spread = new Uint8Array(value.buffer);
                } else if (type === "ArrayBuffer") {
                  spread = new Uint8Array(value);
                }
                return as2([type, [...spread]], value);
              }
              const arr = [];
              const index3 = as2([TYPE, arr], value);
              for (const entry of value)
                arr.push(pair(entry));
              return index3;
            }
            case OBJECT: {
              if (type) {
                switch (type) {
                  case "BigInt":
                    return as2([type, value.toString()], value);
                  case "Boolean":
                  case "Number":
                  case "String":
                    return as2([type, value.valueOf()], value);
                }
              }
              if (json && "toJSON" in value)
                return pair(value.toJSON());
              const entries = [];
              const index3 = as2([TYPE, entries], value);
              for (const key2 of keys(value)) {
                if (strict || !shouldSkip(typeOf(value[key2])))
                  entries.push([pair(key2), pair(value[key2])]);
              }
              return index3;
            }
            case DATE:
              return as2([TYPE, value.toISOString()], value);
            case REGEXP: {
              const { source, flags } = value;
              return as2([TYPE, { source, flags }], value);
            }
            case MAP: {
              const entries = [];
              const index3 = as2([TYPE, entries], value);
              for (const [key2, entry] of value) {
                if (strict || !(shouldSkip(typeOf(key2)) || shouldSkip(typeOf(entry))))
                  entries.push([pair(key2), pair(entry)]);
              }
              return index3;
            }
            case SET: {
              const entries = [];
              const index3 = as2([TYPE, entries], value);
              for (const entry of value) {
                if (strict || !shouldSkip(typeOf(entry)))
                  entries.push(pair(entry));
              }
              return index3;
            }
          }
          const { message } = value;
          return as2([TYPE, { name: type, message }], value);
        };
        return pair;
      };
      serialize2 = (value, { json, lossy } = {}) => {
        const _2 = [];
        return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _2)(value), _2;
      };
    }
  });

  // node_modules/@ungap/structured-clone/esm/index.js
  var esm_default;
  var init_esm = __esm({
    "node_modules/@ungap/structured-clone/esm/index.js"() {
      init_deserialize();
      init_serialize();
      esm_default = typeof structuredClone === "function" ? (
        /* c8 ignore start */
        (any2, options2) => options2 && ("json" in options2 || "lossy" in options2) ? deserialize(serialize2(any2, options2)) : structuredClone(any2)
      ) : (any2, options2) => deserialize(serialize2(any2, options2));
    }
  });

  // node_modules/hast-util-is-element/lib/index.js
  function anyFactory(tests) {
    const checks2 = [];
    let index3 = -1;
    while (++index3 < tests.length) {
      checks2[index3] = convertElement(tests[index3]);
    }
    return castFactory(any2);
    function any2(...parameters) {
      let index4 = -1;
      while (++index4 < checks2.length) {
        if (checks2[index4].apply(this, parameters)) return true;
      }
      return false;
    }
  }
  function tagNameFactory(check) {
    return castFactory(tagName);
    function tagName(element7) {
      return element7.tagName === check;
    }
  }
  function castFactory(testFunction) {
    return check;
    function check(value, index3, parent) {
      return Boolean(
        looksLikeAnElement(value) && testFunction.call(
          this,
          value,
          typeof index3 === "number" ? index3 : void 0,
          parent || void 0
        )
      );
    }
  }
  function element4(element7) {
    return Boolean(
      element7 && typeof element7 === "object" && "type" in element7 && element7.type === "element" && "tagName" in element7 && typeof element7.tagName === "string"
    );
  }
  function looksLikeAnElement(value) {
    return value !== null && typeof value === "object" && "type" in value && "tagName" in value;
  }
  var isElement, convertElement;
  var init_lib17 = __esm({
    "node_modules/hast-util-is-element/lib/index.js"() {
      isElement = // Note: overloads in JSDoc cant yet use different `@template`s.
      /**
       * @type {(
       *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
       *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
       *   ((element?: null | undefined) => false) &
       *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
       *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)
       * )}
       */
      /**
       * @param {unknown} [element]
       * @param {Test | undefined} [test]
       * @param {number | null | undefined} [index]
       * @param {Parents | null | undefined} [parent]
       * @param {unknown} [context]
       * @returns {boolean}
       */
      // eslint-disable-next-line max-params
      function(element7, test2, index3, parent, context) {
        const check = convertElement(test2);
        if (index3 !== null && index3 !== void 0 && (typeof index3 !== "number" || index3 < 0 || index3 === Number.POSITIVE_INFINITY)) {
          throw new Error("Expected positive finite `index`");
        }
        if (parent !== null && parent !== void 0 && (!parent.type || !parent.children)) {
          throw new Error("Expected valid `parent`");
        }
        if ((index3 === null || index3 === void 0) !== (parent === null || parent === void 0)) {
          throw new Error("Expected both `index` and `parent`");
        }
        return looksLikeAnElement(element7) ? check.call(context, element7, index3, parent) : false;
      };
      convertElement = // Note: overloads in JSDoc cant yet use different `@template`s.
      /**
       * @type {(
       *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
       *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
       *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
       *   ((test?: Test) => Check)
       * )}
       */
      /**
       * @param {Test | null | undefined} [test]
       * @returns {Check}
       */
      function(test2) {
        if (test2 === null || test2 === void 0) {
          return element4;
        }
        if (typeof test2 === "string") {
          return tagNameFactory(test2);
        }
        if (typeof test2 === "object") {
          return anyFactory(test2);
        }
        if (typeof test2 === "function") {
          return castFactory(test2);
        }
        throw new Error("Expected function, string, or array as `test`");
      };
    }
  });

  // node_modules/hast-util-is-element/index.js
  var init_hast_util_is_element = __esm({
    "node_modules/hast-util-is-element/index.js"() {
      init_lib17();
    }
  });

  // node_modules/hast-util-embedded/lib/index.js
  var embedded;
  var init_lib18 = __esm({
    "node_modules/hast-util-embedded/lib/index.js"() {
      init_hast_util_is_element();
      embedded = convertElement(
        /**
         * @param element
         * @returns {element is {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}}
         */
        function(element7) {
          return element7.tagName === "audio" || element7.tagName === "canvas" || element7.tagName === "embed" || element7.tagName === "iframe" || element7.tagName === "img" || element7.tagName === "math" || element7.tagName === "object" || element7.tagName === "picture" || element7.tagName === "svg" || element7.tagName === "video";
        }
      );
    }
  });

  // node_modules/hast-util-embedded/index.js
  var init_hast_util_embedded = __esm({
    "node_modules/hast-util-embedded/index.js"() {
      init_lib18();
    }
  });

  // node_modules/unist-util-is/lib/index.js
  function anyFactory2(tests) {
    const checks2 = [];
    let index3 = -1;
    while (++index3 < tests.length) {
      checks2[index3] = convert(tests[index3]);
    }
    return castFactory2(any2);
    function any2(...parameters) {
      let index4 = -1;
      while (++index4 < checks2.length) {
        if (checks2[index4].apply(this, parameters)) return true;
      }
      return false;
    }
  }
  function propsFactory(check) {
    const checkAsRecord = (
      /** @type {Record<string, unknown>} */
      check
    );
    return castFactory2(all10);
    function all10(node2) {
      const nodeAsRecord = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        node2
      );
      let key2;
      for (key2 in check) {
        if (nodeAsRecord[key2] !== checkAsRecord[key2]) return false;
      }
      return true;
    }
  }
  function typeFactory(check) {
    return castFactory2(type);
    function type(node2) {
      return node2 && node2.type === check;
    }
  }
  function castFactory2(testFunction) {
    return check;
    function check(value, index3, parent) {
      return Boolean(
        looksLikeANode(value) && testFunction.call(
          this,
          value,
          typeof index3 === "number" ? index3 : void 0,
          parent || void 0
        )
      );
    }
  }
  function ok2() {
    return true;
  }
  function looksLikeANode(value) {
    return value !== null && typeof value === "object" && "type" in value;
  }
  var is, convert;
  var init_lib19 = __esm({
    "node_modules/unist-util-is/lib/index.js"() {
      is = // Note: overloads in JSDoc cant yet use different `@template`s.
      /**
       * @type {(
       *   (<Condition extends string>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
       *   (<Condition extends Props>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
       *   (<Condition extends TestFunction>(node: unknown, test: Condition, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
       *   ((node?: null | undefined) => false) &
       *   ((node: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
       *   ((node: unknown, test?: Test, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => boolean)
       * )}
       */
      /**
       * @param {unknown} [node]
       * @param {Test} [test]
       * @param {number | null | undefined} [index]
       * @param {Parent | null | undefined} [parent]
       * @param {unknown} [context]
       * @returns {boolean}
       */
      // eslint-disable-next-line max-params
      function(node2, test2, index3, parent, context) {
        const check = convert(test2);
        if (index3 !== void 0 && index3 !== null && (typeof index3 !== "number" || index3 < 0 || index3 === Number.POSITIVE_INFINITY)) {
          throw new Error("Expected positive finite index");
        }
        if (parent !== void 0 && parent !== null && (!is(parent) || !parent.children)) {
          throw new Error("Expected parent node");
        }
        if ((parent === void 0 || parent === null) !== (index3 === void 0 || index3 === null)) {
          throw new Error("Expected both parent and index");
        }
        return looksLikeANode(node2) ? check.call(context, node2, index3, parent) : false;
      };
      convert = // Note: overloads in JSDoc cant yet use different `@template`s.
      /**
       * @type {(
       *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
       *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
       *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
       *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
       *   ((test?: Test) => Check)
       * )}
       */
      /**
       * @param {Test} [test]
       * @returns {Check}
       */
      function(test2) {
        if (test2 === null || test2 === void 0) {
          return ok2;
        }
        if (typeof test2 === "function") {
          return castFactory2(test2);
        }
        if (typeof test2 === "object") {
          return Array.isArray(test2) ? anyFactory2(test2) : propsFactory(test2);
        }
        if (typeof test2 === "string") {
          return typeFactory(test2);
        }
        throw new Error("Expected function, string, or object as test");
      };
    }
  });

  // node_modules/unist-util-is/index.js
  var init_unist_util_is = __esm({
    "node_modules/unist-util-is/index.js"() {
      init_lib19();
    }
  });

  // node_modules/hast-util-minify-whitespace/lib/block.js
  var blocks;
  var init_block = __esm({
    "node_modules/hast-util-minify-whitespace/lib/block.js"() {
      blocks = [
        "address",
        // Flow content.
        "article",
        // Sections and headings.
        "aside",
        // Sections and headings.
        "blockquote",
        // Flow content.
        "body",
        // Page.
        "br",
        // Contribute whitespace intrinsically.
        "caption",
        // Similar to block.
        "center",
        // Flow content, legacy.
        "col",
        // Similar to block.
        "colgroup",
        // Similar to block.
        "dd",
        // Lists.
        "dialog",
        // Flow content.
        "dir",
        // Lists, legacy.
        "div",
        // Flow content.
        "dl",
        // Lists.
        "dt",
        // Lists.
        "figcaption",
        // Flow content.
        "figure",
        // Flow content.
        "footer",
        // Flow content.
        "form",
        // Flow content.
        "h1",
        // Sections and headings.
        "h2",
        // Sections and headings.
        "h3",
        // Sections and headings.
        "h4",
        // Sections and headings.
        "h5",
        // Sections and headings.
        "h6",
        // Sections and headings.
        "head",
        // Page.
        "header",
        // Flow content.
        "hgroup",
        // Sections and headings.
        "hr",
        // Flow content.
        "html",
        // Page.
        "legend",
        // Flow content.
        "li",
        // Block-like.
        "li",
        // Similar to block.
        "listing",
        // Flow content, legacy
        "main",
        // Flow content.
        "menu",
        // Lists.
        "nav",
        // Sections and headings.
        "ol",
        // Lists.
        "optgroup",
        // Similar to block.
        "option",
        // Similar to block.
        "p",
        // Flow content.
        "plaintext",
        // Flow content, legacy
        "pre",
        // Flow content.
        "section",
        // Sections and headings.
        "summary",
        // Similar to block.
        "table",
        // Similar to block.
        "tbody",
        // Similar to block.
        "td",
        // Block-like.
        "td",
        // Similar to block.
        "tfoot",
        // Similar to block.
        "th",
        // Block-like.
        "th",
        // Similar to block.
        "thead",
        // Similar to block.
        "tr",
        // Similar to block.
        "ul",
        // Lists.
        "wbr",
        // Contribute whitespace intrinsically.
        "xmp"
        // Flow content, legacy
      ];
    }
  });

  // node_modules/hast-util-minify-whitespace/lib/content.js
  var content;
  var init_content = __esm({
    "node_modules/hast-util-minify-whitespace/lib/content.js"() {
      content = [
        // Form.
        "button",
        "input",
        "select",
        "textarea"
      ];
    }
  });

  // node_modules/hast-util-minify-whitespace/lib/skippable.js
  var skippable;
  var init_skippable = __esm({
    "node_modules/hast-util-minify-whitespace/lib/skippable.js"() {
      skippable = [
        "area",
        "base",
        "basefont",
        "dialog",
        "datalist",
        "head",
        "link",
        "meta",
        "noembed",
        "noframes",
        "param",
        "rp",
        "script",
        "source",
        "style",
        "template",
        "track",
        "title"
      ];
    }
  });

  // node_modules/hast-util-minify-whitespace/lib/index.js
  function minifyWhitespace(tree, options2) {
    const settings = options2 || emptyOptions3;
    minify(tree, {
      collapse: collapseFactory(
        settings.newlines ? replaceNewlines : replaceWhitespace
      ),
      whitespace: "normal"
    });
  }
  function minify(node2, state) {
    if ("children" in node2) {
      const settings = { ...state };
      if (node2.type === "root" || blocklike(node2)) {
        settings.before = true;
        settings.after = true;
      }
      settings.whitespace = inferWhiteSpace(node2, state);
      return all4(node2, settings);
    }
    if (node2.type === "text") {
      if (state.whitespace === "normal") {
        return minifyText(node2, state);
      }
      if (state.whitespace === "nowrap") {
        node2.value = state.collapse(node2.value);
      }
    }
    return { ignore: ignorableNode(node2), stripAtStart: false, remove: false };
  }
  function minifyText(node2, state) {
    const value = state.collapse(node2.value);
    const result = { ignore: false, stripAtStart: false, remove: false };
    let start = 0;
    let end = value.length;
    if (state.before && removable(value.charAt(0))) {
      start++;
    }
    if (start !== end && removable(value.charAt(end - 1))) {
      if (state.after) {
        end--;
      } else {
        result.stripAtStart = true;
      }
    }
    if (start === end) {
      result.remove = true;
    } else {
      node2.value = value.slice(start, end);
    }
    return result;
  }
  function all4(parent, state) {
    let before = state.before;
    const after = state.after;
    const children = parent.children;
    let length3 = children.length;
    let index3 = -1;
    while (++index3 < length3) {
      const result = minify(children[index3], {
        ...state,
        after: collapsableAfter(children, index3, after),
        before
      });
      if (result.remove) {
        children.splice(index3, 1);
        index3--;
        length3--;
      } else if (!result.ignore) {
        before = result.stripAtStart;
      }
      if (content2(children[index3])) {
        before = false;
      }
    }
    return { ignore: false, stripAtStart: Boolean(before || after), remove: false };
  }
  function collapsableAfter(nodes, index3, after) {
    while (++index3 < nodes.length) {
      const node2 = nodes[index3];
      let result = inferBoundary(node2);
      if (result === void 0 && "children" in node2 && !skippable2(node2)) {
        result = collapsableAfter(node2.children, -1);
      }
      if (typeof result === "boolean") {
        return result;
      }
    }
    return after;
  }
  function inferBoundary(node2) {
    if (node2.type === "element") {
      if (content2(node2)) {
        return false;
      }
      if (blocklike(node2)) {
        return true;
      }
    } else if (node2.type === "text") {
      if (!whitespace(node2)) {
        return false;
      }
    } else if (!ignorableNode(node2)) {
      return false;
    }
  }
  function content2(node2) {
    return embedded(node2) || isElement(node2, content);
  }
  function blocklike(node2) {
    return isElement(node2, blocks);
  }
  function skippable2(node2) {
    return Boolean(node2.type === "element" && node2.properties.hidden) || ignorableNode(node2) || isElement(node2, skippable);
  }
  function removable(character) {
    return character === " " || character === "\n";
  }
  function replaceNewlines(value) {
    const match = /\r?\n|\r/.exec(value);
    return match ? match[0] : " ";
  }
  function replaceWhitespace() {
    return " ";
  }
  function collapseFactory(replace4) {
    return collapse;
    function collapse(value) {
      return String(value).replace(/[\t\n\v\f\r ]+/g, replace4);
    }
  }
  function inferWhiteSpace(node2, state) {
    if ("tagName" in node2 && node2.properties) {
      switch (node2.tagName) {
        // Whitespace in script/style, while not displayed by CSS as significant,
        // could have some meaning in JS/CSS, so we cant touch them.
        case "listing":
        case "plaintext":
        case "script":
        case "style":
        case "xmp": {
          return "pre";
        }
        case "nobr": {
          return "nowrap";
        }
        case "pre": {
          return node2.properties.wrap ? "pre-wrap" : "pre";
        }
        case "td":
        case "th": {
          return node2.properties.noWrap ? "nowrap" : state.whitespace;
        }
        case "textarea": {
          return "pre-wrap";
        }
        default:
      }
    }
    return state.whitespace;
  }
  var emptyOptions3, ignorableNode;
  var init_lib20 = __esm({
    "node_modules/hast-util-minify-whitespace/lib/index.js"() {
      init_hast_util_embedded();
      init_hast_util_is_element();
      init_hast_util_whitespace();
      init_unist_util_is();
      init_block();
      init_content();
      init_skippable();
      emptyOptions3 = {};
      ignorableNode = convert(["comment", "doctype"]);
    }
  });

  // node_modules/hast-util-minify-whitespace/index.js
  var init_hast_util_minify_whitespace = __esm({
    "node_modules/hast-util-minify-whitespace/index.js"() {
      init_lib20();
    }
  });

  // node_modules/rehype-minify-whitespace/lib/index.js
  function rehypeMinifyWhitespace(options2) {
    return function(tree) {
      minifyWhitespace(tree, options2);
    };
  }
  var init_lib21 = __esm({
    "node_modules/rehype-minify-whitespace/lib/index.js"() {
      init_hast_util_minify_whitespace();
    }
  });

  // node_modules/rehype-minify-whitespace/index.js
  var init_rehype_minify_whitespace = __esm({
    "node_modules/rehype-minify-whitespace/index.js"() {
      init_lib21();
    }
  });

  // node_modules/unist-util-visit-parents/lib/color.js
  function color(d) {
    return d;
  }
  var init_color = __esm({
    "node_modules/unist-util-visit-parents/lib/color.js"() {
    }
  });

  // node_modules/unist-util-visit-parents/lib/index.js
  function visitParents(tree, test2, visitor, reverse) {
    let check;
    if (typeof test2 === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test2;
    } else {
      check = test2;
    }
    const is4 = convert(check);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node2, index3, parents) {
      const value = (
        /** @type {Record<string, unknown>} */
        node2 && typeof node2 === "object" ? node2 : {}
      );
      if (typeof value.type === "string") {
        const name = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit2, "name", {
          value: "node (" + color(node2.type + (name ? "<" + name + ">" : "")) + ")"
        });
      }
      return visit2;
      function visit2() {
        let result = empty2;
        let subresult;
        let offset;
        let grandparents;
        if (!test2 || is4(node2, index3, parents[parents.length - 1] || void 0)) {
          result = toResult(visitor(node2, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if ("children" in node2 && node2.children) {
          const nodeAsParent = (
            /** @type {UnistParent} */
            node2
          );
          if (nodeAsParent.children && result[0] !== SKIP) {
            offset = (reverse ? nodeAsParent.children.length : -1) + step;
            grandparents = parents.concat(nodeAsParent);
            while (offset > -1 && offset < nodeAsParent.children.length) {
              const child = nodeAsParent.children[offset];
              subresult = factory(child, offset, grandparents)();
              if (subresult[0] === EXIT) {
                return subresult;
              }
              offset = typeof subresult[1] === "number" ? subresult[1] : offset + step;
            }
          }
        }
        return result;
      }
    }
  }
  function toResult(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "number") {
      return [CONTINUE, value];
    }
    return value === null || value === void 0 ? empty2 : [value];
  }
  var empty2, CONTINUE, EXIT, SKIP;
  var init_lib22 = __esm({
    "node_modules/unist-util-visit-parents/lib/index.js"() {
      init_unist_util_is();
      init_color();
      empty2 = [];
      CONTINUE = true;
      EXIT = false;
      SKIP = "skip";
    }
  });

  // node_modules/unist-util-visit-parents/index.js
  var init_unist_util_visit_parents = __esm({
    "node_modules/unist-util-visit-parents/index.js"() {
      init_lib22();
    }
  });

  // node_modules/unist-util-visit/lib/index.js
  function visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {
    let reverse;
    let test2;
    let visitor;
    if (typeof testOrVisitor === "function" && typeof visitorOrReverse !== "function") {
      test2 = void 0;
      visitor = testOrVisitor;
      reverse = visitorOrReverse;
    } else {
      test2 = testOrVisitor;
      visitor = visitorOrReverse;
      reverse = maybeReverse;
    }
    visitParents(tree, test2, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      const index3 = parent ? parent.children.indexOf(node2) : void 0;
      return visitor(node2, index3, parent);
    }
  }
  var init_lib23 = __esm({
    "node_modules/unist-util-visit/lib/index.js"() {
      init_unist_util_visit_parents();
      init_unist_util_visit_parents();
    }
  });

  // node_modules/unist-util-visit/index.js
  var init_unist_util_visit = __esm({
    "node_modules/unist-util-visit/index.js"() {
      init_lib23();
    }
  });

  // node_modules/unist-util-position/lib/index.js
  function point3(type) {
    return point5;
    function point5(node2) {
      const point6 = node2 && node2.position && node2.position[type] || {};
      if (typeof point6.line === "number" && point6.line > 0 && typeof point6.column === "number" && point6.column > 0) {
        return {
          line: point6.line,
          column: point6.column,
          offset: typeof point6.offset === "number" && point6.offset > -1 ? point6.offset : void 0
        };
      }
    }
  }
  function position3(node2) {
    const start = pointStart(node2);
    const end = pointEnd(node2);
    if (start && end) {
      return { start, end };
    }
  }
  var pointEnd, pointStart;
  var init_lib24 = __esm({
    "node_modules/unist-util-position/lib/index.js"() {
      pointEnd = point3("end");
      pointStart = point3("start");
    }
  });

  // node_modules/unist-util-position/index.js
  var init_unist_util_position = __esm({
    "node_modules/unist-util-position/index.js"() {
      init_lib24();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/a.js
  function a(state, node2) {
    const properties = node2.properties || {};
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = {
      type: "link",
      url: state.resolve(String(properties.href || "") || null),
      title: properties.title ? String(properties.title) : null,
      children
    };
    state.patch(node2, result);
    return result;
  }
  var init_a = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/a.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/base.js
  function base2(state, node2) {
    if (!state.baseFound) {
      state.frozenBaseUrl = String(node2.properties && node2.properties.href || "") || void 0;
      state.baseFound = true;
    }
  }
  var init_base = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/base.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/blockquote.js
  function blockquote(state, node2) {
    const result = { type: "blockquote", children: state.toFlow(state.all(node2)) };
    state.patch(node2, result);
    return result;
  }
  var init_blockquote = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/blockquote.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/br.js
  function br(state, node2) {
    const result = { type: "break" };
    state.patch(node2, result);
    return result;
  }
  var init_br = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/br.js"() {
    }
  });

  // node_modules/unist-util-find-after/lib/index.js
  var findAfter;
  var init_lib25 = __esm({
    "node_modules/unist-util-find-after/lib/index.js"() {
      init_unist_util_is();
      findAfter = // Note: overloads like this are needed to support optional generics.
      /**
       * @type {(
       *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &
       *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)
       * )}
       */
      /**
       * @param {UnistParent} parent
       * @param {UnistNode | number} index
       * @param {Test} [test]
       * @returns {UnistNode | undefined}
       */
      function(parent, index3, test2) {
        const is4 = convert(test2);
        if (!parent || !parent.type || !parent.children) {
          throw new Error("Expected parent node");
        }
        if (typeof index3 === "number") {
          if (index3 < 0 || index3 === Number.POSITIVE_INFINITY) {
            throw new Error("Expected positive finite number as index");
          }
        } else {
          index3 = parent.children.indexOf(index3);
          if (index3 < 0) {
            throw new Error("Expected child node or index");
          }
        }
        while (++index3 < parent.children.length) {
          if (is4(parent.children[index3], index3, parent)) {
            return parent.children[index3];
          }
        }
        return void 0;
      };
    }
  });

  // node_modules/unist-util-find-after/index.js
  var init_unist_util_find_after = __esm({
    "node_modules/unist-util-find-after/index.js"() {
      init_lib25();
    }
  });

  // node_modules/hast-util-to-text/lib/index.js
  function toText(tree, options2) {
    const options_ = options2 || {};
    const children = "children" in tree ? tree.children : [];
    const block = blockOrCaption(tree);
    const whitespace3 = inferWhitespace(tree, {
      whitespace: options_.whitespace || "normal",
      breakBefore: false,
      breakAfter: false
    });
    const results = [];
    if (tree.type === "text" || tree.type === "comment") {
      results.push(
        ...collectText(tree, {
          whitespace: whitespace3,
          breakBefore: true,
          breakAfter: true
        })
      );
    }
    let index3 = -1;
    while (++index3 < children.length) {
      results.push(
        ...renderedTextCollection(
          children[index3],
          // @ts-expect-error: `tree` is a parent if were here.
          tree,
          {
            whitespace: whitespace3,
            breakBefore: index3 ? void 0 : block,
            breakAfter: index3 < children.length - 1 ? br2(children[index3 + 1]) : block
          }
        )
      );
    }
    const result = [];
    let count;
    index3 = -1;
    while (++index3 < results.length) {
      const value = results[index3];
      if (typeof value === "number") {
        if (count !== void 0 && value > count) count = value;
      } else if (value) {
        if (count !== void 0 && count > -1) {
          result.push("\n".repeat(count) || " ");
        }
        count = -1;
        result.push(value);
      }
    }
    return result.join("");
  }
  function renderedTextCollection(node2, parent, info) {
    if (node2.type === "element") {
      return collectElement(node2, parent, info);
    }
    if (node2.type === "text") {
      return info.whitespace === "normal" ? collectText(node2, info) : collectPreText(node2);
    }
    return [];
  }
  function collectElement(node2, parent, info) {
    const whitespace3 = inferWhitespace(node2, info);
    const children = node2.children || [];
    let index3 = -1;
    let items = [];
    if (notRendered(node2)) {
      return items;
    }
    let prefix3;
    let suffix;
    if (br2(node2)) {
      suffix = "\n";
    } else if (row(node2) && // @ts-expect-error: something up with types of parents.
    findAfter(parent, node2, row)) {
      suffix = "\n";
    } else if (p2(node2)) {
      prefix3 = 2;
      suffix = 2;
    } else if (blockOrCaption(node2)) {
      prefix3 = 1;
      suffix = 1;
    }
    while (++index3 < children.length) {
      items = items.concat(
        renderedTextCollection(children[index3], node2, {
          whitespace: whitespace3,
          breakBefore: index3 ? void 0 : prefix3,
          breakAfter: index3 < children.length - 1 ? br2(children[index3 + 1]) : suffix
        })
      );
    }
    if (cell(node2) && // @ts-expect-error: something up with types of parents.
    findAfter(parent, node2, cell)) {
      items.push("	");
    }
    if (prefix3) items.unshift(prefix3);
    if (suffix) items.push(suffix);
    return items;
  }
  function collectText(node2, info) {
    const value = String(node2.value);
    const lines = [];
    const result = [];
    let start = 0;
    while (start <= value.length) {
      searchLineFeeds.lastIndex = start;
      const match = searchLineFeeds.exec(value);
      const end = match && "index" in match ? match.index : value.length;
      lines.push(
        // Any sequence of collapsible spaces and tabs immediately preceding or
        // following a segment break is removed.
        trimAndCollapseSpacesAndTabs(
          // [] ignoring bidi formatting characters (characters with the
          // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if
          // they were not there.
          value.slice(start, end).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ""),
          start === 0 ? info.breakBefore : true,
          end === value.length ? info.breakAfter : true
        )
      );
      start = end + 1;
    }
    let index3 = -1;
    let join4;
    while (++index3 < lines.length) {
      if (lines[index3].charCodeAt(lines[index3].length - 1) === 8203 || index3 < lines.length - 1 && lines[index3 + 1].charCodeAt(0) === 8203) {
        result.push(lines[index3]);
        join4 = void 0;
      } else if (lines[index3]) {
        if (typeof join4 === "number") result.push(join4);
        result.push(lines[index3]);
        join4 = 0;
      } else if (index3 === 0 || index3 === lines.length - 1) {
        result.push(0);
      }
    }
    return result;
  }
  function collectPreText(node2) {
    return [String(node2.value)];
  }
  function trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {
    const result = [];
    let start = 0;
    let end;
    while (start < value.length) {
      searchTabOrSpaces.lastIndex = start;
      const match = searchTabOrSpaces.exec(value);
      end = match ? match.index : value.length;
      if (!start && !end && match && !breakBefore) {
        result.push("");
      }
      if (start !== end) {
        result.push(value.slice(start, end));
      }
      start = match ? end + match[0].length : end;
    }
    if (start !== end && !breakAfter) {
      result.push("");
    }
    return result.join(" ");
  }
  function inferWhitespace(node2, info) {
    if (node2.type === "element") {
      const properties = node2.properties || {};
      switch (node2.tagName) {
        case "listing":
        case "plaintext":
        case "xmp": {
          return "pre";
        }
        case "nobr": {
          return "nowrap";
        }
        case "pre": {
          return properties.wrap ? "pre-wrap" : "pre";
        }
        case "td":
        case "th": {
          return properties.noWrap ? "nowrap" : info.whitespace;
        }
        case "textarea": {
          return "pre-wrap";
        }
        default:
      }
    }
    return info.whitespace;
  }
  function hidden(node2) {
    return Boolean((node2.properties || {}).hidden);
  }
  function isCell(node2) {
    return node2.tagName === "td" || node2.tagName === "th";
  }
  function closedDialog(node2) {
    return node2.tagName === "dialog" && !(node2.properties || {}).open;
  }
  var searchLineFeeds, searchTabOrSpaces, br2, cell, p2, row, notRendered, blockOrCaption;
  var init_lib26 = __esm({
    "node_modules/hast-util-to-text/lib/index.js"() {
      init_unist_util_find_after();
      init_hast_util_is_element();
      searchLineFeeds = /\n/g;
      searchTabOrSpaces = /[\t ]+/g;
      br2 = convertElement("br");
      cell = convertElement(isCell);
      p2 = convertElement("p");
      row = convertElement("tr");
      notRendered = convertElement([
        // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>
        "datalist",
        "head",
        "noembed",
        "noframes",
        "noscript",
        // Act as if we support scripting.
        "rp",
        "script",
        "style",
        "template",
        "title",
        // Hidden attribute.
        hidden,
        // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>
        closedDialog
      ]);
      blockOrCaption = convertElement([
        "address",
        // Flow content
        "article",
        // Sections and headings
        "aside",
        // Sections and headings
        "blockquote",
        // Flow content
        "body",
        // Page
        "caption",
        // `table-caption`
        "center",
        // Flow content (legacy)
        "dd",
        // Lists
        "dialog",
        // Flow content
        "dir",
        // Lists (legacy)
        "dl",
        // Lists
        "dt",
        // Lists
        "div",
        // Flow content
        "figure",
        // Flow content
        "figcaption",
        // Flow content
        "footer",
        // Flow content
        "form,",
        // Flow content
        "h1",
        // Sections and headings
        "h2",
        // Sections and headings
        "h3",
        // Sections and headings
        "h4",
        // Sections and headings
        "h5",
        // Sections and headings
        "h6",
        // Sections and headings
        "header",
        // Flow content
        "hgroup",
        // Sections and headings
        "hr",
        // Flow content
        "html",
        // Page
        "legend",
        // Flow content
        "li",
        // Lists (as `display: list-item`)
        "listing",
        // Flow content (legacy)
        "main",
        // Flow content
        "menu",
        // Lists
        "nav",
        // Sections and headings
        "ol",
        // Lists
        "p",
        // Flow content
        "plaintext",
        // Flow content (legacy)
        "pre",
        // Flow content
        "section",
        // Sections and headings
        "ul",
        // Lists
        "xmp"
        // Flow content (legacy)
      ]);
    }
  });

  // node_modules/hast-util-to-text/index.js
  var init_hast_util_to_text = __esm({
    "node_modules/hast-util-to-text/index.js"() {
      init_lib26();
    }
  });

  // node_modules/trim-trailing-lines/index.js
  function trimTrailingLines(value) {
    const input2 = String(value);
    let end = input2.length;
    while (end > 0) {
      const code5 = input2.codePointAt(end - 1);
      if (code5 !== void 0 && (code5 === 10 || code5 === 13)) {
        end--;
      } else {
        break;
      }
    }
    return input2.slice(0, end);
  }
  var init_trim_trailing_lines = __esm({
    "node_modules/trim-trailing-lines/index.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/code.js
  function code(state, node2) {
    const children = node2.children;
    let index3 = -1;
    let classList;
    let lang;
    if (node2.tagName === "pre") {
      while (++index3 < children.length) {
        const child = children[index3];
        if (child.type === "element" && child.tagName === "code" && child.properties && child.properties.className && Array.isArray(child.properties.className)) {
          classList = child.properties.className;
          break;
        }
      }
    }
    if (classList) {
      index3 = -1;
      while (++index3 < classList.length) {
        if (String(classList[index3]).slice(0, prefix.length) === prefix) {
          lang = String(classList[index3]).slice(prefix.length);
          break;
        }
      }
    }
    const result = {
      type: "code",
      lang: lang || null,
      meta: null,
      value: trimTrailingLines(toText(node2))
    };
    state.patch(node2, result);
    return result;
  }
  var prefix;
  var init_code = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/code.js"() {
      init_hast_util_to_text();
      init_trim_trailing_lines();
      prefix = "language-";
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/comment.js
  function comment3(state, node2) {
    const result = {
      type: "html",
      value: "<!--" + node2.value + "-->"
    };
    state.patch(node2, result);
    return result;
  }
  var init_comment2 = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/comment.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/del.js
  function del(state, node2) {
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = { type: "delete", children };
    state.patch(node2, result);
    return result;
  }
  var init_del = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/del.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/util/list-items-spread.js
  function listItemsSpread(children) {
    let index3 = -1;
    if (children.length > 1) {
      while (++index3 < children.length) {
        if (children[index3].spread) {
          return true;
        }
      }
    }
    return false;
  }
  var init_list_items_spread = __esm({
    "node_modules/hast-util-to-mdast/lib/util/list-items-spread.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/dl.js
  function dl(state, node2) {
    const clean = [];
    const groups = [];
    let index3 = -1;
    while (++index3 < node2.children.length) {
      const child = node2.children[index3];
      if (child.type === "element" && child.tagName === "div") {
        clean.push(...child.children);
      } else {
        clean.push(child);
      }
    }
    let group2 = { definitions: [], titles: [] };
    index3 = -1;
    while (++index3 < clean.length) {
      const child = clean[index3];
      if (child.type === "element" && child.tagName === "dt") {
        const previous3 = clean[index3 - 1];
        if (previous3 && previous3.type === "element" && previous3.tagName === "dd") {
          groups.push(group2);
          group2 = { definitions: [], titles: [] };
        }
        group2.titles.push(child);
      } else {
        group2.definitions.push(child);
      }
    }
    groups.push(group2);
    index3 = -1;
    const content5 = [];
    while (++index3 < groups.length) {
      const result = [
        ...handle2(state, groups[index3].titles),
        ...handle2(state, groups[index3].definitions)
      ];
      if (result.length > 0) {
        content5.push({
          type: "listItem",
          spread: result.length > 1,
          checked: null,
          children: result
        });
      }
    }
    if (content5.length > 0) {
      const result = {
        type: "list",
        ordered: false,
        start: null,
        spread: listItemsSpread(content5),
        children: content5
      };
      state.patch(node2, result);
      return result;
    }
  }
  function handle2(state, children) {
    const nodes = state.all({ type: "root", children });
    const listItems = state.toSpecificContent(nodes, create2);
    if (listItems.length === 0) {
      return [];
    }
    if (listItems.length === 1) {
      return listItems[0].children;
    }
    return [
      {
        type: "list",
        ordered: false,
        start: null,
        spread: listItemsSpread(listItems),
        children: listItems
      }
    ];
  }
  function create2() {
    return { type: "listItem", spread: false, checked: null, children: [] };
  }
  var init_dl = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/dl.js"() {
      init_list_items_spread();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/em.js
  function em(state, node2) {
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = { type: "emphasis", children };
    state.patch(node2, result);
    return result;
  }
  var init_em = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/em.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/util/drop-surrounding-breaks.js
  function dropSurroundingBreaks(nodes) {
    let start = 0;
    let end = nodes.length;
    while (start < end && nodes[start].type === "break") start++;
    while (end > start && nodes[end - 1].type === "break") end--;
    return start === 0 && end === nodes.length ? nodes : nodes.slice(start, end);
  }
  var init_drop_surrounding_breaks = __esm({
    "node_modules/hast-util-to-mdast/lib/util/drop-surrounding-breaks.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/heading.js
  function heading(state, node2) {
    const depth = (
      /** @type {Heading['depth']} */
      /* c8 ignore next */
      Number(node2.tagName.charAt(1)) || 1
    );
    const children = dropSurroundingBreaks(
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = { type: "heading", depth, children };
    state.patch(node2, result);
    return result;
  }
  var init_heading = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/heading.js"() {
      init_drop_surrounding_breaks();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/hr.js
  function hr(state, node2) {
    const result = { type: "thematicBreak" };
    state.patch(node2, result);
    return result;
  }
  var init_hr = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/hr.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/iframe.js
  function iframe(state, node2) {
    const properties = node2.properties || {};
    const source = String(properties.src || "");
    const title = String(properties.title || "");
    if (source && title) {
      const result = {
        type: "link",
        title: null,
        url: state.resolve(source),
        children: [{ type: "text", value: title }]
      };
      state.patch(node2, result);
      return result;
    }
  }
  var init_iframe = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/iframe.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/img.js
  function img(state, node2) {
    const properties = node2.properties || {};
    const result = {
      type: "image",
      url: state.resolve(String(properties.src || "") || null),
      title: properties.title ? String(properties.title) : null,
      alt: properties.alt ? String(properties.alt) : ""
    };
    state.patch(node2, result);
    return result;
  }
  var init_img = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/img.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/inline-code.js
  function inlineCode(state, node2) {
    const result = { type: "inlineCode", value: toText(node2) };
    state.patch(node2, result);
    return result;
  }
  var init_inline_code = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/inline-code.js"() {
      init_hast_util_to_text();
    }
  });

  // node_modules/hast-util-to-mdast/lib/util/find-selected-options.js
  function findSelectedOptions(node2, explicitProperties) {
    const selectedOptions = [];
    const values = [];
    const properties = explicitProperties || node2.properties || {};
    const options2 = findOptions(node2);
    const size2 = Math.min(Number.parseInt(String(properties.size), 10), 0) || (properties.multiple ? 4 : 1);
    let index3 = -1;
    while (++index3 < options2.length) {
      const option2 = options2[index3];
      if (option2 && option2.properties && option2.properties.selected) {
        selectedOptions.push(option2);
      }
    }
    const list7 = selectedOptions.length > 0 ? selectedOptions : options2;
    const max2 = Math.min(list7.length, size2);
    index3 = -1;
    while (++index3 < max2) {
      const option2 = list7[index3];
      const properties2 = option2.properties || {};
      const content5 = toText(option2);
      const label = content5 || String(properties2.label || "");
      const value = String(properties2.value || "") || content5;
      values.push([value, label === value ? void 0 : label]);
    }
    return values;
  }
  function findOptions(node2) {
    const results = [];
    let index3 = -1;
    while (++index3 < node2.children.length) {
      const child = node2.children[index3];
      if ("children" in child && Array.isArray(child.children)) {
        results.push(...findOptions(child));
      }
      if (child.type === "element" && child.tagName === "option" && (!child.properties || !child.properties.disabled)) {
        results.push(child);
      }
    }
    return results;
  }
  var init_find_selected_options = __esm({
    "node_modules/hast-util-to-mdast/lib/util/find-selected-options.js"() {
      init_hast_util_to_text();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/input.js
  function input(state, node2) {
    const properties = node2.properties || {};
    const value = String(properties.value || properties.placeholder || "");
    if (properties.disabled || properties.type === "hidden" || properties.type === "file") {
      return;
    }
    if (properties.type === "checkbox" || properties.type === "radio") {
      const result2 = {
        type: "text",
        value: properties.checked ? state.options.checked || defaultChecked : state.options.unchecked || defaultUnchecked
      };
      state.patch(node2, result2);
      return result2;
    }
    if (properties.type === "image") {
      const alt = properties.alt || value;
      if (alt) {
        const result2 = {
          type: "image",
          url: state.resolve(String(properties.src || "") || null),
          title: String(properties.title || "") || null,
          alt: String(alt)
        };
        state.patch(node2, result2);
        return result2;
      }
      return;
    }
    let values = [];
    if (value) {
      values = [[value, void 0]];
    } else if (
      // `list` is not supported on these types:
      properties.type !== "button" && properties.type !== "file" && properties.type !== "password" && properties.type !== "reset" && properties.type !== "submit" && properties.list
    ) {
      const list7 = String(properties.list);
      const datalist = state.elementById.get(list7);
      if (datalist && datalist.tagName === "datalist") {
        values = findSelectedOptions(datalist, properties);
      }
    }
    if (values.length === 0) {
      return;
    }
    if (properties.type === "password") {
      values[0] = ["\u2022".repeat(values[0][0].length), void 0];
    }
    if (properties.type === "email" || properties.type === "url") {
      const results = [];
      let index4 = -1;
      while (++index4 < values.length) {
        const value2 = state.resolve(values[index4][0]);
        const result2 = {
          type: "link",
          title: null,
          url: properties.type === "email" ? "mailto:" + value2 : value2,
          children: [{ type: "text", value: values[index4][1] || value2 }]
        };
        results.push(result2);
        if (index4 !== values.length - 1) {
          results.push({ type: "text", value: ", " });
        }
      }
      return results;
    }
    const texts = [];
    let index3 = -1;
    while (++index3 < values.length) {
      texts.push(
        values[index3][1] ? values[index3][1] + " (" + values[index3][0] + ")" : values[index3][0]
      );
    }
    const result = { type: "text", value: texts.join(", ") };
    state.patch(node2, result);
    return result;
  }
  var defaultChecked, defaultUnchecked;
  var init_input = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/input.js"() {
      init_find_selected_options();
      defaultChecked = "[x]";
      defaultUnchecked = "[ ]";
    }
  });

  // node_modules/hast-util-has-property/lib/index.js
  function hasProperty(node2, name) {
    const value = node2.type === "element" && own6.call(node2.properties, name) && node2.properties[name];
    return value !== null && value !== void 0 && value !== false;
  }
  var own6;
  var init_lib27 = __esm({
    "node_modules/hast-util-has-property/lib/index.js"() {
      own6 = {}.hasOwnProperty;
    }
  });

  // node_modules/hast-util-has-property/index.js
  var init_hast_util_has_property = __esm({
    "node_modules/hast-util-has-property/index.js"() {
      init_lib27();
    }
  });

  // node_modules/hast-util-is-body-ok-link/lib/index.js
  function isBodyOkLink(node2) {
    if (node2.type !== "element" || node2.tagName !== "link") {
      return false;
    }
    if (node2.properties.itemProp) {
      return true;
    }
    const value = node2.properties.rel;
    let index3 = -1;
    if (!Array.isArray(value) || value.length === 0) {
      return false;
    }
    while (++index3 < value.length) {
      if (!list.has(String(value[index3]))) {
        return false;
      }
    }
    return true;
  }
  var list;
  var init_lib28 = __esm({
    "node_modules/hast-util-is-body-ok-link/lib/index.js"() {
      list = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
    }
  });

  // node_modules/hast-util-is-body-ok-link/index.js
  var init_hast_util_is_body_ok_link = __esm({
    "node_modules/hast-util-is-body-ok-link/index.js"() {
      init_lib28();
    }
  });

  // node_modules/hast-util-phrasing/lib/index.js
  function phrasing(value) {
    return Boolean(
      value.type === "text" || basic(value) || embedded(value) || isBodyOkLink(value) || meta(value) && hasProperty(value, "itemProp")
    );
  }
  var basic, meta;
  var init_lib29 = __esm({
    "node_modules/hast-util-phrasing/lib/index.js"() {
      init_hast_util_embedded();
      init_hast_util_has_property();
      init_hast_util_is_body_ok_link();
      init_hast_util_is_element();
      basic = convertElement([
        "a",
        "abbr",
        // `area` is in fact only phrasing if it is inside a `map` element.
        // However, since `area`s are required to be inside a `map` element, and its
        // a rather involved check, its ignored here for now.
        "area",
        "b",
        "bdi",
        "bdo",
        "br",
        "button",
        "cite",
        "code",
        "data",
        "datalist",
        "del",
        "dfn",
        "em",
        "i",
        "input",
        "ins",
        "kbd",
        "keygen",
        "label",
        "map",
        "mark",
        "meter",
        "noscript",
        "output",
        "progress",
        "q",
        "ruby",
        "s",
        "samp",
        "script",
        "select",
        "small",
        "span",
        "strong",
        "sub",
        "sup",
        "template",
        "textarea",
        "time",
        "u",
        "var",
        "wbr"
      ]);
      meta = convertElement("meta");
    }
  });

  // node_modules/hast-util-phrasing/index.js
  var init_hast_util_phrasing = __esm({
    "node_modules/hast-util-phrasing/index.js"() {
      init_lib29();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/li.js
  function li2(state, node2) {
    const { rest, checkbox } = extractLeadingCheckbox(node2);
    const checked = checkbox ? Boolean(checkbox.properties.checked) : null;
    const spread = spreadout(rest);
    const children = state.toFlow(state.all(rest));
    const result = { type: "listItem", spread, checked, children };
    state.patch(node2, result);
    return result;
  }
  function spreadout(node2) {
    let index3 = -1;
    let seenFlow = false;
    while (++index3 < node2.children.length) {
      const child = node2.children[index3];
      if (child.type === "element") {
        if (phrasing(child)) continue;
        if (child.tagName === "p" || seenFlow || spreadout(child)) {
          return true;
        }
        seenFlow = true;
      }
    }
    return false;
  }
  function extractLeadingCheckbox(node2) {
    const head2 = node2.children[0];
    if (head2 && head2.type === "element" && head2.tagName === "input" && head2.properties && (head2.properties.type === "checkbox" || head2.properties.type === "radio")) {
      const rest = { ...node2, children: node2.children.slice(1) };
      return { checkbox: head2, rest };
    }
    if (head2 && head2.type === "element" && head2.tagName === "p") {
      const { checkbox, rest: restHead } = extractLeadingCheckbox(head2);
      if (checkbox) {
        const rest = { ...node2, children: [restHead, ...node2.children.slice(1)] };
        return { checkbox, rest };
      }
    }
    return { checkbox: void 0, rest: node2 };
  }
  var init_li = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/li.js"() {
      init_hast_util_phrasing();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/list.js
  function list2(state, node2) {
    const ordered = node2.tagName === "ol";
    const children = state.toSpecificContent(state.all(node2), create3);
    let start = null;
    if (ordered) {
      start = node2.properties && node2.properties.start ? Number.parseInt(String(node2.properties.start), 10) : 1;
    }
    const result = {
      type: "list",
      ordered,
      start,
      spread: listItemsSpread(children),
      children
    };
    state.patch(node2, result);
    return result;
  }
  function create3() {
    return { type: "listItem", spread: false, checked: null, children: [] };
  }
  var init_list = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/list.js"() {
      init_list_items_spread();
    }
  });

  // node_modules/mdast-util-to-string/lib/index.js
  function toString2(value, options2) {
    const settings = options2 || emptyOptions4;
    const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
    const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
    return one4(value, includeImageAlt, includeHtml);
  }
  function one4(value, includeImageAlt, includeHtml) {
    if (node(value)) {
      if ("value" in value) {
        return value.type === "html" && !includeHtml ? "" : value.value;
      }
      if (includeImageAlt && "alt" in value && value.alt) {
        return value.alt;
      }
      if ("children" in value) {
        return all5(value.children, includeImageAlt, includeHtml);
      }
    }
    if (Array.isArray(value)) {
      return all5(value, includeImageAlt, includeHtml);
    }
    return "";
  }
  function all5(values, includeImageAlt, includeHtml) {
    const result = [];
    let index3 = -1;
    while (++index3 < values.length) {
      result[index3] = one4(values[index3], includeImageAlt, includeHtml);
    }
    return result.join("");
  }
  function node(value) {
    return Boolean(value && typeof value === "object");
  }
  var emptyOptions4;
  var init_lib30 = __esm({
    "node_modules/mdast-util-to-string/lib/index.js"() {
      emptyOptions4 = {};
    }
  });

  // node_modules/mdast-util-to-string/index.js
  var init_mdast_util_to_string = __esm({
    "node_modules/mdast-util-to-string/index.js"() {
      init_lib30();
    }
  });

  // node_modules/mdast-util-phrasing/lib/index.js
  var phrasing2;
  var init_lib31 = __esm({
    "node_modules/mdast-util-phrasing/lib/index.js"() {
      init_unist_util_is();
      phrasing2 = /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
      convert([
        "break",
        "delete",
        "emphasis",
        // To do: next major: removed since footnotes were added to GFM.
        "footnote",
        "footnoteReference",
        "image",
        "imageReference",
        "inlineCode",
        // Enabled by `mdast-util-math`:
        "inlineMath",
        "link",
        "linkReference",
        // Enabled by `mdast-util-mdx`:
        "mdxJsxTextElement",
        // Enabled by `mdast-util-mdx`:
        "mdxTextExpression",
        "strong",
        "text",
        // Enabled by `mdast-util-directive`:
        "textDirective"
      ]);
    }
  });

  // node_modules/mdast-util-phrasing/index.js
  var init_mdast_util_phrasing = __esm({
    "node_modules/mdast-util-phrasing/index.js"() {
      init_lib31();
    }
  });

  // node_modules/hast-util-to-mdast/lib/util/wrap.js
  function wrapNeeded(nodes) {
    let index3 = -1;
    while (++index3 < nodes.length) {
      const node2 = nodes[index3];
      if (!phrasing3(node2) || "children" in node2 && wrapNeeded(node2.children)) {
        return true;
      }
    }
    return false;
  }
  function wrap2(nodes) {
    return runs(nodes, onphrasing, function(d) {
      return d;
    });
    function onphrasing(nodes2) {
      return nodes2.every(function(d) {
        return d.type === "text" ? whitespace(d.value) : false;
      }) ? [] : [{ type: "paragraph", children: dropSurroundingBreaks(nodes2) }];
    }
  }
  function split(node2) {
    return runs(node2.children, onphrasing, onnonphrasing);
    function onphrasing(nodes) {
      const newParent = cloneWithoutChildren(node2);
      newParent.children = nodes;
      return [newParent];
    }
    function onnonphrasing(child) {
      if ("children" in child && "children" in node2) {
        const newParent = cloneWithoutChildren(node2);
        const newChild = cloneWithoutChildren(child);
        newParent.children = child.children;
        newChild.children.push(newParent);
        return newChild;
      }
      return { ...child };
    }
  }
  function runs(nodes, onphrasing, onnonphrasing) {
    const flattened = flatten(nodes);
    const result = [];
    let queue2 = [];
    let index3 = -1;
    while (++index3 < flattened.length) {
      const node2 = flattened[index3];
      if (phrasing3(node2)) {
        queue2.push(node2);
      } else {
        if (queue2.length > 0) {
          result.push(...onphrasing(queue2));
          queue2 = [];
        }
        result.push(onnonphrasing(node2));
      }
    }
    if (queue2.length > 0) {
      result.push(...onphrasing(queue2));
      queue2 = [];
    }
    return result;
  }
  function flatten(nodes) {
    const flattened = [];
    let index3 = -1;
    while (++index3 < nodes.length) {
      const node2 = nodes[index3];
      if ((node2.type === "delete" || node2.type === "link") && wrapNeeded(node2.children)) {
        flattened.push(...split(node2));
      } else {
        flattened.push(node2);
      }
    }
    return flattened;
  }
  function phrasing3(node2) {
    const tagName = node2.data && node2.data.hName;
    return tagName ? phrasing({ type: "element", tagName, properties: {}, children: [] }) : phrasing2(node2);
  }
  function cloneWithoutChildren(node2) {
    return esm_default({ ...node2, children: [] });
  }
  var init_wrap = __esm({
    "node_modules/hast-util-to-mdast/lib/util/wrap.js"() {
      init_esm();
      init_hast_util_phrasing();
      init_hast_util_whitespace();
      init_mdast_util_phrasing();
      init_drop_surrounding_breaks();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/media.js
  function media(state, node2) {
    const properties = node2.properties || {};
    const poster = node2.tagName === "video" ? String(properties.poster || "") : "";
    let source = String(properties.src || "");
    let index3 = -1;
    let linkInFallbackContent = false;
    let nodes = state.all(node2);
    const fragment2 = { type: "root", children: nodes };
    visit(fragment2, function(node3) {
      if (node3.type === "link") {
        linkInFallbackContent = true;
        return EXIT;
      }
    });
    if (linkInFallbackContent || wrapNeeded(nodes)) {
      return nodes;
    }
    while (!source && ++index3 < node2.children.length) {
      const child = node2.children[index3];
      if (child.type === "element" && child.tagName === "source" && child.properties) {
        source = String(child.properties.src || "");
      }
    }
    if (poster) {
      const image3 = {
        type: "image",
        title: null,
        url: state.resolve(poster),
        alt: toString2(nodes)
      };
      state.patch(node2, image3);
      nodes = [image3];
    }
    const children = (
      /** @type {Array<PhrasingContent>} */
      nodes
    );
    const result = {
      type: "link",
      title: properties.title ? String(properties.title) : null,
      url: state.resolve(source),
      children
    };
    state.patch(node2, result);
    return result;
  }
  var init_media = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/media.js"() {
      init_mdast_util_to_string();
      init_unist_util_visit();
      init_wrap();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/p.js
  function p3(state, node2) {
    const children = dropSurroundingBreaks(
      // Allow potentially invalid nodes, they might be unknown.
      // We also support straddling later.
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    if (children.length > 0) {
      const result = { type: "paragraph", children };
      state.patch(node2, result);
      return result;
    }
  }
  var init_p = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/p.js"() {
      init_drop_surrounding_breaks();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/q.js
  function q(state, node2) {
    const quotes = state.options.quotes || defaultQuotes;
    state.qNesting++;
    const contents = state.all(node2);
    state.qNesting--;
    const quote = quotes[state.qNesting % quotes.length];
    const head2 = contents[0];
    const tail = contents[contents.length - 1];
    const open = quote.charAt(0);
    const close2 = quote.length > 1 ? quote.charAt(1) : quote;
    if (head2 && head2.type === "text") {
      head2.value = open + head2.value;
    } else {
      contents.unshift({ type: "text", value: open });
    }
    if (tail && tail.type === "text") {
      tail.value += close2;
    } else {
      contents.push({ type: "text", value: close2 });
    }
    return contents;
  }
  var defaultQuotes;
  var init_q = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/q.js"() {
      defaultQuotes = ['"'];
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/root.js
  function root3(state, node2) {
    let children = state.all(node2);
    if (state.options.document || wrapNeeded(children)) {
      children = wrap2(children);
    }
    const result = { type: "root", children };
    state.patch(node2, result);
    return result;
  }
  var init_root2 = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/root.js"() {
      init_wrap();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/select.js
  function select(state, node2) {
    const values = findSelectedOptions(node2);
    let index3 = -1;
    const results = [];
    while (++index3 < values.length) {
      const value = values[index3];
      results.push(value[1] ? value[1] + " (" + value[0] + ")" : value[0]);
    }
    if (results.length > 0) {
      const result = { type: "text", value: results.join(", ") };
      state.patch(node2, result);
      return result;
    }
  }
  var init_select = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/select.js"() {
      init_find_selected_options();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/strong.js
  function strong(state, node2) {
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = { type: "strong", children };
    state.patch(node2, result);
    return result;
  }
  var init_strong = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/strong.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/table-cell.js
  function tableCell(state, node2) {
    const children = (
      /** @type {Array<PhrasingContent>} */
      state.all(node2)
    );
    const result = { type: "tableCell", children };
    state.patch(node2, result);
    if (node2.properties) {
      const rowSpan = node2.properties.rowSpan;
      const colSpan = node2.properties.colSpan;
      if (rowSpan || colSpan) {
        const data = (
          /** @type {Record<string, unknown>} */
          result.data || (result.data = {})
        );
        if (rowSpan) data.hastUtilToMdastTemporaryRowSpan = rowSpan;
        if (colSpan) data.hastUtilToMdastTemporaryColSpan = colSpan;
      }
    }
    return result;
  }
  var init_table_cell = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/table-cell.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/table-row.js
  function tableRow(state, node2) {
    const children = state.toSpecificContent(state.all(node2), create4);
    const result = { type: "tableRow", children };
    state.patch(node2, result);
    return result;
  }
  function create4() {
    return { type: "tableCell", children: [] };
  }
  var init_table_row = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/table-row.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/table.js
  function table(state, node2) {
    if (state.inTable) {
      const result2 = { type: "text", value: toText(node2) };
      state.patch(node2, result2);
      return result2;
    }
    state.inTable = true;
    const { align, headless } = inspect(node2);
    const rows = state.toSpecificContent(state.all(node2), createRow);
    if (headless) {
      rows.unshift(createRow());
    }
    let rowIndex = -1;
    while (++rowIndex < rows.length) {
      const row2 = rows[rowIndex];
      const cells2 = state.toSpecificContent(row2.children, createCell);
      row2.children = cells2;
    }
    let columns = 1;
    rowIndex = -1;
    while (++rowIndex < rows.length) {
      const cells2 = rows[rowIndex].children;
      let cellIndex = -1;
      while (++cellIndex < cells2.length) {
        const cell2 = cells2[cellIndex];
        if (cell2.data) {
          const data = (
            /** @type {Record<string, unknown>} */
            cell2.data
          );
          const colSpan = Number.parseInt(String(data.hastUtilToMdastTemporaryColSpan), 10) || 1;
          const rowSpan = Number.parseInt(String(data.hastUtilToMdastTemporaryRowSpan), 10) || 1;
          if (colSpan > 1 || rowSpan > 1) {
            let otherRowIndex = rowIndex - 1;
            while (++otherRowIndex < rowIndex + rowSpan) {
              let colIndex = cellIndex - 1;
              while (++colIndex < cellIndex + colSpan) {
                if (!rows[otherRowIndex]) {
                  break;
                }
                const newCells = [];
                if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {
                  newCells.push({ type: "tableCell", children: [] });
                }
                rows[otherRowIndex].children.splice(colIndex, 0, ...newCells);
              }
            }
          }
          if ("hastUtilToMdastTemporaryColSpan" in cell2.data)
            delete cell2.data.hastUtilToMdastTemporaryColSpan;
          if ("hastUtilToMdastTemporaryRowSpan" in cell2.data)
            delete cell2.data.hastUtilToMdastTemporaryRowSpan;
          if (Object.keys(cell2.data).length === 0) delete cell2.data;
        }
      }
      if (cells2.length > columns) columns = cells2.length;
    }
    rowIndex = -1;
    while (++rowIndex < rows.length) {
      const cells2 = rows[rowIndex].children;
      let cellIndex = cells2.length - 1;
      while (++cellIndex < columns) {
        cells2.push({ type: "tableCell", children: [] });
      }
    }
    let alignIndex = align.length - 1;
    while (++alignIndex < columns) {
      align.push(null);
    }
    state.inTable = false;
    const result = { type: "table", align, children: rows };
    state.patch(node2, result);
    return result;
  }
  function inspect(node2) {
    const info = { align: [null], headless: true };
    let rowIndex = 0;
    let cellIndex = 0;
    visit(node2, function(child) {
      if (child.type === "element") {
        if (child.tagName === "table" && node2 !== child) {
          return SKIP;
        }
        if ((child.tagName === "th" || child.tagName === "td") && child.properties) {
          if (!info.align[cellIndex]) {
            const value = String(child.properties.align || "") || null;
            if (value === "center" || value === "left" || value === "right" || value === null) {
              info.align[cellIndex] = value;
            }
          }
          if (info.headless && rowIndex < 2 && child.tagName === "th") {
            info.headless = false;
          }
          cellIndex++;
        } else if (child.tagName === "thead") {
          info.headless = false;
        } else if (child.tagName === "tr") {
          rowIndex++;
          cellIndex = 0;
        }
      }
    });
    return info;
  }
  function createCell() {
    return { type: "tableCell", children: [] };
  }
  function createRow() {
    return { type: "tableRow", children: [] };
  }
  var init_table = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/table.js"() {
      init_hast_util_to_text();
      init_unist_util_visit();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/text.js
  function text3(state, node2) {
    const result = { type: "text", value: node2.value };
    state.patch(node2, result);
    return result;
  }
  var init_text2 = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/text.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/textarea.js
  function textarea(state, node2) {
    const result = { type: "text", value: toText(node2) };
    state.patch(node2, result);
    return result;
  }
  var init_textarea = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/textarea.js"() {
      init_hast_util_to_text();
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/wbr.js
  function wbr(state, node2) {
    const result = { type: "text", value: "\u200B" };
    state.patch(node2, result);
    return result;
  }
  var init_wbr = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/wbr.js"() {
    }
  });

  // node_modules/hast-util-to-mdast/lib/handlers/index.js
  function all6(state, node2) {
    return state.all(node2);
  }
  function flow(state, node2) {
    return state.toFlow(state.all(node2));
  }
  function ignore() {
  }
  var nodeHandlers, handlers;
  var init_handlers = __esm({
    "node_modules/hast-util-to-mdast/lib/handlers/index.js"() {
      init_a();
      init_base();
      init_blockquote();
      init_br();
      init_code();
      init_comment2();
      init_del();
      init_dl();
      init_em();
      init_heading();
      init_hr();
      init_iframe();
      init_img();
      init_inline_code();
      init_input();
      init_li();
      init_list();
      init_media();
      init_p();
      init_q();
      init_root2();
      init_select();
      init_strong();
      init_table_cell();
      init_table_row();
      init_table();
      init_text2();
      init_textarea();
      init_wbr();
      nodeHandlers = {
        comment: comment3,
        doctype: ignore,
        root: root3,
        text: text3
      };
      handlers = {
        // Ignore:
        applet: ignore,
        area: ignore,
        basefont: ignore,
        bgsound: ignore,
        caption: ignore,
        col: ignore,
        colgroup: ignore,
        command: ignore,
        content: ignore,
        datalist: ignore,
        dialog: ignore,
        element: ignore,
        embed: ignore,
        frame: ignore,
        frameset: ignore,
        isindex: ignore,
        keygen: ignore,
        link: ignore,
        math: ignore,
        menu: ignore,
        menuitem: ignore,
        meta: ignore,
        nextid: ignore,
        noembed: ignore,
        noframes: ignore,
        optgroup: ignore,
        option: ignore,
        param: ignore,
        script: ignore,
        shadow: ignore,
        source: ignore,
        spacer: ignore,
        style: ignore,
        svg: ignore,
        template: ignore,
        title: ignore,
        track: ignore,
        // Use children:
        abbr: all6,
        acronym: all6,
        bdi: all6,
        bdo: all6,
        big: all6,
        blink: all6,
        button: all6,
        canvas: all6,
        cite: all6,
        data: all6,
        details: all6,
        dfn: all6,
        font: all6,
        ins: all6,
        label: all6,
        map: all6,
        marquee: all6,
        meter: all6,
        nobr: all6,
        noscript: all6,
        object: all6,
        output: all6,
        progress: all6,
        rb: all6,
        rbc: all6,
        rp: all6,
        rt: all6,
        rtc: all6,
        ruby: all6,
        slot: all6,
        small: all6,
        span: all6,
        sup: all6,
        sub: all6,
        tbody: all6,
        tfoot: all6,
        thead: all6,
        time: all6,
        // Use children as flow.
        address: flow,
        article: flow,
        aside: flow,
        body: flow,
        center: flow,
        div: flow,
        fieldset: flow,
        figcaption: flow,
        figure: flow,
        form: flow,
        footer: flow,
        header: flow,
        hgroup: flow,
        html: flow,
        legend: flow,
        main: flow,
        multicol: flow,
        nav: flow,
        picture: flow,
        section: flow,
        // Handle.
        a,
        audio: media,
        b: strong,
        base: base2,
        blockquote,
        br,
        code: inlineCode,
        dir: list2,
        dl,
        dt: li2,
        dd: li2,
        del,
        em,
        h1: heading,
        h2: heading,
        h3: heading,
        h4: heading,
        h5: heading,
        h6: heading,
        hr,
        i: em,
        iframe,
        img,
        image: img,
        input,
        kbd: inlineCode,
        li: li2,
        listing: code,
        mark: em,
        ol: list2,
        p: p3,
        plaintext: code,
        pre: code,
        q,
        s: del,
        samp: inlineCode,
        select,
        strike: del,
        strong,
        summary: p3,
        table,
        td: tableCell,
        textarea,
        th: tableCell,
        tr: tableRow,
        tt: inlineCode,
        u: em,
        ul: list2,
        var: inlineCode,
        video: media,
        wbr,
        xmp: code
      };
    }
  });

  // node_modules/hast-util-to-mdast/lib/state.js
  function createState(options2) {
    return {
      all: all7,
      baseFound: false,
      elementById: /* @__PURE__ */ new Map(),
      frozenBaseUrl: void 0,
      handlers: { ...handlers, ...options2.handlers },
      inTable: false,
      nodeHandlers: { ...nodeHandlers, ...options2.nodeHandlers },
      one: one5,
      options: options2,
      patch: patch2,
      qNesting: 0,
      resolve,
      toFlow,
      toSpecificContent
    };
  }
  function all7(parent) {
    const children = parent.children || [];
    const results = [];
    let index3 = -1;
    while (++index3 < children.length) {
      const child = children[index3];
      const result = (
        /** @type {Array<MdastRootContent> | MdastRootContent | undefined} */
        this.one(child, parent)
      );
      if (Array.isArray(result)) {
        results.push(...result);
      } else if (result) {
        results.push(result);
      }
    }
    return results;
  }
  function one5(node2, parent) {
    if (node2.type === "element") {
      if (node2.properties && node2.properties.dataMdast === "ignore") {
        return;
      }
      if (own7.call(this.handlers, node2.tagName)) {
        return this.handlers[node2.tagName](this, node2, parent) || void 0;
      }
    } else if (own7.call(this.nodeHandlers, node2.type)) {
      return this.nodeHandlers[node2.type](this, node2, parent) || void 0;
    }
    if ("value" in node2 && typeof node2.value === "string") {
      const result = { type: "text", value: node2.value };
      this.patch(node2, result);
      return result;
    }
    if ("children" in node2) {
      return this.all(node2);
    }
  }
  function patch2(origin, node2) {
    if (origin.position) node2.position = position3(origin);
  }
  function resolve(url) {
    const base4 = this.frozenBaseUrl;
    if (url === null || url === void 0) {
      return "";
    }
    if (base4) {
      return String(new URL(url, base4));
    }
    return url;
  }
  function toFlow(nodes) {
    return wrap2(nodes);
  }
  function toSpecificContent(nodes, build) {
    const reference = build();
    const results = [];
    let queue2 = [];
    let index3 = -1;
    while (++index3 < nodes.length) {
      const node2 = nodes[index3];
      if (expectedParent(node2)) {
        if (queue2.length > 0) {
          node2.children.unshift(...queue2);
          queue2 = [];
        }
        results.push(node2);
      } else {
        const child = (
          /** @type {ChildType} */
          node2
        );
        queue2.push(child);
      }
    }
    if (queue2.length > 0) {
      let node2 = results[results.length - 1];
      if (!node2) {
        node2 = build();
        results.push(node2);
      }
      node2.children.push(...queue2);
      queue2 = [];
    }
    return results;
    function expectedParent(node2) {
      return node2.type === reference.type;
    }
  }
  var own7;
  var init_state = __esm({
    "node_modules/hast-util-to-mdast/lib/state.js"() {
      init_unist_util_position();
      init_handlers();
      init_wrap();
      own7 = {}.hasOwnProperty;
    }
  });

  // node_modules/hast-util-to-mdast/lib/index.js
  function toMdast(tree, options2) {
    const cleanTree = esm_default(tree);
    const settings = options2 || emptyOptions5;
    const transformWhitespace = rehypeMinifyWhitespace({
      newlines: settings.newlines === true
    });
    const state = createState(settings);
    let mdast;
    transformWhitespace(cleanTree);
    visit(cleanTree, function(node2) {
      if (node2 && node2.type === "element" && node2.properties) {
        const id2 = String(node2.properties.id || "") || void 0;
        if (id2 && !state.elementById.has(id2)) {
          state.elementById.set(id2, node2);
        }
      }
    });
    const result = state.one(cleanTree, void 0);
    if (!result) {
      mdast = { type: "root", children: [] };
    } else if (Array.isArray(result)) {
      const children = (
        /** @type {Array<MdastRootContent>} */
        result
      );
      mdast = { type: "root", children };
    } else {
      mdast = result;
    }
    visit(mdast, function(node2, index3, parent) {
      if (node2.type === "text" && index3 !== void 0 && parent) {
        const previous3 = parent.children[index3 - 1];
        if (previous3 && previous3.type === node2.type) {
          previous3.value += node2.value;
          parent.children.splice(index3, 1);
          if (previous3.position && node2.position) {
            previous3.position.end = node2.position.end;
          }
          return index3 - 1;
        }
        node2.value = node2.value.replace(/[\t ]*(\r?\n|\r)[\t ]*/, "$1");
        if (parent && (parent.type === "heading" || parent.type === "paragraph" || parent.type === "root")) {
          if (!index3) {
            node2.value = node2.value.replace(/^[\t ]+/, "");
          }
          if (index3 === parent.children.length - 1) {
            node2.value = node2.value.replace(/[\t ]+$/, "");
          }
        }
        if (!node2.value) {
          parent.children.splice(index3, 1);
          return index3;
        }
      }
    });
    return mdast;
  }
  var emptyOptions5;
  var init_lib32 = __esm({
    "node_modules/hast-util-to-mdast/lib/index.js"() {
      init_esm();
      init_rehype_minify_whitespace();
      init_unist_util_visit();
      init_state();
      emptyOptions5 = {};
    }
  });

  // node_modules/hast-util-to-mdast/index.js
  var init_hast_util_to_mdast = __esm({
    "node_modules/hast-util-to-mdast/index.js"() {
      init_lib32();
      init_handlers();
    }
  });

  // node_modules/rehype-remark/lib/index.js
  function rehypeRemark(destination, options2) {
    if (destination && "run" in destination) {
      return async function(tree, file) {
        const mdastTree = toMdast(tree, { ...defaults, ...options2 });
        await destination.run(mdastTree, file);
      };
    }
    return function(tree) {
      return (
        /** @type {MdastRoot} */
        toMdast(tree, { ...defaults, ...destination })
      );
    };
  }
  var defaults;
  var init_lib33 = __esm({
    "node_modules/rehype-remark/lib/index.js"() {
      init_hast_util_to_mdast();
      defaults = { document: true };
    }
  });

  // node_modules/rehype-remark/index.js
  var rehype_remark_exports = {};
  __export(rehype_remark_exports, {
    default: () => rehypeRemark
  });
  var init_rehype_remark = __esm({
    "node_modules/rehype-remark/index.js"() {
      init_lib33();
    }
  });

  // node_modules/micromark-util-character/index.js
  function asciiControl(code5) {
    return (
      // Special whitespace codes (which have negative values), C0 and Control
      // character DEL
      code5 !== null && (code5 < 32 || code5 === 127)
    );
  }
  function markdownLineEnding(code5) {
    return code5 !== null && code5 < -2;
  }
  function markdownLineEndingOrSpace(code5) {
    return code5 !== null && (code5 < 0 || code5 === 32);
  }
  function markdownSpace(code5) {
    return code5 === -2 || code5 === -1 || code5 === 32;
  }
  function regexCheck(regex) {
    return check;
    function check(code5) {
      return code5 !== null && code5 > -1 && regex.test(String.fromCharCode(code5));
    }
  }
  var asciiAlpha, asciiAlphanumeric, asciiAtext, asciiDigit, asciiHexDigit, asciiPunctuation, unicodePunctuation, unicodeWhitespace;
  var init_micromark_util_character = __esm({
    "node_modules/micromark-util-character/index.js"() {
      asciiAlpha = regexCheck(/[A-Za-z]/);
      asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
      asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
      asciiDigit = regexCheck(/\d/);
      asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
      asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
      unicodePunctuation = regexCheck(/\p{P}|\p{S}/u);
      unicodeWhitespace = regexCheck(/\s/);
    }
  });

  // node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js
  function escapeStringRegexp(string3) {
    if (typeof string3 !== "string") {
      throw new TypeError("Expected a string");
    }
    return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  var init_escape_string_regexp = __esm({
    "node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js"() {
    }
  });

  // node_modules/mdast-util-find-and-replace/lib/index.js
  function findAndReplace(tree, list7, options2) {
    const settings = options2 || {};
    const ignored = convert(settings.ignore || []);
    const pairs = toPairs(list7);
    let pairIndex = -1;
    while (++pairIndex < pairs.length) {
      visitParents(tree, "text", visitor);
    }
    function visitor(node2, parents) {
      let index3 = -1;
      let grandparent;
      while (++index3 < parents.length) {
        const parent = parents[index3];
        const siblings2 = grandparent ? grandparent.children : void 0;
        if (ignored(
          parent,
          siblings2 ? siblings2.indexOf(parent) : void 0,
          grandparent
        )) {
          return;
        }
        grandparent = parent;
      }
      if (grandparent) {
        return handler(node2, parents);
      }
    }
    function handler(node2, parents) {
      const parent = parents[parents.length - 1];
      const find4 = pairs[pairIndex][0];
      const replace4 = pairs[pairIndex][1];
      let start = 0;
      const siblings2 = parent.children;
      const index3 = siblings2.indexOf(node2);
      let change = false;
      let nodes = [];
      find4.lastIndex = 0;
      let match = find4.exec(node2.value);
      while (match) {
        const position4 = match.index;
        const matchObject = {
          index: match.index,
          input: match.input,
          stack: [...parents, node2]
        };
        let value = replace4(...match, matchObject);
        if (typeof value === "string") {
          value = value.length > 0 ? { type: "text", value } : void 0;
        }
        if (value === false) {
          find4.lastIndex = position4 + 1;
        } else {
          if (start !== position4) {
            nodes.push({
              type: "text",
              value: node2.value.slice(start, position4)
            });
          }
          if (Array.isArray(value)) {
            nodes.push(...value);
          } else if (value) {
            nodes.push(value);
          }
          start = position4 + match[0].length;
          change = true;
        }
        if (!find4.global) {
          break;
        }
        match = find4.exec(node2.value);
      }
      if (change) {
        if (start < node2.value.length) {
          nodes.push({ type: "text", value: node2.value.slice(start) });
        }
        parent.children.splice(index3, 1, ...nodes);
      } else {
        nodes = [node2];
      }
      return index3 + nodes.length;
    }
  }
  function toPairs(tupleOrList) {
    const result = [];
    if (!Array.isArray(tupleOrList)) {
      throw new TypeError("Expected find and replace tuple or list of tuples");
    }
    const list7 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];
    let index3 = -1;
    while (++index3 < list7.length) {
      const tuple = list7[index3];
      result.push([toExpression(tuple[0]), toFunction(tuple[1])]);
    }
    return result;
  }
  function toExpression(find4) {
    return typeof find4 === "string" ? new RegExp(escapeStringRegexp(find4), "g") : find4;
  }
  function toFunction(replace4) {
    return typeof replace4 === "function" ? replace4 : function() {
      return replace4;
    };
  }
  var init_lib34 = __esm({
    "node_modules/mdast-util-find-and-replace/lib/index.js"() {
      init_escape_string_regexp();
      init_unist_util_visit_parents();
      init_unist_util_is();
    }
  });

  // node_modules/mdast-util-find-and-replace/index.js
  var init_mdast_util_find_and_replace = __esm({
    "node_modules/mdast-util-find-and-replace/index.js"() {
      init_lib34();
    }
  });

  // node_modules/mdast-util-gfm-autolink-literal/lib/index.js
  function gfmAutolinkLiteralFromMarkdown() {
    return {
      transforms: [transformGfmAutolinkLiterals],
      enter: {
        literalAutolink: enterLiteralAutolink,
        literalAutolinkEmail: enterLiteralAutolinkValue,
        literalAutolinkHttp: enterLiteralAutolinkValue,
        literalAutolinkWww: enterLiteralAutolinkValue
      },
      exit: {
        literalAutolink: exitLiteralAutolink,
        literalAutolinkEmail: exitLiteralAutolinkEmail,
        literalAutolinkHttp: exitLiteralAutolinkHttp,
        literalAutolinkWww: exitLiteralAutolinkWww
      }
    };
  }
  function gfmAutolinkLiteralToMarkdown() {
    return {
      unsafe: [
        {
          character: "@",
          before: "[+\\-.\\w]",
          after: "[\\-.\\w]",
          inConstruct,
          notInConstruct
        },
        {
          character: ".",
          before: "[Ww]",
          after: "[\\-.\\w]",
          inConstruct,
          notInConstruct
        },
        {
          character: ":",
          before: "[ps]",
          after: "\\/",
          inConstruct,
          notInConstruct
        }
      ]
    };
  }
  function enterLiteralAutolink(token) {
    this.enter({ type: "link", title: null, url: "", children: [] }, token);
  }
  function enterLiteralAutolinkValue(token) {
    this.config.enter.autolinkProtocol.call(this, token);
  }
  function exitLiteralAutolinkHttp(token) {
    this.config.exit.autolinkProtocol.call(this, token);
  }
  function exitLiteralAutolinkWww(token) {
    this.config.exit.data.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "link");
    node2.url = "http://" + this.sliceSerialize(token);
  }
  function exitLiteralAutolinkEmail(token) {
    this.config.exit.autolinkEmail.call(this, token);
  }
  function exitLiteralAutolink(token) {
    this.exit(token);
  }
  function transformGfmAutolinkLiterals(tree) {
    findAndReplace(
      tree,
      [
        [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
        [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, findEmail]
      ],
      { ignore: ["link", "linkReference"] }
    );
  }
  function findUrl(_2, protocol, domain3, path2, match) {
    let prefix3 = "";
    if (!previous(match)) {
      return false;
    }
    if (/^w/i.test(protocol)) {
      domain3 = protocol + domain3;
      protocol = "";
      prefix3 = "http://";
    }
    if (!isCorrectDomain(domain3)) {
      return false;
    }
    const parts = splitUrl(domain3 + path2);
    if (!parts[0]) return false;
    const result = {
      type: "link",
      title: null,
      url: prefix3 + protocol + parts[0],
      children: [{ type: "text", value: protocol + parts[0] }]
    };
    if (parts[1]) {
      return [result, { type: "text", value: parts[1] }];
    }
    return result;
  }
  function findEmail(_2, atext, label, match) {
    if (
      // Not an expected previous character.
      !previous(match, true) || // Label ends in not allowed character.
      /[-\d_]$/.test(label)
    ) {
      return false;
    }
    return {
      type: "link",
      title: null,
      url: "mailto:" + atext + "@" + label,
      children: [{ type: "text", value: atext + "@" + label }]
    };
  }
  function isCorrectDomain(domain3) {
    const parts = domain3.split(".");
    if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
      return false;
    }
    return true;
  }
  function splitUrl(url) {
    const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
    if (!trailExec) {
      return [url, void 0];
    }
    url = url.slice(0, trailExec.index);
    let trail2 = trailExec[0];
    let closingParenIndex = trail2.indexOf(")");
    const openingParens = ccount(url, "(");
    let closingParens = ccount(url, ")");
    while (closingParenIndex !== -1 && openingParens > closingParens) {
      url += trail2.slice(0, closingParenIndex + 1);
      trail2 = trail2.slice(closingParenIndex + 1);
      closingParenIndex = trail2.indexOf(")");
      closingParens++;
    }
    return [url, trail2];
  }
  function previous(match, email) {
    const code5 = match.input.charCodeAt(match.index - 1);
    return (match.index === 0 || unicodeWhitespace(code5) || unicodePunctuation(code5)) && // If its an email, the previous character should not be a slash.
    (!email || code5 !== 47);
  }
  var inConstruct, notInConstruct;
  var init_lib35 = __esm({
    "node_modules/mdast-util-gfm-autolink-literal/lib/index.js"() {
      init_ccount();
      init_default();
      init_micromark_util_character();
      init_mdast_util_find_and_replace();
      inConstruct = "phrasing";
      notInConstruct = ["autolink", "link", "image", "label"];
    }
  });

  // node_modules/mdast-util-gfm-autolink-literal/index.js
  var init_mdast_util_gfm_autolink_literal = __esm({
    "node_modules/mdast-util-gfm-autolink-literal/index.js"() {
      init_lib35();
    }
  });

  // node_modules/micromark-util-normalize-identifier/index.js
  function normalizeIdentifier(value) {
    return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
  }
  var init_micromark_util_normalize_identifier = __esm({
    "node_modules/micromark-util-normalize-identifier/index.js"() {
    }
  });

  // node_modules/mdast-util-gfm-footnote/lib/index.js
  function enterFootnoteCallString() {
    this.buffer();
  }
  function enterFootnoteCall(token) {
    this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
  }
  function enterFootnoteDefinitionLabelString() {
    this.buffer();
  }
  function enterFootnoteDefinition(token) {
    this.enter(
      { type: "footnoteDefinition", identifier: "", label: "", children: [] },
      token
    );
  }
  function exitFootnoteCallString(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "footnoteReference");
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    node2.label = label;
  }
  function exitFootnoteCall(token) {
    this.exit(token);
  }
  function exitFootnoteDefinitionLabelString(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "footnoteDefinition");
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    node2.label = label;
  }
  function exitFootnoteDefinition(token) {
    this.exit(token);
  }
  function footnoteReferencePeek() {
    return "[";
  }
  function footnoteReference(node2, _2, state, info) {
    const tracker = state.createTracker(info);
    let value = tracker.move("[^");
    const exit3 = state.enter("footnoteReference");
    const subexit = state.enter("reference");
    value += tracker.move(
      state.safe(state.associationId(node2), { after: "]", before: value })
    );
    subexit();
    exit3();
    value += tracker.move("]");
    return value;
  }
  function gfmFootnoteFromMarkdown() {
    return {
      enter: {
        gfmFootnoteCallString: enterFootnoteCallString,
        gfmFootnoteCall: enterFootnoteCall,
        gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
        gfmFootnoteDefinition: enterFootnoteDefinition
      },
      exit: {
        gfmFootnoteCallString: exitFootnoteCallString,
        gfmFootnoteCall: exitFootnoteCall,
        gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
        gfmFootnoteDefinition: exitFootnoteDefinition
      }
    };
  }
  function gfmFootnoteToMarkdown(options2) {
    let firstLineBlank = false;
    if (options2 && options2.firstLineBlank) {
      firstLineBlank = true;
    }
    return {
      handlers: { footnoteDefinition, footnoteReference },
      // This is on by default already.
      unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
    };
    function footnoteDefinition(node2, _2, state, info) {
      const tracker = state.createTracker(info);
      let value = tracker.move("[^");
      const exit3 = state.enter("footnoteDefinition");
      const subexit = state.enter("label");
      value += tracker.move(
        state.safe(state.associationId(node2), { before: value, after: "]" })
      );
      subexit();
      value += tracker.move("]:");
      if (node2.children && node2.children.length > 0) {
        tracker.shift(4);
        value += tracker.move(
          (firstLineBlank ? "\n" : " ") + state.indentLines(
            state.containerFlow(node2, tracker.current()),
            firstLineBlank ? mapAll : mapExceptFirst
          )
        );
      }
      exit3();
      return value;
    }
  }
  function mapExceptFirst(line, index3, blank2) {
    return index3 === 0 ? line : mapAll(line, index3, blank2);
  }
  function mapAll(line, index3, blank2) {
    return (blank2 ? "" : "    ") + line;
  }
  var init_lib36 = __esm({
    "node_modules/mdast-util-gfm-footnote/lib/index.js"() {
      init_default();
      init_micromark_util_normalize_identifier();
      footnoteReference.peek = footnoteReferencePeek;
    }
  });

  // node_modules/mdast-util-gfm-footnote/index.js
  var init_mdast_util_gfm_footnote = __esm({
    "node_modules/mdast-util-gfm-footnote/index.js"() {
      init_lib36();
    }
  });

  // node_modules/mdast-util-gfm-strikethrough/lib/index.js
  function gfmStrikethroughFromMarkdown() {
    return {
      canContainEols: ["delete"],
      enter: { strikethrough: enterStrikethrough },
      exit: { strikethrough: exitStrikethrough }
    };
  }
  function gfmStrikethroughToMarkdown() {
    return {
      unsafe: [
        {
          character: "~",
          inConstruct: "phrasing",
          notInConstruct: constructsWithoutStrikethrough
        }
      ],
      handlers: { delete: handleDelete }
    };
  }
  function enterStrikethrough(token) {
    this.enter({ type: "delete", children: [] }, token);
  }
  function exitStrikethrough(token) {
    this.exit(token);
  }
  function handleDelete(node2, _2, state, info) {
    const tracker = state.createTracker(info);
    const exit3 = state.enter("strikethrough");
    let value = tracker.move("~~");
    value += state.containerPhrasing(node2, {
      ...tracker.current(),
      before: value,
      after: "~"
    });
    value += tracker.move("~~");
    exit3();
    return value;
  }
  function peekDelete() {
    return "~";
  }
  var constructsWithoutStrikethrough;
  var init_lib37 = __esm({
    "node_modules/mdast-util-gfm-strikethrough/lib/index.js"() {
      constructsWithoutStrikethrough = [
        "autolink",
        "destinationLiteral",
        "destinationRaw",
        "reference",
        "titleQuote",
        "titleApostrophe"
      ];
      handleDelete.peek = peekDelete;
    }
  });

  // node_modules/mdast-util-gfm-strikethrough/index.js
  var init_mdast_util_gfm_strikethrough = __esm({
    "node_modules/mdast-util-gfm-strikethrough/index.js"() {
      init_lib37();
    }
  });

  // node_modules/markdown-table/index.js
  function defaultStringLength(value) {
    return value.length;
  }
  function markdownTable(table3, options2) {
    const settings = options2 || {};
    const align = (settings.align || []).concat();
    const stringLength = settings.stringLength || defaultStringLength;
    const alignments = [];
    const cellMatrix = [];
    const sizeMatrix = [];
    const longestCellByColumn = [];
    let mostCellsPerRow = 0;
    let rowIndex = -1;
    while (++rowIndex < table3.length) {
      const row3 = [];
      const sizes2 = [];
      let columnIndex2 = -1;
      if (table3[rowIndex].length > mostCellsPerRow) {
        mostCellsPerRow = table3[rowIndex].length;
      }
      while (++columnIndex2 < table3[rowIndex].length) {
        const cell2 = serialize3(table3[rowIndex][columnIndex2]);
        if (settings.alignDelimiters !== false) {
          const size2 = stringLength(cell2);
          sizes2[columnIndex2] = size2;
          if (longestCellByColumn[columnIndex2] === void 0 || size2 > longestCellByColumn[columnIndex2]) {
            longestCellByColumn[columnIndex2] = size2;
          }
        }
        row3.push(cell2);
      }
      cellMatrix[rowIndex] = row3;
      sizeMatrix[rowIndex] = sizes2;
    }
    let columnIndex = -1;
    if (typeof align === "object" && "length" in align) {
      while (++columnIndex < mostCellsPerRow) {
        alignments[columnIndex] = toAlignment(align[columnIndex]);
      }
    } else {
      const code5 = toAlignment(align);
      while (++columnIndex < mostCellsPerRow) {
        alignments[columnIndex] = code5;
      }
    }
    columnIndex = -1;
    const row2 = [];
    const sizes = [];
    while (++columnIndex < mostCellsPerRow) {
      const code5 = alignments[columnIndex];
      let before = "";
      let after = "";
      if (code5 === 99) {
        before = ":";
        after = ":";
      } else if (code5 === 108) {
        before = ":";
      } else if (code5 === 114) {
        after = ":";
      }
      let size2 = settings.alignDelimiters === false ? 1 : Math.max(
        1,
        longestCellByColumn[columnIndex] - before.length - after.length
      );
      const cell2 = before + "-".repeat(size2) + after;
      if (settings.alignDelimiters !== false) {
        size2 = before.length + size2 + after.length;
        if (size2 > longestCellByColumn[columnIndex]) {
          longestCellByColumn[columnIndex] = size2;
        }
        sizes[columnIndex] = size2;
      }
      row2[columnIndex] = cell2;
    }
    cellMatrix.splice(1, 0, row2);
    sizeMatrix.splice(1, 0, sizes);
    rowIndex = -1;
    const lines = [];
    while (++rowIndex < cellMatrix.length) {
      const row3 = cellMatrix[rowIndex];
      const sizes2 = sizeMatrix[rowIndex];
      columnIndex = -1;
      const line = [];
      while (++columnIndex < mostCellsPerRow) {
        const cell2 = row3[columnIndex] || "";
        let before = "";
        let after = "";
        if (settings.alignDelimiters !== false) {
          const size2 = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
          const code5 = alignments[columnIndex];
          if (code5 === 114) {
            before = " ".repeat(size2);
          } else if (code5 === 99) {
            if (size2 % 2) {
              before = " ".repeat(size2 / 2 + 0.5);
              after = " ".repeat(size2 / 2 - 0.5);
            } else {
              before = " ".repeat(size2 / 2);
              after = before;
            }
          } else {
            after = " ".repeat(size2);
          }
        }
        if (settings.delimiterStart !== false && !columnIndex) {
          line.push("|");
        }
        if (settings.padding !== false && // Dont add the opening space if were not aligning and the cell is
        // empty: there will be a closing space.
        !(settings.alignDelimiters === false && cell2 === "") && (settings.delimiterStart !== false || columnIndex)) {
          line.push(" ");
        }
        if (settings.alignDelimiters !== false) {
          line.push(before);
        }
        line.push(cell2);
        if (settings.alignDelimiters !== false) {
          line.push(after);
        }
        if (settings.padding !== false) {
          line.push(" ");
        }
        if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
          line.push("|");
        }
      }
      lines.push(
        settings.delimiterEnd === false ? line.join("").replace(/ +$/, "") : line.join("")
      );
    }
    return lines.join("\n");
  }
  function serialize3(value) {
    return value === null || value === void 0 ? "" : String(value);
  }
  function toAlignment(value) {
    const code5 = typeof value === "string" ? value.codePointAt(0) : 0;
    return code5 === 67 || code5 === 99 ? 99 : code5 === 76 || code5 === 108 ? 108 : code5 === 82 || code5 === 114 ? 114 : 0;
  }
  var init_markdown_table = __esm({
    "node_modules/markdown-table/index.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/configure.js
  function configure(base4, extension2) {
    let index3 = -1;
    let key2;
    if (extension2.extensions) {
      while (++index3 < extension2.extensions.length) {
        configure(base4, extension2.extensions[index3]);
      }
    }
    for (key2 in extension2) {
      if (own8.call(extension2, key2)) {
        switch (key2) {
          case "extensions": {
            break;
          }
          /* c8 ignore next 4 */
          case "unsafe": {
            list3(base4[key2], extension2[key2]);
            break;
          }
          case "join": {
            list3(base4[key2], extension2[key2]);
            break;
          }
          case "handlers": {
            map(base4[key2], extension2[key2]);
            break;
          }
          default: {
            base4.options[key2] = extension2[key2];
          }
        }
      }
    }
    return base4;
  }
  function list3(left, right) {
    if (right) {
      left.push(...right);
    }
  }
  function map(left, right) {
    if (right) {
      Object.assign(left, right);
    }
  }
  var own8;
  var init_configure = __esm({
    "node_modules/mdast-util-to-markdown/lib/configure.js"() {
      own8 = {}.hasOwnProperty;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
  function blockquote2(node2, _2, state, info) {
    const exit3 = state.enter("blockquote");
    const tracker = state.createTracker(info);
    tracker.move("> ");
    tracker.shift(2);
    const value = state.indentLines(
      state.containerFlow(node2, tracker.current()),
      map2
    );
    exit3();
    return value;
  }
  function map2(line, _2, blank2) {
    return ">" + (blank2 ? "" : " ") + line;
  }
  var init_blockquote2 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/blockquote.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
  function patternInScope(stack, pattern) {
    return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
  }
  function listInScope(stack, list7, none2) {
    if (typeof list7 === "string") {
      list7 = [list7];
    }
    if (!list7 || list7.length === 0) {
      return none2;
    }
    let index3 = -1;
    while (++index3 < list7.length) {
      if (stack.includes(list7[index3])) {
        return true;
      }
    }
    return false;
  }
  var init_pattern_in_scope = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/break.js
  function hardBreak(_2, _1, state, info) {
    let index3 = -1;
    while (++index3 < state.unsafe.length) {
      if (state.unsafe[index3].character === "\n" && patternInScope(state.stack, state.unsafe[index3])) {
        return /[ \t]/.test(info.before) ? "" : " ";
      }
    }
    return "\\\n";
  }
  var init_break = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/break.js"() {
      init_pattern_in_scope();
    }
  });

  // node_modules/longest-streak/index.js
  function longestStreak(value, substring) {
    const source = String(value);
    let index3 = source.indexOf(substring);
    let expected = index3;
    let count = 0;
    let max2 = 0;
    if (typeof substring !== "string") {
      throw new TypeError("Expected substring");
    }
    while (index3 !== -1) {
      if (index3 === expected) {
        if (++count > max2) {
          max2 = count;
        }
      } else {
        count = 1;
      }
      expected = index3 + substring.length;
      index3 = source.indexOf(substring, expected);
    }
    return max2;
  }
  var init_longest_streak = __esm({
    "node_modules/longest-streak/index.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
  function formatCodeAsIndented(node2, state) {
    return Boolean(
      state.options.fences === false && node2.value && // If theres no info
      !node2.lang && // And theres a non-whitespace character
      /[^ \r\n]/.test(node2.value) && // And the value doesnt start or end in a blank
      !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
    );
  }
  var init_format_code_as_indented = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-fence.js
  function checkFence(state) {
    const marker = state.options.fence || "`";
    if (marker !== "`" && marker !== "~") {
      throw new Error(
        "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
      );
    }
    return marker;
  }
  var init_check_fence = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-fence.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/code.js
  function code2(node2, _2, state, info) {
    const marker = checkFence(state);
    const raw2 = node2.value || "";
    const suffix = marker === "`" ? "GraveAccent" : "Tilde";
    if (formatCodeAsIndented(node2, state)) {
      const exit4 = state.enter("codeIndented");
      const value2 = state.indentLines(raw2, map3);
      exit4();
      return value2;
    }
    const tracker = state.createTracker(info);
    const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
    const exit3 = state.enter("codeFenced");
    let value = tracker.move(sequence);
    if (node2.lang) {
      const subexit = state.enter(`codeFencedLang${suffix}`);
      value += tracker.move(
        state.safe(node2.lang, {
          before: value,
          after: " ",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    if (node2.lang && node2.meta) {
      const subexit = state.enter(`codeFencedMeta${suffix}`);
      value += tracker.move(" ");
      value += tracker.move(
        state.safe(node2.meta, {
          before: value,
          after: "\n",
          encode: ["`"],
          ...tracker.current()
        })
      );
      subexit();
    }
    value += tracker.move("\n");
    if (raw2) {
      value += tracker.move(raw2 + "\n");
    }
    value += tracker.move(sequence);
    exit3();
    return value;
  }
  function map3(line, _2, blank2) {
    return (blank2 ? "" : "    ") + line;
  }
  var init_code2 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/code.js"() {
      init_longest_streak();
      init_format_code_as_indented();
      init_check_fence();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-quote.js
  function checkQuote(state) {
    const marker = state.options.quote || '"';
    if (marker !== '"' && marker !== "'") {
      throw new Error(
        "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
      );
    }
    return marker;
  }
  var init_check_quote = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-quote.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/definition.js
  function definition(node2, _2, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit3 = state.enter("definition");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("[");
    value += tracker.move(
      state.safe(state.associationId(node2), {
        before: value,
        after: "]",
        ...tracker.current()
      })
    );
    value += tracker.move("]: ");
    subexit();
    if (
      // If theres no url, or
      !node2.url || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node2.url, {
          before: value,
          after: node2.title ? " " : "\n",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node2.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    exit3();
    return value;
  }
  var init_definition = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/definition.js"() {
      init_check_quote();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
  function checkEmphasis(state) {
    const marker = state.options.emphasis || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
      );
    }
    return marker;
  }
  var init_check_emphasis = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js
  function encodeCharacterReference(code5) {
    return "&#x" + code5.toString(16).toUpperCase() + ";";
  }
  var init_encode_character_reference = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js"() {
    }
  });

  // node_modules/micromark-util-classify-character/index.js
  function classifyCharacter(code5) {
    if (code5 === null || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5)) {
      return 1;
    }
    if (unicodePunctuation(code5)) {
      return 2;
    }
  }
  var init_micromark_util_classify_character = __esm({
    "node_modules/micromark-util-classify-character/index.js"() {
      init_micromark_util_character();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/encode-info.js
  function encodeInfo(outside, inside, marker) {
    const outsideKind = classifyCharacter(outside);
    const insideKind = classifyCharacter(inside);
    if (outsideKind === void 0) {
      return insideKind === void 0 ? (
        // Letter inside:
        // we have to encode *both* letters for `_` as it is looser.
        // it already forms for `*` (and GFMs `~`).
        marker === "_" ? { inside: true, outside: true } : { inside: false, outside: false }
      ) : insideKind === 1 ? (
        // Whitespace inside: encode both (letter, whitespace).
        { inside: true, outside: true }
      ) : (
        // Punctuation inside: encode outer (letter)
        { inside: false, outside: true }
      );
    }
    if (outsideKind === 1) {
      return insideKind === void 0 ? (
        // Letter inside: already forms.
        { inside: false, outside: false }
      ) : insideKind === 1 ? (
        // Whitespace inside: encode both (whitespace).
        { inside: true, outside: true }
      ) : (
        // Punctuation inside: already forms.
        { inside: false, outside: false }
      );
    }
    return insideKind === void 0 ? (
      // Letter inside: already forms.
      { inside: false, outside: false }
    ) : insideKind === 1 ? (
      // Whitespace inside: encode inner (whitespace).
      { inside: true, outside: false }
    ) : (
      // Punctuation inside: already forms.
      { inside: false, outside: false }
    );
  }
  var init_encode_info = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/encode-info.js"() {
      init_micromark_util_classify_character();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
  function emphasis(node2, _2, state, info) {
    const marker = checkEmphasis(state);
    const exit3 = state.enter("emphasis");
    const tracker = state.createTracker(info);
    const before = tracker.move(marker);
    let between2 = tracker.move(
      state.containerPhrasing(node2, {
        after: marker,
        before,
        ...tracker.current()
      })
    );
    const betweenHead = between2.charCodeAt(0);
    const open = encodeInfo(
      info.before.charCodeAt(info.before.length - 1),
      betweenHead,
      marker
    );
    if (open.inside) {
      between2 = encodeCharacterReference(betweenHead) + between2.slice(1);
    }
    const betweenTail = between2.charCodeAt(between2.length - 1);
    const close2 = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
    if (close2.inside) {
      between2 = between2.slice(0, -1) + encodeCharacterReference(betweenTail);
    }
    const after = tracker.move(marker);
    exit3();
    state.attentionEncodeSurroundingInfo = {
      after: close2.outside,
      before: open.outside
    };
    return before + between2 + after;
  }
  function emphasisPeek(_2, _1, state) {
    return state.options.emphasis || "*";
  }
  var init_emphasis = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/emphasis.js"() {
      init_check_emphasis();
      init_encode_character_reference();
      init_encode_info();
      emphasis.peek = emphasisPeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
  function formatHeadingAsSetext(node2, state) {
    let literalWithBreak = false;
    visit(node2, function(node3) {
      if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
        literalWithBreak = true;
        return EXIT;
      }
    });
    return Boolean(
      (!node2.depth || node2.depth < 3) && toString2(node2) && (state.options.setext || literalWithBreak)
    );
  }
  var init_format_heading_as_setext = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js"() {
      init_unist_util_visit();
      init_mdast_util_to_string();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/heading.js
  function heading2(node2, _2, state, info) {
    const rank = Math.max(Math.min(6, node2.depth || 1), 1);
    const tracker = state.createTracker(info);
    if (formatHeadingAsSetext(node2, state)) {
      const exit4 = state.enter("headingSetext");
      const subexit2 = state.enter("phrasing");
      const value2 = state.containerPhrasing(node2, {
        ...tracker.current(),
        before: "\n",
        after: "\n"
      });
      subexit2();
      exit4();
      return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
        // The whole size
        value2.length - // Minus the position of the character after the last EOL (or
        // 0 if there is none)
        (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
      );
    }
    const sequence = "#".repeat(rank);
    const exit3 = state.enter("headingAtx");
    const subexit = state.enter("phrasing");
    tracker.move(sequence + " ");
    let value = state.containerPhrasing(node2, {
      before: "# ",
      after: "\n",
      ...tracker.current()
    });
    if (/^[\t ]/.test(value)) {
      value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);
    }
    value = value ? sequence + " " + value : sequence;
    if (state.options.closeAtx) {
      value += " " + sequence;
    }
    subexit();
    exit3();
    return value;
  }
  var init_heading2 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/heading.js"() {
      init_encode_character_reference();
      init_format_heading_as_setext();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/html.js
  function html5(node2) {
    return node2.value || "";
  }
  function htmlPeek() {
    return "<";
  }
  var init_html3 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/html.js"() {
      html5.peek = htmlPeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/image.js
  function image(node2, _2, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const exit3 = state.enter("image");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("![");
    value += tracker.move(
      state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
    );
    value += tracker.move("](");
    subexit();
    if (
      // If theres no url but there is a title
      !node2.url && node2.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node2.url, {
          before: value,
          after: node2.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node2.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    value += tracker.move(")");
    exit3();
    return value;
  }
  function imagePeek() {
    return "!";
  }
  var init_image = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/image.js"() {
      init_check_quote();
      image.peek = imagePeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
  function imageReference(node2, _2, state, info) {
    const type = node2.referenceType;
    const exit3 = state.enter("imageReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("![");
    const alt = state.safe(node2.alt, {
      before: value,
      after: "]",
      ...tracker.current()
    });
    value += tracker.move(alt + "][");
    subexit();
    const stack = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack;
    exit3();
    if (type === "full" || !alt || alt !== reference) {
      value += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value = value.slice(0, -1);
    } else {
      value += tracker.move("]");
    }
    return value;
  }
  function imageReferencePeek() {
    return "!";
  }
  var init_image_reference = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/image-reference.js"() {
      imageReference.peek = imageReferencePeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
  function inlineCode2(node2, _2, state) {
    let value = node2.value || "";
    let sequence = "`";
    let index3 = -1;
    while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
      sequence += "`";
    }
    if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
      value = " " + value + " ";
    }
    while (++index3 < state.unsafe.length) {
      const pattern = state.unsafe[index3];
      const expression = state.compilePattern(pattern);
      let match;
      if (!pattern.atBreak) continue;
      while (match = expression.exec(value)) {
        let position4 = match.index;
        if (value.charCodeAt(position4) === 10 && value.charCodeAt(position4 - 1) === 13) {
          position4--;
        }
        value = value.slice(0, position4) + " " + value.slice(match.index + 1);
      }
    }
    return sequence + value + sequence;
  }
  function inlineCodePeek() {
    return "`";
  }
  var init_inline_code2 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/inline-code.js"() {
      inlineCode2.peek = inlineCodePeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
  function formatLinkAsAutolink(node2, state) {
    const raw2 = toString2(node2);
    return Boolean(
      !state.options.resourceLink && // If theres a url
      node2.url && // And theres a no title
      !node2.title && // And the content of `node` is a single text node
      node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content
      (raw2 === node2.url || "mailto:" + raw2 === node2.url) && // And that starts w/ a protocol
      /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesnt contain ASCII control codes (character escapes and
      // references dont work), space, or angle brackets
      !/[\0- <>\u007F]/.test(node2.url)
    );
  }
  var init_format_link_as_autolink = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js"() {
      init_mdast_util_to_string();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/link.js
  function link(node2, _2, state, info) {
    const quote = checkQuote(state);
    const suffix = quote === '"' ? "Quote" : "Apostrophe";
    const tracker = state.createTracker(info);
    let exit3;
    let subexit;
    if (formatLinkAsAutolink(node2, state)) {
      const stack = state.stack;
      state.stack = [];
      exit3 = state.enter("autolink");
      let value2 = tracker.move("<");
      value2 += tracker.move(
        state.containerPhrasing(node2, {
          before: value2,
          after: ">",
          ...tracker.current()
        })
      );
      value2 += tracker.move(">");
      exit3();
      state.stack = stack;
      return value2;
    }
    exit3 = state.enter("link");
    subexit = state.enter("label");
    let value = tracker.move("[");
    value += tracker.move(
      state.containerPhrasing(node2, {
        before: value,
        after: "](",
        ...tracker.current()
      })
    );
    value += tracker.move("](");
    subexit();
    if (
      // If theres no url but there is a title
      !node2.url && node2.title || // If there are control characters or whitespace.
      /[\0- \u007F]/.test(node2.url)
    ) {
      subexit = state.enter("destinationLiteral");
      value += tracker.move("<");
      value += tracker.move(
        state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
      );
      value += tracker.move(">");
    } else {
      subexit = state.enter("destinationRaw");
      value += tracker.move(
        state.safe(node2.url, {
          before: value,
          after: node2.title ? " " : ")",
          ...tracker.current()
        })
      );
    }
    subexit();
    if (node2.title) {
      subexit = state.enter(`title${suffix}`);
      value += tracker.move(" " + quote);
      value += tracker.move(
        state.safe(node2.title, {
          before: value,
          after: quote,
          ...tracker.current()
        })
      );
      value += tracker.move(quote);
      subexit();
    }
    value += tracker.move(")");
    exit3();
    return value;
  }
  function linkPeek(node2, _2, state) {
    return formatLinkAsAutolink(node2, state) ? "<" : "[";
  }
  var init_link = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/link.js"() {
      init_check_quote();
      init_format_link_as_autolink();
      link.peek = linkPeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
  function linkReference(node2, _2, state, info) {
    const type = node2.referenceType;
    const exit3 = state.enter("linkReference");
    let subexit = state.enter("label");
    const tracker = state.createTracker(info);
    let value = tracker.move("[");
    const text10 = state.containerPhrasing(node2, {
      before: value,
      after: "]",
      ...tracker.current()
    });
    value += tracker.move(text10 + "][");
    subexit();
    const stack = state.stack;
    state.stack = [];
    subexit = state.enter("reference");
    const reference = state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    });
    subexit();
    state.stack = stack;
    exit3();
    if (type === "full" || !text10 || text10 !== reference) {
      value += tracker.move(reference + "]");
    } else if (type === "shortcut") {
      value = value.slice(0, -1);
    } else {
      value += tracker.move("]");
    }
    return value;
  }
  function linkReferencePeek() {
    return "[";
  }
  var init_link_reference = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/link-reference.js"() {
      linkReference.peek = linkReferencePeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
  function checkBullet(state) {
    const marker = state.options.bullet || "*";
    if (marker !== "*" && marker !== "+" && marker !== "-") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
      );
    }
    return marker;
  }
  var init_check_bullet = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-bullet.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
  function checkBulletOther(state) {
    const bullet = checkBullet(state);
    const bulletOther = state.options.bulletOther;
    if (!bulletOther) {
      return bullet === "*" ? "-" : "*";
    }
    if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
      throw new Error(
        "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
      );
    }
    if (bulletOther === bullet) {
      throw new Error(
        "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
      );
    }
    return bulletOther;
  }
  var init_check_bullet_other = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js"() {
      init_check_bullet();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
  function checkBulletOrdered(state) {
    const marker = state.options.bulletOrdered || ".";
    if (marker !== "." && marker !== ")") {
      throw new Error(
        "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
      );
    }
    return marker;
  }
  var init_check_bullet_ordered = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-rule.js
  function checkRule(state) {
    const marker = state.options.rule || "*";
    if (marker !== "*" && marker !== "-" && marker !== "_") {
      throw new Error(
        "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
      );
    }
    return marker;
  }
  var init_check_rule = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-rule.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/list.js
  function list4(node2, parent, state, info) {
    const exit3 = state.enter("list");
    const bulletCurrent = state.bulletCurrent;
    let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
    const bulletOther = node2.ordered ? bullet === "." ? ")" : "." : checkBulletOther(state);
    let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;
    if (!node2.ordered) {
      const firstListItem = node2.children ? node2.children[0] : void 0;
      if (
        // Bullet could be used as a thematic break marker:
        (bullet === "*" || bullet === "-") && // Empty first list item:
        firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
        state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
        state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
      ) {
        useDifferentMarker = true;
      }
      if (checkRule(state) === bullet && firstListItem) {
        let index3 = -1;
        while (++index3 < node2.children.length) {
          const item = node2.children[index3];
          if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
            useDifferentMarker = true;
            break;
          }
        }
      }
    }
    if (useDifferentMarker) {
      bullet = bulletOther;
    }
    state.bulletCurrent = bullet;
    const value = state.containerFlow(node2, info);
    state.bulletLastUsed = bullet;
    state.bulletCurrent = bulletCurrent;
    exit3();
    return value;
  }
  var init_list2 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/list.js"() {
      init_check_bullet();
      init_check_bullet_other();
      init_check_bullet_ordered();
      init_check_rule();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
  function checkListItemIndent(state) {
    const style3 = state.options.listItemIndent || "one";
    if (style3 !== "tab" && style3 !== "one" && style3 !== "mixed") {
      throw new Error(
        "Cannot serialize items with `" + style3 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
      );
    }
    return style3;
  }
  var init_check_list_item_indent = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/list-item.js
  function listItem(node2, parent, state, info) {
    const listItemIndent = checkListItemIndent(state);
    let bullet = state.bulletCurrent || checkBullet(state);
    if (parent && parent.type === "list" && parent.ordered) {
      bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
    }
    let size2 = bullet.length + 1;
    if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
      size2 = Math.ceil(size2 / 4) * 4;
    }
    const tracker = state.createTracker(info);
    tracker.move(bullet + " ".repeat(size2 - bullet.length));
    tracker.shift(size2);
    const exit3 = state.enter("listItem");
    const value = state.indentLines(
      state.containerFlow(node2, tracker.current()),
      map9
    );
    exit3();
    return value;
    function map9(line, index3, blank2) {
      if (index3) {
        return (blank2 ? "" : " ".repeat(size2)) + line;
      }
      return (blank2 ? bullet : bullet + " ".repeat(size2 - bullet.length)) + line;
    }
  }
  var init_list_item = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/list-item.js"() {
      init_check_bullet();
      init_check_list_item_indent();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
  function paragraph(node2, _2, state, info) {
    const exit3 = state.enter("paragraph");
    const subexit = state.enter("phrasing");
    const value = state.containerPhrasing(node2, info);
    subexit();
    exit3();
    return value;
  }
  var init_paragraph = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/paragraph.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/root.js
  function root4(node2, _2, state, info) {
    const hasPhrasing = node2.children.some(function(d) {
      return phrasing2(d);
    });
    const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;
    return container.call(state, node2, info);
  }
  var init_root3 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/root.js"() {
      init_mdast_util_phrasing();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-strong.js
  function checkStrong(state) {
    const marker = state.options.strong || "*";
    if (marker !== "*" && marker !== "_") {
      throw new Error(
        "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
      );
    }
    return marker;
  }
  var init_check_strong = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-strong.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/strong.js
  function strong2(node2, _2, state, info) {
    const marker = checkStrong(state);
    const exit3 = state.enter("strong");
    const tracker = state.createTracker(info);
    const before = tracker.move(marker + marker);
    let between2 = tracker.move(
      state.containerPhrasing(node2, {
        after: marker,
        before,
        ...tracker.current()
      })
    );
    const betweenHead = between2.charCodeAt(0);
    const open = encodeInfo(
      info.before.charCodeAt(info.before.length - 1),
      betweenHead,
      marker
    );
    if (open.inside) {
      between2 = encodeCharacterReference(betweenHead) + between2.slice(1);
    }
    const betweenTail = between2.charCodeAt(between2.length - 1);
    const close2 = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);
    if (close2.inside) {
      between2 = between2.slice(0, -1) + encodeCharacterReference(betweenTail);
    }
    const after = tracker.move(marker + marker);
    exit3();
    state.attentionEncodeSurroundingInfo = {
      after: close2.outside,
      before: open.outside
    };
    return before + between2 + after;
  }
  function strongPeek(_2, _1, state) {
    return state.options.strong || "*";
  }
  var init_strong2 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/strong.js"() {
      init_check_strong();
      init_encode_character_reference();
      init_encode_info();
      strong2.peek = strongPeek;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/text.js
  function text4(node2, _2, state, info) {
    return state.safe(node2.value, info);
  }
  var init_text3 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/text.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
  function checkRuleRepetition(state) {
    const repetition = state.options.ruleRepetition || 3;
    if (repetition < 3) {
      throw new Error(
        "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
      );
    }
    return repetition;
  }
  var init_check_rule_repetition = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
  function thematicBreak(_2, _1, state) {
    const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
    return state.options.ruleSpaces ? value.slice(0, -1) : value;
  }
  var init_thematic_break = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js"() {
      init_check_rule_repetition();
      init_check_rule();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/handle/index.js
  var handle3;
  var init_handle2 = __esm({
    "node_modules/mdast-util-to-markdown/lib/handle/index.js"() {
      init_blockquote2();
      init_break();
      init_code2();
      init_definition();
      init_emphasis();
      init_heading2();
      init_html3();
      init_image();
      init_image_reference();
      init_inline_code2();
      init_link();
      init_link_reference();
      init_list2();
      init_list_item();
      init_paragraph();
      init_root3();
      init_strong2();
      init_text3();
      init_thematic_break();
      handle3 = {
        blockquote: blockquote2,
        break: hardBreak,
        code: code2,
        definition,
        emphasis,
        hardBreak,
        heading: heading2,
        html: html5,
        image,
        imageReference,
        inlineCode: inlineCode2,
        link,
        linkReference,
        list: list4,
        listItem,
        paragraph,
        root: root4,
        strong: strong2,
        text: text4,
        thematicBreak
      };
    }
  });

  // node_modules/mdast-util-to-markdown/lib/join.js
  function joinDefaults(left, right, parent, state) {
    if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
      return false;
    }
    if ("spread" in parent && typeof parent.spread === "boolean") {
      if (left.type === "paragraph" && // Two paragraphs.
      (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
      right.type === "heading" && formatHeadingAsSetext(right, state))) {
        return;
      }
      return parent.spread ? 1 : 0;
    }
  }
  var join2;
  var init_join = __esm({
    "node_modules/mdast-util-to-markdown/lib/join.js"() {
      init_format_code_as_indented();
      init_format_heading_as_setext();
      join2 = [joinDefaults];
    }
  });

  // node_modules/mdast-util-to-markdown/lib/unsafe.js
  var fullPhrasingSpans, unsafe;
  var init_unsafe = __esm({
    "node_modules/mdast-util-to-markdown/lib/unsafe.js"() {
      fullPhrasingSpans = [
        "autolink",
        "destinationLiteral",
        "destinationRaw",
        "reference",
        "titleQuote",
        "titleApostrophe"
      ];
      unsafe = [
        { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
        { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
        {
          character: "	",
          inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
        },
        {
          character: "\r",
          inConstruct: [
            "codeFencedLangGraveAccent",
            "codeFencedLangTilde",
            "codeFencedMetaGraveAccent",
            "codeFencedMetaTilde",
            "destinationLiteral",
            "headingAtx"
          ]
        },
        {
          character: "\n",
          inConstruct: [
            "codeFencedLangGraveAccent",
            "codeFencedLangTilde",
            "codeFencedMetaGraveAccent",
            "codeFencedMetaTilde",
            "destinationLiteral",
            "headingAtx"
          ]
        },
        { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
        { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
        {
          character: " ",
          inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
        },
        // An exclamation mark can start an image, if it is followed by a link or
        // a link reference.
        {
          character: "!",
          after: "\\[",
          inConstruct: "phrasing",
          notInConstruct: fullPhrasingSpans
        },
        // A quote can break out of a title.
        { character: '"', inConstruct: "titleQuote" },
        // A number sign could start an ATX heading if it starts a line.
        { atBreak: true, character: "#" },
        { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
        // Dollar sign and percentage are not used in markdown.
        // An ampersand could start a character reference.
        { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
        // An apostrophe can break out of a title.
        { character: "'", inConstruct: "titleApostrophe" },
        // A left paren could break out of a destination raw.
        { character: "(", inConstruct: "destinationRaw" },
        // A left paren followed by `]` could make something into a link or image.
        {
          before: "\\]",
          character: "(",
          inConstruct: "phrasing",
          notInConstruct: fullPhrasingSpans
        },
        // A right paren could start a list item or break out of a destination
        // raw.
        { atBreak: true, before: "\\d+", character: ")" },
        { character: ")", inConstruct: "destinationRaw" },
        // An asterisk can start thematic breaks, list items, emphasis, strong.
        { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
        { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
        // A plus sign could start a list item.
        { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
        // A dash can start thematic breaks, list items, and setext heading
        // underlines.
        { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
        // A dot could start a list item.
        { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
        // Slash, colon, and semicolon are not used in markdown for constructs.
        // A less than can start html (flow or text) or an autolink.
        // HTML could start with an exclamation mark (declaration, cdata, comment),
        // slash (closing tag), question mark (instruction), or a letter (tag).
        // An autolink also starts with a letter.
        // Finally, it could break out of a destination literal.
        { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
        {
          character: "<",
          after: "[!/?A-Za-z]",
          inConstruct: "phrasing",
          notInConstruct: fullPhrasingSpans
        },
        { character: "<", inConstruct: "destinationLiteral" },
        // An equals to can start setext heading underlines.
        { atBreak: true, character: "=" },
        // A greater than can start block quotes and it can break out of a
        // destination literal.
        { atBreak: true, character: ">" },
        { character: ">", inConstruct: "destinationLiteral" },
        // Question mark and at sign are not used in markdown for constructs.
        // A left bracket can start definitions, references, labels,
        { atBreak: true, character: "[" },
        { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
        { character: "[", inConstruct: ["label", "reference"] },
        // A backslash can start an escape (when followed by punctuation) or a
        // hard break (when followed by an eol).
        // Note: typical escapes are handled in `safe`!
        { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
        // A right bracket can exit labels.
        { character: "]", inConstruct: ["label", "reference"] },
        // Caret is not used in markdown for constructs.
        // An underscore can start emphasis, strong, or a thematic break.
        { atBreak: true, character: "_" },
        { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
        // A grave accent can start code (fenced or text), or it can break out of
        // a grave accent code fence.
        { atBreak: true, character: "`" },
        {
          character: "`",
          inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
        },
        { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
        // Left brace, vertical bar, right brace are not used in markdown for
        // constructs.
        // A tilde can start code (fenced).
        { atBreak: true, character: "~" }
      ];
    }
  });

  // node_modules/decode-named-character-reference/index.dom.js
  function decodeNamedCharacterReference(value) {
    const characterReference2 = "&" + value + ";";
    element5.innerHTML = characterReference2;
    const character = element5.textContent;
    if (
      // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
      // yield `null`.
      character.charCodeAt(character.length - 1) === 59 && value !== "semi"
    ) {
      return false;
    }
    return character === characterReference2 ? false : character;
  }
  var element5;
  var init_index_dom = __esm({
    "node_modules/decode-named-character-reference/index.dom.js"() {
      element5 = document.createElement("i");
    }
  });

  // node_modules/micromark-util-decode-numeric-character-reference/index.js
  function decodeNumericCharacterReference(value, base4) {
    const code5 = Number.parseInt(value, base4);
    if (
      // C0 except for HT, LF, FF, CR, space.
      code5 < 9 || code5 === 11 || code5 > 13 && code5 < 32 || // Control character (DEL) of C0, and C1 controls.
      code5 > 126 && code5 < 160 || // Lone high surrogates and low surrogates.
      code5 > 55295 && code5 < 57344 || // Noncharacters.
      code5 > 64975 && code5 < 65008 || /* eslint-disable no-bitwise */
      (code5 & 65535) === 65535 || (code5 & 65535) === 65534 || /* eslint-enable no-bitwise */
      // Out of range
      code5 > 1114111
    ) {
      return "\uFFFD";
    }
    return String.fromCodePoint(code5);
  }
  var init_micromark_util_decode_numeric_character_reference = __esm({
    "node_modules/micromark-util-decode-numeric-character-reference/index.js"() {
    }
  });

  // node_modules/micromark-util-decode-string/index.js
  function decodeString(value) {
    return value.replace(characterEscapeOrReference, decode);
  }
  function decode($0, $1, $2) {
    if ($1) {
      return $1;
    }
    const head2 = $2.charCodeAt(0);
    if (head2 === 35) {
      const head3 = $2.charCodeAt(1);
      const hex = head3 === 120 || head3 === 88;
      return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
    }
    return decodeNamedCharacterReference($2) || $0;
  }
  var characterEscapeOrReference;
  var init_micromark_util_decode_string = __esm({
    "node_modules/micromark-util-decode-string/index.js"() {
      init_index_dom();
      init_micromark_util_decode_numeric_character_reference();
      characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/association.js
  function association(node2) {
    if (node2.label || !node2.identifier) {
      return node2.label || "";
    }
    return decodeString(node2.identifier);
  }
  var init_association = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/association.js"() {
      init_micromark_util_decode_string();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js
  function compilePattern(pattern) {
    if (!pattern._compiled) {
      const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
      pattern._compiled = new RegExp(
        (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
        "g"
      );
    }
    return pattern._compiled;
  }
  var init_compile_pattern = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
  function containerPhrasing(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    const results = [];
    let index3 = -1;
    let before = info.before;
    let encodeAfter;
    indexStack.push(-1);
    let tracker = state.createTracker(info);
    while (++index3 < children.length) {
      const child = children[index3];
      let after;
      indexStack[indexStack.length - 1] = index3;
      if (index3 + 1 < children.length) {
        let handle4 = state.handle.handlers[children[index3 + 1].type];
        if (handle4 && handle4.peek) handle4 = handle4.peek;
        after = handle4 ? handle4(children[index3 + 1], parent, state, {
          before: "",
          after: "",
          ...tracker.current()
        }).charAt(0) : "";
      } else {
        after = info.after;
      }
      if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
        results[results.length - 1] = results[results.length - 1].replace(
          /(\r?\n|\r)$/,
          " "
        );
        before = " ";
        tracker = state.createTracker(info);
        tracker.move(results.join(""));
      }
      let value = state.handle(child, parent, state, {
        ...tracker.current(),
        after,
        before
      });
      if (encodeAfter && encodeAfter === value.slice(0, 1)) {
        value = encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1);
      }
      const encodingInfo = state.attentionEncodeSurroundingInfo;
      state.attentionEncodeSurroundingInfo = void 0;
      encodeAfter = void 0;
      if (encodingInfo) {
        if (results.length > 0 && encodingInfo.before && before === results[results.length - 1].slice(-1)) {
          results[results.length - 1] = results[results.length - 1].slice(0, -1) + encodeCharacterReference(before.charCodeAt(0));
        }
        if (encodingInfo.after) encodeAfter = after;
      }
      tracker.move(value);
      results.push(value);
      before = value.slice(-1);
    }
    indexStack.pop();
    return results.join("");
  }
  var init_container_phrasing = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js"() {
      init_encode_character_reference();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/container-flow.js
  function containerFlow(parent, state, info) {
    const indexStack = state.indexStack;
    const children = parent.children || [];
    const tracker = state.createTracker(info);
    const results = [];
    let index3 = -1;
    indexStack.push(-1);
    while (++index3 < children.length) {
      const child = children[index3];
      indexStack[indexStack.length - 1] = index3;
      results.push(
        tracker.move(
          state.handle(child, parent, state, {
            before: "\n",
            after: "\n",
            ...tracker.current()
          })
        )
      );
      if (child.type !== "list") {
        state.bulletLastUsed = void 0;
      }
      if (index3 < children.length - 1) {
        results.push(
          tracker.move(between(child, children[index3 + 1], parent, state))
        );
      }
    }
    indexStack.pop();
    return results.join("");
  }
  function between(left, right, parent, state) {
    let index3 = state.join.length;
    while (index3--) {
      const result = state.join[index3](left, right, parent, state);
      if (result === true || result === 1) {
        break;
      }
      if (typeof result === "number") {
        return "\n".repeat(1 + result);
      }
      if (result === false) {
        return "\n\n<!---->\n\n";
      }
    }
    return "\n\n";
  }
  var init_container_flow = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/container-flow.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
  function indentLines(value, map9) {
    const result = [];
    let start = 0;
    let line = 0;
    let match;
    while (match = eol.exec(value)) {
      one6(value.slice(start, match.index));
      result.push(match[0]);
      start = match.index + match[0].length;
      line++;
    }
    one6(value.slice(start));
    return result.join("");
    function one6(value2) {
      result.push(map9(value2, line, !value2));
    }
  }
  var eol;
  var init_indent_lines = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/indent-lines.js"() {
      eol = /\r?\n|\r/g;
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/safe.js
  function safe(state, input2, config) {
    const value = (config.before || "") + (input2 || "") + (config.after || "");
    const positions = [];
    const result = [];
    const infos = {};
    let index3 = -1;
    while (++index3 < state.unsafe.length) {
      const pattern = state.unsafe[index3];
      if (!patternInScope(state.stack, pattern)) {
        continue;
      }
      const expression = state.compilePattern(pattern);
      let match;
      while (match = expression.exec(value)) {
        const before = "before" in pattern || Boolean(pattern.atBreak);
        const after = "after" in pattern;
        const position4 = match.index + (before ? match[1].length : 0);
        if (positions.includes(position4)) {
          if (infos[position4].before && !before) {
            infos[position4].before = false;
          }
          if (infos[position4].after && !after) {
            infos[position4].after = false;
          }
        } else {
          positions.push(position4);
          infos[position4] = { before, after };
        }
      }
    }
    positions.sort(numerical);
    let start = config.before ? config.before.length : 0;
    const end = value.length - (config.after ? config.after.length : 0);
    index3 = -1;
    while (++index3 < positions.length) {
      const position4 = positions[index3];
      if (position4 < start || position4 >= end) {
        continue;
      }
      if (position4 + 1 < end && positions[index3 + 1] === position4 + 1 && infos[position4].after && !infos[position4 + 1].before && !infos[position4 + 1].after || positions[index3 - 1] === position4 - 1 && infos[position4].before && !infos[position4 - 1].before && !infos[position4 - 1].after) {
        continue;
      }
      if (start !== position4) {
        result.push(escapeBackslashes(value.slice(start, position4), "\\"));
      }
      start = position4;
      if (/[!-/:-@[-`{-~]/.test(value.charAt(position4)) && (!config.encode || !config.encode.includes(value.charAt(position4)))) {
        result.push("\\");
      } else {
        result.push(encodeCharacterReference(value.charCodeAt(position4)));
        start++;
      }
    }
    result.push(escapeBackslashes(value.slice(start, end), config.after));
    return result.join("");
  }
  function numerical(a2, b) {
    return a2 - b;
  }
  function escapeBackslashes(value, after) {
    const expression = /\\(?=[!-/:-@[-`{-~])/g;
    const positions = [];
    const results = [];
    const whole = value + after;
    let index3 = -1;
    let start = 0;
    let match;
    while (match = expression.exec(whole)) {
      positions.push(match.index);
    }
    while (++index3 < positions.length) {
      if (start !== positions[index3]) {
        results.push(value.slice(start, positions[index3]));
      }
      results.push("\\");
      start = positions[index3];
    }
    results.push(value.slice(start));
    return results.join("");
  }
  var init_safe = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/safe.js"() {
      init_encode_character_reference();
      init_pattern_in_scope();
    }
  });

  // node_modules/mdast-util-to-markdown/lib/util/track.js
  function track(config) {
    const options2 = config || {};
    const now = options2.now || {};
    let lineShift = options2.lineShift || 0;
    let line = now.line || 1;
    let column = now.column || 1;
    return { move, current, shift: shift2 };
    function current() {
      return { now: { line, column }, lineShift };
    }
    function shift2(value) {
      lineShift += value;
    }
    function move(input2) {
      const value = input2 || "";
      const chunks = value.split(/\r?\n|\r/g);
      const tail = chunks[chunks.length - 1];
      line += chunks.length - 1;
      column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
      return value;
    }
  }
  var init_track = __esm({
    "node_modules/mdast-util-to-markdown/lib/util/track.js"() {
    }
  });

  // node_modules/mdast-util-to-markdown/lib/index.js
  function toMarkdown(tree, options2) {
    const settings = options2 || {};
    const state = {
      associationId: association,
      containerPhrasing: containerPhrasingBound,
      containerFlow: containerFlowBound,
      createTracker: track,
      compilePattern,
      enter: enter2,
      // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
      // here.
      handlers: { ...handle3 },
      // @ts-expect-error: add `handle` in a second.
      handle: void 0,
      indentLines,
      indexStack: [],
      join: [...join2],
      options: {},
      safe: safeBound,
      stack: [],
      unsafe: [...unsafe]
    };
    configure(state, settings);
    if (state.options.tightDefinitions) {
      state.join.push(joinDefinition);
    }
    state.handle = zwitch("type", {
      invalid: invalid2,
      unknown: unknown2,
      handlers: state.handlers
    });
    let result = state.handle(tree, void 0, state, {
      before: "\n",
      after: "\n",
      now: { line: 1, column: 1 },
      lineShift: 0
    });
    if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
      result += "\n";
    }
    return result;
    function enter2(name) {
      state.stack.push(name);
      return exit3;
      function exit3() {
        state.stack.pop();
      }
    }
  }
  function invalid2(value) {
    throw new Error("Cannot handle value `" + value + "`, expected node");
  }
  function unknown2(value) {
    const node2 = (
      /** @type {Nodes} */
      value
    );
    throw new Error("Cannot handle unknown node `" + node2.type + "`");
  }
  function joinDefinition(left, right) {
    if (left.type === "definition" && left.type === right.type) {
      return 0;
    }
  }
  function containerPhrasingBound(parent, info) {
    return containerPhrasing(parent, this, info);
  }
  function containerFlowBound(parent, info) {
    return containerFlow(parent, this, info);
  }
  function safeBound(value, config) {
    return safe(this, value, config);
  }
  var init_lib38 = __esm({
    "node_modules/mdast-util-to-markdown/lib/index.js"() {
      init_zwitch();
      init_configure();
      init_handle2();
      init_join();
      init_unsafe();
      init_association();
      init_compile_pattern();
      init_container_phrasing();
      init_container_flow();
      init_indent_lines();
      init_safe();
      init_track();
    }
  });

  // node_modules/mdast-util-to-markdown/index.js
  var init_mdast_util_to_markdown = __esm({
    "node_modules/mdast-util-to-markdown/index.js"() {
      init_lib38();
      init_handle2();
    }
  });

  // node_modules/mdast-util-gfm-table/lib/index.js
  function gfmTableFromMarkdown() {
    return {
      enter: {
        table: enterTable,
        tableData: enterCell,
        tableHeader: enterCell,
        tableRow: enterRow
      },
      exit: {
        codeText: exitCodeText,
        table: exitTable,
        tableData: exit,
        tableHeader: exit,
        tableRow: exit
      }
    };
  }
  function enterTable(token) {
    const align = token._align;
    ok(align, "expected `_align` on table");
    this.enter(
      {
        type: "table",
        align: align.map(function(d) {
          return d === "none" ? null : d;
        }),
        children: []
      },
      token
    );
    this.data.inTable = true;
  }
  function exitTable(token) {
    this.exit(token);
    this.data.inTable = void 0;
  }
  function enterRow(token) {
    this.enter({ type: "tableRow", children: [] }, token);
  }
  function exit(token) {
    this.exit(token);
  }
  function enterCell(token) {
    this.enter({ type: "tableCell", children: [] }, token);
  }
  function exitCodeText(token) {
    let value = this.resume();
    if (this.data.inTable) {
      value = value.replace(/\\([\\|])/g, replace);
    }
    const node2 = this.stack[this.stack.length - 1];
    ok(node2.type === "inlineCode");
    node2.value = value;
    this.exit(token);
  }
  function replace($0, $1) {
    return $1 === "|" ? $1 : $0;
  }
  function gfmTableToMarkdown(options2) {
    const settings = options2 || {};
    const padding2 = settings.tableCellPadding;
    const alignDelimiters = settings.tablePipeAlign;
    const stringLength = settings.stringLength;
    const around = padding2 ? " " : "|";
    return {
      unsafe: [
        { character: "\r", inConstruct: "tableCell" },
        { character: "\n", inConstruct: "tableCell" },
        // A pipe, when followed by a tab or space (padding), or a dash or colon
        // (unpadded delimiter row), could result in a table.
        { atBreak: true, character: "|", after: "[	 :-]" },
        // A pipe in a cell must be encoded.
        { character: "|", inConstruct: "tableCell" },
        // A colon must be followed by a dash, in which case it could start a
        // delimiter row.
        { atBreak: true, character: ":", after: "-" },
        // A delimiter row can also start with a dash, when followed by more
        // dashes, a colon, or a pipe.
        // This is a stricter version than the built in check for lists, thematic
        // breaks, and setex heading underlines though:
        // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
        { atBreak: true, character: "-", after: "[:|-]" }
      ],
      handlers: {
        inlineCode: inlineCodeWithTable,
        table: handleTable,
        tableCell: handleTableCell,
        tableRow: handleTableRow
      }
    };
    function handleTable(node2, _2, state, info) {
      return serializeData(handleTableAsData(node2, state, info), node2.align);
    }
    function handleTableRow(node2, _2, state, info) {
      const row2 = handleTableRowAsData(node2, state, info);
      const value = serializeData([row2]);
      return value.slice(0, value.indexOf("\n"));
    }
    function handleTableCell(node2, _2, state, info) {
      const exit3 = state.enter("tableCell");
      const subexit = state.enter("phrasing");
      const value = state.containerPhrasing(node2, {
        ...info,
        before: around,
        after: around
      });
      subexit();
      exit3();
      return value;
    }
    function serializeData(matrix, align) {
      return markdownTable(matrix, {
        align,
        // @ts-expect-error: `markdown-table` types should support `null`.
        alignDelimiters,
        // @ts-expect-error: `markdown-table` types should support `null`.
        padding: padding2,
        // @ts-expect-error: `markdown-table` types should support `null`.
        stringLength
      });
    }
    function handleTableAsData(node2, state, info) {
      const children = node2.children;
      let index3 = -1;
      const result = [];
      const subexit = state.enter("table");
      while (++index3 < children.length) {
        result[index3] = handleTableRowAsData(children[index3], state, info);
      }
      subexit();
      return result;
    }
    function handleTableRowAsData(node2, state, info) {
      const children = node2.children;
      let index3 = -1;
      const result = [];
      const subexit = state.enter("tableRow");
      while (++index3 < children.length) {
        result[index3] = handleTableCell(children[index3], node2, state, info);
      }
      subexit();
      return result;
    }
    function inlineCodeWithTable(node2, parent, state) {
      let value = handle3.inlineCode(node2, parent, state);
      if (state.stack.includes("tableCell")) {
        value = value.replace(/\|/g, "\\$&");
      }
      return value;
    }
  }
  var init_lib39 = __esm({
    "node_modules/mdast-util-gfm-table/lib/index.js"() {
      init_default();
      init_markdown_table();
      init_mdast_util_to_markdown();
    }
  });

  // node_modules/mdast-util-gfm-table/index.js
  var init_mdast_util_gfm_table = __esm({
    "node_modules/mdast-util-gfm-table/index.js"() {
      init_lib39();
    }
  });

  // node_modules/mdast-util-gfm-task-list-item/lib/index.js
  function gfmTaskListItemFromMarkdown() {
    return {
      exit: {
        taskListCheckValueChecked: exitCheck,
        taskListCheckValueUnchecked: exitCheck,
        paragraph: exitParagraphWithTaskListItem
      }
    };
  }
  function gfmTaskListItemToMarkdown() {
    return {
      unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
      handlers: { listItem: listItemWithTaskListItem }
    };
  }
  function exitCheck(token) {
    const node2 = this.stack[this.stack.length - 2];
    ok(node2.type === "listItem");
    node2.checked = token.type === "taskListCheckValueChecked";
  }
  function exitParagraphWithTaskListItem(token) {
    const parent = this.stack[this.stack.length - 2];
    if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
      const node2 = this.stack[this.stack.length - 1];
      ok(node2.type === "paragraph");
      const head2 = node2.children[0];
      if (head2 && head2.type === "text") {
        const siblings2 = parent.children;
        let index3 = -1;
        let firstParaghraph;
        while (++index3 < siblings2.length) {
          const sibling = siblings2[index3];
          if (sibling.type === "paragraph") {
            firstParaghraph = sibling;
            break;
          }
        }
        if (firstParaghraph === node2) {
          head2.value = head2.value.slice(1);
          if (head2.value.length === 0) {
            node2.children.shift();
          } else if (node2.position && head2.position && typeof head2.position.start.offset === "number") {
            head2.position.start.column++;
            head2.position.start.offset++;
            node2.position.start = Object.assign({}, head2.position.start);
          }
        }
      }
    }
    this.exit(token);
  }
  function listItemWithTaskListItem(node2, parent, state, info) {
    const head2 = node2.children[0];
    const checkable = typeof node2.checked === "boolean" && head2 && head2.type === "paragraph";
    const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
    const tracker = state.createTracker(info);
    if (checkable) {
      tracker.move(checkbox);
    }
    let value = handle3.listItem(node2, parent, state, {
      ...info,
      ...tracker.current()
    });
    if (checkable) {
      value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
    }
    return value;
    function check($0) {
      return $0 + checkbox;
    }
  }
  var init_lib40 = __esm({
    "node_modules/mdast-util-gfm-task-list-item/lib/index.js"() {
      init_default();
      init_mdast_util_to_markdown();
    }
  });

  // node_modules/mdast-util-gfm-task-list-item/index.js
  var init_mdast_util_gfm_task_list_item = __esm({
    "node_modules/mdast-util-gfm-task-list-item/index.js"() {
      init_lib40();
    }
  });

  // node_modules/mdast-util-gfm/lib/index.js
  function gfmFromMarkdown() {
    return [
      gfmAutolinkLiteralFromMarkdown(),
      gfmFootnoteFromMarkdown(),
      gfmStrikethroughFromMarkdown(),
      gfmTableFromMarkdown(),
      gfmTaskListItemFromMarkdown()
    ];
  }
  function gfmToMarkdown(options2) {
    return {
      extensions: [
        gfmAutolinkLiteralToMarkdown(),
        gfmFootnoteToMarkdown(options2),
        gfmStrikethroughToMarkdown(),
        gfmTableToMarkdown(options2),
        gfmTaskListItemToMarkdown()
      ]
    };
  }
  var init_lib41 = __esm({
    "node_modules/mdast-util-gfm/lib/index.js"() {
      init_mdast_util_gfm_autolink_literal();
      init_mdast_util_gfm_footnote();
      init_mdast_util_gfm_strikethrough();
      init_mdast_util_gfm_table();
      init_mdast_util_gfm_task_list_item();
    }
  });

  // node_modules/mdast-util-gfm/index.js
  var init_mdast_util_gfm = __esm({
    "node_modules/mdast-util-gfm/index.js"() {
      init_lib41();
    }
  });

  // node_modules/micromark-util-chunked/index.js
  function splice(list7, start, remove2, items) {
    const end = list7.length;
    let chunkStart = 0;
    let parameters;
    if (start < 0) {
      start = -start > end ? 0 : end + start;
    } else {
      start = start > end ? end : start;
    }
    remove2 = remove2 > 0 ? remove2 : 0;
    if (items.length < 1e4) {
      parameters = Array.from(items);
      parameters.unshift(start, remove2);
      list7.splice(...parameters);
    } else {
      if (remove2) list7.splice(start, remove2);
      while (chunkStart < items.length) {
        parameters = items.slice(chunkStart, chunkStart + 1e4);
        parameters.unshift(start, 0);
        list7.splice(...parameters);
        chunkStart += 1e4;
        start += 1e4;
      }
    }
  }
  function push(list7, items) {
    if (list7.length > 0) {
      splice(list7, list7.length, 0, items);
      return list7;
    }
    return items;
  }
  var init_micromark_util_chunked = __esm({
    "node_modules/micromark-util-chunked/index.js"() {
    }
  });

  // node_modules/micromark-util-combine-extensions/index.js
  function combineExtensions(extensions) {
    const all10 = {};
    let index3 = -1;
    while (++index3 < extensions.length) {
      syntaxExtension(all10, extensions[index3]);
    }
    return all10;
  }
  function syntaxExtension(all10, extension2) {
    let hook;
    for (hook in extension2) {
      const maybe = hasOwnProperty.call(all10, hook) ? all10[hook] : void 0;
      const left = maybe || (all10[hook] = {});
      const right = extension2[hook];
      let code5;
      if (right) {
        for (code5 in right) {
          if (!hasOwnProperty.call(left, code5)) left[code5] = [];
          const value = right[code5];
          constructs(
            // @ts-expect-error Looks like a list.
            left[code5],
            Array.isArray(value) ? value : value ? [value] : []
          );
        }
      }
    }
  }
  function constructs(existing, list7) {
    let index3 = -1;
    const before = [];
    while (++index3 < list7.length) {
      ;
      (list7[index3].add === "after" ? existing : before).push(list7[index3]);
    }
    splice(existing, 0, 0, before);
  }
  function combineHtmlExtensions(htmlExtensions) {
    const handlers4 = {};
    let index3 = -1;
    while (++index3 < htmlExtensions.length) {
      htmlExtension(handlers4, htmlExtensions[index3]);
    }
    return handlers4;
  }
  function htmlExtension(all10, extension2) {
    let hook;
    for (hook in extension2) {
      const maybe = hasOwnProperty.call(all10, hook) ? all10[hook] : void 0;
      const left = maybe || (all10[hook] = {});
      const right = extension2[hook];
      let type;
      if (right) {
        for (type in right) {
          left[type] = right[type];
        }
      }
    }
  }
  var hasOwnProperty;
  var init_micromark_util_combine_extensions = __esm({
    "node_modules/micromark-util-combine-extensions/index.js"() {
      init_micromark_util_chunked();
      hasOwnProperty = {}.hasOwnProperty;
    }
  });

  // node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
  function gfmAutolinkLiteral() {
    return {
      text: text5
    };
  }
  function tokenizeEmailAutolink(effects, ok3, nok) {
    const self2 = this;
    let dot;
    let data;
    return start;
    function start(code5) {
      if (!gfmAtext(code5) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
        return nok(code5);
      }
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkEmail");
      return atext(code5);
    }
    function atext(code5) {
      if (gfmAtext(code5)) {
        effects.consume(code5);
        return atext;
      }
      if (code5 === 64) {
        effects.consume(code5);
        return emailDomain;
      }
      return nok(code5);
    }
    function emailDomain(code5) {
      if (code5 === 46) {
        return effects.check(emailDomainDotTrail, emailDomainAfter, emailDomainDot)(code5);
      }
      if (code5 === 45 || code5 === 95 || asciiAlphanumeric(code5)) {
        data = true;
        effects.consume(code5);
        return emailDomain;
      }
      return emailDomainAfter(code5);
    }
    function emailDomainDot(code5) {
      effects.consume(code5);
      dot = true;
      return emailDomain;
    }
    function emailDomainAfter(code5) {
      if (data && dot && asciiAlpha(self2.previous)) {
        effects.exit("literalAutolinkEmail");
        effects.exit("literalAutolink");
        return ok3(code5);
      }
      return nok(code5);
    }
  }
  function tokenizeWwwAutolink(effects, ok3, nok) {
    const self2 = this;
    return wwwStart;
    function wwwStart(code5) {
      if (code5 !== 87 && code5 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
        return nok(code5);
      }
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkWww");
      return effects.check(wwwPrefix, effects.attempt(domain, effects.attempt(path, wwwAfter), nok), nok)(code5);
    }
    function wwwAfter(code5) {
      effects.exit("literalAutolinkWww");
      effects.exit("literalAutolink");
      return ok3(code5);
    }
  }
  function tokenizeProtocolAutolink(effects, ok3, nok) {
    const self2 = this;
    let buffer = "";
    let seen = false;
    return protocolStart;
    function protocolStart(code5) {
      if ((code5 === 72 || code5 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkHttp");
        buffer += String.fromCodePoint(code5);
        effects.consume(code5);
        return protocolPrefixInside;
      }
      return nok(code5);
    }
    function protocolPrefixInside(code5) {
      if (asciiAlpha(code5) && buffer.length < 5) {
        buffer += String.fromCodePoint(code5);
        effects.consume(code5);
        return protocolPrefixInside;
      }
      if (code5 === 58) {
        const protocol = buffer.toLowerCase();
        if (protocol === "http" || protocol === "https") {
          effects.consume(code5);
          return protocolSlashesInside;
        }
      }
      return nok(code5);
    }
    function protocolSlashesInside(code5) {
      if (code5 === 47) {
        effects.consume(code5);
        if (seen) {
          return afterProtocol;
        }
        seen = true;
        return protocolSlashesInside;
      }
      return nok(code5);
    }
    function afterProtocol(code5) {
      return code5 === null || asciiControl(code5) || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5) || unicodePunctuation(code5) ? nok(code5) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code5);
    }
    function protocolAfter(code5) {
      effects.exit("literalAutolinkHttp");
      effects.exit("literalAutolink");
      return ok3(code5);
    }
  }
  function tokenizeWwwPrefix(effects, ok3, nok) {
    let size2 = 0;
    return wwwPrefixInside;
    function wwwPrefixInside(code5) {
      if ((code5 === 87 || code5 === 119) && size2 < 3) {
        size2++;
        effects.consume(code5);
        return wwwPrefixInside;
      }
      if (code5 === 46 && size2 === 3) {
        effects.consume(code5);
        return wwwPrefixAfter;
      }
      return nok(code5);
    }
    function wwwPrefixAfter(code5) {
      return code5 === null ? nok(code5) : ok3(code5);
    }
  }
  function tokenizeDomain(effects, ok3, nok) {
    let underscoreInLastSegment;
    let underscoreInLastLastSegment;
    let seen;
    return domainInside;
    function domainInside(code5) {
      if (code5 === 46 || code5 === 95) {
        return effects.check(trail, domainAfter, domainAtPunctuation)(code5);
      }
      if (code5 === null || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5) || code5 !== 45 && unicodePunctuation(code5)) {
        return domainAfter(code5);
      }
      seen = true;
      effects.consume(code5);
      return domainInside;
    }
    function domainAtPunctuation(code5) {
      if (code5 === 95) {
        underscoreInLastSegment = true;
      } else {
        underscoreInLastLastSegment = underscoreInLastSegment;
        underscoreInLastSegment = void 0;
      }
      effects.consume(code5);
      return domainInside;
    }
    function domainAfter(code5) {
      if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
        return nok(code5);
      }
      return ok3(code5);
    }
  }
  function tokenizePath(effects, ok3) {
    let sizeOpen = 0;
    let sizeClose = 0;
    return pathInside;
    function pathInside(code5) {
      if (code5 === 40) {
        sizeOpen++;
        effects.consume(code5);
        return pathInside;
      }
      if (code5 === 41 && sizeClose < sizeOpen) {
        return pathAtPunctuation(code5);
      }
      if (code5 === 33 || code5 === 34 || code5 === 38 || code5 === 39 || code5 === 41 || code5 === 42 || code5 === 44 || code5 === 46 || code5 === 58 || code5 === 59 || code5 === 60 || code5 === 63 || code5 === 93 || code5 === 95 || code5 === 126) {
        return effects.check(trail, ok3, pathAtPunctuation)(code5);
      }
      if (code5 === null || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5)) {
        return ok3(code5);
      }
      effects.consume(code5);
      return pathInside;
    }
    function pathAtPunctuation(code5) {
      if (code5 === 41) {
        sizeClose++;
      }
      effects.consume(code5);
      return pathInside;
    }
  }
  function tokenizeTrail(effects, ok3, nok) {
    return trail2;
    function trail2(code5) {
      if (code5 === 33 || code5 === 34 || code5 === 39 || code5 === 41 || code5 === 42 || code5 === 44 || code5 === 46 || code5 === 58 || code5 === 59 || code5 === 63 || code5 === 95 || code5 === 126) {
        effects.consume(code5);
        return trail2;
      }
      if (code5 === 38) {
        effects.consume(code5);
        return trailCharacterReferenceStart;
      }
      if (code5 === 93) {
        effects.consume(code5);
        return trailBracketAfter;
      }
      if (
        // `<` is an end.
        code5 === 60 || // So is whitespace.
        code5 === null || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5)
      ) {
        return ok3(code5);
      }
      return nok(code5);
    }
    function trailBracketAfter(code5) {
      if (code5 === null || code5 === 40 || code5 === 91 || markdownLineEndingOrSpace(code5) || unicodeWhitespace(code5)) {
        return ok3(code5);
      }
      return trail2(code5);
    }
    function trailCharacterReferenceStart(code5) {
      return asciiAlpha(code5) ? trailCharacterReferenceInside(code5) : nok(code5);
    }
    function trailCharacterReferenceInside(code5) {
      if (code5 === 59) {
        effects.consume(code5);
        return trail2;
      }
      if (asciiAlpha(code5)) {
        effects.consume(code5);
        return trailCharacterReferenceInside;
      }
      return nok(code5);
    }
  }
  function tokenizeEmailDomainDotTrail(effects, ok3, nok) {
    return start;
    function start(code5) {
      effects.consume(code5);
      return after;
    }
    function after(code5) {
      return asciiAlphanumeric(code5) ? nok(code5) : ok3(code5);
    }
  }
  function previousWww(code5) {
    return code5 === null || code5 === 40 || code5 === 42 || code5 === 95 || code5 === 91 || code5 === 93 || code5 === 126 || markdownLineEndingOrSpace(code5);
  }
  function previousProtocol(code5) {
    return !asciiAlpha(code5);
  }
  function previousEmail(code5) {
    return !(code5 === 47 || gfmAtext(code5));
  }
  function gfmAtext(code5) {
    return code5 === 43 || code5 === 45 || code5 === 46 || code5 === 95 || asciiAlphanumeric(code5);
  }
  function previousUnbalanced(events) {
    let index3 = events.length;
    let result = false;
    while (index3--) {
      const token = events[index3][1];
      if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
        result = true;
        break;
      }
      if (token._gfmAutolinkLiteralWalkedInto) {
        result = false;
        break;
      }
    }
    if (events.length > 0 && !result) {
      events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
    }
    return result;
  }
  var wwwPrefix, domain, path, trail, emailDomainDotTrail, wwwAutolink, protocolAutolink, emailAutolink, text5, code3;
  var init_syntax = __esm({
    "node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js"() {
      init_micromark_util_character();
      wwwPrefix = {
        tokenize: tokenizeWwwPrefix,
        partial: true
      };
      domain = {
        tokenize: tokenizeDomain,
        partial: true
      };
      path = {
        tokenize: tokenizePath,
        partial: true
      };
      trail = {
        tokenize: tokenizeTrail,
        partial: true
      };
      emailDomainDotTrail = {
        tokenize: tokenizeEmailDomainDotTrail,
        partial: true
      };
      wwwAutolink = {
        name: "wwwAutolink",
        tokenize: tokenizeWwwAutolink,
        previous: previousWww
      };
      protocolAutolink = {
        name: "protocolAutolink",
        tokenize: tokenizeProtocolAutolink,
        previous: previousProtocol
      };
      emailAutolink = {
        name: "emailAutolink",
        tokenize: tokenizeEmailAutolink,
        previous: previousEmail
      };
      text5 = {};
      code3 = 48;
      while (code3 < 123) {
        text5[code3] = emailAutolink;
        code3++;
        if (code3 === 58) code3 = 65;
        else if (code3 === 91) code3 = 97;
      }
      text5[43] = emailAutolink;
      text5[45] = emailAutolink;
      text5[46] = emailAutolink;
      text5[95] = emailAutolink;
      text5[72] = [emailAutolink, protocolAutolink];
      text5[104] = [emailAutolink, protocolAutolink];
      text5[87] = [emailAutolink, wwwAutolink];
      text5[119] = [emailAutolink, wwwAutolink];
    }
  });

  // node_modules/micromark-util-encode/index.js
  function encode(value) {
    return value.replace(/["&<>]/g, replace4);
    function replace4(value2) {
      return "&" + characterReferences[
        /** @type {keyof typeof characterReferences} */
        value2
      ] + ";";
    }
  }
  var characterReferences;
  var init_micromark_util_encode = __esm({
    "node_modules/micromark-util-encode/index.js"() {
      characterReferences = { '"': "quot", "&": "amp", "<": "lt", ">": "gt" };
    }
  });

  // node_modules/micromark-util-sanitize-uri/index.js
  function sanitizeUri(url, protocol) {
    const value = encode(normalizeUri(url || ""));
    if (!protocol) {
      return value;
    }
    const colon = value.indexOf(":");
    const questionMark = value.indexOf("?");
    const numberSign = value.indexOf("#");
    const slash = value.indexOf("/");
    if (
      // If there is no protocol, its relative.
      colon < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
      slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || // It is a protocol, it should be allowed.
      protocol.test(value.slice(0, colon))
    ) {
      return value;
    }
    return "";
  }
  function normalizeUri(value) {
    const result = [];
    let index3 = -1;
    let start = 0;
    let skip = 0;
    while (++index3 < value.length) {
      const code5 = value.charCodeAt(index3);
      let replace4 = "";
      if (code5 === 37 && asciiAlphanumeric(value.charCodeAt(index3 + 1)) && asciiAlphanumeric(value.charCodeAt(index3 + 2))) {
        skip = 2;
      } else if (code5 < 128) {
        if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code5))) {
          replace4 = String.fromCharCode(code5);
        }
      } else if (code5 > 55295 && code5 < 57344) {
        const next2 = value.charCodeAt(index3 + 1);
        if (code5 < 56320 && next2 > 56319 && next2 < 57344) {
          replace4 = String.fromCharCode(code5, next2);
          skip = 1;
        } else {
          replace4 = "\uFFFD";
        }
      } else {
        replace4 = String.fromCharCode(code5);
      }
      if (replace4) {
        result.push(value.slice(start, index3), encodeURIComponent(replace4));
        start = index3 + skip + 1;
        replace4 = "";
      }
      if (skip) {
        index3 += skip;
        skip = 0;
      }
    }
    return result.join("") + value.slice(start);
  }
  var init_micromark_util_sanitize_uri = __esm({
    "node_modules/micromark-util-sanitize-uri/index.js"() {
      init_micromark_util_character();
      init_micromark_util_encode();
    }
  });

  // node_modules/micromark-extension-gfm-autolink-literal/lib/html.js
  function gfmAutolinkLiteralHtml() {
    return {
      exit: {
        literalAutolinkEmail,
        literalAutolinkHttp,
        literalAutolinkWww
      }
    };
  }
  function literalAutolinkWww(token) {
    anchorFromToken.call(this, token, "http://");
  }
  function literalAutolinkEmail(token) {
    anchorFromToken.call(this, token, "mailto:");
  }
  function literalAutolinkHttp(token) {
    anchorFromToken.call(this, token);
  }
  function anchorFromToken(token, protocol) {
    const url = this.sliceSerialize(token);
    this.tag('<a href="' + sanitizeUri((protocol || "") + url) + '">');
    this.raw(this.encode(url));
    this.tag("</a>");
  }
  var init_html4 = __esm({
    "node_modules/micromark-extension-gfm-autolink-literal/lib/html.js"() {
      init_micromark_util_sanitize_uri();
    }
  });

  // node_modules/micromark-extension-gfm-autolink-literal/index.js
  var init_micromark_extension_gfm_autolink_literal = __esm({
    "node_modules/micromark-extension-gfm-autolink-literal/index.js"() {
      init_syntax();
      init_html4();
    }
  });

  // node_modules/micromark-util-resolve-all/index.js
  function resolveAll(constructs2, events, context) {
    const called = [];
    let index3 = -1;
    while (++index3 < constructs2.length) {
      const resolve3 = constructs2[index3].resolveAll;
      if (resolve3 && !called.includes(resolve3)) {
        events = resolve3(events, context);
        called.push(resolve3);
      }
    }
    return events;
  }
  var init_micromark_util_resolve_all = __esm({
    "node_modules/micromark-util-resolve-all/index.js"() {
    }
  });

  // node_modules/micromark-core-commonmark/lib/attention.js
  function resolveAllAttention(events, context) {
    let index3 = -1;
    let open;
    let group2;
    let text10;
    let openingSequence;
    let closingSequence;
    let use;
    let nextEvents;
    let offset;
    while (++index3 < events.length) {
      if (events[index3][0] === "enter" && events[index3][1].type === "attentionSequence" && events[index3][1]._close) {
        open = index3;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
          context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index3][1]).charCodeAt(0)) {
            if ((events[open][1]._close || events[index3][1]._open) && (events[index3][1].end.offset - events[index3][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index3][1].end.offset - events[index3][1].start.offset) % 3)) {
              continue;
            }
            use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index3][1].end.offset - events[index3][1].start.offset > 1 ? 2 : 1;
            const start = {
              ...events[open][1].end
            };
            const end = {
              ...events[index3][1].start
            };
            movePoint(start, -use);
            movePoint(end, use);
            openingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start,
              end: {
                ...events[open][1].end
              }
            };
            closingSequence = {
              type: use > 1 ? "strongSequence" : "emphasisSequence",
              start: {
                ...events[index3][1].start
              },
              end
            };
            text10 = {
              type: use > 1 ? "strongText" : "emphasisText",
              start: {
                ...events[open][1].end
              },
              end: {
                ...events[index3][1].start
              }
            };
            group2 = {
              type: use > 1 ? "strong" : "emphasis",
              start: {
                ...openingSequence.start
              },
              end: {
                ...closingSequence.end
              }
            };
            events[open][1].end = {
              ...openingSequence.start
            };
            events[index3][1].start = {
              ...closingSequence.end
            };
            nextEvents = [];
            if (events[open][1].end.offset - events[open][1].start.offset) {
              nextEvents = push(nextEvents, [["enter", events[open][1], context], ["exit", events[open][1], context]]);
            }
            nextEvents = push(nextEvents, [["enter", group2, context], ["enter", openingSequence, context], ["exit", openingSequence, context], ["enter", text10, context]]);
            nextEvents = push(nextEvents, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index3), context));
            nextEvents = push(nextEvents, [["exit", text10, context], ["enter", closingSequence, context], ["exit", closingSequence, context], ["exit", group2, context]]);
            if (events[index3][1].end.offset - events[index3][1].start.offset) {
              offset = 2;
              nextEvents = push(nextEvents, [["enter", events[index3][1], context], ["exit", events[index3][1], context]]);
            } else {
              offset = 0;
            }
            splice(events, open - 1, index3 - open + 3, nextEvents);
            index3 = open + nextEvents.length - offset - 2;
            break;
          }
        }
      }
    }
    index3 = -1;
    while (++index3 < events.length) {
      if (events[index3][1].type === "attentionSequence") {
        events[index3][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeAttention(effects, ok3) {
    const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
    const previous3 = this.previous;
    const before = classifyCharacter(previous3);
    let marker;
    return start;
    function start(code5) {
      marker = code5;
      effects.enter("attentionSequence");
      return inside(code5);
    }
    function inside(code5) {
      if (code5 === marker) {
        effects.consume(code5);
        return inside;
      }
      const token = effects.exit("attentionSequence");
      const after = classifyCharacter(code5);
      const open = !after || after === 2 && before || attentionMarkers2.includes(code5);
      const close2 = !before || before === 2 && after || attentionMarkers2.includes(previous3);
      token._open = Boolean(marker === 42 ? open : open && (before || !close2));
      token._close = Boolean(marker === 42 ? close2 : close2 && (after || !open));
      return ok3(code5);
    }
  }
  function movePoint(point5, offset) {
    point5.column += offset;
    point5.offset += offset;
    point5._bufferIndex += offset;
  }
  var attention;
  var init_attention = __esm({
    "node_modules/micromark-core-commonmark/lib/attention.js"() {
      init_micromark_util_chunked();
      init_micromark_util_classify_character();
      init_micromark_util_resolve_all();
      attention = {
        name: "attention",
        resolveAll: resolveAllAttention,
        tokenize: tokenizeAttention
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/autolink.js
  function tokenizeAutolink(effects, ok3, nok) {
    let size2 = 0;
    return start;
    function start(code5) {
      effects.enter("autolink");
      effects.enter("autolinkMarker");
      effects.consume(code5);
      effects.exit("autolinkMarker");
      effects.enter("autolinkProtocol");
      return open;
    }
    function open(code5) {
      if (asciiAlpha(code5)) {
        effects.consume(code5);
        return schemeOrEmailAtext;
      }
      if (code5 === 64) {
        return nok(code5);
      }
      return emailAtext(code5);
    }
    function schemeOrEmailAtext(code5) {
      if (code5 === 43 || code5 === 45 || code5 === 46 || asciiAlphanumeric(code5)) {
        size2 = 1;
        return schemeInsideOrEmailAtext(code5);
      }
      return emailAtext(code5);
    }
    function schemeInsideOrEmailAtext(code5) {
      if (code5 === 58) {
        effects.consume(code5);
        size2 = 0;
        return urlInside;
      }
      if ((code5 === 43 || code5 === 45 || code5 === 46 || asciiAlphanumeric(code5)) && size2++ < 32) {
        effects.consume(code5);
        return schemeInsideOrEmailAtext;
      }
      size2 = 0;
      return emailAtext(code5);
    }
    function urlInside(code5) {
      if (code5 === 62) {
        effects.exit("autolinkProtocol");
        effects.enter("autolinkMarker");
        effects.consume(code5);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok3;
      }
      if (code5 === null || code5 === 32 || code5 === 60 || asciiControl(code5)) {
        return nok(code5);
      }
      effects.consume(code5);
      return urlInside;
    }
    function emailAtext(code5) {
      if (code5 === 64) {
        effects.consume(code5);
        return emailAtSignOrDot;
      }
      if (asciiAtext(code5)) {
        effects.consume(code5);
        return emailAtext;
      }
      return nok(code5);
    }
    function emailAtSignOrDot(code5) {
      return asciiAlphanumeric(code5) ? emailLabel(code5) : nok(code5);
    }
    function emailLabel(code5) {
      if (code5 === 46) {
        effects.consume(code5);
        size2 = 0;
        return emailAtSignOrDot;
      }
      if (code5 === 62) {
        effects.exit("autolinkProtocol").type = "autolinkEmail";
        effects.enter("autolinkMarker");
        effects.consume(code5);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok3;
      }
      return emailValue(code5);
    }
    function emailValue(code5) {
      if ((code5 === 45 || asciiAlphanumeric(code5)) && size2++ < 63) {
        const next2 = code5 === 45 ? emailValue : emailLabel;
        effects.consume(code5);
        return next2;
      }
      return nok(code5);
    }
  }
  var autolink;
  var init_autolink = __esm({
    "node_modules/micromark-core-commonmark/lib/autolink.js"() {
      init_micromark_util_character();
      autolink = {
        name: "autolink",
        tokenize: tokenizeAutolink
      };
    }
  });

  // node_modules/micromark-factory-space/index.js
  function factorySpace(effects, ok3, type, max2) {
    const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
    let size2 = 0;
    return start;
    function start(code5) {
      if (markdownSpace(code5)) {
        effects.enter(type);
        return prefix3(code5);
      }
      return ok3(code5);
    }
    function prefix3(code5) {
      if (markdownSpace(code5) && size2++ < limit) {
        effects.consume(code5);
        return prefix3;
      }
      effects.exit(type);
      return ok3(code5);
    }
  }
  var init_micromark_factory_space = __esm({
    "node_modules/micromark-factory-space/index.js"() {
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-core-commonmark/lib/blank-line.js
  function tokenizeBlankLine(effects, ok3, nok) {
    return start;
    function start(code5) {
      return markdownSpace(code5) ? factorySpace(effects, after, "linePrefix")(code5) : after(code5);
    }
    function after(code5) {
      return code5 === null || markdownLineEnding(code5) ? ok3(code5) : nok(code5);
    }
  }
  var blankLine;
  var init_blank_line = __esm({
    "node_modules/micromark-core-commonmark/lib/blank-line.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      blankLine = {
        partial: true,
        tokenize: tokenizeBlankLine
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/block-quote.js
  function tokenizeBlockQuoteStart(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code5) {
      if (code5 === 62) {
        const state = self2.containerState;
        if (!state.open) {
          effects.enter("blockQuote", {
            _container: true
          });
          state.open = true;
        }
        effects.enter("blockQuotePrefix");
        effects.enter("blockQuoteMarker");
        effects.consume(code5);
        effects.exit("blockQuoteMarker");
        return after;
      }
      return nok(code5);
    }
    function after(code5) {
      if (markdownSpace(code5)) {
        effects.enter("blockQuotePrefixWhitespace");
        effects.consume(code5);
        effects.exit("blockQuotePrefixWhitespace");
        effects.exit("blockQuotePrefix");
        return ok3;
      }
      effects.exit("blockQuotePrefix");
      return ok3(code5);
    }
  }
  function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
    const self2 = this;
    return contStart;
    function contStart(code5) {
      if (markdownSpace(code5)) {
        return factorySpace(effects, contBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code5);
      }
      return contBefore(code5);
    }
    function contBefore(code5) {
      return effects.attempt(blockQuote, ok3, nok)(code5);
    }
  }
  function exit2(effects) {
    effects.exit("blockQuote");
  }
  var blockQuote;
  var init_block_quote = __esm({
    "node_modules/micromark-core-commonmark/lib/block-quote.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      blockQuote = {
        continuation: {
          tokenize: tokenizeBlockQuoteContinuation
        },
        exit: exit2,
        name: "blockQuote",
        tokenize: tokenizeBlockQuoteStart
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/character-escape.js
  function tokenizeCharacterEscape(effects, ok3, nok) {
    return start;
    function start(code5) {
      effects.enter("characterEscape");
      effects.enter("escapeMarker");
      effects.consume(code5);
      effects.exit("escapeMarker");
      return inside;
    }
    function inside(code5) {
      if (asciiPunctuation(code5)) {
        effects.enter("characterEscapeValue");
        effects.consume(code5);
        effects.exit("characterEscapeValue");
        effects.exit("characterEscape");
        return ok3;
      }
      return nok(code5);
    }
  }
  var characterEscape;
  var init_character_escape = __esm({
    "node_modules/micromark-core-commonmark/lib/character-escape.js"() {
      init_micromark_util_character();
      characterEscape = {
        name: "characterEscape",
        tokenize: tokenizeCharacterEscape
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/character-reference.js
  function tokenizeCharacterReference(effects, ok3, nok) {
    const self2 = this;
    let size2 = 0;
    let max2;
    let test2;
    return start;
    function start(code5) {
      effects.enter("characterReference");
      effects.enter("characterReferenceMarker");
      effects.consume(code5);
      effects.exit("characterReferenceMarker");
      return open;
    }
    function open(code5) {
      if (code5 === 35) {
        effects.enter("characterReferenceMarkerNumeric");
        effects.consume(code5);
        effects.exit("characterReferenceMarkerNumeric");
        return numeric2;
      }
      effects.enter("characterReferenceValue");
      max2 = 31;
      test2 = asciiAlphanumeric;
      return value(code5);
    }
    function numeric2(code5) {
      if (code5 === 88 || code5 === 120) {
        effects.enter("characterReferenceMarkerHexadecimal");
        effects.consume(code5);
        effects.exit("characterReferenceMarkerHexadecimal");
        effects.enter("characterReferenceValue");
        max2 = 6;
        test2 = asciiHexDigit;
        return value;
      }
      effects.enter("characterReferenceValue");
      max2 = 7;
      test2 = asciiDigit;
      return value(code5);
    }
    function value(code5) {
      if (code5 === 59 && size2) {
        const token = effects.exit("characterReferenceValue");
        if (test2 === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
          return nok(code5);
        }
        effects.enter("characterReferenceMarker");
        effects.consume(code5);
        effects.exit("characterReferenceMarker");
        effects.exit("characterReference");
        return ok3;
      }
      if (test2(code5) && size2++ < max2) {
        effects.consume(code5);
        return value;
      }
      return nok(code5);
    }
  }
  var characterReference;
  var init_character_reference = __esm({
    "node_modules/micromark-core-commonmark/lib/character-reference.js"() {
      init_index_dom();
      init_micromark_util_character();
      characterReference = {
        name: "characterReference",
        tokenize: tokenizeCharacterReference
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/code-fenced.js
  function tokenizeCodeFenced(effects, ok3, nok) {
    const self2 = this;
    const closeStart = {
      partial: true,
      tokenize: tokenizeCloseStart
    };
    let initialPrefix = 0;
    let sizeOpen = 0;
    let marker;
    return start;
    function start(code5) {
      return beforeSequenceOpen(code5);
    }
    function beforeSequenceOpen(code5) {
      const tail = self2.events[self2.events.length - 1];
      initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
      marker = code5;
      effects.enter("codeFenced");
      effects.enter("codeFencedFence");
      effects.enter("codeFencedFenceSequence");
      return sequenceOpen(code5);
    }
    function sequenceOpen(code5) {
      if (code5 === marker) {
        sizeOpen++;
        effects.consume(code5);
        return sequenceOpen;
      }
      if (sizeOpen < 3) {
        return nok(code5);
      }
      effects.exit("codeFencedFenceSequence");
      return markdownSpace(code5) ? factorySpace(effects, infoBefore, "whitespace")(code5) : infoBefore(code5);
    }
    function infoBefore(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        effects.exit("codeFencedFence");
        return self2.interrupt ? ok3(code5) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code5);
      }
      effects.enter("codeFencedFenceInfo");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return info(code5);
    }
    function info(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return infoBefore(code5);
      }
      if (markdownSpace(code5)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceInfo");
        return factorySpace(effects, metaBefore, "whitespace")(code5);
      }
      if (code5 === 96 && code5 === marker) {
        return nok(code5);
      }
      effects.consume(code5);
      return info;
    }
    function metaBefore(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        return infoBefore(code5);
      }
      effects.enter("codeFencedFenceMeta");
      effects.enter("chunkString", {
        contentType: "string"
      });
      return meta2(code5);
    }
    function meta2(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        effects.exit("chunkString");
        effects.exit("codeFencedFenceMeta");
        return infoBefore(code5);
      }
      if (code5 === 96 && code5 === marker) {
        return nok(code5);
      }
      effects.consume(code5);
      return meta2;
    }
    function atNonLazyBreak(code5) {
      return effects.attempt(closeStart, after, contentBefore)(code5);
    }
    function contentBefore(code5) {
      effects.enter("lineEnding");
      effects.consume(code5);
      effects.exit("lineEnding");
      return contentStart;
    }
    function contentStart(code5) {
      return initialPrefix > 0 && markdownSpace(code5) ? factorySpace(effects, beforeContentChunk, "linePrefix", initialPrefix + 1)(code5) : beforeContentChunk(code5);
    }
    function beforeContentChunk(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code5);
      }
      effects.enter("codeFlowValue");
      return contentChunk(code5);
    }
    function contentChunk(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        effects.exit("codeFlowValue");
        return beforeContentChunk(code5);
      }
      effects.consume(code5);
      return contentChunk;
    }
    function after(code5) {
      effects.exit("codeFenced");
      return ok3(code5);
    }
    function tokenizeCloseStart(effects2, ok4, nok2) {
      let size2 = 0;
      return startBefore;
      function startBefore(code5) {
        effects2.enter("lineEnding");
        effects2.consume(code5);
        effects2.exit("lineEnding");
        return start2;
      }
      function start2(code5) {
        effects2.enter("codeFencedFence");
        return markdownSpace(code5) ? factorySpace(effects2, beforeSequenceClose, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code5) : beforeSequenceClose(code5);
      }
      function beforeSequenceClose(code5) {
        if (code5 === marker) {
          effects2.enter("codeFencedFenceSequence");
          return sequenceClose(code5);
        }
        return nok2(code5);
      }
      function sequenceClose(code5) {
        if (code5 === marker) {
          size2++;
          effects2.consume(code5);
          return sequenceClose;
        }
        if (size2 >= sizeOpen) {
          effects2.exit("codeFencedFenceSequence");
          return markdownSpace(code5) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code5) : sequenceCloseAfter(code5);
        }
        return nok2(code5);
      }
      function sequenceCloseAfter(code5) {
        if (code5 === null || markdownLineEnding(code5)) {
          effects2.exit("codeFencedFence");
          return ok4(code5);
        }
        return nok2(code5);
      }
    }
  }
  function tokenizeNonLazyContinuation(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code5) {
      if (code5 === null) {
        return nok(code5);
      }
      effects.enter("lineEnding");
      effects.consume(code5);
      effects.exit("lineEnding");
      return lineStart;
    }
    function lineStart(code5) {
      return self2.parser.lazy[self2.now().line] ? nok(code5) : ok3(code5);
    }
  }
  var nonLazyContinuation, codeFenced;
  var init_code_fenced = __esm({
    "node_modules/micromark-core-commonmark/lib/code-fenced.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      nonLazyContinuation = {
        partial: true,
        tokenize: tokenizeNonLazyContinuation
      };
      codeFenced = {
        concrete: true,
        name: "codeFenced",
        tokenize: tokenizeCodeFenced
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/code-indented.js
  function tokenizeCodeIndented(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code5) {
      effects.enter("codeIndented");
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code5);
    }
    function afterPrefix(code5) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code5) : nok(code5);
    }
    function atBreak(code5) {
      if (code5 === null) {
        return after(code5);
      }
      if (markdownLineEnding(code5)) {
        return effects.attempt(furtherStart, atBreak, after)(code5);
      }
      effects.enter("codeFlowValue");
      return inside(code5);
    }
    function inside(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        effects.exit("codeFlowValue");
        return atBreak(code5);
      }
      effects.consume(code5);
      return inside;
    }
    function after(code5) {
      effects.exit("codeIndented");
      return ok3(code5);
    }
  }
  function tokenizeFurtherStart(effects, ok3, nok) {
    const self2 = this;
    return furtherStart2;
    function furtherStart2(code5) {
      if (self2.parser.lazy[self2.now().line]) {
        return nok(code5);
      }
      if (markdownLineEnding(code5)) {
        effects.enter("lineEnding");
        effects.consume(code5);
        effects.exit("lineEnding");
        return furtherStart2;
      }
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code5);
    }
    function afterPrefix(code5) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok3(code5) : markdownLineEnding(code5) ? furtherStart2(code5) : nok(code5);
    }
  }
  var codeIndented, furtherStart;
  var init_code_indented = __esm({
    "node_modules/micromark-core-commonmark/lib/code-indented.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      codeIndented = {
        name: "codeIndented",
        tokenize: tokenizeCodeIndented
      };
      furtherStart = {
        partial: true,
        tokenize: tokenizeFurtherStart
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/code-text.js
  function resolveCodeText(events) {
    let tailExitIndex = events.length - 4;
    let headEnterIndex = 3;
    let index3;
    let enter2;
    if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
      index3 = headEnterIndex;
      while (++index3 < tailExitIndex) {
        if (events[index3][1].type === "codeTextData") {
          events[headEnterIndex][1].type = "codeTextPadding";
          events[tailExitIndex][1].type = "codeTextPadding";
          headEnterIndex += 2;
          tailExitIndex -= 2;
          break;
        }
      }
    }
    index3 = headEnterIndex - 1;
    tailExitIndex++;
    while (++index3 <= tailExitIndex) {
      if (enter2 === void 0) {
        if (index3 !== tailExitIndex && events[index3][1].type !== "lineEnding") {
          enter2 = index3;
        }
      } else if (index3 === tailExitIndex || events[index3][1].type === "lineEnding") {
        events[enter2][1].type = "codeTextData";
        if (index3 !== enter2 + 2) {
          events[enter2][1].end = events[index3 - 1][1].end;
          events.splice(enter2 + 2, index3 - enter2 - 2);
          tailExitIndex -= index3 - enter2 - 2;
          index3 = enter2 + 2;
        }
        enter2 = void 0;
      }
    }
    return events;
  }
  function previous2(code5) {
    return code5 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
  }
  function tokenizeCodeText(effects, ok3, nok) {
    const self2 = this;
    let sizeOpen = 0;
    let size2;
    let token;
    return start;
    function start(code5) {
      effects.enter("codeText");
      effects.enter("codeTextSequence");
      return sequenceOpen(code5);
    }
    function sequenceOpen(code5) {
      if (code5 === 96) {
        effects.consume(code5);
        sizeOpen++;
        return sequenceOpen;
      }
      effects.exit("codeTextSequence");
      return between2(code5);
    }
    function between2(code5) {
      if (code5 === null) {
        return nok(code5);
      }
      if (code5 === 32) {
        effects.enter("space");
        effects.consume(code5);
        effects.exit("space");
        return between2;
      }
      if (code5 === 96) {
        token = effects.enter("codeTextSequence");
        size2 = 0;
        return sequenceClose(code5);
      }
      if (markdownLineEnding(code5)) {
        effects.enter("lineEnding");
        effects.consume(code5);
        effects.exit("lineEnding");
        return between2;
      }
      effects.enter("codeTextData");
      return data(code5);
    }
    function data(code5) {
      if (code5 === null || code5 === 32 || code5 === 96 || markdownLineEnding(code5)) {
        effects.exit("codeTextData");
        return between2(code5);
      }
      effects.consume(code5);
      return data;
    }
    function sequenceClose(code5) {
      if (code5 === 96) {
        effects.consume(code5);
        size2++;
        return sequenceClose;
      }
      if (size2 === sizeOpen) {
        effects.exit("codeTextSequence");
        effects.exit("codeText");
        return ok3(code5);
      }
      token.type = "codeTextData";
      return data(code5);
    }
  }
  var codeText;
  var init_code_text = __esm({
    "node_modules/micromark-core-commonmark/lib/code-text.js"() {
      init_micromark_util_character();
      codeText = {
        name: "codeText",
        previous: previous2,
        resolve: resolveCodeText,
        tokenize: tokenizeCodeText
      };
    }
  });

  // node_modules/micromark-util-subtokenize/lib/splice-buffer.js
  function chunkedPush(list7, right) {
    let chunkStart = 0;
    if (right.length < 1e4) {
      list7.push(...right);
    } else {
      while (chunkStart < right.length) {
        list7.push(...right.slice(chunkStart, chunkStart + 1e4));
        chunkStart += 1e4;
      }
    }
  }
  var SpliceBuffer;
  var init_splice_buffer = __esm({
    "node_modules/micromark-util-subtokenize/lib/splice-buffer.js"() {
      SpliceBuffer = class {
        /**
         * @param {ReadonlyArray<T> | null | undefined} [initial]
         *   Initial items (optional).
         * @returns
         *   Splice buffer.
         */
        constructor(initial) {
          this.left = initial ? [...initial] : [];
          this.right = [];
        }
        /**
         * Array access;
         * does not move the cursor.
         *
         * @param {number} index
         *   Index.
         * @return {T}
         *   Item.
         */
        get(index3) {
          if (index3 < 0 || index3 >= this.left.length + this.right.length) {
            throw new RangeError("Cannot access index `" + index3 + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
          }
          if (index3 < this.left.length) return this.left[index3];
          return this.right[this.right.length - index3 + this.left.length - 1];
        }
        /**
         * The length of the splice buffer, one greater than the largest index in the
         * array.
         */
        get length() {
          return this.left.length + this.right.length;
        }
        /**
         * Remove and return `list[0]`;
         * moves the cursor to `0`.
         *
         * @returns {T | undefined}
         *   Item, optional.
         */
        shift() {
          this.setCursor(0);
          return this.right.pop();
        }
        /**
         * Slice the buffer to get an array;
         * does not move the cursor.
         *
         * @param {number} start
         *   Start.
         * @param {number | null | undefined} [end]
         *   End (optional).
         * @returns {Array<T>}
         *   Array of items.
         */
        slice(start, end) {
          const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;
          if (stop < this.left.length) {
            return this.left.slice(start, stop);
          }
          if (start > this.left.length) {
            return this.right.slice(this.right.length - stop + this.left.length, this.right.length - start + this.left.length).reverse();
          }
          return this.left.slice(start).concat(this.right.slice(this.right.length - stop + this.left.length).reverse());
        }
        /**
         * Mimics the behavior of Array.prototype.splice() except for the change of
         * interface necessary to avoid segfaults when patching in very large arrays.
         *
         * This operation moves cursor is moved to `start` and results in the cursor
         * placed after any inserted items.
         *
         * @param {number} start
         *   Start;
         *   zero-based index at which to start changing the array;
         *   negative numbers count backwards from the end of the array and values
         *   that are out-of bounds are clamped to the appropriate end of the array.
         * @param {number | null | undefined} [deleteCount=0]
         *   Delete count (default: `0`);
         *   maximum number of elements to delete, starting from start.
         * @param {Array<T> | null | undefined} [items=[]]
         *   Items to include in place of the deleted items (default: `[]`).
         * @return {Array<T>}
         *   Any removed items.
         */
        splice(start, deleteCount, items) {
          const count = deleteCount || 0;
          this.setCursor(Math.trunc(start));
          const removed = this.right.splice(this.right.length - count, Number.POSITIVE_INFINITY);
          if (items) chunkedPush(this.left, items);
          return removed.reverse();
        }
        /**
         * Remove and return the highest-numbered item in the array, so
         * `list[list.length - 1]`;
         * Moves the cursor to `length`.
         *
         * @returns {T | undefined}
         *   Item, optional.
         */
        pop() {
          this.setCursor(Number.POSITIVE_INFINITY);
          return this.left.pop();
        }
        /**
         * Inserts a single item to the high-numbered side of the array;
         * moves the cursor to `length`.
         *
         * @param {T} item
         *   Item.
         * @returns {undefined}
         *   Nothing.
         */
        push(item) {
          this.setCursor(Number.POSITIVE_INFINITY);
          this.left.push(item);
        }
        /**
         * Inserts many items to the high-numbered side of the array.
         * Moves the cursor to `length`.
         *
         * @param {Array<T>} items
         *   Items.
         * @returns {undefined}
         *   Nothing.
         */
        pushMany(items) {
          this.setCursor(Number.POSITIVE_INFINITY);
          chunkedPush(this.left, items);
        }
        /**
         * Inserts a single item to the low-numbered side of the array;
         * Moves the cursor to `0`.
         *
         * @param {T} item
         *   Item.
         * @returns {undefined}
         *   Nothing.
         */
        unshift(item) {
          this.setCursor(0);
          this.right.push(item);
        }
        /**
         * Inserts many items to the low-numbered side of the array;
         * moves the cursor to `0`.
         *
         * @param {Array<T>} items
         *   Items.
         * @returns {undefined}
         *   Nothing.
         */
        unshiftMany(items) {
          this.setCursor(0);
          chunkedPush(this.right, items.reverse());
        }
        /**
         * Move the cursor to a specific position in the array. Requires
         * time proportional to the distance moved.
         *
         * If `n < 0`, the cursor will end up at the beginning.
         * If `n > length`, the cursor will end up at the end.
         *
         * @param {number} n
         *   Position.
         * @return {undefined}
         *   Nothing.
         */
        setCursor(n) {
          if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0) return;
          if (n < this.left.length) {
            const removed = this.left.splice(n, Number.POSITIVE_INFINITY);
            chunkedPush(this.right, removed.reverse());
          } else {
            const removed = this.right.splice(this.left.length + this.right.length - n, Number.POSITIVE_INFINITY);
            chunkedPush(this.left, removed.reverse());
          }
        }
      };
    }
  });

  // node_modules/micromark-util-subtokenize/index.js
  function subtokenize(eventsArray) {
    const jumps = {};
    let index3 = -1;
    let event;
    let lineIndex;
    let otherIndex;
    let otherEvent;
    let parameters;
    let subevents;
    let more;
    const events = new SpliceBuffer(eventsArray);
    while (++index3 < events.length) {
      while (index3 in jumps) {
        index3 = jumps[index3];
      }
      event = events.get(index3);
      if (index3 && event[1].type === "chunkFlow" && events.get(index3 - 1)[1].type === "listItemPrefix") {
        subevents = event[1]._tokenizer.events;
        otherIndex = 0;
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
          otherIndex += 2;
        }
        if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
          while (++otherIndex < subevents.length) {
            if (subevents[otherIndex][1].type === "content") {
              break;
            }
            if (subevents[otherIndex][1].type === "chunkText") {
              subevents[otherIndex][1]._isInFirstContentOfListItem = true;
              otherIndex++;
            }
          }
        }
      }
      if (event[0] === "enter") {
        if (event[1].contentType) {
          Object.assign(jumps, subcontent(events, index3));
          index3 = jumps[index3];
          more = true;
        }
      } else if (event[1]._container) {
        otherIndex = index3;
        lineIndex = void 0;
        while (otherIndex--) {
          otherEvent = events.get(otherIndex);
          if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
            if (otherEvent[0] === "enter") {
              if (lineIndex) {
                events.get(lineIndex)[1].type = "lineEndingBlank";
              }
              otherEvent[1].type = "lineEnding";
              lineIndex = otherIndex;
            }
          } else if (otherEvent[1].type === "linePrefix" || otherEvent[1].type === "listItemIndent") {
          } else {
            break;
          }
        }
        if (lineIndex) {
          event[1].end = {
            ...events.get(lineIndex)[1].start
          };
          parameters = events.slice(lineIndex, index3);
          parameters.unshift(event);
          events.splice(lineIndex, index3 - lineIndex + 1, parameters);
        }
      }
    }
    splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));
    return !more;
  }
  function subcontent(events, eventIndex) {
    const token = events.get(eventIndex)[1];
    const context = events.get(eventIndex)[2];
    let startPosition = eventIndex - 1;
    const startPositions = [];
    let tokenizer = token._tokenizer;
    if (!tokenizer) {
      tokenizer = context.parser[token.contentType](token.start);
      if (token._contentTypeTextTrailing) {
        tokenizer._contentTypeTextTrailing = true;
      }
    }
    const childEvents = tokenizer.events;
    const jumps = [];
    const gaps = {};
    let stream;
    let previous3;
    let index3 = -1;
    let current = token;
    let adjust = 0;
    let start = 0;
    const breaks = [start];
    while (current) {
      while (events.get(++startPosition)[1] !== current) {
      }
      startPositions.push(startPosition);
      if (!current._tokenizer) {
        stream = context.sliceStream(current);
        if (!current.next) {
          stream.push(null);
        }
        if (previous3) {
          tokenizer.defineSkip(current.start);
        }
        if (current._isInFirstContentOfListItem) {
          tokenizer._gfmTasklistFirstContentOfListItem = true;
        }
        tokenizer.write(stream);
        if (current._isInFirstContentOfListItem) {
          tokenizer._gfmTasklistFirstContentOfListItem = void 0;
        }
      }
      previous3 = current;
      current = current.next;
    }
    current = token;
    while (++index3 < childEvents.length) {
      if (
        // Find a void token that includes a break.
        childEvents[index3][0] === "exit" && childEvents[index3 - 1][0] === "enter" && childEvents[index3][1].type === childEvents[index3 - 1][1].type && childEvents[index3][1].start.line !== childEvents[index3][1].end.line
      ) {
        start = index3 + 1;
        breaks.push(start);
        current._tokenizer = void 0;
        current.previous = void 0;
        current = current.next;
      }
    }
    tokenizer.events = [];
    if (current) {
      current._tokenizer = void 0;
      current.previous = void 0;
    } else {
      breaks.pop();
    }
    index3 = breaks.length;
    while (index3--) {
      const slice2 = childEvents.slice(breaks[index3], breaks[index3 + 1]);
      const start2 = startPositions.pop();
      jumps.push([start2, start2 + slice2.length - 1]);
      events.splice(start2, 2, slice2);
    }
    jumps.reverse();
    index3 = -1;
    while (++index3 < jumps.length) {
      gaps[adjust + jumps[index3][0]] = adjust + jumps[index3][1];
      adjust += jumps[index3][1] - jumps[index3][0] - 1;
    }
    return gaps;
  }
  var init_micromark_util_subtokenize = __esm({
    "node_modules/micromark-util-subtokenize/index.js"() {
      init_micromark_util_chunked();
      init_splice_buffer();
      init_splice_buffer();
    }
  });

  // node_modules/micromark-core-commonmark/lib/content.js
  function resolveContent(events) {
    subtokenize(events);
    return events;
  }
  function tokenizeContent(effects, ok3) {
    let previous3;
    return chunkStart;
    function chunkStart(code5) {
      effects.enter("content");
      previous3 = effects.enter("chunkContent", {
        contentType: "content"
      });
      return chunkInside(code5);
    }
    function chunkInside(code5) {
      if (code5 === null) {
        return contentEnd(code5);
      }
      if (markdownLineEnding(code5)) {
        return effects.check(continuationConstruct, contentContinue, contentEnd)(code5);
      }
      effects.consume(code5);
      return chunkInside;
    }
    function contentEnd(code5) {
      effects.exit("chunkContent");
      effects.exit("content");
      return ok3(code5);
    }
    function contentContinue(code5) {
      effects.consume(code5);
      effects.exit("chunkContent");
      previous3.next = effects.enter("chunkContent", {
        contentType: "content",
        previous: previous3
      });
      previous3 = previous3.next;
      return chunkInside;
    }
  }
  function tokenizeContinuation(effects, ok3, nok) {
    const self2 = this;
    return startLookahead;
    function startLookahead(code5) {
      effects.exit("chunkContent");
      effects.enter("lineEnding");
      effects.consume(code5);
      effects.exit("lineEnding");
      return factorySpace(effects, prefixed, "linePrefix");
    }
    function prefixed(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        return nok(code5);
      }
      const tail = self2.events[self2.events.length - 1];
      if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
        return ok3(code5);
      }
      return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code5);
    }
  }
  var content3, continuationConstruct;
  var init_content2 = __esm({
    "node_modules/micromark-core-commonmark/lib/content.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      init_micromark_util_subtokenize();
      content3 = {
        resolve: resolveContent,
        tokenize: tokenizeContent
      };
      continuationConstruct = {
        partial: true,
        tokenize: tokenizeContinuation
      };
    }
  });

  // node_modules/micromark-factory-destination/index.js
  function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max2) {
    const limit = max2 || Number.POSITIVE_INFINITY;
    let balance = 0;
    return start;
    function start(code5) {
      if (code5 === 60) {
        effects.enter(type);
        effects.enter(literalType);
        effects.enter(literalMarkerType);
        effects.consume(code5);
        effects.exit(literalMarkerType);
        return enclosedBefore;
      }
      if (code5 === null || code5 === 32 || code5 === 41 || asciiControl(code5)) {
        return nok(code5);
      }
      effects.enter(type);
      effects.enter(rawType);
      effects.enter(stringType);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return raw2(code5);
    }
    function enclosedBefore(code5) {
      if (code5 === 62) {
        effects.enter(literalMarkerType);
        effects.consume(code5);
        effects.exit(literalMarkerType);
        effects.exit(literalType);
        effects.exit(type);
        return ok3;
      }
      effects.enter(stringType);
      effects.enter("chunkString", {
        contentType: "string"
      });
      return enclosed(code5);
    }
    function enclosed(code5) {
      if (code5 === 62) {
        effects.exit("chunkString");
        effects.exit(stringType);
        return enclosedBefore(code5);
      }
      if (code5 === null || code5 === 60 || markdownLineEnding(code5)) {
        return nok(code5);
      }
      effects.consume(code5);
      return code5 === 92 ? enclosedEscape : enclosed;
    }
    function enclosedEscape(code5) {
      if (code5 === 60 || code5 === 62 || code5 === 92) {
        effects.consume(code5);
        return enclosed;
      }
      return enclosed(code5);
    }
    function raw2(code5) {
      if (!balance && (code5 === null || code5 === 41 || markdownLineEndingOrSpace(code5))) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type);
        return ok3(code5);
      }
      if (balance < limit && code5 === 40) {
        effects.consume(code5);
        balance++;
        return raw2;
      }
      if (code5 === 41) {
        effects.consume(code5);
        balance--;
        return raw2;
      }
      if (code5 === null || code5 === 32 || code5 === 40 || asciiControl(code5)) {
        return nok(code5);
      }
      effects.consume(code5);
      return code5 === 92 ? rawEscape : raw2;
    }
    function rawEscape(code5) {
      if (code5 === 40 || code5 === 41 || code5 === 92) {
        effects.consume(code5);
        return raw2;
      }
      return raw2(code5);
    }
  }
  var init_micromark_factory_destination = __esm({
    "node_modules/micromark-factory-destination/index.js"() {
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-factory-label/index.js
  function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
    const self2 = this;
    let size2 = 0;
    let seen;
    return start;
    function start(code5) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code5);
      effects.exit(markerType);
      effects.enter(stringType);
      return atBreak;
    }
    function atBreak(code5) {
      if (size2 > 999 || code5 === null || code5 === 91 || code5 === 93 && !seen || // To do: remove in the future once weve switched from
      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
      // which doesnt need this.
      // Hidden footnotes hook.
      /* c8 ignore next 3 */
      code5 === 94 && !size2 && "_hiddenFootnoteSupport" in self2.parser.constructs) {
        return nok(code5);
      }
      if (code5 === 93) {
        effects.exit(stringType);
        effects.enter(markerType);
        effects.consume(code5);
        effects.exit(markerType);
        effects.exit(type);
        return ok3;
      }
      if (markdownLineEnding(code5)) {
        effects.enter("lineEnding");
        effects.consume(code5);
        effects.exit("lineEnding");
        return atBreak;
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return labelInside(code5);
    }
    function labelInside(code5) {
      if (code5 === null || code5 === 91 || code5 === 93 || markdownLineEnding(code5) || size2++ > 999) {
        effects.exit("chunkString");
        return atBreak(code5);
      }
      effects.consume(code5);
      if (!seen) seen = !markdownSpace(code5);
      return code5 === 92 ? labelEscape : labelInside;
    }
    function labelEscape(code5) {
      if (code5 === 91 || code5 === 92 || code5 === 93) {
        effects.consume(code5);
        size2++;
        return labelInside;
      }
      return labelInside(code5);
    }
  }
  var init_micromark_factory_label = __esm({
    "node_modules/micromark-factory-label/index.js"() {
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-factory-title/index.js
  function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
    let marker;
    return start;
    function start(code5) {
      if (code5 === 34 || code5 === 39 || code5 === 40) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code5);
        effects.exit(markerType);
        marker = code5 === 40 ? 41 : code5;
        return begin;
      }
      return nok(code5);
    }
    function begin(code5) {
      if (code5 === marker) {
        effects.enter(markerType);
        effects.consume(code5);
        effects.exit(markerType);
        effects.exit(type);
        return ok3;
      }
      effects.enter(stringType);
      return atBreak(code5);
    }
    function atBreak(code5) {
      if (code5 === marker) {
        effects.exit(stringType);
        return begin(marker);
      }
      if (code5 === null) {
        return nok(code5);
      }
      if (markdownLineEnding(code5)) {
        effects.enter("lineEnding");
        effects.consume(code5);
        effects.exit("lineEnding");
        return factorySpace(effects, atBreak, "linePrefix");
      }
      effects.enter("chunkString", {
        contentType: "string"
      });
      return inside(code5);
    }
    function inside(code5) {
      if (code5 === marker || code5 === null || markdownLineEnding(code5)) {
        effects.exit("chunkString");
        return atBreak(code5);
      }
      effects.consume(code5);
      return code5 === 92 ? escape3 : inside;
    }
    function escape3(code5) {
      if (code5 === marker || code5 === 92) {
        effects.consume(code5);
        return inside;
      }
      return inside(code5);
    }
  }
  var init_micromark_factory_title = __esm({
    "node_modules/micromark-factory-title/index.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-factory-whitespace/index.js
  function factoryWhitespace(effects, ok3) {
    let seen;
    return start;
    function start(code5) {
      if (markdownLineEnding(code5)) {
        effects.enter("lineEnding");
        effects.consume(code5);
        effects.exit("lineEnding");
        seen = true;
        return start;
      }
      if (markdownSpace(code5)) {
        return factorySpace(effects, start, seen ? "linePrefix" : "lineSuffix")(code5);
      }
      return ok3(code5);
    }
  }
  var init_micromark_factory_whitespace = __esm({
    "node_modules/micromark-factory-whitespace/index.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
    }
  });

  // node_modules/micromark-core-commonmark/lib/definition.js
  function tokenizeDefinition(effects, ok3, nok) {
    const self2 = this;
    let identifier;
    return start;
    function start(code5) {
      effects.enter("definition");
      return before(code5);
    }
    function before(code5) {
      return factoryLabel.call(
        self2,
        effects,
        labelAfter,
        // Note: we dont need to reset the way `markdown-rs` does.
        nok,
        "definitionLabel",
        "definitionLabelMarker",
        "definitionLabelString"
      )(code5);
    }
    function labelAfter(code5) {
      identifier = normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
      if (code5 === 58) {
        effects.enter("definitionMarker");
        effects.consume(code5);
        effects.exit("definitionMarker");
        return markerAfter;
      }
      return nok(code5);
    }
    function markerAfter(code5) {
      return markdownLineEndingOrSpace(code5) ? factoryWhitespace(effects, destinationBefore)(code5) : destinationBefore(code5);
    }
    function destinationBefore(code5) {
      return factoryDestination(
        effects,
        destinationAfter,
        // Note: we dont need to reset the way `markdown-rs` does.
        nok,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )(code5);
    }
    function destinationAfter(code5) {
      return effects.attempt(titleBefore, after, after)(code5);
    }
    function after(code5) {
      return markdownSpace(code5) ? factorySpace(effects, afterWhitespace, "whitespace")(code5) : afterWhitespace(code5);
    }
    function afterWhitespace(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        effects.exit("definition");
        self2.parser.defined.push(identifier);
        return ok3(code5);
      }
      return nok(code5);
    }
  }
  function tokenizeTitleBefore(effects, ok3, nok) {
    return titleBefore2;
    function titleBefore2(code5) {
      return markdownLineEndingOrSpace(code5) ? factoryWhitespace(effects, beforeMarker)(code5) : nok(code5);
    }
    function beforeMarker(code5) {
      return factoryTitle(effects, titleAfter, nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code5);
    }
    function titleAfter(code5) {
      return markdownSpace(code5) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code5) : titleAfterOptionalWhitespace(code5);
    }
    function titleAfterOptionalWhitespace(code5) {
      return code5 === null || markdownLineEnding(code5) ? ok3(code5) : nok(code5);
    }
  }
  var definition2, titleBefore;
  var init_definition2 = __esm({
    "node_modules/micromark-core-commonmark/lib/definition.js"() {
      init_micromark_factory_destination();
      init_micromark_factory_label();
      init_micromark_factory_space();
      init_micromark_factory_title();
      init_micromark_factory_whitespace();
      init_micromark_util_character();
      init_micromark_util_normalize_identifier();
      definition2 = {
        name: "definition",
        tokenize: tokenizeDefinition
      };
      titleBefore = {
        partial: true,
        tokenize: tokenizeTitleBefore
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/hard-break-escape.js
  function tokenizeHardBreakEscape(effects, ok3, nok) {
    return start;
    function start(code5) {
      effects.enter("hardBreakEscape");
      effects.consume(code5);
      return after;
    }
    function after(code5) {
      if (markdownLineEnding(code5)) {
        effects.exit("hardBreakEscape");
        return ok3(code5);
      }
      return nok(code5);
    }
  }
  var hardBreakEscape;
  var init_hard_break_escape = __esm({
    "node_modules/micromark-core-commonmark/lib/hard-break-escape.js"() {
      init_micromark_util_character();
      hardBreakEscape = {
        name: "hardBreakEscape",
        tokenize: tokenizeHardBreakEscape
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/heading-atx.js
  function resolveHeadingAtx(events, context) {
    let contentEnd = events.length - 2;
    let contentStart = 3;
    let content5;
    let text10;
    if (events[contentStart][1].type === "whitespace") {
      contentStart += 2;
    }
    if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
      contentEnd -= 2;
    }
    if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
      contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
    }
    if (contentEnd > contentStart) {
      content5 = {
        type: "atxHeadingText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end
      };
      text10 = {
        type: "chunkText",
        start: events[contentStart][1].start,
        end: events[contentEnd][1].end,
        contentType: "text"
      };
      splice(events, contentStart, contentEnd - contentStart + 1, [["enter", content5, context], ["enter", text10, context], ["exit", text10, context], ["exit", content5, context]]);
    }
    return events;
  }
  function tokenizeHeadingAtx(effects, ok3, nok) {
    let size2 = 0;
    return start;
    function start(code5) {
      effects.enter("atxHeading");
      return before(code5);
    }
    function before(code5) {
      effects.enter("atxHeadingSequence");
      return sequenceOpen(code5);
    }
    function sequenceOpen(code5) {
      if (code5 === 35 && size2++ < 6) {
        effects.consume(code5);
        return sequenceOpen;
      }
      if (code5 === null || markdownLineEndingOrSpace(code5)) {
        effects.exit("atxHeadingSequence");
        return atBreak(code5);
      }
      return nok(code5);
    }
    function atBreak(code5) {
      if (code5 === 35) {
        effects.enter("atxHeadingSequence");
        return sequenceFurther(code5);
      }
      if (code5 === null || markdownLineEnding(code5)) {
        effects.exit("atxHeading");
        return ok3(code5);
      }
      if (markdownSpace(code5)) {
        return factorySpace(effects, atBreak, "whitespace")(code5);
      }
      effects.enter("atxHeadingText");
      return data(code5);
    }
    function sequenceFurther(code5) {
      if (code5 === 35) {
        effects.consume(code5);
        return sequenceFurther;
      }
      effects.exit("atxHeadingSequence");
      return atBreak(code5);
    }
    function data(code5) {
      if (code5 === null || code5 === 35 || markdownLineEndingOrSpace(code5)) {
        effects.exit("atxHeadingText");
        return atBreak(code5);
      }
      effects.consume(code5);
      return data;
    }
  }
  var headingAtx;
  var init_heading_atx = __esm({
    "node_modules/micromark-core-commonmark/lib/heading-atx.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      init_micromark_util_chunked();
      headingAtx = {
        name: "headingAtx",
        resolve: resolveHeadingAtx,
        tokenize: tokenizeHeadingAtx
      };
    }
  });

  // node_modules/micromark-util-html-tag-name/index.js
  var htmlBlockNames, htmlRawNames;
  var init_micromark_util_html_tag_name = __esm({
    "node_modules/micromark-util-html-tag-name/index.js"() {
      htmlBlockNames = [
        "address",
        "article",
        "aside",
        "base",
        "basefont",
        "blockquote",
        "body",
        "caption",
        "center",
        "col",
        "colgroup",
        "dd",
        "details",
        "dialog",
        "dir",
        "div",
        "dl",
        "dt",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "frame",
        "frameset",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hr",
        "html",
        "iframe",
        "legend",
        "li",
        "link",
        "main",
        "menu",
        "menuitem",
        "nav",
        "noframes",
        "ol",
        "optgroup",
        "option",
        "p",
        "param",
        "search",
        "section",
        "summary",
        "table",
        "tbody",
        "td",
        "tfoot",
        "th",
        "thead",
        "title",
        "tr",
        "track",
        "ul"
      ];
      htmlRawNames = ["pre", "script", "style", "textarea"];
    }
  });

  // node_modules/micromark-core-commonmark/lib/html-flow.js
  function resolveToHtmlFlow(events) {
    let index3 = events.length;
    while (index3--) {
      if (events[index3][0] === "enter" && events[index3][1].type === "htmlFlow") {
        break;
      }
    }
    if (index3 > 1 && events[index3 - 2][1].type === "linePrefix") {
      events[index3][1].start = events[index3 - 2][1].start;
      events[index3 + 1][1].start = events[index3 - 2][1].start;
      events.splice(index3 - 2, 2);
    }
    return events;
  }
  function tokenizeHtmlFlow(effects, ok3, nok) {
    const self2 = this;
    let marker;
    let closingTag;
    let buffer;
    let index3;
    let markerB;
    return start;
    function start(code5) {
      return before(code5);
    }
    function before(code5) {
      effects.enter("htmlFlow");
      effects.enter("htmlFlowData");
      effects.consume(code5);
      return open;
    }
    function open(code5) {
      if (code5 === 33) {
        effects.consume(code5);
        return declarationOpen;
      }
      if (code5 === 47) {
        effects.consume(code5);
        closingTag = true;
        return tagCloseStart;
      }
      if (code5 === 63) {
        effects.consume(code5);
        marker = 3;
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      if (asciiAlpha(code5)) {
        effects.consume(code5);
        buffer = String.fromCharCode(code5);
        return tagName;
      }
      return nok(code5);
    }
    function declarationOpen(code5) {
      if (code5 === 45) {
        effects.consume(code5);
        marker = 2;
        return commentOpenInside;
      }
      if (code5 === 91) {
        effects.consume(code5);
        marker = 5;
        index3 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha(code5)) {
        effects.consume(code5);
        marker = 4;
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      return nok(code5);
    }
    function commentOpenInside(code5) {
      if (code5 === 45) {
        effects.consume(code5);
        return self2.interrupt ? ok3 : continuationDeclarationInside;
      }
      return nok(code5);
    }
    function cdataOpenInside(code5) {
      const value = "CDATA[";
      if (code5 === value.charCodeAt(index3++)) {
        effects.consume(code5);
        if (index3 === value.length) {
          return self2.interrupt ? ok3 : continuation;
        }
        return cdataOpenInside;
      }
      return nok(code5);
    }
    function tagCloseStart(code5) {
      if (asciiAlpha(code5)) {
        effects.consume(code5);
        buffer = String.fromCharCode(code5);
        return tagName;
      }
      return nok(code5);
    }
    function tagName(code5) {
      if (code5 === null || code5 === 47 || code5 === 62 || markdownLineEndingOrSpace(code5)) {
        const slash = code5 === 47;
        const name = buffer.toLowerCase();
        if (!slash && !closingTag && htmlRawNames.includes(name)) {
          marker = 1;
          return self2.interrupt ? ok3(code5) : continuation(code5);
        }
        if (htmlBlockNames.includes(buffer.toLowerCase())) {
          marker = 6;
          if (slash) {
            effects.consume(code5);
            return basicSelfClosing;
          }
          return self2.interrupt ? ok3(code5) : continuation(code5);
        }
        marker = 7;
        return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code5) : closingTag ? completeClosingTagAfter(code5) : completeAttributeNameBefore(code5);
      }
      if (code5 === 45 || asciiAlphanumeric(code5)) {
        effects.consume(code5);
        buffer += String.fromCharCode(code5);
        return tagName;
      }
      return nok(code5);
    }
    function basicSelfClosing(code5) {
      if (code5 === 62) {
        effects.consume(code5);
        return self2.interrupt ? ok3 : continuation;
      }
      return nok(code5);
    }
    function completeClosingTagAfter(code5) {
      if (markdownSpace(code5)) {
        effects.consume(code5);
        return completeClosingTagAfter;
      }
      return completeEnd(code5);
    }
    function completeAttributeNameBefore(code5) {
      if (code5 === 47) {
        effects.consume(code5);
        return completeEnd;
      }
      if (code5 === 58 || code5 === 95 || asciiAlpha(code5)) {
        effects.consume(code5);
        return completeAttributeName;
      }
      if (markdownSpace(code5)) {
        effects.consume(code5);
        return completeAttributeNameBefore;
      }
      return completeEnd(code5);
    }
    function completeAttributeName(code5) {
      if (code5 === 45 || code5 === 46 || code5 === 58 || code5 === 95 || asciiAlphanumeric(code5)) {
        effects.consume(code5);
        return completeAttributeName;
      }
      return completeAttributeNameAfter(code5);
    }
    function completeAttributeNameAfter(code5) {
      if (code5 === 61) {
        effects.consume(code5);
        return completeAttributeValueBefore;
      }
      if (markdownSpace(code5)) {
        effects.consume(code5);
        return completeAttributeNameAfter;
      }
      return completeAttributeNameBefore(code5);
    }
    function completeAttributeValueBefore(code5) {
      if (code5 === null || code5 === 60 || code5 === 61 || code5 === 62 || code5 === 96) {
        return nok(code5);
      }
      if (code5 === 34 || code5 === 39) {
        effects.consume(code5);
        markerB = code5;
        return completeAttributeValueQuoted;
      }
      if (markdownSpace(code5)) {
        effects.consume(code5);
        return completeAttributeValueBefore;
      }
      return completeAttributeValueUnquoted(code5);
    }
    function completeAttributeValueQuoted(code5) {
      if (code5 === markerB) {
        effects.consume(code5);
        markerB = null;
        return completeAttributeValueQuotedAfter;
      }
      if (code5 === null || markdownLineEnding(code5)) {
        return nok(code5);
      }
      effects.consume(code5);
      return completeAttributeValueQuoted;
    }
    function completeAttributeValueUnquoted(code5) {
      if (code5 === null || code5 === 34 || code5 === 39 || code5 === 47 || code5 === 60 || code5 === 61 || code5 === 62 || code5 === 96 || markdownLineEndingOrSpace(code5)) {
        return completeAttributeNameAfter(code5);
      }
      effects.consume(code5);
      return completeAttributeValueUnquoted;
    }
    function completeAttributeValueQuotedAfter(code5) {
      if (code5 === 47 || code5 === 62 || markdownSpace(code5)) {
        return completeAttributeNameBefore(code5);
      }
      return nok(code5);
    }
    function completeEnd(code5) {
      if (code5 === 62) {
        effects.consume(code5);
        return completeAfter;
      }
      return nok(code5);
    }
    function completeAfter(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        return continuation(code5);
      }
      if (markdownSpace(code5)) {
        effects.consume(code5);
        return completeAfter;
      }
      return nok(code5);
    }
    function continuation(code5) {
      if (code5 === 45 && marker === 2) {
        effects.consume(code5);
        return continuationCommentInside;
      }
      if (code5 === 60 && marker === 1) {
        effects.consume(code5);
        return continuationRawTagOpen;
      }
      if (code5 === 62 && marker === 4) {
        effects.consume(code5);
        return continuationClose;
      }
      if (code5 === 63 && marker === 3) {
        effects.consume(code5);
        return continuationDeclarationInside;
      }
      if (code5 === 93 && marker === 5) {
        effects.consume(code5);
        return continuationCdataInside;
      }
      if (markdownLineEnding(code5) && (marker === 6 || marker === 7)) {
        effects.exit("htmlFlowData");
        return effects.check(blankLineBefore, continuationAfter, continuationStart)(code5);
      }
      if (code5 === null || markdownLineEnding(code5)) {
        effects.exit("htmlFlowData");
        return continuationStart(code5);
      }
      effects.consume(code5);
      return continuation;
    }
    function continuationStart(code5) {
      return effects.check(nonLazyContinuationStart, continuationStartNonLazy, continuationAfter)(code5);
    }
    function continuationStartNonLazy(code5) {
      effects.enter("lineEnding");
      effects.consume(code5);
      effects.exit("lineEnding");
      return continuationBefore;
    }
    function continuationBefore(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        return continuationStart(code5);
      }
      effects.enter("htmlFlowData");
      return continuation(code5);
    }
    function continuationCommentInside(code5) {
      if (code5 === 45) {
        effects.consume(code5);
        return continuationDeclarationInside;
      }
      return continuation(code5);
    }
    function continuationRawTagOpen(code5) {
      if (code5 === 47) {
        effects.consume(code5);
        buffer = "";
        return continuationRawEndTag;
      }
      return continuation(code5);
    }
    function continuationRawEndTag(code5) {
      if (code5 === 62) {
        const name = buffer.toLowerCase();
        if (htmlRawNames.includes(name)) {
          effects.consume(code5);
          return continuationClose;
        }
        return continuation(code5);
      }
      if (asciiAlpha(code5) && buffer.length < 8) {
        effects.consume(code5);
        buffer += String.fromCharCode(code5);
        return continuationRawEndTag;
      }
      return continuation(code5);
    }
    function continuationCdataInside(code5) {
      if (code5 === 93) {
        effects.consume(code5);
        return continuationDeclarationInside;
      }
      return continuation(code5);
    }
    function continuationDeclarationInside(code5) {
      if (code5 === 62) {
        effects.consume(code5);
        return continuationClose;
      }
      if (code5 === 45 && marker === 2) {
        effects.consume(code5);
        return continuationDeclarationInside;
      }
      return continuation(code5);
    }
    function continuationClose(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        effects.exit("htmlFlowData");
        return continuationAfter(code5);
      }
      effects.consume(code5);
      return continuationClose;
    }
    function continuationAfter(code5) {
      effects.exit("htmlFlow");
      return ok3(code5);
    }
  }
  function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code5) {
      if (markdownLineEnding(code5)) {
        effects.enter("lineEnding");
        effects.consume(code5);
        effects.exit("lineEnding");
        return after;
      }
      return nok(code5);
    }
    function after(code5) {
      return self2.parser.lazy[self2.now().line] ? nok(code5) : ok3(code5);
    }
  }
  function tokenizeBlankLineBefore(effects, ok3, nok) {
    return start;
    function start(code5) {
      effects.enter("lineEnding");
      effects.consume(code5);
      effects.exit("lineEnding");
      return effects.attempt(blankLine, ok3, nok);
    }
  }
  var htmlFlow, blankLineBefore, nonLazyContinuationStart;
  var init_html_flow = __esm({
    "node_modules/micromark-core-commonmark/lib/html-flow.js"() {
      init_micromark_util_character();
      init_micromark_util_html_tag_name();
      init_blank_line();
      htmlFlow = {
        concrete: true,
        name: "htmlFlow",
        resolveTo: resolveToHtmlFlow,
        tokenize: tokenizeHtmlFlow
      };
      blankLineBefore = {
        partial: true,
        tokenize: tokenizeBlankLineBefore
      };
      nonLazyContinuationStart = {
        partial: true,
        tokenize: tokenizeNonLazyContinuationStart
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/html-text.js
  function tokenizeHtmlText(effects, ok3, nok) {
    const self2 = this;
    let marker;
    let index3;
    let returnState;
    return start;
    function start(code5) {
      effects.enter("htmlText");
      effects.enter("htmlTextData");
      effects.consume(code5);
      return open;
    }
    function open(code5) {
      if (code5 === 33) {
        effects.consume(code5);
        return declarationOpen;
      }
      if (code5 === 47) {
        effects.consume(code5);
        return tagCloseStart;
      }
      if (code5 === 63) {
        effects.consume(code5);
        return instruction;
      }
      if (asciiAlpha(code5)) {
        effects.consume(code5);
        return tagOpen;
      }
      return nok(code5);
    }
    function declarationOpen(code5) {
      if (code5 === 45) {
        effects.consume(code5);
        return commentOpenInside;
      }
      if (code5 === 91) {
        effects.consume(code5);
        index3 = 0;
        return cdataOpenInside;
      }
      if (asciiAlpha(code5)) {
        effects.consume(code5);
        return declaration;
      }
      return nok(code5);
    }
    function commentOpenInside(code5) {
      if (code5 === 45) {
        effects.consume(code5);
        return commentEnd;
      }
      return nok(code5);
    }
    function comment4(code5) {
      if (code5 === null) {
        return nok(code5);
      }
      if (code5 === 45) {
        effects.consume(code5);
        return commentClose;
      }
      if (markdownLineEnding(code5)) {
        returnState = comment4;
        return lineEndingBefore(code5);
      }
      effects.consume(code5);
      return comment4;
    }
    function commentClose(code5) {
      if (code5 === 45) {
        effects.consume(code5);
        return commentEnd;
      }
      return comment4(code5);
    }
    function commentEnd(code5) {
      return code5 === 62 ? end(code5) : code5 === 45 ? commentClose(code5) : comment4(code5);
    }
    function cdataOpenInside(code5) {
      const value = "CDATA[";
      if (code5 === value.charCodeAt(index3++)) {
        effects.consume(code5);
        return index3 === value.length ? cdata : cdataOpenInside;
      }
      return nok(code5);
    }
    function cdata(code5) {
      if (code5 === null) {
        return nok(code5);
      }
      if (code5 === 93) {
        effects.consume(code5);
        return cdataClose;
      }
      if (markdownLineEnding(code5)) {
        returnState = cdata;
        return lineEndingBefore(code5);
      }
      effects.consume(code5);
      return cdata;
    }
    function cdataClose(code5) {
      if (code5 === 93) {
        effects.consume(code5);
        return cdataEnd;
      }
      return cdata(code5);
    }
    function cdataEnd(code5) {
      if (code5 === 62) {
        return end(code5);
      }
      if (code5 === 93) {
        effects.consume(code5);
        return cdataEnd;
      }
      return cdata(code5);
    }
    function declaration(code5) {
      if (code5 === null || code5 === 62) {
        return end(code5);
      }
      if (markdownLineEnding(code5)) {
        returnState = declaration;
        return lineEndingBefore(code5);
      }
      effects.consume(code5);
      return declaration;
    }
    function instruction(code5) {
      if (code5 === null) {
        return nok(code5);
      }
      if (code5 === 63) {
        effects.consume(code5);
        return instructionClose;
      }
      if (markdownLineEnding(code5)) {
        returnState = instruction;
        return lineEndingBefore(code5);
      }
      effects.consume(code5);
      return instruction;
    }
    function instructionClose(code5) {
      return code5 === 62 ? end(code5) : instruction(code5);
    }
    function tagCloseStart(code5) {
      if (asciiAlpha(code5)) {
        effects.consume(code5);
        return tagClose;
      }
      return nok(code5);
    }
    function tagClose(code5) {
      if (code5 === 45 || asciiAlphanumeric(code5)) {
        effects.consume(code5);
        return tagClose;
      }
      return tagCloseBetween(code5);
    }
    function tagCloseBetween(code5) {
      if (markdownLineEnding(code5)) {
        returnState = tagCloseBetween;
        return lineEndingBefore(code5);
      }
      if (markdownSpace(code5)) {
        effects.consume(code5);
        return tagCloseBetween;
      }
      return end(code5);
    }
    function tagOpen(code5) {
      if (code5 === 45 || asciiAlphanumeric(code5)) {
        effects.consume(code5);
        return tagOpen;
      }
      if (code5 === 47 || code5 === 62 || markdownLineEndingOrSpace(code5)) {
        return tagOpenBetween(code5);
      }
      return nok(code5);
    }
    function tagOpenBetween(code5) {
      if (code5 === 47) {
        effects.consume(code5);
        return end;
      }
      if (code5 === 58 || code5 === 95 || asciiAlpha(code5)) {
        effects.consume(code5);
        return tagOpenAttributeName;
      }
      if (markdownLineEnding(code5)) {
        returnState = tagOpenBetween;
        return lineEndingBefore(code5);
      }
      if (markdownSpace(code5)) {
        effects.consume(code5);
        return tagOpenBetween;
      }
      return end(code5);
    }
    function tagOpenAttributeName(code5) {
      if (code5 === 45 || code5 === 46 || code5 === 58 || code5 === 95 || asciiAlphanumeric(code5)) {
        effects.consume(code5);
        return tagOpenAttributeName;
      }
      return tagOpenAttributeNameAfter(code5);
    }
    function tagOpenAttributeNameAfter(code5) {
      if (code5 === 61) {
        effects.consume(code5);
        return tagOpenAttributeValueBefore;
      }
      if (markdownLineEnding(code5)) {
        returnState = tagOpenAttributeNameAfter;
        return lineEndingBefore(code5);
      }
      if (markdownSpace(code5)) {
        effects.consume(code5);
        return tagOpenAttributeNameAfter;
      }
      return tagOpenBetween(code5);
    }
    function tagOpenAttributeValueBefore(code5) {
      if (code5 === null || code5 === 60 || code5 === 61 || code5 === 62 || code5 === 96) {
        return nok(code5);
      }
      if (code5 === 34 || code5 === 39) {
        effects.consume(code5);
        marker = code5;
        return tagOpenAttributeValueQuoted;
      }
      if (markdownLineEnding(code5)) {
        returnState = tagOpenAttributeValueBefore;
        return lineEndingBefore(code5);
      }
      if (markdownSpace(code5)) {
        effects.consume(code5);
        return tagOpenAttributeValueBefore;
      }
      effects.consume(code5);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuoted(code5) {
      if (code5 === marker) {
        effects.consume(code5);
        marker = void 0;
        return tagOpenAttributeValueQuotedAfter;
      }
      if (code5 === null) {
        return nok(code5);
      }
      if (markdownLineEnding(code5)) {
        returnState = tagOpenAttributeValueQuoted;
        return lineEndingBefore(code5);
      }
      effects.consume(code5);
      return tagOpenAttributeValueQuoted;
    }
    function tagOpenAttributeValueUnquoted(code5) {
      if (code5 === null || code5 === 34 || code5 === 39 || code5 === 60 || code5 === 61 || code5 === 96) {
        return nok(code5);
      }
      if (code5 === 47 || code5 === 62 || markdownLineEndingOrSpace(code5)) {
        return tagOpenBetween(code5);
      }
      effects.consume(code5);
      return tagOpenAttributeValueUnquoted;
    }
    function tagOpenAttributeValueQuotedAfter(code5) {
      if (code5 === 47 || code5 === 62 || markdownLineEndingOrSpace(code5)) {
        return tagOpenBetween(code5);
      }
      return nok(code5);
    }
    function end(code5) {
      if (code5 === 62) {
        effects.consume(code5);
        effects.exit("htmlTextData");
        effects.exit("htmlText");
        return ok3;
      }
      return nok(code5);
    }
    function lineEndingBefore(code5) {
      effects.exit("htmlTextData");
      effects.enter("lineEnding");
      effects.consume(code5);
      effects.exit("lineEnding");
      return lineEndingAfter;
    }
    function lineEndingAfter(code5) {
      return markdownSpace(code5) ? factorySpace(effects, lineEndingAfterPrefix, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code5) : lineEndingAfterPrefix(code5);
    }
    function lineEndingAfterPrefix(code5) {
      effects.enter("htmlTextData");
      return returnState(code5);
    }
  }
  var htmlText;
  var init_html_text = __esm({
    "node_modules/micromark-core-commonmark/lib/html-text.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      htmlText = {
        name: "htmlText",
        tokenize: tokenizeHtmlText
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/label-end.js
  function resolveAllLabelEnd(events) {
    let index3 = -1;
    const newEvents = [];
    while (++index3 < events.length) {
      const token = events[index3][1];
      newEvents.push(events[index3]);
      if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
        const offset = token.type === "labelImage" ? 4 : 2;
        token.type = "data";
        index3 += offset;
      }
    }
    if (events.length !== newEvents.length) {
      splice(events, 0, events.length, newEvents);
    }
    return events;
  }
  function resolveToLabelEnd(events, context) {
    let index3 = events.length;
    let offset = 0;
    let token;
    let open;
    let close2;
    let media2;
    while (index3--) {
      token = events[index3][1];
      if (open) {
        if (token.type === "link" || token.type === "labelLink" && token._inactive) {
          break;
        }
        if (events[index3][0] === "enter" && token.type === "labelLink") {
          token._inactive = true;
        }
      } else if (close2) {
        if (events[index3][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
          open = index3;
          if (token.type !== "labelLink") {
            offset = 2;
            break;
          }
        }
      } else if (token.type === "labelEnd") {
        close2 = index3;
      }
    }
    const group2 = {
      type: events[open][1].type === "labelLink" ? "link" : "image",
      start: {
        ...events[open][1].start
      },
      end: {
        ...events[events.length - 1][1].end
      }
    };
    const label = {
      type: "label",
      start: {
        ...events[open][1].start
      },
      end: {
        ...events[close2][1].end
      }
    };
    const text10 = {
      type: "labelText",
      start: {
        ...events[open + offset + 2][1].end
      },
      end: {
        ...events[close2 - 2][1].start
      }
    };
    media2 = [["enter", group2, context], ["enter", label, context]];
    media2 = push(media2, events.slice(open + 1, open + offset + 3));
    media2 = push(media2, [["enter", text10, context]]);
    media2 = push(media2, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close2 - 3), context));
    media2 = push(media2, [["exit", text10, context], events[close2 - 2], events[close2 - 1], ["exit", label, context]]);
    media2 = push(media2, events.slice(close2 + 1));
    media2 = push(media2, [["exit", group2, context]]);
    splice(events, open, events.length, media2);
    return events;
  }
  function tokenizeLabelEnd(effects, ok3, nok) {
    const self2 = this;
    let index3 = self2.events.length;
    let labelStart;
    let defined;
    while (index3--) {
      if ((self2.events[index3][1].type === "labelImage" || self2.events[index3][1].type === "labelLink") && !self2.events[index3][1]._balanced) {
        labelStart = self2.events[index3][1];
        break;
      }
    }
    return start;
    function start(code5) {
      if (!labelStart) {
        return nok(code5);
      }
      if (labelStart._inactive) {
        return labelEndNok(code5);
      }
      defined = self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      })));
      effects.enter("labelEnd");
      effects.enter("labelMarker");
      effects.consume(code5);
      effects.exit("labelMarker");
      effects.exit("labelEnd");
      return after;
    }
    function after(code5) {
      if (code5 === 40) {
        return effects.attempt(resourceConstruct, labelEndOk, defined ? labelEndOk : labelEndNok)(code5);
      }
      if (code5 === 91) {
        return effects.attempt(referenceFullConstruct, labelEndOk, defined ? referenceNotFull : labelEndNok)(code5);
      }
      return defined ? labelEndOk(code5) : labelEndNok(code5);
    }
    function referenceNotFull(code5) {
      return effects.attempt(referenceCollapsedConstruct, labelEndOk, labelEndNok)(code5);
    }
    function labelEndOk(code5) {
      return ok3(code5);
    }
    function labelEndNok(code5) {
      labelStart._balanced = true;
      return nok(code5);
    }
  }
  function tokenizeResource(effects, ok3, nok) {
    return resourceStart;
    function resourceStart(code5) {
      effects.enter("resource");
      effects.enter("resourceMarker");
      effects.consume(code5);
      effects.exit("resourceMarker");
      return resourceBefore;
    }
    function resourceBefore(code5) {
      return markdownLineEndingOrSpace(code5) ? factoryWhitespace(effects, resourceOpen)(code5) : resourceOpen(code5);
    }
    function resourceOpen(code5) {
      if (code5 === 41) {
        return resourceEnd(code5);
      }
      return factoryDestination(effects, resourceDestinationAfter, resourceDestinationMissing, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(code5);
    }
    function resourceDestinationAfter(code5) {
      return markdownLineEndingOrSpace(code5) ? factoryWhitespace(effects, resourceBetween)(code5) : resourceEnd(code5);
    }
    function resourceDestinationMissing(code5) {
      return nok(code5);
    }
    function resourceBetween(code5) {
      if (code5 === 34 || code5 === 39 || code5 === 40) {
        return factoryTitle(effects, resourceTitleAfter, nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code5);
      }
      return resourceEnd(code5);
    }
    function resourceTitleAfter(code5) {
      return markdownLineEndingOrSpace(code5) ? factoryWhitespace(effects, resourceEnd)(code5) : resourceEnd(code5);
    }
    function resourceEnd(code5) {
      if (code5 === 41) {
        effects.enter("resourceMarker");
        effects.consume(code5);
        effects.exit("resourceMarker");
        effects.exit("resource");
        return ok3;
      }
      return nok(code5);
    }
  }
  function tokenizeReferenceFull(effects, ok3, nok) {
    const self2 = this;
    return referenceFull;
    function referenceFull(code5) {
      return factoryLabel.call(self2, effects, referenceFullAfter, referenceFullMissing, "reference", "referenceMarker", "referenceString")(code5);
    }
    function referenceFullAfter(code5) {
      return self2.parser.defined.includes(normalizeIdentifier(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) ? ok3(code5) : nok(code5);
    }
    function referenceFullMissing(code5) {
      return nok(code5);
    }
  }
  function tokenizeReferenceCollapsed(effects, ok3, nok) {
    return referenceCollapsedStart;
    function referenceCollapsedStart(code5) {
      effects.enter("reference");
      effects.enter("referenceMarker");
      effects.consume(code5);
      effects.exit("referenceMarker");
      return referenceCollapsedOpen;
    }
    function referenceCollapsedOpen(code5) {
      if (code5 === 93) {
        effects.enter("referenceMarker");
        effects.consume(code5);
        effects.exit("referenceMarker");
        effects.exit("reference");
        return ok3;
      }
      return nok(code5);
    }
  }
  var labelEnd, resourceConstruct, referenceFullConstruct, referenceCollapsedConstruct;
  var init_label_end = __esm({
    "node_modules/micromark-core-commonmark/lib/label-end.js"() {
      init_micromark_factory_destination();
      init_micromark_factory_label();
      init_micromark_factory_title();
      init_micromark_factory_whitespace();
      init_micromark_util_character();
      init_micromark_util_chunked();
      init_micromark_util_normalize_identifier();
      init_micromark_util_resolve_all();
      labelEnd = {
        name: "labelEnd",
        resolveAll: resolveAllLabelEnd,
        resolveTo: resolveToLabelEnd,
        tokenize: tokenizeLabelEnd
      };
      resourceConstruct = {
        tokenize: tokenizeResource
      };
      referenceFullConstruct = {
        tokenize: tokenizeReferenceFull
      };
      referenceCollapsedConstruct = {
        tokenize: tokenizeReferenceCollapsed
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/label-start-image.js
  function tokenizeLabelStartImage(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code5) {
      effects.enter("labelImage");
      effects.enter("labelImageMarker");
      effects.consume(code5);
      effects.exit("labelImageMarker");
      return open;
    }
    function open(code5) {
      if (code5 === 91) {
        effects.enter("labelMarker");
        effects.consume(code5);
        effects.exit("labelMarker");
        effects.exit("labelImage");
        return after;
      }
      return nok(code5);
    }
    function after(code5) {
      return code5 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code5) : ok3(code5);
    }
  }
  var labelStartImage;
  var init_label_start_image = __esm({
    "node_modules/micromark-core-commonmark/lib/label-start-image.js"() {
      init_label_end();
      labelStartImage = {
        name: "labelStartImage",
        resolveAll: labelEnd.resolveAll,
        tokenize: tokenizeLabelStartImage
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/label-start-link.js
  function tokenizeLabelStartLink(effects, ok3, nok) {
    const self2 = this;
    return start;
    function start(code5) {
      effects.enter("labelLink");
      effects.enter("labelMarker");
      effects.consume(code5);
      effects.exit("labelMarker");
      effects.exit("labelLink");
      return after;
    }
    function after(code5) {
      return code5 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code5) : ok3(code5);
    }
  }
  var labelStartLink;
  var init_label_start_link = __esm({
    "node_modules/micromark-core-commonmark/lib/label-start-link.js"() {
      init_label_end();
      labelStartLink = {
        name: "labelStartLink",
        resolveAll: labelEnd.resolveAll,
        tokenize: tokenizeLabelStartLink
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/line-ending.js
  function tokenizeLineEnding(effects, ok3) {
    return start;
    function start(code5) {
      effects.enter("lineEnding");
      effects.consume(code5);
      effects.exit("lineEnding");
      return factorySpace(effects, ok3, "linePrefix");
    }
  }
  var lineEnding;
  var init_line_ending = __esm({
    "node_modules/micromark-core-commonmark/lib/line-ending.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      lineEnding = {
        name: "lineEnding",
        tokenize: tokenizeLineEnding
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/thematic-break.js
  function tokenizeThematicBreak(effects, ok3, nok) {
    let size2 = 0;
    let marker;
    return start;
    function start(code5) {
      effects.enter("thematicBreak");
      return before(code5);
    }
    function before(code5) {
      marker = code5;
      return atBreak(code5);
    }
    function atBreak(code5) {
      if (code5 === marker) {
        effects.enter("thematicBreakSequence");
        return sequence(code5);
      }
      if (size2 >= 3 && (code5 === null || markdownLineEnding(code5))) {
        effects.exit("thematicBreak");
        return ok3(code5);
      }
      return nok(code5);
    }
    function sequence(code5) {
      if (code5 === marker) {
        effects.consume(code5);
        size2++;
        return sequence;
      }
      effects.exit("thematicBreakSequence");
      return markdownSpace(code5) ? factorySpace(effects, atBreak, "whitespace")(code5) : atBreak(code5);
    }
  }
  var thematicBreak2;
  var init_thematic_break2 = __esm({
    "node_modules/micromark-core-commonmark/lib/thematic-break.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      thematicBreak2 = {
        name: "thematicBreak",
        tokenize: tokenizeThematicBreak
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/list.js
  function tokenizeListStart(effects, ok3, nok) {
    const self2 = this;
    const tail = self2.events[self2.events.length - 1];
    let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    let size2 = 0;
    return start;
    function start(code5) {
      const kind = self2.containerState.type || (code5 === 42 || code5 === 43 || code5 === 45 ? "listUnordered" : "listOrdered");
      if (kind === "listUnordered" ? !self2.containerState.marker || code5 === self2.containerState.marker : asciiDigit(code5)) {
        if (!self2.containerState.type) {
          self2.containerState.type = kind;
          effects.enter(kind, {
            _container: true
          });
        }
        if (kind === "listUnordered") {
          effects.enter("listItemPrefix");
          return code5 === 42 || code5 === 45 ? effects.check(thematicBreak2, nok, atMarker)(code5) : atMarker(code5);
        }
        if (!self2.interrupt || code5 === 49) {
          effects.enter("listItemPrefix");
          effects.enter("listItemValue");
          return inside(code5);
        }
      }
      return nok(code5);
    }
    function inside(code5) {
      if (asciiDigit(code5) && ++size2 < 10) {
        effects.consume(code5);
        return inside;
      }
      if ((!self2.interrupt || size2 < 2) && (self2.containerState.marker ? code5 === self2.containerState.marker : code5 === 41 || code5 === 46)) {
        effects.exit("listItemValue");
        return atMarker(code5);
      }
      return nok(code5);
    }
    function atMarker(code5) {
      effects.enter("listItemMarker");
      effects.consume(code5);
      effects.exit("listItemMarker");
      self2.containerState.marker = self2.containerState.marker || code5;
      return effects.check(
        blankLine,
        // Cant be empty when interrupting.
        self2.interrupt ? nok : onBlank,
        effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
      );
    }
    function onBlank(code5) {
      self2.containerState.initialBlankLine = true;
      initialSize++;
      return endOfPrefix(code5);
    }
    function otherPrefix(code5) {
      if (markdownSpace(code5)) {
        effects.enter("listItemPrefixWhitespace");
        effects.consume(code5);
        effects.exit("listItemPrefixWhitespace");
        return endOfPrefix;
      }
      return nok(code5);
    }
    function endOfPrefix(code5) {
      self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
      return ok3(code5);
    }
  }
  function tokenizeListContinuation(effects, ok3, nok) {
    const self2 = this;
    self2.containerState._closeFlow = void 0;
    return effects.check(blankLine, onBlank, notBlank);
    function onBlank(code5) {
      self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
      return factorySpace(effects, ok3, "listItemIndent", self2.containerState.size + 1)(code5);
    }
    function notBlank(code5) {
      if (self2.containerState.furtherBlankLines || !markdownSpace(code5)) {
        self2.containerState.furtherBlankLines = void 0;
        self2.containerState.initialBlankLine = void 0;
        return notInCurrentItem(code5);
      }
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code5);
    }
    function notInCurrentItem(code5) {
      self2.containerState._closeFlow = true;
      self2.interrupt = void 0;
      return factorySpace(effects, effects.attempt(list5, ok3, nok), "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code5);
    }
  }
  function tokenizeIndent(effects, ok3, nok) {
    const self2 = this;
    return factorySpace(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
    function afterPrefix(code5) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code5) : nok(code5);
    }
  }
  function tokenizeListEnd(effects) {
    effects.exit(this.containerState.type);
  }
  function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
    const self2 = this;
    return factorySpace(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1);
    function afterPrefix(code5) {
      const tail = self2.events[self2.events.length - 1];
      return !markdownSpace(code5) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok3(code5) : nok(code5);
    }
  }
  var list5, listItemPrefixWhitespaceConstruct, indentConstruct;
  var init_list3 = __esm({
    "node_modules/micromark-core-commonmark/lib/list.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      init_blank_line();
      init_thematic_break2();
      list5 = {
        continuation: {
          tokenize: tokenizeListContinuation
        },
        exit: tokenizeListEnd,
        name: "list",
        tokenize: tokenizeListStart
      };
      listItemPrefixWhitespaceConstruct = {
        partial: true,
        tokenize: tokenizeListItemPrefixWhitespace
      };
      indentConstruct = {
        partial: true,
        tokenize: tokenizeIndent
      };
    }
  });

  // node_modules/micromark-core-commonmark/lib/setext-underline.js
  function resolveToSetextUnderline(events, context) {
    let index3 = events.length;
    let content5;
    let text10;
    let definition3;
    while (index3--) {
      if (events[index3][0] === "enter") {
        if (events[index3][1].type === "content") {
          content5 = index3;
          break;
        }
        if (events[index3][1].type === "paragraph") {
          text10 = index3;
        }
      } else {
        if (events[index3][1].type === "content") {
          events.splice(index3, 1);
        }
        if (!definition3 && events[index3][1].type === "definition") {
          definition3 = index3;
        }
      }
    }
    const heading4 = {
      type: "setextHeading",
      start: {
        ...events[content5][1].start
      },
      end: {
        ...events[events.length - 1][1].end
      }
    };
    events[text10][1].type = "setextHeadingText";
    if (definition3) {
      events.splice(text10, 0, ["enter", heading4, context]);
      events.splice(definition3 + 1, 0, ["exit", events[content5][1], context]);
      events[content5][1].end = {
        ...events[definition3][1].end
      };
    } else {
      events[content5][1] = heading4;
    }
    events.push(["exit", heading4, context]);
    return events;
  }
  function tokenizeSetextUnderline(effects, ok3, nok) {
    const self2 = this;
    let marker;
    return start;
    function start(code5) {
      let index3 = self2.events.length;
      let paragraph3;
      while (index3--) {
        if (self2.events[index3][1].type !== "lineEnding" && self2.events[index3][1].type !== "linePrefix" && self2.events[index3][1].type !== "content") {
          paragraph3 = self2.events[index3][1].type === "paragraph";
          break;
        }
      }
      if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph3)) {
        effects.enter("setextHeadingLine");
        marker = code5;
        return before(code5);
      }
      return nok(code5);
    }
    function before(code5) {
      effects.enter("setextHeadingLineSequence");
      return inside(code5);
    }
    function inside(code5) {
      if (code5 === marker) {
        effects.consume(code5);
        return inside;
      }
      effects.exit("setextHeadingLineSequence");
      return markdownSpace(code5) ? factorySpace(effects, after, "lineSuffix")(code5) : after(code5);
    }
    function after(code5) {
      if (code5 === null || markdownLineEnding(code5)) {
        effects.exit("setextHeadingLine");
        return ok3(code5);
      }
      return nok(code5);
    }
  }
  var setextUnderline;
  var init_setext_underline = __esm({
    "node_modules/micromark-core-commonmark/lib/setext-underline.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      setextUnderline = {
        name: "setextUnderline",
        resolveTo: resolveToSetextUnderline,
        tokenize: tokenizeSetextUnderline
      };
    }
  });

  // node_modules/micromark-core-commonmark/index.js
  var init_micromark_core_commonmark = __esm({
    "node_modules/micromark-core-commonmark/index.js"() {
      init_attention();
      init_autolink();
      init_blank_line();
      init_block_quote();
      init_character_escape();
      init_character_reference();
      init_code_fenced();
      init_code_indented();
      init_code_text();
      init_content2();
      init_definition2();
      init_hard_break_escape();
      init_heading_atx();
      init_html_flow();
      init_html_text();
      init_label_end();
      init_label_start_image();
      init_label_start_link();
      init_line_ending();
      init_list3();
      init_setext_underline();
      init_thematic_break2();
    }
  });

  // node_modules/micromark-extension-gfm-footnote/lib/syntax.js
  function gfmFootnote() {
    return {
      document: {
        [91]: {
          name: "gfmFootnoteDefinition",
          tokenize: tokenizeDefinitionStart,
          continuation: {
            tokenize: tokenizeDefinitionContinuation
          },
          exit: gfmFootnoteDefinitionEnd
        }
      },
      text: {
        [91]: {
          name: "gfmFootnoteCall",
          tokenize: tokenizeGfmFootnoteCall
        },
        [93]: {
          name: "gfmPotentialFootnoteCall",
          add: "after",
          tokenize: tokenizePotentialGfmFootnoteCall,
          resolveTo: resolveToPotentialGfmFootnoteCall
        }
      }
    };
  }
  function tokenizePotentialGfmFootnoteCall(effects, ok3, nok) {
    const self2 = this;
    let index3 = self2.events.length;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let labelStart;
    while (index3--) {
      const token = self2.events[index3][1];
      if (token.type === "labelImage") {
        labelStart = token;
        break;
      }
      if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
        break;
      }
    }
    return start;
    function start(code5) {
      if (!labelStart || !labelStart._balanced) {
        return nok(code5);
      }
      const id2 = normalizeIdentifier(self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      }));
      if (id2.codePointAt(0) !== 94 || !defined.includes(id2.slice(1))) {
        return nok(code5);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code5);
      effects.exit("gfmFootnoteCallLabelMarker");
      return ok3(code5);
    }
  }
  function resolveToPotentialGfmFootnoteCall(events, context) {
    let index3 = events.length;
    let labelStart;
    while (index3--) {
      if (events[index3][1].type === "labelImage" && events[index3][0] === "enter") {
        labelStart = events[index3][1];
        break;
      }
    }
    events[index3 + 1][1].type = "data";
    events[index3 + 3][1].type = "gfmFootnoteCallLabelMarker";
    const call = {
      type: "gfmFootnoteCall",
      start: Object.assign({}, events[index3 + 3][1].start),
      end: Object.assign({}, events[events.length - 1][1].end)
    };
    const marker = {
      type: "gfmFootnoteCallMarker",
      start: Object.assign({}, events[index3 + 3][1].end),
      end: Object.assign({}, events[index3 + 3][1].end)
    };
    marker.end.column++;
    marker.end.offset++;
    marker.end._bufferIndex++;
    const string3 = {
      type: "gfmFootnoteCallString",
      start: Object.assign({}, marker.end),
      end: Object.assign({}, events[events.length - 1][1].start)
    };
    const chunk = {
      type: "chunkString",
      contentType: "string",
      start: Object.assign({}, string3.start),
      end: Object.assign({}, string3.end)
    };
    const replacement = [
      // Take the `labelImageMarker` (now `data`, the `!`)
      events[index3 + 1],
      events[index3 + 2],
      ["enter", call, context],
      // The `[`
      events[index3 + 3],
      events[index3 + 4],
      // The `^`.
      ["enter", marker, context],
      ["exit", marker, context],
      // Everything in between.
      ["enter", string3, context],
      ["enter", chunk, context],
      ["exit", chunk, context],
      ["exit", string3, context],
      // The ending (`]`, properly parsed and labelled).
      events[events.length - 2],
      events[events.length - 1],
      ["exit", call, context]
    ];
    events.splice(index3, events.length - index3 + 1, ...replacement);
    return events;
  }
  function tokenizeGfmFootnoteCall(effects, ok3, nok) {
    const self2 = this;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let size2 = 0;
    let data;
    return start;
    function start(code5) {
      effects.enter("gfmFootnoteCall");
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code5);
      effects.exit("gfmFootnoteCallLabelMarker");
      return callStart;
    }
    function callStart(code5) {
      if (code5 !== 94) return nok(code5);
      effects.enter("gfmFootnoteCallMarker");
      effects.consume(code5);
      effects.exit("gfmFootnoteCallMarker");
      effects.enter("gfmFootnoteCallString");
      effects.enter("chunkString").contentType = "string";
      return callData;
    }
    function callData(code5) {
      if (
        // Too long.
        size2 > 999 || // Closing brace with nothing.
        code5 === 93 && !data || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code5 === null || code5 === 91 || markdownLineEndingOrSpace(code5)
      ) {
        return nok(code5);
      }
      if (code5 === 93) {
        effects.exit("chunkString");
        const token = effects.exit("gfmFootnoteCallString");
        if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
          return nok(code5);
        }
        effects.enter("gfmFootnoteCallLabelMarker");
        effects.consume(code5);
        effects.exit("gfmFootnoteCallLabelMarker");
        effects.exit("gfmFootnoteCall");
        return ok3;
      }
      if (!markdownLineEndingOrSpace(code5)) {
        data = true;
      }
      size2++;
      effects.consume(code5);
      return code5 === 92 ? callEscape : callData;
    }
    function callEscape(code5) {
      if (code5 === 91 || code5 === 92 || code5 === 93) {
        effects.consume(code5);
        size2++;
        return callData;
      }
      return callData(code5);
    }
  }
  function tokenizeDefinitionStart(effects, ok3, nok) {
    const self2 = this;
    const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
    let identifier;
    let size2 = 0;
    let data;
    return start;
    function start(code5) {
      effects.enter("gfmFootnoteDefinition")._container = true;
      effects.enter("gfmFootnoteDefinitionLabel");
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code5);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      return labelAtMarker;
    }
    function labelAtMarker(code5) {
      if (code5 === 94) {
        effects.enter("gfmFootnoteDefinitionMarker");
        effects.consume(code5);
        effects.exit("gfmFootnoteDefinitionMarker");
        effects.enter("gfmFootnoteDefinitionLabelString");
        effects.enter("chunkString").contentType = "string";
        return labelInside;
      }
      return nok(code5);
    }
    function labelInside(code5) {
      if (
        // Too long.
        size2 > 999 || // Closing brace with nothing.
        code5 === 93 && !data || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        code5 === null || code5 === 91 || markdownLineEndingOrSpace(code5)
      ) {
        return nok(code5);
      }
      if (code5 === 93) {
        effects.exit("chunkString");
        const token = effects.exit("gfmFootnoteDefinitionLabelString");
        identifier = normalizeIdentifier(self2.sliceSerialize(token));
        effects.enter("gfmFootnoteDefinitionLabelMarker");
        effects.consume(code5);
        effects.exit("gfmFootnoteDefinitionLabelMarker");
        effects.exit("gfmFootnoteDefinitionLabel");
        return labelAfter;
      }
      if (!markdownLineEndingOrSpace(code5)) {
        data = true;
      }
      size2++;
      effects.consume(code5);
      return code5 === 92 ? labelEscape : labelInside;
    }
    function labelEscape(code5) {
      if (code5 === 91 || code5 === 92 || code5 === 93) {
        effects.consume(code5);
        size2++;
        return labelInside;
      }
      return labelInside(code5);
    }
    function labelAfter(code5) {
      if (code5 === 58) {
        effects.enter("definitionMarker");
        effects.consume(code5);
        effects.exit("definitionMarker");
        if (!defined.includes(identifier)) {
          defined.push(identifier);
        }
        return factorySpace(effects, whitespaceAfter, "gfmFootnoteDefinitionWhitespace");
      }
      return nok(code5);
    }
    function whitespaceAfter(code5) {
      return ok3(code5);
    }
  }
  function tokenizeDefinitionContinuation(effects, ok3, nok) {
    return effects.check(blankLine, ok3, effects.attempt(indent, ok3, nok));
  }
  function gfmFootnoteDefinitionEnd(effects) {
    effects.exit("gfmFootnoteDefinition");
  }
  function tokenizeIndent2(effects, ok3, nok) {
    const self2 = this;
    return factorySpace(effects, afterPrefix, "gfmFootnoteDefinitionIndent", 4 + 1);
    function afterPrefix(code5) {
      const tail = self2.events[self2.events.length - 1];
      return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok3(code5) : nok(code5);
    }
  }
  var indent;
  var init_syntax2 = __esm({
    "node_modules/micromark-extension-gfm-footnote/lib/syntax.js"() {
      init_micromark_core_commonmark();
      init_micromark_factory_space();
      init_micromark_util_character();
      init_micromark_util_normalize_identifier();
      indent = {
        tokenize: tokenizeIndent2,
        partial: true
      };
    }
  });

  // node_modules/micromark-extension-gfm-footnote/lib/html.js
  function defaultBackLabel(referenceIndex, rereferenceIndex) {
    return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
  }
  function gfmFootnoteHtml(options2) {
    const config = options2 || emptyOptions6;
    const label = config.label || "Footnotes";
    const labelTagName = config.labelTagName || "h2";
    const labelAttributes = config.labelAttributes === null || config.labelAttributes === void 0 ? 'class="sr-only"' : config.labelAttributes;
    const backLabel = config.backLabel || defaultBackLabel;
    const clobberPrefix = config.clobberPrefix === null || config.clobberPrefix === void 0 ? "user-content-" : config.clobberPrefix;
    return {
      enter: {
        gfmFootnoteDefinition() {
          const stack = this.getData("tightStack");
          stack.push(false);
        },
        gfmFootnoteDefinitionLabelString() {
          this.buffer();
        },
        gfmFootnoteCallString() {
          this.buffer();
        }
      },
      exit: {
        gfmFootnoteDefinition() {
          let definitions = this.getData("gfmFootnoteDefinitions");
          const footnoteStack = this.getData("gfmFootnoteDefinitionStack");
          const tightStack = this.getData("tightStack");
          const current = footnoteStack.pop();
          const value = this.resume();
          if (!definitions) {
            this.setData("gfmFootnoteDefinitions", definitions = {});
          }
          if (!own9.call(definitions, current)) definitions[current] = value;
          tightStack.pop();
          this.setData("slurpOneLineEnding", true);
          this.setData("lastWasTag");
        },
        gfmFootnoteDefinitionLabelString(token) {
          let footnoteStack = this.getData("gfmFootnoteDefinitionStack");
          if (!footnoteStack) {
            this.setData("gfmFootnoteDefinitionStack", footnoteStack = []);
          }
          footnoteStack.push(normalizeIdentifier(this.sliceSerialize(token)));
          this.resume();
          this.buffer();
        },
        gfmFootnoteCallString(token) {
          let calls = this.getData("gfmFootnoteCallOrder");
          let counts = this.getData("gfmFootnoteCallCounts");
          const id2 = normalizeIdentifier(this.sliceSerialize(token));
          let counter;
          this.resume();
          if (!calls) this.setData("gfmFootnoteCallOrder", calls = []);
          if (!counts) this.setData("gfmFootnoteCallCounts", counts = {});
          const index3 = calls.indexOf(id2);
          const safeId = sanitizeUri(id2.toLowerCase());
          if (index3 === -1) {
            calls.push(id2);
            counts[id2] = 1;
            counter = calls.length;
          } else {
            counts[id2]++;
            counter = index3 + 1;
          }
          const reuseCounter = counts[id2];
          this.tag('<sup><a href="#' + clobberPrefix + "fn-" + safeId + '" id="' + clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : "") + '" data-footnote-ref="" aria-describedby="footnote-label">' + String(counter) + "</a></sup>");
        },
        null() {
          const calls = this.getData("gfmFootnoteCallOrder") || [];
          const counts = this.getData("gfmFootnoteCallCounts") || {};
          const definitions = this.getData("gfmFootnoteDefinitions") || {};
          let index3 = -1;
          if (calls.length > 0) {
            this.lineEndingIfNeeded();
            this.tag('<section data-footnotes="" class="footnotes"><' + labelTagName + ' id="footnote-label"' + (labelAttributes ? " " + labelAttributes : "") + ">");
            this.raw(this.encode(label));
            this.tag("</" + labelTagName + ">");
            this.lineEndingIfNeeded();
            this.tag("<ol>");
          }
          while (++index3 < calls.length) {
            const id2 = calls[index3];
            const safeId = sanitizeUri(id2.toLowerCase());
            let referenceIndex = 0;
            const references = [];
            while (++referenceIndex <= counts[id2]) {
              references.push('<a href="#' + clobberPrefix + "fnref-" + safeId + (referenceIndex > 1 ? "-" + referenceIndex : "") + '" data-footnote-backref="" aria-label="' + this.encode(typeof backLabel === "string" ? backLabel : backLabel(index3, referenceIndex)) + '" class="data-footnote-backref">\u21A9' + (referenceIndex > 1 ? "<sup>" + referenceIndex + "</sup>" : "") + "</a>");
            }
            const reference = references.join(" ");
            let injected = false;
            this.lineEndingIfNeeded();
            this.tag('<li id="' + clobberPrefix + "fn-" + safeId + '">');
            this.lineEndingIfNeeded();
            this.tag(definitions[id2].replace(/<\/p>(?:\r?\n|\r)?$/, function($0) {
              injected = true;
              return " " + reference + $0;
            }));
            if (!injected) {
              this.lineEndingIfNeeded();
              this.tag(reference);
            }
            this.lineEndingIfNeeded();
            this.tag("</li>");
          }
          if (calls.length > 0) {
            this.lineEndingIfNeeded();
            this.tag("</ol>");
            this.lineEndingIfNeeded();
            this.tag("</section>");
          }
        }
      }
    };
  }
  var own9, emptyOptions6;
  var init_html5 = __esm({
    "node_modules/micromark-extension-gfm-footnote/lib/html.js"() {
      init_micromark_util_normalize_identifier();
      init_micromark_util_sanitize_uri();
      own9 = {}.hasOwnProperty;
      emptyOptions6 = {};
    }
  });

  // node_modules/micromark-extension-gfm-footnote/index.js
  var init_micromark_extension_gfm_footnote = __esm({
    "node_modules/micromark-extension-gfm-footnote/index.js"() {
      init_syntax2();
      init_html5();
    }
  });

  // node_modules/micromark-extension-gfm-strikethrough/lib/html.js
  function gfmStrikethroughHtml() {
    return {
      enter: {
        strikethrough() {
          this.tag("<del>");
        }
      },
      exit: {
        strikethrough() {
          this.tag("</del>");
        }
      }
    };
  }
  var init_html6 = __esm({
    "node_modules/micromark-extension-gfm-strikethrough/lib/html.js"() {
    }
  });

  // node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
  function gfmStrikethrough(options2) {
    const options_ = options2 || {};
    let single = options_.singleTilde;
    const tokenizer = {
      name: "strikethrough",
      tokenize: tokenizeStrikethrough,
      resolveAll: resolveAllStrikethrough
    };
    if (single === null || single === void 0) {
      single = true;
    }
    return {
      text: {
        [126]: tokenizer
      },
      insideSpan: {
        null: [tokenizer]
      },
      attentionMarkers: {
        null: [126]
      }
    };
    function resolveAllStrikethrough(events, context) {
      let index3 = -1;
      while (++index3 < events.length) {
        if (events[index3][0] === "enter" && events[index3][1].type === "strikethroughSequenceTemporary" && events[index3][1]._close) {
          let open = index3;
          while (open--) {
            if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
            events[index3][1].end.offset - events[index3][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
              events[index3][1].type = "strikethroughSequence";
              events[open][1].type = "strikethroughSequence";
              const strikethrough2 = {
                type: "strikethrough",
                start: Object.assign({}, events[open][1].start),
                end: Object.assign({}, events[index3][1].end)
              };
              const text10 = {
                type: "strikethroughText",
                start: Object.assign({}, events[open][1].end),
                end: Object.assign({}, events[index3][1].start)
              };
              const nextEvents = [["enter", strikethrough2, context], ["enter", events[open][1], context], ["exit", events[open][1], context], ["enter", text10, context]];
              const insideSpan2 = context.parser.constructs.insideSpan.null;
              if (insideSpan2) {
                splice(nextEvents, nextEvents.length, 0, resolveAll(insideSpan2, events.slice(open + 1, index3), context));
              }
              splice(nextEvents, nextEvents.length, 0, [["exit", text10, context], ["enter", events[index3][1], context], ["exit", events[index3][1], context], ["exit", strikethrough2, context]]);
              splice(events, open - 1, index3 - open + 3, nextEvents);
              index3 = open + nextEvents.length - 2;
              break;
            }
          }
        }
      }
      index3 = -1;
      while (++index3 < events.length) {
        if (events[index3][1].type === "strikethroughSequenceTemporary") {
          events[index3][1].type = "data";
        }
      }
      return events;
    }
    function tokenizeStrikethrough(effects, ok3, nok) {
      const previous3 = this.previous;
      const events = this.events;
      let size2 = 0;
      return start;
      function start(code5) {
        if (previous3 === 126 && events[events.length - 1][1].type !== "characterEscape") {
          return nok(code5);
        }
        effects.enter("strikethroughSequenceTemporary");
        return more(code5);
      }
      function more(code5) {
        const before = classifyCharacter(previous3);
        if (code5 === 126) {
          if (size2 > 1) return nok(code5);
          effects.consume(code5);
          size2++;
          return more;
        }
        if (size2 < 2 && !single) return nok(code5);
        const token = effects.exit("strikethroughSequenceTemporary");
        const after = classifyCharacter(code5);
        token._open = !after || after === 2 && Boolean(before);
        token._close = !before || before === 2 && Boolean(after);
        return ok3(code5);
      }
    }
  }
  var init_syntax3 = __esm({
    "node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js"() {
      init_micromark_util_chunked();
      init_micromark_util_classify_character();
      init_micromark_util_resolve_all();
    }
  });

  // node_modules/micromark-extension-gfm-strikethrough/index.js
  var init_micromark_extension_gfm_strikethrough = __esm({
    "node_modules/micromark-extension-gfm-strikethrough/index.js"() {
      init_html6();
      init_syntax3();
    }
  });

  // node_modules/micromark-extension-gfm-table/lib/html.js
  function gfmTableHtml() {
    return {
      enter: {
        table(token) {
          const tableAlign = token._align;
          this.lineEndingIfNeeded();
          this.tag("<table>");
          this.setData("tableAlign", tableAlign);
        },
        tableBody() {
          this.tag("<tbody>");
        },
        tableData() {
          const tableAlign = this.getData("tableAlign");
          const tableColumn = this.getData("tableColumn");
          const align = alignment[tableAlign[tableColumn]];
          if (align === void 0) {
            this.buffer();
          } else {
            this.lineEndingIfNeeded();
            this.tag("<td" + align + ">");
          }
        },
        tableHead() {
          this.lineEndingIfNeeded();
          this.tag("<thead>");
        },
        tableHeader() {
          const tableAlign = this.getData("tableAlign");
          const tableColumn = this.getData("tableColumn");
          const align = alignment[tableAlign[tableColumn]];
          this.lineEndingIfNeeded();
          this.tag("<th" + align + ">");
        },
        tableRow() {
          this.setData("tableColumn", 0);
          this.lineEndingIfNeeded();
          this.tag("<tr>");
        }
      },
      exit: {
        // Overwrite the default code text data handler to unescape escaped pipes when
        // they are in tables.
        codeTextData(token) {
          let value = this.sliceSerialize(token);
          if (this.getData("tableAlign")) {
            value = value.replace(/\\([\\|])/g, replace2);
          }
          this.raw(this.encode(value));
        },
        table() {
          this.setData("tableAlign");
          this.setData("slurpAllLineEndings");
          this.lineEndingIfNeeded();
          this.tag("</table>");
        },
        tableBody() {
          this.lineEndingIfNeeded();
          this.tag("</tbody>");
        },
        tableData() {
          const tableAlign = this.getData("tableAlign");
          const tableColumn = this.getData("tableColumn");
          if (tableColumn in tableAlign) {
            this.tag("</td>");
            this.setData("tableColumn", tableColumn + 1);
          } else {
            this.resume();
          }
        },
        tableHead() {
          this.lineEndingIfNeeded();
          this.tag("</thead>");
        },
        tableHeader() {
          const tableColumn = this.getData("tableColumn");
          this.tag("</th>");
          this.setData("tableColumn", tableColumn + 1);
        },
        tableRow() {
          const tableAlign = this.getData("tableAlign");
          let tableColumn = this.getData("tableColumn");
          while (tableColumn < tableAlign.length) {
            this.lineEndingIfNeeded();
            this.tag("<td" + alignment[tableAlign[tableColumn]] + "></td>");
            tableColumn++;
          }
          this.setData("tableColumn", tableColumn);
          this.lineEndingIfNeeded();
          this.tag("</tr>");
        }
      }
    };
  }
  function replace2($0, $1) {
    return $1 === "|" ? $1 : $0;
  }
  var alignment;
  var init_html7 = __esm({
    "node_modules/micromark-extension-gfm-table/lib/html.js"() {
      alignment = {
        none: "",
        left: ' align="left"',
        right: ' align="right"',
        center: ' align="center"'
      };
    }
  });

  // node_modules/micromark-extension-gfm-table/lib/edit-map.js
  function addImplementation(editMap, at2, remove2, add3) {
    let index3 = 0;
    if (remove2 === 0 && add3.length === 0) {
      return;
    }
    while (index3 < editMap.map.length) {
      if (editMap.map[index3][0] === at2) {
        editMap.map[index3][1] += remove2;
        editMap.map[index3][2].push(...add3);
        return;
      }
      index3 += 1;
    }
    editMap.map.push([at2, remove2, add3]);
  }
  var EditMap;
  var init_edit_map = __esm({
    "node_modules/micromark-extension-gfm-table/lib/edit-map.js"() {
      EditMap = class {
        /**
         * Create a new edit map.
         */
        constructor() {
          this.map = [];
        }
        /**
         * Create an edit: a remove and/or add at a certain place.
         *
         * @param {number} index
         * @param {number} remove
         * @param {Array<Event>} add
         * @returns {undefined}
         */
        add(index3, remove2, add3) {
          addImplementation(this, index3, remove2, add3);
        }
        // To do: add this when moving to `micromark`.
        // /**
        //  * Create an edit: but insert `add` before existing additions.
        //  *
        //  * @param {number} index
        //  * @param {number} remove
        //  * @param {Array<Event>} add
        //  * @returns {undefined}
        //  */
        // addBefore(index, remove, add) {
        //   addImplementation(this, index, remove, add, true)
        // }
        /**
         * Done, change the events.
         *
         * @param {Array<Event>} events
         * @returns {undefined}
         */
        consume(events) {
          this.map.sort(function(a2, b) {
            return a2[0] - b[0];
          });
          if (this.map.length === 0) {
            return;
          }
          let index3 = this.map.length;
          const vecs = [];
          while (index3 > 0) {
            index3 -= 1;
            vecs.push(events.slice(this.map[index3][0] + this.map[index3][1]), this.map[index3][2]);
            events.length = this.map[index3][0];
          }
          vecs.push(events.slice());
          events.length = 0;
          let slice2 = vecs.pop();
          while (slice2) {
            for (const element7 of slice2) {
              events.push(element7);
            }
            slice2 = vecs.pop();
          }
          this.map.length = 0;
        }
      };
    }
  });

  // node_modules/micromark-extension-gfm-table/lib/infer.js
  function gfmTableAlign(events, index3) {
    let inDelimiterRow = false;
    const align = [];
    while (index3 < events.length) {
      const event = events[index3];
      if (inDelimiterRow) {
        if (event[0] === "enter") {
          if (event[1].type === "tableContent") {
            align.push(events[index3 + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
          }
        } else if (event[1].type === "tableContent") {
          if (events[index3 - 1][1].type === "tableDelimiterMarker") {
            const alignIndex = align.length - 1;
            align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
          }
        } else if (event[1].type === "tableDelimiterRow") {
          break;
        }
      } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
        inDelimiterRow = true;
      }
      index3 += 1;
    }
    return align;
  }
  var init_infer = __esm({
    "node_modules/micromark-extension-gfm-table/lib/infer.js"() {
    }
  });

  // node_modules/micromark-extension-gfm-table/lib/syntax.js
  function gfmTable() {
    return {
      flow: {
        null: {
          name: "table",
          tokenize: tokenizeTable,
          resolveAll: resolveTable
        }
      }
    };
  }
  function tokenizeTable(effects, ok3, nok) {
    const self2 = this;
    let size2 = 0;
    let sizeB = 0;
    let seen;
    return start;
    function start(code5) {
      let index3 = self2.events.length - 1;
      while (index3 > -1) {
        const type = self2.events[index3][1].type;
        if (type === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
        type === "linePrefix") index3--;
        else break;
      }
      const tail = index3 > -1 ? self2.events[index3][1].type : null;
      const next2 = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
      if (next2 === bodyRowStart && self2.parser.lazy[self2.now().line]) {
        return nok(code5);
      }
      return next2(code5);
    }
    function headRowBefore(code5) {
      effects.enter("tableHead");
      effects.enter("tableRow");
      return headRowStart(code5);
    }
    function headRowStart(code5) {
      if (code5 === 124) {
        return headRowBreak(code5);
      }
      seen = true;
      sizeB += 1;
      return headRowBreak(code5);
    }
    function headRowBreak(code5) {
      if (code5 === null) {
        return nok(code5);
      }
      if (markdownLineEnding(code5)) {
        if (sizeB > 1) {
          sizeB = 0;
          self2.interrupt = true;
          effects.exit("tableRow");
          effects.enter("lineEnding");
          effects.consume(code5);
          effects.exit("lineEnding");
          return headDelimiterStart;
        }
        return nok(code5);
      }
      if (markdownSpace(code5)) {
        return factorySpace(effects, headRowBreak, "whitespace")(code5);
      }
      sizeB += 1;
      if (seen) {
        seen = false;
        size2 += 1;
      }
      if (code5 === 124) {
        effects.enter("tableCellDivider");
        effects.consume(code5);
        effects.exit("tableCellDivider");
        seen = true;
        return headRowBreak;
      }
      effects.enter("data");
      return headRowData(code5);
    }
    function headRowData(code5) {
      if (code5 === null || code5 === 124 || markdownLineEndingOrSpace(code5)) {
        effects.exit("data");
        return headRowBreak(code5);
      }
      effects.consume(code5);
      return code5 === 92 ? headRowEscape : headRowData;
    }
    function headRowEscape(code5) {
      if (code5 === 92 || code5 === 124) {
        effects.consume(code5);
        return headRowData;
      }
      return headRowData(code5);
    }
    function headDelimiterStart(code5) {
      self2.interrupt = false;
      if (self2.parser.lazy[self2.now().line]) {
        return nok(code5);
      }
      effects.enter("tableDelimiterRow");
      seen = false;
      if (markdownSpace(code5)) {
        return factorySpace(effects, headDelimiterBefore, "linePrefix", self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(code5);
      }
      return headDelimiterBefore(code5);
    }
    function headDelimiterBefore(code5) {
      if (code5 === 45 || code5 === 58) {
        return headDelimiterValueBefore(code5);
      }
      if (code5 === 124) {
        seen = true;
        effects.enter("tableCellDivider");
        effects.consume(code5);
        effects.exit("tableCellDivider");
        return headDelimiterCellBefore;
      }
      return headDelimiterNok(code5);
    }
    function headDelimiterCellBefore(code5) {
      if (markdownSpace(code5)) {
        return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code5);
      }
      return headDelimiterValueBefore(code5);
    }
    function headDelimiterValueBefore(code5) {
      if (code5 === 58) {
        sizeB += 1;
        seen = true;
        effects.enter("tableDelimiterMarker");
        effects.consume(code5);
        effects.exit("tableDelimiterMarker");
        return headDelimiterLeftAlignmentAfter;
      }
      if (code5 === 45) {
        sizeB += 1;
        return headDelimiterLeftAlignmentAfter(code5);
      }
      if (code5 === null || markdownLineEnding(code5)) {
        return headDelimiterCellAfter(code5);
      }
      return headDelimiterNok(code5);
    }
    function headDelimiterLeftAlignmentAfter(code5) {
      if (code5 === 45) {
        effects.enter("tableDelimiterFiller");
        return headDelimiterFiller(code5);
      }
      return headDelimiterNok(code5);
    }
    function headDelimiterFiller(code5) {
      if (code5 === 45) {
        effects.consume(code5);
        return headDelimiterFiller;
      }
      if (code5 === 58) {
        seen = true;
        effects.exit("tableDelimiterFiller");
        effects.enter("tableDelimiterMarker");
        effects.consume(code5);
        effects.exit("tableDelimiterMarker");
        return headDelimiterRightAlignmentAfter;
      }
      effects.exit("tableDelimiterFiller");
      return headDelimiterRightAlignmentAfter(code5);
    }
    function headDelimiterRightAlignmentAfter(code5) {
      if (markdownSpace(code5)) {
        return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code5);
      }
      return headDelimiterCellAfter(code5);
    }
    function headDelimiterCellAfter(code5) {
      if (code5 === 124) {
        return headDelimiterBefore(code5);
      }
      if (code5 === null || markdownLineEnding(code5)) {
        if (!seen || size2 !== sizeB) {
          return headDelimiterNok(code5);
        }
        effects.exit("tableDelimiterRow");
        effects.exit("tableHead");
        return ok3(code5);
      }
      return headDelimiterNok(code5);
    }
    function headDelimiterNok(code5) {
      return nok(code5);
    }
    function bodyRowStart(code5) {
      effects.enter("tableRow");
      return bodyRowBreak(code5);
    }
    function bodyRowBreak(code5) {
      if (code5 === 124) {
        effects.enter("tableCellDivider");
        effects.consume(code5);
        effects.exit("tableCellDivider");
        return bodyRowBreak;
      }
      if (code5 === null || markdownLineEnding(code5)) {
        effects.exit("tableRow");
        return ok3(code5);
      }
      if (markdownSpace(code5)) {
        return factorySpace(effects, bodyRowBreak, "whitespace")(code5);
      }
      effects.enter("data");
      return bodyRowData(code5);
    }
    function bodyRowData(code5) {
      if (code5 === null || code5 === 124 || markdownLineEndingOrSpace(code5)) {
        effects.exit("data");
        return bodyRowBreak(code5);
      }
      effects.consume(code5);
      return code5 === 92 ? bodyRowEscape : bodyRowData;
    }
    function bodyRowEscape(code5) {
      if (code5 === 92 || code5 === 124) {
        effects.consume(code5);
        return bodyRowData;
      }
      return bodyRowData(code5);
    }
  }
  function resolveTable(events, context) {
    let index3 = -1;
    let inFirstCellAwaitingPipe = true;
    let rowKind = 0;
    let lastCell = [0, 0, 0, 0];
    let cell2 = [0, 0, 0, 0];
    let afterHeadAwaitingFirstBodyRow = false;
    let lastTableEnd = 0;
    let currentTable;
    let currentBody;
    let currentCell;
    const map9 = new EditMap();
    while (++index3 < events.length) {
      const event = events[index3];
      const token = event[1];
      if (event[0] === "enter") {
        if (token.type === "tableHead") {
          afterHeadAwaitingFirstBodyRow = false;
          if (lastTableEnd !== 0) {
            flushTableEnd(map9, context, lastTableEnd, currentTable, currentBody);
            currentBody = void 0;
            lastTableEnd = 0;
          }
          currentTable = {
            type: "table",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map9.add(index3, 0, [["enter", currentTable, context]]);
        } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
          inFirstCellAwaitingPipe = true;
          currentCell = void 0;
          lastCell = [0, 0, 0, 0];
          cell2 = [0, index3 + 1, 0, 0];
          if (afterHeadAwaitingFirstBodyRow) {
            afterHeadAwaitingFirstBodyRow = false;
            currentBody = {
              type: "tableBody",
              start: Object.assign({}, token.start),
              // Note: correct end is set later.
              end: Object.assign({}, token.end)
            };
            map9.add(index3, 0, [["enter", currentBody, context]]);
          }
          rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
        } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
          inFirstCellAwaitingPipe = false;
          if (cell2[2] === 0) {
            if (lastCell[1] !== 0) {
              cell2[0] = cell2[1];
              currentCell = flushCell(map9, context, lastCell, rowKind, void 0, currentCell);
              lastCell = [0, 0, 0, 0];
            }
            cell2[2] = index3;
          }
        } else if (token.type === "tableCellDivider") {
          if (inFirstCellAwaitingPipe) {
            inFirstCellAwaitingPipe = false;
          } else {
            if (lastCell[1] !== 0) {
              cell2[0] = cell2[1];
              currentCell = flushCell(map9, context, lastCell, rowKind, void 0, currentCell);
            }
            lastCell = cell2;
            cell2 = [lastCell[1], index3, 0, 0];
          }
        }
      } else if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = true;
        lastTableEnd = index3;
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        lastTableEnd = index3;
        if (lastCell[1] !== 0) {
          cell2[0] = cell2[1];
          currentCell = flushCell(map9, context, lastCell, rowKind, index3, currentCell);
        } else if (cell2[1] !== 0) {
          currentCell = flushCell(map9, context, cell2, rowKind, index3, currentCell);
        }
        rowKind = 0;
      } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        cell2[3] = index3;
      }
    }
    if (lastTableEnd !== 0) {
      flushTableEnd(map9, context, lastTableEnd, currentTable, currentBody);
    }
    map9.consume(context.events);
    index3 = -1;
    while (++index3 < context.events.length) {
      const event = context.events[index3];
      if (event[0] === "enter" && event[1].type === "table") {
        event[1]._align = gfmTableAlign(context.events, index3);
      }
    }
    return events;
  }
  function flushCell(map9, context, range, rowKind, rowEnd, previousCell) {
    const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
    const valueName = "tableContent";
    if (range[0] !== 0) {
      previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
      map9.add(range[0], 0, [["exit", previousCell, context]]);
    }
    const now = getPoint(context.events, range[1]);
    previousCell = {
      type: groupName,
      start: Object.assign({}, now),
      // Note: correct end is set later.
      end: Object.assign({}, now)
    };
    map9.add(range[1], 0, [["enter", previousCell, context]]);
    if (range[2] !== 0) {
      const relatedStart = getPoint(context.events, range[2]);
      const relatedEnd = getPoint(context.events, range[3]);
      const valueToken = {
        type: valueName,
        start: Object.assign({}, relatedStart),
        end: Object.assign({}, relatedEnd)
      };
      map9.add(range[2], 0, [["enter", valueToken, context]]);
      if (rowKind !== 2) {
        const start = context.events[range[2]];
        const end = context.events[range[3]];
        start[1].end = Object.assign({}, end[1].end);
        start[1].type = "chunkText";
        start[1].contentType = "text";
        if (range[3] > range[2] + 1) {
          const a2 = range[2] + 1;
          const b = range[3] - range[2] - 1;
          map9.add(a2, b, []);
        }
      }
      map9.add(range[3] + 1, 0, [["exit", valueToken, context]]);
    }
    if (rowEnd !== void 0) {
      previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
      map9.add(rowEnd, 0, [["exit", previousCell, context]]);
      previousCell = void 0;
    }
    return previousCell;
  }
  function flushTableEnd(map9, context, index3, table3, tableBody) {
    const exits = [];
    const related = getPoint(context.events, index3);
    if (tableBody) {
      tableBody.end = Object.assign({}, related);
      exits.push(["exit", tableBody, context]);
    }
    table3.end = Object.assign({}, related);
    exits.push(["exit", table3, context]);
    map9.add(index3 + 1, 0, exits);
  }
  function getPoint(events, index3) {
    const event = events[index3];
    const side = event[0] === "enter" ? "start" : "end";
    return event[1][side];
  }
  var init_syntax4 = __esm({
    "node_modules/micromark-extension-gfm-table/lib/syntax.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      init_edit_map();
      init_infer();
    }
  });

  // node_modules/micromark-extension-gfm-table/index.js
  var init_micromark_extension_gfm_table = __esm({
    "node_modules/micromark-extension-gfm-table/index.js"() {
      init_html7();
      init_syntax4();
    }
  });

  // node_modules/micromark-extension-gfm-tagfilter/lib/index.js
  function gfmTagfilterHtml() {
    return {
      exit: {
        htmlFlowData(token) {
          exitHtmlData.call(this, token, reFlow);
        },
        htmlTextData(token) {
          exitHtmlData.call(this, token, reText);
        }
      }
    };
  }
  function exitHtmlData(token, filter) {
    let value = this.sliceSerialize(token);
    if (this.options.allowDangerousHtml) {
      value = value.replace(filter, "&lt;$1$2");
    }
    this.raw(this.encode(value));
  }
  var reFlow, reText;
  var init_lib42 = __esm({
    "node_modules/micromark-extension-gfm-tagfilter/lib/index.js"() {
      reFlow = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\t\n\f\r />])/gi;
      reText = new RegExp("^" + reFlow.source, "i");
    }
  });

  // node_modules/micromark-extension-gfm-tagfilter/index.js
  var init_micromark_extension_gfm_tagfilter = __esm({
    "node_modules/micromark-extension-gfm-tagfilter/index.js"() {
      init_lib42();
    }
  });

  // node_modules/micromark-extension-gfm-task-list-item/lib/html.js
  function gfmTaskListItemHtml() {
    return {
      enter: {
        taskListCheck() {
          this.tag('<input type="checkbox" disabled="" ');
        }
      },
      exit: {
        taskListCheck() {
          this.tag("/>");
        },
        taskListCheckValueChecked() {
          this.tag('checked="" ');
        }
      }
    };
  }
  var init_html8 = __esm({
    "node_modules/micromark-extension-gfm-task-list-item/lib/html.js"() {
    }
  });

  // node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
  function gfmTaskListItem() {
    return {
      text: {
        [91]: tasklistCheck
      }
    };
  }
  function tokenizeTasklistCheck(effects, ok3, nok) {
    const self2 = this;
    return open;
    function open(code5) {
      if (
        // Exit if theres stuff before.
        self2.previous !== null || // Exit if not in the first content that is the first child of a list
        // item.
        !self2._gfmTasklistFirstContentOfListItem
      ) {
        return nok(code5);
      }
      effects.enter("taskListCheck");
      effects.enter("taskListCheckMarker");
      effects.consume(code5);
      effects.exit("taskListCheckMarker");
      return inside;
    }
    function inside(code5) {
      if (markdownLineEndingOrSpace(code5)) {
        effects.enter("taskListCheckValueUnchecked");
        effects.consume(code5);
        effects.exit("taskListCheckValueUnchecked");
        return close2;
      }
      if (code5 === 88 || code5 === 120) {
        effects.enter("taskListCheckValueChecked");
        effects.consume(code5);
        effects.exit("taskListCheckValueChecked");
        return close2;
      }
      return nok(code5);
    }
    function close2(code5) {
      if (code5 === 93) {
        effects.enter("taskListCheckMarker");
        effects.consume(code5);
        effects.exit("taskListCheckMarker");
        effects.exit("taskListCheck");
        return after;
      }
      return nok(code5);
    }
    function after(code5) {
      if (markdownLineEnding(code5)) {
        return ok3(code5);
      }
      if (markdownSpace(code5)) {
        return effects.check({
          tokenize: spaceThenNonSpace
        }, ok3, nok)(code5);
      }
      return nok(code5);
    }
  }
  function spaceThenNonSpace(effects, ok3, nok) {
    return factorySpace(effects, after, "whitespace");
    function after(code5) {
      return code5 === null ? nok(code5) : ok3(code5);
    }
  }
  var tasklistCheck;
  var init_syntax5 = __esm({
    "node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      tasklistCheck = {
        name: "tasklistCheck",
        tokenize: tokenizeTasklistCheck
      };
    }
  });

  // node_modules/micromark-extension-gfm-task-list-item/index.js
  var init_micromark_extension_gfm_task_list_item = __esm({
    "node_modules/micromark-extension-gfm-task-list-item/index.js"() {
      init_html8();
      init_syntax5();
    }
  });

  // node_modules/micromark-extension-gfm/index.js
  function gfm(options2) {
    return combineExtensions([
      gfmAutolinkLiteral(),
      gfmFootnote(),
      gfmStrikethrough(options2),
      gfmTable(),
      gfmTaskListItem()
    ]);
  }
  function gfmHtml(options2) {
    return combineHtmlExtensions([
      gfmAutolinkLiteralHtml(),
      gfmFootnoteHtml(options2),
      gfmStrikethroughHtml(),
      gfmTableHtml(),
      gfmTagfilterHtml(),
      gfmTaskListItemHtml()
    ]);
  }
  var init_micromark_extension_gfm = __esm({
    "node_modules/micromark-extension-gfm/index.js"() {
      init_micromark_util_combine_extensions();
      init_micromark_extension_gfm_autolink_literal();
      init_micromark_extension_gfm_footnote();
      init_micromark_extension_gfm_strikethrough();
      init_micromark_extension_gfm_table();
      init_micromark_extension_gfm_tagfilter();
      init_micromark_extension_gfm_task_list_item();
    }
  });

  // node_modules/remark-gfm/lib/index.js
  function remarkGfm(options2) {
    const self2 = (
      /** @type {Processor<Root>} */
      this
    );
    const settings = options2 || emptyOptions7;
    const data = self2.data();
    const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);
    const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);
    const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);
    micromarkExtensions.push(gfm(settings));
    fromMarkdownExtensions.push(gfmFromMarkdown());
    toMarkdownExtensions.push(gfmToMarkdown(settings));
  }
  var emptyOptions7;
  var init_lib43 = __esm({
    "node_modules/remark-gfm/lib/index.js"() {
      init_mdast_util_gfm();
      init_micromark_extension_gfm();
      emptyOptions7 = {};
    }
  });

  // node_modules/remark-gfm/index.js
  var remark_gfm_exports = {};
  __export(remark_gfm_exports, {
    default: () => remarkGfm
  });
  var init_remark_gfm = __esm({
    "node_modules/remark-gfm/index.js"() {
      init_lib43();
    }
  });

  // node_modules/remark-stringify/lib/index.js
  function remarkStringify(options2) {
    const self2 = this;
    self2.compiler = compiler2;
    function compiler2(tree) {
      return toMarkdown(tree, {
        ...self2.data("settings"),
        ...options2,
        // Note: this option is not in the readme.
        // The goal is for it to be set by plugins on `data` instead of being
        // passed by users.
        extensions: self2.data("toMarkdownExtensions") || []
      });
    }
  }
  var init_lib44 = __esm({
    "node_modules/remark-stringify/lib/index.js"() {
      init_mdast_util_to_markdown();
    }
  });

  // node_modules/remark-stringify/index.js
  var remark_stringify_exports = {};
  __export(remark_stringify_exports, {
    default: () => remarkStringify
  });
  var init_remark_stringify = __esm({
    "node_modules/remark-stringify/index.js"() {
      init_lib44();
    }
  });

  // node_modules/micromark/lib/compile.js
  function compile(options2) {
    const settings = options2 || {};
    let tags = true;
    const definitions = {};
    const buffers = [[]];
    const mediaStack = [];
    const tightStack = [];
    const defaultHandlers = {
      enter: {
        blockQuote: onenterblockquote,
        codeFenced: onentercodefenced,
        codeFencedFenceInfo: buffer,
        codeFencedFenceMeta: buffer,
        codeIndented: onentercodeindented,
        codeText: onentercodetext,
        content: onentercontent,
        definition: onenterdefinition,
        definitionDestinationString: onenterdefinitiondestinationstring,
        definitionLabelString: buffer,
        definitionTitleString: buffer,
        emphasis: onenteremphasis,
        htmlFlow: onenterhtmlflow,
        htmlText: onenterhtml,
        image: onenterimage,
        label: buffer,
        link: onenterlink,
        listItemMarker: onenterlistitemmarker,
        listItemValue: onenterlistitemvalue,
        listOrdered: onenterlistordered,
        listUnordered: onenterlistunordered,
        paragraph: onenterparagraph,
        reference: buffer,
        resource: onenterresource,
        resourceDestinationString: onenterresourcedestinationstring,
        resourceTitleString: buffer,
        setextHeading: onentersetextheading,
        strong: onenterstrong
      },
      exit: {
        atxHeading: onexitatxheading,
        atxHeadingSequence: onexitatxheadingsequence,
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: onexitblockquote,
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        codeFenced: onexitflowcode,
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onresumedrop,
        codeFlowValue: onexitcodeflowvalue,
        codeIndented: onexitflowcode,
        codeText: onexitcodetext,
        codeTextData: onexitdata,
        data: onexitdata,
        definition: onexitdefinition,
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: onexitemphasis,
        hardBreakEscape: onexithardbreak,
        hardBreakTrailing: onexithardbreak,
        htmlFlow: onexithtml,
        htmlFlowData: onexitdata,
        htmlText: onexithtml,
        htmlTextData: onexitdata,
        image: onexitmedia,
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: onexitmedia,
        listOrdered: onexitlistordered,
        listUnordered: onexitlistunordered,
        paragraph: onexitparagraph,
        reference: onresumedrop,
        referenceString: onexitreferencestring,
        resource: onresumedrop,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        setextHeading: onexitsetextheading,
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: onexitstrong,
        thematicBreak: onexitthematicbreak
      }
    };
    const handlers4 = (
      /** @type {NormalizedHtmlExtension} */
      combineHtmlExtensions([defaultHandlers, ...settings.htmlExtensions || []])
    );
    const data = {
      definitions,
      tightStack
    };
    const context = {
      buffer,
      encode: encode3,
      getData,
      lineEndingIfNeeded,
      options: settings,
      raw: raw2,
      resume,
      setData,
      tag
    };
    let lineEndingStyle = settings.defaultLineEnding;
    return compile2;
    function compile2(events) {
      let index3 = -1;
      let start = 0;
      const listStack = [];
      let head2 = [];
      let body3 = [];
      while (++index3 < events.length) {
        if (!lineEndingStyle && (events[index3][1].type === "lineEnding" || events[index3][1].type === "lineEndingBlank")) {
          lineEndingStyle = /** @type {LineEnding} */
          events[index3][2].sliceSerialize(events[index3][1]);
        }
        if (events[index3][1].type === "listOrdered" || events[index3][1].type === "listUnordered") {
          if (events[index3][0] === "enter") {
            listStack.push(index3);
          } else {
            prepareList(events.slice(listStack.pop(), index3));
          }
        }
        if (events[index3][1].type === "definition") {
          if (events[index3][0] === "enter") {
            body3 = push(body3, events.slice(start, index3));
            start = index3;
          } else {
            head2 = push(head2, events.slice(start, index3 + 1));
            start = index3 + 1;
          }
        }
      }
      head2 = push(head2, body3);
      head2 = push(head2, events.slice(start));
      index3 = -1;
      const result = head2;
      if (handlers4.enter.null) {
        handlers4.enter.null.call(context);
      }
      while (++index3 < events.length) {
        const handles = handlers4[result[index3][0]];
        const kind = result[index3][1].type;
        const handle4 = handles[kind];
        if (hasOwnProperty2.call(handles, kind) && handle4) {
          handle4.call({
            sliceSerialize: result[index3][2].sliceSerialize,
            ...context
          }, result[index3][1]);
        }
      }
      if (handlers4.exit.null) {
        handlers4.exit.null.call(context);
      }
      return buffers[0].join("");
    }
    function prepareList(slice2) {
      const length3 = slice2.length;
      let index3 = 0;
      let containerBalance = 0;
      let loose = false;
      let atMarker;
      while (++index3 < length3) {
        const event = slice2[index3];
        if (event[1]._container) {
          atMarker = void 0;
          if (event[0] === "enter") {
            containerBalance++;
          } else {
            containerBalance--;
          }
        } else switch (event[1].type) {
          case "listItemPrefix": {
            if (event[0] === "exit") {
              atMarker = true;
            }
            break;
          }
          case "linePrefix": {
            break;
          }
          case "lineEndingBlank": {
            if (event[0] === "enter" && !containerBalance) {
              if (atMarker) {
                atMarker = void 0;
              } else {
                loose = true;
              }
            }
            break;
          }
          default: {
            atMarker = void 0;
          }
        }
      }
      slice2[0][1]._loose = loose;
    }
    function setData(key2, value) {
      data[key2] = value;
    }
    function getData(key2) {
      return data[key2];
    }
    function buffer() {
      buffers.push([]);
    }
    function resume() {
      const buf = buffers.pop();
      return buf.join("");
    }
    function tag(value) {
      if (!tags) return;
      setData("lastWasTag", true);
      buffers[buffers.length - 1].push(value);
    }
    function raw2(value) {
      setData("lastWasTag");
      buffers[buffers.length - 1].push(value);
    }
    function lineEnding2() {
      raw2(lineEndingStyle || "\n");
    }
    function lineEndingIfNeeded() {
      const buffer2 = buffers[buffers.length - 1];
      const slice2 = buffer2[buffer2.length - 1];
      const previous3 = slice2 ? slice2.charCodeAt(slice2.length - 1) : null;
      if (previous3 === 10 || previous3 === 13 || previous3 === null) {
        return;
      }
      lineEnding2();
    }
    function encode3(value) {
      return getData("ignoreEncode") ? value : encode(value);
    }
    function onresumedrop() {
      resume();
    }
    function onenterlistordered(token) {
      tightStack.push(!token._loose);
      lineEndingIfNeeded();
      tag("<ol");
      setData("expectFirstItem", true);
    }
    function onenterlistunordered(token) {
      tightStack.push(!token._loose);
      lineEndingIfNeeded();
      tag("<ul");
      setData("expectFirstItem", true);
    }
    function onenterlistitemvalue(token) {
      if (getData("expectFirstItem")) {
        const value = Number.parseInt(this.sliceSerialize(token), 10);
        if (value !== 1) {
          tag(' start="' + encode3(String(value)) + '"');
        }
      }
    }
    function onenterlistitemmarker() {
      if (getData("expectFirstItem")) {
        tag(">");
      } else {
        onexitlistitem();
      }
      lineEndingIfNeeded();
      tag("<li>");
      setData("expectFirstItem");
      setData("lastWasTag");
    }
    function onexitlistordered() {
      onexitlistitem();
      tightStack.pop();
      lineEnding2();
      tag("</ol>");
    }
    function onexitlistunordered() {
      onexitlistitem();
      tightStack.pop();
      lineEnding2();
      tag("</ul>");
    }
    function onexitlistitem() {
      if (getData("lastWasTag") && !getData("slurpAllLineEndings")) {
        lineEndingIfNeeded();
      }
      tag("</li>");
      setData("slurpAllLineEndings");
    }
    function onenterblockquote() {
      tightStack.push(false);
      lineEndingIfNeeded();
      tag("<blockquote>");
    }
    function onexitblockquote() {
      tightStack.pop();
      lineEndingIfNeeded();
      tag("</blockquote>");
      setData("slurpAllLineEndings");
    }
    function onenterparagraph() {
      if (!tightStack[tightStack.length - 1]) {
        lineEndingIfNeeded();
        tag("<p>");
      }
      setData("slurpAllLineEndings");
    }
    function onexitparagraph() {
      if (tightStack[tightStack.length - 1]) {
        setData("slurpAllLineEndings", true);
      } else {
        tag("</p>");
      }
    }
    function onentercodefenced() {
      lineEndingIfNeeded();
      tag("<pre><code");
      setData("fencesCount", 0);
    }
    function onexitcodefencedfenceinfo() {
      const value = resume();
      tag(' class="language-' + value + '"');
    }
    function onexitcodefencedfence() {
      const count = getData("fencesCount") || 0;
      if (!count) {
        tag(">");
        setData("slurpOneLineEnding", true);
      }
      setData("fencesCount", count + 1);
    }
    function onentercodeindented() {
      lineEndingIfNeeded();
      tag("<pre><code>");
    }
    function onexitflowcode() {
      const count = getData("fencesCount");
      if (count !== void 0 && count < 2 && data.tightStack.length > 0 && !getData("lastWasTag")) {
        lineEnding2();
      }
      if (getData("flowCodeSeenData")) {
        lineEndingIfNeeded();
      }
      tag("</code></pre>");
      if (count !== void 0 && count < 2) lineEndingIfNeeded();
      setData("flowCodeSeenData");
      setData("fencesCount");
      setData("slurpOneLineEnding");
    }
    function onenterimage() {
      mediaStack.push({
        image: true
      });
      tags = void 0;
    }
    function onenterlink() {
      mediaStack.push({});
    }
    function onexitlabeltext(token) {
      mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token);
    }
    function onexitlabel() {
      mediaStack[mediaStack.length - 1].label = resume();
    }
    function onexitreferencestring(token) {
      mediaStack[mediaStack.length - 1].referenceId = this.sliceSerialize(token);
    }
    function onenterresource() {
      buffer();
      mediaStack[mediaStack.length - 1].destination = "";
    }
    function onenterresourcedestinationstring() {
      buffer();
      setData("ignoreEncode", true);
    }
    function onexitresourcedestinationstring() {
      mediaStack[mediaStack.length - 1].destination = resume();
      setData("ignoreEncode");
    }
    function onexitresourcetitlestring() {
      mediaStack[mediaStack.length - 1].title = resume();
    }
    function onexitmedia() {
      let index3 = mediaStack.length - 1;
      const media2 = mediaStack[index3];
      const id2 = media2.referenceId || media2.labelId;
      const context2 = media2.destination === void 0 ? definitions[normalizeIdentifier(id2)] : media2;
      tags = true;
      while (index3--) {
        if (mediaStack[index3].image) {
          tags = void 0;
          break;
        }
      }
      if (media2.image) {
        tag('<img src="' + sanitizeUri(context2.destination, settings.allowDangerousProtocol ? void 0 : protocolSource) + '" alt="');
        raw2(media2.label);
        tag('"');
      } else {
        tag('<a href="' + sanitizeUri(context2.destination, settings.allowDangerousProtocol ? void 0 : protocolHref) + '"');
      }
      tag(context2.title ? ' title="' + context2.title + '"' : "");
      if (media2.image) {
        tag(" />");
      } else {
        tag(">");
        raw2(media2.label);
        tag("</a>");
      }
      mediaStack.pop();
    }
    function onenterdefinition() {
      buffer();
      mediaStack.push({});
    }
    function onexitdefinitionlabelstring(token) {
      resume();
      mediaStack[mediaStack.length - 1].labelId = this.sliceSerialize(token);
    }
    function onenterdefinitiondestinationstring() {
      buffer();
      setData("ignoreEncode", true);
    }
    function onexitdefinitiondestinationstring() {
      mediaStack[mediaStack.length - 1].destination = resume();
      setData("ignoreEncode");
    }
    function onexitdefinitiontitlestring() {
      mediaStack[mediaStack.length - 1].title = resume();
    }
    function onexitdefinition() {
      const media2 = mediaStack[mediaStack.length - 1];
      const id2 = normalizeIdentifier(media2.labelId);
      resume();
      if (!hasOwnProperty2.call(definitions, id2)) {
        definitions[id2] = mediaStack[mediaStack.length - 1];
      }
      mediaStack.pop();
    }
    function onentercontent() {
      setData("slurpAllLineEndings", true);
    }
    function onexitatxheadingsequence(token) {
      if (getData("headingRank")) return;
      setData("headingRank", this.sliceSerialize(token).length);
      lineEndingIfNeeded();
      tag("<h" + getData("headingRank") + ">");
    }
    function onentersetextheading() {
      buffer();
      setData("slurpAllLineEndings");
    }
    function onexitsetextheadingtext() {
      setData("slurpAllLineEndings", true);
    }
    function onexitatxheading() {
      tag("</h" + getData("headingRank") + ">");
      setData("headingRank");
    }
    function onexitsetextheadinglinesequence(token) {
      setData("headingRank", this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2);
    }
    function onexitsetextheading() {
      const value = resume();
      lineEndingIfNeeded();
      tag("<h" + getData("headingRank") + ">");
      raw2(value);
      tag("</h" + getData("headingRank") + ">");
      setData("slurpAllLineEndings");
      setData("headingRank");
    }
    function onexitdata(token) {
      raw2(encode3(this.sliceSerialize(token)));
    }
    function onexitlineending(token) {
      if (getData("slurpAllLineEndings")) {
        return;
      }
      if (getData("slurpOneLineEnding")) {
        setData("slurpOneLineEnding");
        return;
      }
      if (getData("inCodeText")) {
        raw2(" ");
        return;
      }
      raw2(encode3(this.sliceSerialize(token)));
    }
    function onexitcodeflowvalue(token) {
      raw2(encode3(this.sliceSerialize(token)));
      setData("flowCodeSeenData", true);
    }
    function onexithardbreak() {
      tag("<br />");
    }
    function onenterhtmlflow() {
      lineEndingIfNeeded();
      onenterhtml();
    }
    function onexithtml() {
      setData("ignoreEncode");
    }
    function onenterhtml() {
      if (settings.allowDangerousHtml) {
        setData("ignoreEncode", true);
      }
    }
    function onenteremphasis() {
      tag("<em>");
    }
    function onenterstrong() {
      tag("<strong>");
    }
    function onentercodetext() {
      setData("inCodeText", true);
      tag("<code>");
    }
    function onexitcodetext() {
      setData("inCodeText");
      tag("</code>");
    }
    function onexitemphasis() {
      tag("</em>");
    }
    function onexitstrong() {
      tag("</strong>");
    }
    function onexitthematicbreak() {
      lineEndingIfNeeded();
      tag("<hr />");
    }
    function onexitcharacterreferencemarker(token) {
      setData("characterReferenceType", token.type);
    }
    function onexitcharacterreferencevalue(token) {
      const value = this.sliceSerialize(token);
      const decoded = getData("characterReferenceType") ? decodeNumericCharacterReference(value, getData("characterReferenceType") === "characterReferenceMarkerNumeric" ? 10 : 16) : decodeNamedCharacterReference(value);
      raw2(encode3(
        /** @type {string} */
        decoded
      ));
      setData("characterReferenceType");
    }
    function onexitautolinkprotocol(token) {
      const uri = this.sliceSerialize(token);
      tag('<a href="' + sanitizeUri(uri, settings.allowDangerousProtocol ? void 0 : protocolHref) + '">');
      raw2(encode3(uri));
      tag("</a>");
    }
    function onexitautolinkemail(token) {
      const uri = this.sliceSerialize(token);
      tag('<a href="' + sanitizeUri("mailto:" + uri) + '">');
      raw2(encode3(uri));
      tag("</a>");
    }
  }
  var hasOwnProperty2, protocolHref, protocolSource;
  var init_compile = __esm({
    "node_modules/micromark/lib/compile.js"() {
      init_index_dom();
      init_micromark_util_chunked();
      init_micromark_util_combine_extensions();
      init_micromark_util_decode_numeric_character_reference();
      init_micromark_util_encode();
      init_micromark_util_normalize_identifier();
      init_micromark_util_sanitize_uri();
      hasOwnProperty2 = {}.hasOwnProperty;
      protocolHref = /^(https?|ircs?|mailto|xmpp)$/i;
      protocolSource = /^https?$/i;
    }
  });

  // node_modules/micromark/lib/initialize/content.js
  function initializeContent(effects) {
    const contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
    let previous3;
    return contentStart;
    function afterContentStartConstruct(code5) {
      if (code5 === null) {
        effects.consume(code5);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code5);
      effects.exit("lineEnding");
      return factorySpace(effects, contentStart, "linePrefix");
    }
    function paragraphInitial(code5) {
      effects.enter("paragraph");
      return lineStart(code5);
    }
    function lineStart(code5) {
      const token = effects.enter("chunkText", {
        contentType: "text",
        previous: previous3
      });
      if (previous3) {
        previous3.next = token;
      }
      previous3 = token;
      return data(code5);
    }
    function data(code5) {
      if (code5 === null) {
        effects.exit("chunkText");
        effects.exit("paragraph");
        effects.consume(code5);
        return;
      }
      if (markdownLineEnding(code5)) {
        effects.consume(code5);
        effects.exit("chunkText");
        return lineStart;
      }
      effects.consume(code5);
      return data;
    }
  }
  var content4;
  var init_content3 = __esm({
    "node_modules/micromark/lib/initialize/content.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      content4 = {
        tokenize: initializeContent
      };
    }
  });

  // node_modules/micromark/lib/initialize/document.js
  function initializeDocument(effects) {
    const self2 = this;
    const stack = [];
    let continued = 0;
    let childFlow;
    let childToken;
    let lineStartOffset;
    return start;
    function start(code5) {
      if (continued < stack.length) {
        const item = stack[continued];
        self2.containerState = item[1];
        return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code5);
      }
      return checkNewContainers(code5);
    }
    function documentContinue(code5) {
      continued++;
      if (self2.containerState._closeFlow) {
        self2.containerState._closeFlow = void 0;
        if (childFlow) {
          closeFlow();
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let point5;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            point5 = self2.events[indexBeforeFlow][1].end;
            break;
          }
        }
        exitContainers(continued);
        let index3 = indexBeforeExits;
        while (index3 < self2.events.length) {
          self2.events[index3][1].end = {
            ...point5
          };
          index3++;
        }
        splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
        self2.events.length = index3;
        return checkNewContainers(code5);
      }
      return start(code5);
    }
    function checkNewContainers(code5) {
      if (continued === stack.length) {
        if (!childFlow) {
          return documentContinued(code5);
        }
        if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
          return flowStart(code5);
        }
        self2.interrupt = Boolean(childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack);
      }
      self2.containerState = {};
      return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code5);
    }
    function thereIsANewContainer(code5) {
      if (childFlow) closeFlow();
      exitContainers(continued);
      return documentContinued(code5);
    }
    function thereIsNoNewContainer(code5) {
      self2.parser.lazy[self2.now().line] = continued !== stack.length;
      lineStartOffset = self2.now().offset;
      return flowStart(code5);
    }
    function documentContinued(code5) {
      self2.containerState = {};
      return effects.attempt(containerConstruct, containerContinue, flowStart)(code5);
    }
    function containerContinue(code5) {
      continued++;
      stack.push([self2.currentConstruct, self2.containerState]);
      return documentContinued(code5);
    }
    function flowStart(code5) {
      if (code5 === null) {
        if (childFlow) closeFlow();
        exitContainers(0);
        effects.consume(code5);
        return;
      }
      childFlow = childFlow || self2.parser.flow(self2.now());
      effects.enter("chunkFlow", {
        _tokenizer: childFlow,
        contentType: "flow",
        previous: childToken
      });
      return flowContinue(code5);
    }
    function flowContinue(code5) {
      if (code5 === null) {
        writeToChild(effects.exit("chunkFlow"), true);
        exitContainers(0);
        effects.consume(code5);
        return;
      }
      if (markdownLineEnding(code5)) {
        effects.consume(code5);
        writeToChild(effects.exit("chunkFlow"));
        continued = 0;
        self2.interrupt = void 0;
        return start;
      }
      effects.consume(code5);
      return flowContinue;
    }
    function writeToChild(token, endOfFile) {
      const stream = self2.sliceStream(token);
      if (endOfFile) stream.push(null);
      token.previous = childToken;
      if (childToken) childToken.next = token;
      childToken = token;
      childFlow.defineSkip(token.start);
      childFlow.write(stream);
      if (self2.parser.lazy[token.start.line]) {
        let index3 = childFlow.events.length;
        while (index3--) {
          if (
            // The token starts before the line ending
            childFlow.events[index3][1].start.offset < lineStartOffset && // and either is not ended yet
            (!childFlow.events[index3][1].end || // or ends after it.
            childFlow.events[index3][1].end.offset > lineStartOffset)
          ) {
            return;
          }
        }
        const indexBeforeExits = self2.events.length;
        let indexBeforeFlow = indexBeforeExits;
        let seen;
        let point5;
        while (indexBeforeFlow--) {
          if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
            if (seen) {
              point5 = self2.events[indexBeforeFlow][1].end;
              break;
            }
            seen = true;
          }
        }
        exitContainers(continued);
        index3 = indexBeforeExits;
        while (index3 < self2.events.length) {
          self2.events[index3][1].end = {
            ...point5
          };
          index3++;
        }
        splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
        self2.events.length = index3;
      }
    }
    function exitContainers(size2) {
      let index3 = stack.length;
      while (index3-- > size2) {
        const entry = stack[index3];
        self2.containerState = entry[1];
        entry[0].exit.call(self2, effects);
      }
      stack.length = size2;
    }
    function closeFlow() {
      childFlow.write([null]);
      childToken = void 0;
      childFlow = void 0;
      self2.containerState._closeFlow = void 0;
    }
  }
  function tokenizeContainer(effects, ok3, nok) {
    return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok3, nok), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
  }
  var document2, containerConstruct;
  var init_document = __esm({
    "node_modules/micromark/lib/initialize/document.js"() {
      init_micromark_factory_space();
      init_micromark_util_character();
      init_micromark_util_chunked();
      document2 = {
        tokenize: initializeDocument
      };
      containerConstruct = {
        tokenize: tokenizeContainer
      };
    }
  });

  // node_modules/micromark/lib/initialize/flow.js
  function initializeFlow(effects) {
    const self2 = this;
    const initial = effects.attempt(
      // Try to parse a blank line.
      blankLine,
      atBlankEnding,
      // Try to parse initial flow (essentially, only code).
      effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content3, afterConstruct)), "linePrefix"))
    );
    return initial;
    function atBlankEnding(code5) {
      if (code5 === null) {
        effects.consume(code5);
        return;
      }
      effects.enter("lineEndingBlank");
      effects.consume(code5);
      effects.exit("lineEndingBlank");
      self2.currentConstruct = void 0;
      return initial;
    }
    function afterConstruct(code5) {
      if (code5 === null) {
        effects.consume(code5);
        return;
      }
      effects.enter("lineEnding");
      effects.consume(code5);
      effects.exit("lineEnding");
      self2.currentConstruct = void 0;
      return initial;
    }
  }
  var flow2;
  var init_flow = __esm({
    "node_modules/micromark/lib/initialize/flow.js"() {
      init_micromark_core_commonmark();
      init_micromark_factory_space();
      init_micromark_util_character();
      flow2 = {
        tokenize: initializeFlow
      };
    }
  });

  // node_modules/micromark/lib/initialize/text.js
  function initializeFactory(field) {
    return {
      resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0),
      tokenize: initializeText
    };
    function initializeText(effects) {
      const self2 = this;
      const constructs2 = this.parser.constructs[field];
      const text10 = effects.attempt(constructs2, start, notText);
      return start;
      function start(code5) {
        return atBreak(code5) ? text10(code5) : notText(code5);
      }
      function notText(code5) {
        if (code5 === null) {
          effects.consume(code5);
          return;
        }
        effects.enter("data");
        effects.consume(code5);
        return data;
      }
      function data(code5) {
        if (atBreak(code5)) {
          effects.exit("data");
          return text10(code5);
        }
        effects.consume(code5);
        return data;
      }
      function atBreak(code5) {
        if (code5 === null) {
          return true;
        }
        const list7 = constructs2[code5];
        let index3 = -1;
        if (list7) {
          while (++index3 < list7.length) {
            const item = list7[index3];
            if (!item.previous || item.previous.call(self2, self2.previous)) {
              return true;
            }
          }
        }
        return false;
      }
    }
  }
  function createResolver(extraResolver) {
    return resolveAllText;
    function resolveAllText(events, context) {
      let index3 = -1;
      let enter2;
      while (++index3 <= events.length) {
        if (enter2 === void 0) {
          if (events[index3] && events[index3][1].type === "data") {
            enter2 = index3;
            index3++;
          }
        } else if (!events[index3] || events[index3][1].type !== "data") {
          if (index3 !== enter2 + 2) {
            events[enter2][1].end = events[index3 - 1][1].end;
            events.splice(enter2 + 2, index3 - enter2 - 2);
            index3 = enter2 + 2;
          }
          enter2 = void 0;
        }
      }
      return extraResolver ? extraResolver(events, context) : events;
    }
  }
  function resolveAllLineSuffixes(events, context) {
    let eventIndex = 0;
    while (++eventIndex <= events.length) {
      if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
        const data = events[eventIndex - 1][1];
        const chunks = context.sliceStream(data);
        let index3 = chunks.length;
        let bufferIndex = -1;
        let size2 = 0;
        let tabs;
        while (index3--) {
          const chunk = chunks[index3];
          if (typeof chunk === "string") {
            bufferIndex = chunk.length;
            while (chunk.charCodeAt(bufferIndex - 1) === 32) {
              size2++;
              bufferIndex--;
            }
            if (bufferIndex) break;
            bufferIndex = -1;
          } else if (chunk === -2) {
            tabs = true;
            size2++;
          } else if (chunk === -1) {
          } else {
            index3++;
            break;
          }
        }
        if (context._contentTypeTextTrailing && eventIndex === events.length) {
          size2 = 0;
        }
        if (size2) {
          const token = {
            type: eventIndex === events.length || tabs || size2 < 2 ? "lineSuffix" : "hardBreakTrailing",
            start: {
              _bufferIndex: index3 ? bufferIndex : data.start._bufferIndex + bufferIndex,
              _index: data.start._index + index3,
              line: data.end.line,
              column: data.end.column - size2,
              offset: data.end.offset - size2
            },
            end: {
              ...data.end
            }
          };
          data.end = {
            ...token.start
          };
          if (data.start.offset === data.end.offset) {
            Object.assign(data, token);
          } else {
            events.splice(eventIndex, 0, ["enter", token, context], ["exit", token, context]);
            eventIndex += 2;
          }
        }
        eventIndex++;
      }
    }
    return events;
  }
  var resolver, string, text6;
  var init_text4 = __esm({
    "node_modules/micromark/lib/initialize/text.js"() {
      resolver = {
        resolveAll: createResolver()
      };
      string = initializeFactory("string");
      text6 = initializeFactory("text");
    }
  });

  // node_modules/micromark/lib/constructs.js
  var constructs_exports = {};
  __export(constructs_exports, {
    attentionMarkers: () => attentionMarkers,
    contentInitial: () => contentInitial,
    disable: () => disable,
    document: () => document3,
    flow: () => flow3,
    flowInitial: () => flowInitial,
    insideSpan: () => insideSpan,
    string: () => string2,
    text: () => text7
  });
  var document3, contentInitial, flowInitial, flow3, string2, text7, insideSpan, attentionMarkers, disable;
  var init_constructs = __esm({
    "node_modules/micromark/lib/constructs.js"() {
      init_micromark_core_commonmark();
      init_text4();
      document3 = {
        [42]: list5,
        [43]: list5,
        [45]: list5,
        [48]: list5,
        [49]: list5,
        [50]: list5,
        [51]: list5,
        [52]: list5,
        [53]: list5,
        [54]: list5,
        [55]: list5,
        [56]: list5,
        [57]: list5,
        [62]: blockQuote
      };
      contentInitial = {
        [91]: definition2
      };
      flowInitial = {
        [-2]: codeIndented,
        [-1]: codeIndented,
        [32]: codeIndented
      };
      flow3 = {
        [35]: headingAtx,
        [42]: thematicBreak2,
        [45]: [setextUnderline, thematicBreak2],
        [60]: htmlFlow,
        [61]: setextUnderline,
        [95]: thematicBreak2,
        [96]: codeFenced,
        [126]: codeFenced
      };
      string2 = {
        [38]: characterReference,
        [92]: characterEscape
      };
      text7 = {
        [-5]: lineEnding,
        [-4]: lineEnding,
        [-3]: lineEnding,
        [33]: labelStartImage,
        [38]: characterReference,
        [42]: attention,
        [60]: [autolink, htmlText],
        [91]: labelStartLink,
        [92]: [hardBreakEscape, characterEscape],
        [93]: labelEnd,
        [95]: attention,
        [96]: codeText
      };
      insideSpan = {
        null: [attention, resolver]
      };
      attentionMarkers = {
        null: [42, 95]
      };
      disable = {
        null: []
      };
    }
  });

  // node_modules/micromark/lib/create-tokenizer.js
  function createTokenizer(parser, initialize, from4) {
    let point5 = {
      _bufferIndex: -1,
      _index: 0,
      line: from4 && from4.line || 1,
      column: from4 && from4.column || 1,
      offset: from4 && from4.offset || 0
    };
    const columnStart = {};
    const resolveAllConstructs = [];
    let chunks = [];
    let stack = [];
    let consumed = true;
    const effects = {
      attempt: constructFactory(onsuccessfulconstruct),
      check: constructFactory(onsuccessfulcheck),
      consume,
      enter: enter2,
      exit: exit3,
      interrupt: constructFactory(onsuccessfulcheck, {
        interrupt: true
      })
    };
    const context = {
      code: null,
      containerState: {},
      defineSkip,
      events: [],
      now,
      parser,
      previous: null,
      sliceSerialize,
      sliceStream,
      write: write2
    };
    let state = initialize.tokenize.call(context, effects);
    let expectedCode;
    if (initialize.resolveAll) {
      resolveAllConstructs.push(initialize);
    }
    return context;
    function write2(slice2) {
      chunks = push(chunks, slice2);
      main();
      if (chunks[chunks.length - 1] !== null) {
        return [];
      }
      addResult(initialize, 0);
      context.events = resolveAll(resolveAllConstructs, context.events, context);
      return context.events;
    }
    function sliceSerialize(token, expandTabs) {
      return serializeChunks(sliceStream(token), expandTabs);
    }
    function sliceStream(token) {
      return sliceChunks(chunks, token);
    }
    function now() {
      const {
        _bufferIndex,
        _index,
        line,
        column,
        offset
      } = point5;
      return {
        _bufferIndex,
        _index,
        line,
        column,
        offset
      };
    }
    function defineSkip(value) {
      columnStart[value.line] = value.column;
      accountForPotentialSkip();
    }
    function main() {
      let chunkIndex;
      while (point5._index < chunks.length) {
        const chunk = chunks[point5._index];
        if (typeof chunk === "string") {
          chunkIndex = point5._index;
          if (point5._bufferIndex < 0) {
            point5._bufferIndex = 0;
          }
          while (point5._index === chunkIndex && point5._bufferIndex < chunk.length) {
            go(chunk.charCodeAt(point5._bufferIndex));
          }
        } else {
          go(chunk);
        }
      }
    }
    function go(code5) {
      consumed = void 0;
      expectedCode = code5;
      state = state(code5);
    }
    function consume(code5) {
      if (markdownLineEnding(code5)) {
        point5.line++;
        point5.column = 1;
        point5.offset += code5 === -3 ? 2 : 1;
        accountForPotentialSkip();
      } else if (code5 !== -1) {
        point5.column++;
        point5.offset++;
      }
      if (point5._bufferIndex < 0) {
        point5._index++;
      } else {
        point5._bufferIndex++;
        if (point5._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
        // strings.
        /** @type {string} */
        chunks[point5._index].length) {
          point5._bufferIndex = -1;
          point5._index++;
        }
      }
      context.previous = code5;
      consumed = true;
    }
    function enter2(type, fields) {
      const token = fields || {};
      token.type = type;
      token.start = now();
      context.events.push(["enter", token, context]);
      stack.push(token);
      return token;
    }
    function exit3(type) {
      const token = stack.pop();
      token.end = now();
      context.events.push(["exit", token, context]);
      return token;
    }
    function onsuccessfulconstruct(construct, info) {
      addResult(construct, info.from);
    }
    function onsuccessfulcheck(_2, info) {
      info.restore();
    }
    function constructFactory(onreturn, fields) {
      return hook;
      function hook(constructs2, returnState, bogusState) {
        let listOfConstructs;
        let constructIndex;
        let currentConstruct;
        let info;
        return Array.isArray(constructs2) ? (
          /* c8 ignore next 1 */
          handleListOfConstructs(constructs2)
        ) : "tokenize" in constructs2 ? (
          // Looks like a construct.
          handleListOfConstructs([
            /** @type {Construct} */
            constructs2
          ])
        ) : handleMapOfConstructs(constructs2);
        function handleMapOfConstructs(map9) {
          return start;
          function start(code5) {
            const left = code5 !== null && map9[code5];
            const all10 = code5 !== null && map9.null;
            const list7 = [
              // To do: add more extension tests.
              /* c8 ignore next 2 */
              ...Array.isArray(left) ? left : left ? [left] : [],
              ...Array.isArray(all10) ? all10 : all10 ? [all10] : []
            ];
            return handleListOfConstructs(list7)(code5);
          }
        }
        function handleListOfConstructs(list7) {
          listOfConstructs = list7;
          constructIndex = 0;
          if (list7.length === 0) {
            return bogusState;
          }
          return handleConstruct(list7[constructIndex]);
        }
        function handleConstruct(construct) {
          return start;
          function start(code5) {
            info = store();
            currentConstruct = construct;
            if (!construct.partial) {
              context.currentConstruct = construct;
            }
            if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
              return nok(code5);
            }
            return construct.tokenize.call(
              // If we do have fields, create an object w/ `context` as its
              // prototype.
              // This allows a live binding, which is needed for `interrupt`.
              fields ? Object.assign(Object.create(context), fields) : context,
              effects,
              ok3,
              nok
            )(code5);
          }
        }
        function ok3(code5) {
          consumed = true;
          onreturn(currentConstruct, info);
          return returnState;
        }
        function nok(code5) {
          consumed = true;
          info.restore();
          if (++constructIndex < listOfConstructs.length) {
            return handleConstruct(listOfConstructs[constructIndex]);
          }
          return bogusState;
        }
      }
    }
    function addResult(construct, from5) {
      if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
        resolveAllConstructs.push(construct);
      }
      if (construct.resolve) {
        splice(context.events, from5, context.events.length - from5, construct.resolve(context.events.slice(from5), context));
      }
      if (construct.resolveTo) {
        context.events = construct.resolveTo(context.events, context);
      }
    }
    function store() {
      const startPoint = now();
      const startPrevious = context.previous;
      const startCurrentConstruct = context.currentConstruct;
      const startEventsIndex = context.events.length;
      const startStack = Array.from(stack);
      return {
        from: startEventsIndex,
        restore
      };
      function restore() {
        point5 = startPoint;
        context.previous = startPrevious;
        context.currentConstruct = startCurrentConstruct;
        context.events.length = startEventsIndex;
        stack = startStack;
        accountForPotentialSkip();
      }
    }
    function accountForPotentialSkip() {
      if (point5.line in columnStart && point5.column < 2) {
        point5.column = columnStart[point5.line];
        point5.offset += columnStart[point5.line] - 1;
      }
    }
  }
  function sliceChunks(chunks, token) {
    const startIndex = token.start._index;
    const startBufferIndex = token.start._bufferIndex;
    const endIndex = token.end._index;
    const endBufferIndex = token.end._bufferIndex;
    let view;
    if (startIndex === endIndex) {
      view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
    } else {
      view = chunks.slice(startIndex, endIndex);
      if (startBufferIndex > -1) {
        const head2 = view[0];
        if (typeof head2 === "string") {
          view[0] = head2.slice(startBufferIndex);
        } else {
          view.shift();
        }
      }
      if (endBufferIndex > 0) {
        view.push(chunks[endIndex].slice(0, endBufferIndex));
      }
    }
    return view;
  }
  function serializeChunks(chunks, expandTabs) {
    let index3 = -1;
    const result = [];
    let atTab;
    while (++index3 < chunks.length) {
      const chunk = chunks[index3];
      let value;
      if (typeof chunk === "string") {
        value = chunk;
      } else switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab) continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
      atTab = chunk === -2;
      result.push(value);
    }
    return result.join("");
  }
  var init_create_tokenizer = __esm({
    "node_modules/micromark/lib/create-tokenizer.js"() {
      init_micromark_util_character();
      init_micromark_util_chunked();
      init_micromark_util_resolve_all();
    }
  });

  // node_modules/micromark/lib/parse.js
  function parse4(options2) {
    const settings = options2 || {};
    const constructs2 = (
      /** @type {FullNormalizedExtension} */
      combineExtensions([constructs_exports, ...settings.extensions || []])
    );
    const parser = {
      constructs: constructs2,
      content: create13(content4),
      defined: [],
      document: create13(document2),
      flow: create13(flow2),
      lazy: {},
      string: create13(string),
      text: create13(text6)
    };
    return parser;
    function create13(initial) {
      return creator;
      function creator(from4) {
        return createTokenizer(parser, initial, from4);
      }
    }
  }
  var init_parse = __esm({
    "node_modules/micromark/lib/parse.js"() {
      init_micromark_util_combine_extensions();
      init_content3();
      init_document();
      init_flow();
      init_text4();
      init_constructs();
      init_create_tokenizer();
    }
  });

  // node_modules/micromark/lib/postprocess.js
  function postprocess(events) {
    while (!subtokenize(events)) {
    }
    return events;
  }
  var init_postprocess = __esm({
    "node_modules/micromark/lib/postprocess.js"() {
      init_micromark_util_subtokenize();
    }
  });

  // node_modules/micromark/lib/preprocess.js
  function preprocess() {
    let column = 1;
    let buffer = "";
    let start = true;
    let atCarriageReturn;
    return preprocessor;
    function preprocessor(value, encoding, end) {
      const chunks = [];
      let match;
      let next2;
      let startPosition;
      let endPosition;
      let code5;
      value = buffer + (typeof value === "string" ? value.toString() : new TextDecoder(encoding || void 0).decode(value));
      startPosition = 0;
      buffer = "";
      if (start) {
        if (value.charCodeAt(0) === 65279) {
          startPosition++;
        }
        start = void 0;
      }
      while (startPosition < value.length) {
        search2.lastIndex = startPosition;
        match = search2.exec(value);
        endPosition = match && match.index !== void 0 ? match.index : value.length;
        code5 = value.charCodeAt(endPosition);
        if (!match) {
          buffer = value.slice(startPosition);
          break;
        }
        if (code5 === 10 && startPosition === endPosition && atCarriageReturn) {
          chunks.push(-3);
          atCarriageReturn = void 0;
        } else {
          if (atCarriageReturn) {
            chunks.push(-5);
            atCarriageReturn = void 0;
          }
          if (startPosition < endPosition) {
            chunks.push(value.slice(startPosition, endPosition));
            column += endPosition - startPosition;
          }
          switch (code5) {
            case 0: {
              chunks.push(65533);
              column++;
              break;
            }
            case 9: {
              next2 = Math.ceil(column / 4) * 4;
              chunks.push(-2);
              while (column++ < next2) chunks.push(-1);
              break;
            }
            case 10: {
              chunks.push(-4);
              column = 1;
              break;
            }
            default: {
              atCarriageReturn = true;
              column = 1;
            }
          }
        }
        startPosition = endPosition + 1;
      }
      if (end) {
        if (atCarriageReturn) chunks.push(-5);
        if (buffer) chunks.push(buffer);
        chunks.push(null);
      }
      return chunks;
    }
  }
  var search2;
  var init_preprocess = __esm({
    "node_modules/micromark/lib/preprocess.js"() {
      search2 = /[\0\t\n\r]/g;
    }
  });

  // node_modules/micromark/index.js
  function micromark(value, encoding, options2) {
    if (typeof encoding !== "string") {
      options2 = encoding;
      encoding = void 0;
    }
    return compile(options2)(postprocess(parse4(options2).document().write(preprocess()(value, encoding, true))));
  }
  var init_micromark = __esm({
    "node_modules/micromark/index.js"() {
      init_compile();
      init_parse();
      init_postprocess();
      init_preprocess();
      init_compile();
      init_parse();
      init_postprocess();
      init_preprocess();
    }
  });

  // node_modules/mdast-util-from-markdown/lib/index.js
  function fromMarkdown(value, encoding, options2) {
    if (typeof encoding !== "string") {
      options2 = encoding;
      encoding = void 0;
    }
    return compiler(options2)(postprocess(parse4(options2).document().write(preprocess()(value, encoding, true))));
  }
  function compiler(options2) {
    const config = {
      transforms: [],
      canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
      enter: {
        autolink: opener(link3),
        autolinkProtocol: onenterdata,
        autolinkEmail: onenterdata,
        atxHeading: opener(heading4),
        blockQuote: opener(blockQuote2),
        characterEscape: onenterdata,
        characterReference: onenterdata,
        codeFenced: opener(codeFlow),
        codeFencedFenceInfo: buffer,
        codeFencedFenceMeta: buffer,
        codeIndented: opener(codeFlow, buffer),
        codeText: opener(codeText2, buffer),
        codeTextData: onenterdata,
        data: onenterdata,
        codeFlowValue: onenterdata,
        definition: opener(definition3),
        definitionDestinationString: buffer,
        definitionLabelString: buffer,
        definitionTitleString: buffer,
        emphasis: opener(emphasis3),
        hardBreakEscape: opener(hardBreak3),
        hardBreakTrailing: opener(hardBreak3),
        htmlFlow: opener(html7, buffer),
        htmlFlowData: onenterdata,
        htmlText: opener(html7, buffer),
        htmlTextData: onenterdata,
        image: opener(image3),
        label: buffer,
        link: opener(link3),
        listItem: opener(listItem4),
        listItemValue: onenterlistitemvalue,
        listOrdered: opener(list7, onenterlistordered),
        listUnordered: opener(list7),
        paragraph: opener(paragraph3),
        reference: onenterreference,
        referenceString: buffer,
        resourceDestinationString: buffer,
        resourceTitleString: buffer,
        setextHeading: opener(heading4),
        strong: opener(strong4),
        thematicBreak: opener(thematicBreak4)
      },
      exit: {
        atxHeading: closer(),
        atxHeadingSequence: onexitatxheadingsequence,
        autolink: closer(),
        autolinkEmail: onexitautolinkemail,
        autolinkProtocol: onexitautolinkprotocol,
        blockQuote: closer(),
        characterEscapeValue: onexitdata,
        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
        characterReferenceValue: onexitcharacterreferencevalue,
        characterReference: onexitcharacterreference,
        codeFenced: closer(onexitcodefenced),
        codeFencedFence: onexitcodefencedfence,
        codeFencedFenceInfo: onexitcodefencedfenceinfo,
        codeFencedFenceMeta: onexitcodefencedfencemeta,
        codeFlowValue: onexitdata,
        codeIndented: closer(onexitcodeindented),
        codeText: closer(onexitcodetext),
        codeTextData: onexitdata,
        data: onexitdata,
        definition: closer(),
        definitionDestinationString: onexitdefinitiondestinationstring,
        definitionLabelString: onexitdefinitionlabelstring,
        definitionTitleString: onexitdefinitiontitlestring,
        emphasis: closer(),
        hardBreakEscape: closer(onexithardbreak),
        hardBreakTrailing: closer(onexithardbreak),
        htmlFlow: closer(onexithtmlflow),
        htmlFlowData: onexitdata,
        htmlText: closer(onexithtmltext),
        htmlTextData: onexitdata,
        image: closer(onexitimage),
        label: onexitlabel,
        labelText: onexitlabeltext,
        lineEnding: onexitlineending,
        link: closer(onexitlink),
        listItem: closer(),
        listOrdered: closer(),
        listUnordered: closer(),
        paragraph: closer(),
        referenceString: onexitreferencestring,
        resourceDestinationString: onexitresourcedestinationstring,
        resourceTitleString: onexitresourcetitlestring,
        resource: onexitresource,
        setextHeading: closer(onexitsetextheading),
        setextHeadingLineSequence: onexitsetextheadinglinesequence,
        setextHeadingText: onexitsetextheadingtext,
        strong: closer(),
        thematicBreak: closer()
      }
    };
    configure2(config, (options2 || {}).mdastExtensions || []);
    const data = {};
    return compile2;
    function compile2(events) {
      let tree = {
        type: "root",
        children: []
      };
      const context = {
        stack: [tree],
        tokenStack: [],
        config,
        enter: enter2,
        exit: exit3,
        buffer,
        resume,
        data
      };
      const listStack = [];
      let index3 = -1;
      while (++index3 < events.length) {
        if (events[index3][1].type === "listOrdered" || events[index3][1].type === "listUnordered") {
          if (events[index3][0] === "enter") {
            listStack.push(index3);
          } else {
            const tail = listStack.pop();
            index3 = prepareList(events, tail, index3);
          }
        }
      }
      index3 = -1;
      while (++index3 < events.length) {
        const handler = config[events[index3][0]];
        if (own10.call(handler, events[index3][1].type)) {
          handler[events[index3][1].type].call(Object.assign({
            sliceSerialize: events[index3][2].sliceSerialize
          }, context), events[index3][1]);
        }
      }
      if (context.tokenStack.length > 0) {
        const tail = context.tokenStack[context.tokenStack.length - 1];
        const handler = tail[1] || defaultOnError;
        handler.call(context, void 0, tail[0]);
      }
      tree.position = {
        start: point4(events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }),
        end: point4(events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        })
      };
      index3 = -1;
      while (++index3 < config.transforms.length) {
        tree = config.transforms[index3](tree) || tree;
      }
      return tree;
    }
    function prepareList(events, start, length3) {
      let index3 = start - 1;
      let containerBalance = -1;
      let listSpread = false;
      let listItem5;
      let lineIndex;
      let firstBlankLineIndex;
      let atMarker;
      while (++index3 <= length3) {
        const event = events[index3];
        switch (event[1].type) {
          case "listUnordered":
          case "listOrdered":
          case "blockQuote": {
            if (event[0] === "enter") {
              containerBalance++;
            } else {
              containerBalance--;
            }
            atMarker = void 0;
            break;
          }
          case "lineEndingBlank": {
            if (event[0] === "enter") {
              if (listItem5 && !atMarker && !containerBalance && !firstBlankLineIndex) {
                firstBlankLineIndex = index3;
              }
              atMarker = void 0;
            }
            break;
          }
          case "linePrefix":
          case "listItemValue":
          case "listItemMarker":
          case "listItemPrefix":
          case "listItemPrefixWhitespace": {
            break;
          }
          default: {
            atMarker = void 0;
          }
        }
        if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
          if (listItem5) {
            let tailIndex = index3;
            lineIndex = void 0;
            while (tailIndex--) {
              const tailEvent = events[tailIndex];
              if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                if (tailEvent[0] === "exit") continue;
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                  listSpread = true;
                }
                tailEvent[1].type = "lineEnding";
                lineIndex = tailIndex;
              } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
              } else {
                break;
              }
            }
            if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
              listItem5._spread = true;
            }
            listItem5.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
            events.splice(lineIndex || index3, 0, ["exit", listItem5, event[2]]);
            index3++;
            length3++;
          }
          if (event[1].type === "listItemPrefix") {
            const item = {
              type: "listItem",
              _spread: false,
              start: Object.assign({}, event[1].start),
              // @ts-expect-error: well add `end` in a second.
              end: void 0
            };
            listItem5 = item;
            events.splice(index3, 0, ["enter", item, event[2]]);
            index3++;
            length3++;
            firstBlankLineIndex = void 0;
            atMarker = true;
          }
        }
      }
      events[start][1]._spread = listSpread;
      return length3;
    }
    function opener(create13, and) {
      return open;
      function open(token) {
        enter2.call(this, create13(token), token);
        if (and) and.call(this, token);
      }
    }
    function buffer() {
      this.stack.push({
        type: "fragment",
        children: []
      });
    }
    function enter2(node2, token, errorHandler) {
      const parent = this.stack[this.stack.length - 1];
      const siblings2 = parent.children;
      siblings2.push(node2);
      this.stack.push(node2);
      this.tokenStack.push([token, errorHandler || void 0]);
      node2.position = {
        start: point4(token.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      };
    }
    function closer(and) {
      return close2;
      function close2(token) {
        if (and) and.call(this, token);
        exit3.call(this, token);
      }
    }
    function exit3(token, onExitError) {
      const node2 = this.stack.pop();
      const open = this.tokenStack.pop();
      if (!open) {
        throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({
          start: token.start,
          end: token.end
        }) + "): it\u2019s not open");
      } else if (open[0].type !== token.type) {
        if (onExitError) {
          onExitError.call(this, token, open[0]);
        } else {
          const handler = open[1] || defaultOnError;
          handler.call(this, token, open[0]);
        }
      }
      node2.position.end = point4(token.end);
    }
    function resume() {
      return toString2(this.stack.pop());
    }
    function onenterlistordered() {
      this.data.expectingFirstListItemValue = true;
    }
    function onenterlistitemvalue(token) {
      if (this.data.expectingFirstListItemValue) {
        const ancestor = this.stack[this.stack.length - 2];
        ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
        this.data.expectingFirstListItemValue = void 0;
      }
    }
    function onexitcodefencedfenceinfo() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.lang = data2;
    }
    function onexitcodefencedfencemeta() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.meta = data2;
    }
    function onexitcodefencedfence() {
      if (this.data.flowCodeInside) return;
      this.buffer();
      this.data.flowCodeInside = true;
    }
    function onexitcodefenced() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
      this.data.flowCodeInside = void 0;
    }
    function onexitcodeindented() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2.replace(/(\r?\n|\r)$/g, "");
    }
    function onexitdefinitionlabelstring(token) {
      const label = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.label = label;
      node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    }
    function onexitdefinitiontitlestring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.title = data2;
    }
    function onexitdefinitiondestinationstring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.url = data2;
    }
    function onexitatxheadingsequence(token) {
      const node2 = this.stack[this.stack.length - 1];
      if (!node2.depth) {
        const depth = this.sliceSerialize(token).length;
        node2.depth = depth;
      }
    }
    function onexitsetextheadingtext() {
      this.data.setextHeadingSlurpLineEnding = true;
    }
    function onexitsetextheadinglinesequence(token) {
      const node2 = this.stack[this.stack.length - 1];
      node2.depth = this.sliceSerialize(token).codePointAt(0) === 61 ? 1 : 2;
    }
    function onexitsetextheading() {
      this.data.setextHeadingSlurpLineEnding = void 0;
    }
    function onenterdata(token) {
      const node2 = this.stack[this.stack.length - 1];
      const siblings2 = node2.children;
      let tail = siblings2[siblings2.length - 1];
      if (!tail || tail.type !== "text") {
        tail = text10();
        tail.position = {
          start: point4(token.start),
          // @ts-expect-error: well add `end` later.
          end: void 0
        };
        siblings2.push(tail);
      }
      this.stack.push(tail);
    }
    function onexitdata(token) {
      const tail = this.stack.pop();
      tail.value += this.sliceSerialize(token);
      tail.position.end = point4(token.end);
    }
    function onexitlineending(token) {
      const context = this.stack[this.stack.length - 1];
      if (this.data.atHardBreak) {
        const tail = context.children[context.children.length - 1];
        tail.position.end = point4(token.end);
        this.data.atHardBreak = void 0;
        return;
      }
      if (!this.data.setextHeadingSlurpLineEnding && config.canContainEols.includes(context.type)) {
        onenterdata.call(this, token);
        onexitdata.call(this, token);
      }
    }
    function onexithardbreak() {
      this.data.atHardBreak = true;
    }
    function onexithtmlflow() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexithtmltext() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexitcodetext() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.value = data2;
    }
    function onexitlink() {
      const node2 = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const referenceType = this.data.referenceType || "shortcut";
        node2.type += "Reference";
        node2.referenceType = referenceType;
        delete node2.url;
        delete node2.title;
      } else {
        delete node2.identifier;
        delete node2.label;
      }
      this.data.referenceType = void 0;
    }
    function onexitimage() {
      const node2 = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const referenceType = this.data.referenceType || "shortcut";
        node2.type += "Reference";
        node2.referenceType = referenceType;
        delete node2.url;
        delete node2.title;
      } else {
        delete node2.identifier;
        delete node2.label;
      }
      this.data.referenceType = void 0;
    }
    function onexitlabeltext(token) {
      const string3 = this.sliceSerialize(token);
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.label = decodeString(string3);
      ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
    }
    function onexitlabel() {
      const fragment2 = this.stack[this.stack.length - 1];
      const value = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      this.data.inReference = true;
      if (node2.type === "link") {
        const children = fragment2.children;
        node2.children = children;
      } else {
        node2.alt = value;
      }
    }
    function onexitresourcedestinationstring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.url = data2;
    }
    function onexitresourcetitlestring() {
      const data2 = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.title = data2;
    }
    function onexitresource() {
      this.data.inReference = void 0;
    }
    function onenterreference() {
      this.data.referenceType = "collapsed";
    }
    function onexitreferencestring(token) {
      const label = this.resume();
      const node2 = this.stack[this.stack.length - 1];
      node2.label = label;
      node2.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
      this.data.referenceType = "full";
    }
    function onexitcharacterreferencemarker(token) {
      this.data.characterReferenceType = token.type;
    }
    function onexitcharacterreferencevalue(token) {
      const data2 = this.sliceSerialize(token);
      const type = this.data.characterReferenceType;
      let value;
      if (type) {
        value = decodeNumericCharacterReference(data2, type === "characterReferenceMarkerNumeric" ? 10 : 16);
        this.data.characterReferenceType = void 0;
      } else {
        const result = decodeNamedCharacterReference(data2);
        value = result;
      }
      const tail = this.stack[this.stack.length - 1];
      tail.value += value;
    }
    function onexitcharacterreference(token) {
      const tail = this.stack.pop();
      tail.position.end = point4(token.end);
    }
    function onexitautolinkprotocol(token) {
      onexitdata.call(this, token);
      const node2 = this.stack[this.stack.length - 1];
      node2.url = this.sliceSerialize(token);
    }
    function onexitautolinkemail(token) {
      onexitdata.call(this, token);
      const node2 = this.stack[this.stack.length - 1];
      node2.url = "mailto:" + this.sliceSerialize(token);
    }
    function blockQuote2() {
      return {
        type: "blockquote",
        children: []
      };
    }
    function codeFlow() {
      return {
        type: "code",
        lang: null,
        meta: null,
        value: ""
      };
    }
    function codeText2() {
      return {
        type: "inlineCode",
        value: ""
      };
    }
    function definition3() {
      return {
        type: "definition",
        identifier: "",
        label: null,
        title: null,
        url: ""
      };
    }
    function emphasis3() {
      return {
        type: "emphasis",
        children: []
      };
    }
    function heading4() {
      return {
        type: "heading",
        // @ts-expect-error `depth` will be set later.
        depth: 0,
        children: []
      };
    }
    function hardBreak3() {
      return {
        type: "break"
      };
    }
    function html7() {
      return {
        type: "html",
        value: ""
      };
    }
    function image3() {
      return {
        type: "image",
        title: null,
        url: "",
        alt: null
      };
    }
    function link3() {
      return {
        type: "link",
        title: null,
        url: "",
        children: []
      };
    }
    function list7(token) {
      return {
        type: "list",
        ordered: token.type === "listOrdered",
        start: null,
        spread: token._spread,
        children: []
      };
    }
    function listItem4(token) {
      return {
        type: "listItem",
        spread: token._spread,
        checked: null,
        children: []
      };
    }
    function paragraph3() {
      return {
        type: "paragraph",
        children: []
      };
    }
    function strong4() {
      return {
        type: "strong",
        children: []
      };
    }
    function text10() {
      return {
        type: "text",
        value: ""
      };
    }
    function thematicBreak4() {
      return {
        type: "thematicBreak"
      };
    }
  }
  function point4(d) {
    return {
      line: d.line,
      column: d.column,
      offset: d.offset
    };
  }
  function configure2(combined, extensions) {
    let index3 = -1;
    while (++index3 < extensions.length) {
      const value = extensions[index3];
      if (Array.isArray(value)) {
        configure2(combined, value);
      } else {
        extension(combined, value);
      }
    }
  }
  function extension(combined, extension2) {
    let key2;
    for (key2 in extension2) {
      if (own10.call(extension2, key2)) {
        switch (key2) {
          case "canContainEols": {
            const right = extension2[key2];
            if (right) {
              combined[key2].push(...right);
            }
            break;
          }
          case "transforms": {
            const right = extension2[key2];
            if (right) {
              combined[key2].push(...right);
            }
            break;
          }
          case "enter":
          case "exit": {
            const right = extension2[key2];
            if (right) {
              Object.assign(combined[key2], right);
            }
            break;
          }
        }
      }
    }
  }
  function defaultOnError(left, right) {
    if (left) {
      throw new Error("Cannot close `" + left.type + "` (" + stringifyPosition({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is open");
    } else {
      throw new Error("Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is still open");
    }
  }
  var own10;
  var init_lib45 = __esm({
    "node_modules/mdast-util-from-markdown/lib/index.js"() {
      init_mdast_util_to_string();
      init_micromark();
      init_micromark_util_decode_numeric_character_reference();
      init_micromark_util_decode_string();
      init_micromark_util_normalize_identifier();
      init_index_dom();
      init_unist_util_stringify_position();
      own10 = {}.hasOwnProperty;
    }
  });

  // node_modules/mdast-util-from-markdown/index.js
  var init_mdast_util_from_markdown = __esm({
    "node_modules/mdast-util-from-markdown/index.js"() {
      init_lib45();
    }
  });

  // node_modules/remark-parse/lib/index.js
  function remarkParse(options2) {
    const self2 = this;
    self2.parser = parser;
    function parser(doc4) {
      return fromMarkdown(doc4, {
        ...self2.data("settings"),
        ...options2,
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: self2.data("micromarkExtensions") || [],
        mdastExtensions: self2.data("fromMarkdownExtensions") || []
      });
    }
  }
  var init_lib46 = __esm({
    "node_modules/remark-parse/lib/index.js"() {
      init_mdast_util_from_markdown();
    }
  });

  // node_modules/remark-parse/index.js
  var remark_parse_exports = {};
  __export(remark_parse_exports, {
    default: () => remarkParse
  });
  var init_remark_parse = __esm({
    "node_modules/remark-parse/index.js"() {
      init_lib46();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
  function blockquote3(state, node2) {
    const result = {
      type: "element",
      tagName: "blockquote",
      properties: {},
      children: state.wrap(state.all(node2), true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_blockquote3 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/blockquote.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/break.js
  function hardBreak2(state, node2) {
    const result = { type: "element", tagName: "br", properties: {}, children: [] };
    state.patch(node2, result);
    return [state.applyData(node2, result), { type: "text", value: "\n" }];
  }
  var init_break2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/break.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/code.js
  function code4(state, node2) {
    const value = node2.value ? node2.value + "\n" : "";
    const properties = {};
    if (node2.lang) {
      properties.className = ["language-" + node2.lang];
    }
    let result = {
      type: "element",
      tagName: "code",
      properties,
      children: [{ type: "text", value }]
    };
    if (node2.meta) {
      result.data = { meta: node2.meta };
    }
    state.patch(node2, result);
    result = state.applyData(node2, result);
    result = { type: "element", tagName: "pre", properties: {}, children: [result] };
    state.patch(node2, result);
    return result;
  }
  var init_code3 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/code.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/delete.js
  function strikethrough(state, node2) {
    const result = {
      type: "element",
      tagName: "del",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_delete = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/delete.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
  function emphasis2(state, node2) {
    const result = {
      type: "element",
      tagName: "em",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_emphasis2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/emphasis.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
  function footnoteReference2(state, node2) {
    const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
    const id2 = String(node2.identifier).toUpperCase();
    const safeId = normalizeUri(id2.toLowerCase());
    const index3 = state.footnoteOrder.indexOf(id2);
    let counter;
    let reuseCounter = state.footnoteCounts.get(id2);
    if (reuseCounter === void 0) {
      reuseCounter = 0;
      state.footnoteOrder.push(id2);
      counter = state.footnoteOrder.length;
    } else {
      counter = index3 + 1;
    }
    reuseCounter += 1;
    state.footnoteCounts.set(id2, reuseCounter);
    const link3 = {
      type: "element",
      tagName: "a",
      properties: {
        href: "#" + clobberPrefix + "fn-" + safeId,
        id: clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
        dataFootnoteRef: true,
        ariaDescribedBy: ["footnote-label"]
      },
      children: [{ type: "text", value: String(counter) }]
    };
    state.patch(node2, link3);
    const sup = {
      type: "element",
      tagName: "sup",
      properties: {},
      children: [link3]
    };
    state.patch(node2, sup);
    return state.applyData(node2, sup);
  }
  var init_footnote_reference = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js"() {
      init_micromark_util_sanitize_uri();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/heading.js
  function heading3(state, node2) {
    const result = {
      type: "element",
      tagName: "h" + node2.depth,
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_heading3 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/heading.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/html.js
  function html6(state, node2) {
    if (state.options.allowDangerousHtml) {
      const result = { type: "raw", value: node2.value };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    return void 0;
  }
  var init_html9 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/html.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/revert.js
  function revert(state, node2) {
    const subtype = node2.referenceType;
    let suffix = "]";
    if (subtype === "collapsed") {
      suffix += "[]";
    } else if (subtype === "full") {
      suffix += "[" + (node2.label || node2.identifier) + "]";
    }
    if (node2.type === "imageReference") {
      return [{ type: "text", value: "![" + node2.alt + suffix }];
    }
    const contents = state.all(node2);
    const head2 = contents[0];
    if (head2 && head2.type === "text") {
      head2.value = "[" + head2.value;
    } else {
      contents.unshift({ type: "text", value: "[" });
    }
    const tail = contents[contents.length - 1];
    if (tail && tail.type === "text") {
      tail.value += suffix;
    } else {
      contents.push({ type: "text", value: suffix });
    }
    return contents;
  }
  var init_revert = __esm({
    "node_modules/mdast-util-to-hast/lib/revert.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
  function imageReference2(state, node2) {
    const id2 = String(node2.identifier).toUpperCase();
    const definition3 = state.definitionById.get(id2);
    if (!definition3) {
      return revert(state, node2);
    }
    const properties = { src: normalizeUri(definition3.url || ""), alt: node2.alt };
    if (definition3.title !== null && definition3.title !== void 0) {
      properties.title = definition3.title;
    }
    const result = { type: "element", tagName: "img", properties, children: [] };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_image_reference2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/image-reference.js"() {
      init_micromark_util_sanitize_uri();
      init_revert();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/image.js
  function image2(state, node2) {
    const properties = { src: normalizeUri(node2.url) };
    if (node2.alt !== null && node2.alt !== void 0) {
      properties.alt = node2.alt;
    }
    if (node2.title !== null && node2.title !== void 0) {
      properties.title = node2.title;
    }
    const result = { type: "element", tagName: "img", properties, children: [] };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_image2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/image.js"() {
      init_micromark_util_sanitize_uri();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
  function inlineCode3(state, node2) {
    const text10 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
    state.patch(node2, text10);
    const result = {
      type: "element",
      tagName: "code",
      properties: {},
      children: [text10]
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_inline_code3 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/inline-code.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
  function linkReference2(state, node2) {
    const id2 = String(node2.identifier).toUpperCase();
    const definition3 = state.definitionById.get(id2);
    if (!definition3) {
      return revert(state, node2);
    }
    const properties = { href: normalizeUri(definition3.url || "") };
    if (definition3.title !== null && definition3.title !== void 0) {
      properties.title = definition3.title;
    }
    const result = {
      type: "element",
      tagName: "a",
      properties,
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_link_reference2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/link-reference.js"() {
      init_micromark_util_sanitize_uri();
      init_revert();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/link.js
  function link2(state, node2) {
    const properties = { href: normalizeUri(node2.url) };
    if (node2.title !== null && node2.title !== void 0) {
      properties.title = node2.title;
    }
    const result = {
      type: "element",
      tagName: "a",
      properties,
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_link2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/link.js"() {
      init_micromark_util_sanitize_uri();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/list-item.js
  function listItem2(state, node2, parent) {
    const results = state.all(node2);
    const loose = parent ? listLoose(parent) : listItemLoose(node2);
    const properties = {};
    const children = [];
    if (typeof node2.checked === "boolean") {
      const head2 = results[0];
      let paragraph3;
      if (head2 && head2.type === "element" && head2.tagName === "p") {
        paragraph3 = head2;
      } else {
        paragraph3 = { type: "element", tagName: "p", properties: {}, children: [] };
        results.unshift(paragraph3);
      }
      if (paragraph3.children.length > 0) {
        paragraph3.children.unshift({ type: "text", value: " " });
      }
      paragraph3.children.unshift({
        type: "element",
        tagName: "input",
        properties: { type: "checkbox", checked: node2.checked, disabled: true },
        children: []
      });
      properties.className = ["task-list-item"];
    }
    let index3 = -1;
    while (++index3 < results.length) {
      const child = results[index3];
      if (loose || index3 !== 0 || child.type !== "element" || child.tagName !== "p") {
        children.push({ type: "text", value: "\n" });
      }
      if (child.type === "element" && child.tagName === "p" && !loose) {
        children.push(...child.children);
      } else {
        children.push(child);
      }
    }
    const tail = results[results.length - 1];
    if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
      children.push({ type: "text", value: "\n" });
    }
    const result = { type: "element", tagName: "li", properties, children };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function listLoose(node2) {
    let loose = false;
    if (node2.type === "list") {
      loose = node2.spread || false;
      const children = node2.children;
      let index3 = -1;
      while (!loose && ++index3 < children.length) {
        loose = listItemLoose(children[index3]);
      }
    }
    return loose;
  }
  function listItemLoose(node2) {
    const spread = node2.spread;
    return spread === null || spread === void 0 ? node2.children.length > 1 : spread;
  }
  var init_list_item2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/list-item.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/list.js
  function list6(state, node2) {
    const properties = {};
    const results = state.all(node2);
    let index3 = -1;
    if (typeof node2.start === "number" && node2.start !== 1) {
      properties.start = node2.start;
    }
    while (++index3 < results.length) {
      const child = results[index3];
      if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
        properties.className = ["contains-task-list"];
        break;
      }
    }
    const result = {
      type: "element",
      tagName: node2.ordered ? "ol" : "ul",
      properties,
      children: state.wrap(results, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_list4 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/list.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
  function paragraph2(state, node2) {
    const result = {
      type: "element",
      tagName: "p",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_paragraph2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/paragraph.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/root.js
  function root5(state, node2) {
    const result = { type: "root", children: state.wrap(state.all(node2)) };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_root4 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/root.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/strong.js
  function strong3(state, node2) {
    const result = {
      type: "element",
      tagName: "strong",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_strong3 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/strong.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/table.js
  function table2(state, node2) {
    const rows = state.all(node2);
    const firstRow = rows.shift();
    const tableContent = [];
    if (firstRow) {
      const head2 = {
        type: "element",
        tagName: "thead",
        properties: {},
        children: state.wrap([firstRow], true)
      };
      state.patch(node2.children[0], head2);
      tableContent.push(head2);
    }
    if (rows.length > 0) {
      const body3 = {
        type: "element",
        tagName: "tbody",
        properties: {},
        children: state.wrap(rows, true)
      };
      const start = pointStart(node2.children[1]);
      const end = pointEnd(node2.children[node2.children.length - 1]);
      if (start && end) body3.position = { start, end };
      tableContent.push(body3);
    }
    const result = {
      type: "element",
      tagName: "table",
      properties: {},
      children: state.wrap(tableContent, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_table2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/table.js"() {
      init_unist_util_position();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/table-row.js
  function tableRow2(state, node2, parent) {
    const siblings2 = parent ? parent.children : void 0;
    const rowIndex = siblings2 ? siblings2.indexOf(node2) : 1;
    const tagName = rowIndex === 0 ? "th" : "td";
    const align = parent && parent.type === "table" ? parent.align : void 0;
    const length3 = align ? align.length : node2.children.length;
    let cellIndex = -1;
    const cells2 = [];
    while (++cellIndex < length3) {
      const cell2 = node2.children[cellIndex];
      const properties = {};
      const alignValue = align ? align[cellIndex] : void 0;
      if (alignValue) {
        properties.align = alignValue;
      }
      let result2 = { type: "element", tagName, properties, children: [] };
      if (cell2) {
        result2.children = state.all(cell2);
        state.patch(cell2, result2);
        result2 = state.applyData(cell2, result2);
      }
      cells2.push(result2);
    }
    const result = {
      type: "element",
      tagName: "tr",
      properties: {},
      children: state.wrap(cells2, true)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_table_row2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/table-row.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/table-cell.js
  function tableCell2(state, node2) {
    const result = {
      type: "element",
      tagName: "td",
      // Assume body cell.
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_table_cell2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/table-cell.js"() {
      "";
    }
  });

  // node_modules/trim-lines/index.js
  function trimLines(value) {
    const source = String(value);
    const search3 = /\r?\n|\r/g;
    let match = search3.exec(source);
    let last2 = 0;
    const lines = [];
    while (match) {
      lines.push(
        trimLine(source.slice(last2, match.index), last2 > 0, true),
        match[0]
      );
      last2 = match.index + match[0].length;
      match = search3.exec(source);
    }
    lines.push(trimLine(source.slice(last2), last2 > 0, false));
    return lines.join("");
  }
  function trimLine(value, start, end) {
    let startIndex = 0;
    let endIndex = value.length;
    if (start) {
      let code5 = value.codePointAt(startIndex);
      while (code5 === tab || code5 === space) {
        startIndex++;
        code5 = value.codePointAt(startIndex);
      }
    }
    if (end) {
      let code5 = value.codePointAt(endIndex - 1);
      while (code5 === tab || code5 === space) {
        endIndex--;
        code5 = value.codePointAt(endIndex - 1);
      }
    }
    return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
  }
  var tab, space;
  var init_trim_lines = __esm({
    "node_modules/trim-lines/index.js"() {
      tab = 9;
      space = 32;
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/text.js
  function text8(state, node2) {
    const result = { type: "text", value: trimLines(String(node2.value)) };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_text5 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/text.js"() {
      init_trim_lines();
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
  function thematicBreak3(state, node2) {
    const result = {
      type: "element",
      tagName: "hr",
      properties: {},
      children: []
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  var init_thematic_break3 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js"() {
      "";
    }
  });

  // node_modules/mdast-util-to-hast/lib/handlers/index.js
  function ignore2() {
    return void 0;
  }
  var handlers2;
  var init_handlers2 = __esm({
    "node_modules/mdast-util-to-hast/lib/handlers/index.js"() {
      init_blockquote3();
      init_break2();
      init_code3();
      init_delete();
      init_emphasis2();
      init_footnote_reference();
      init_heading3();
      init_html9();
      init_image_reference2();
      init_image2();
      init_inline_code3();
      init_link_reference2();
      init_link2();
      init_list_item2();
      init_list4();
      init_paragraph2();
      init_root4();
      init_strong3();
      init_table2();
      init_table_row2();
      init_table_cell2();
      init_text5();
      init_thematic_break3();
      handlers2 = {
        blockquote: blockquote3,
        break: hardBreak2,
        code: code4,
        delete: strikethrough,
        emphasis: emphasis2,
        footnoteReference: footnoteReference2,
        heading: heading3,
        html: html6,
        imageReference: imageReference2,
        image: image2,
        inlineCode: inlineCode3,
        linkReference: linkReference2,
        link: link2,
        listItem: listItem2,
        list: list6,
        paragraph: paragraph2,
        // @ts-expect-error: root is different, but hard to type.
        root: root5,
        strong: strong3,
        table: table2,
        tableCell: tableCell2,
        tableRow: tableRow2,
        text: text8,
        thematicBreak: thematicBreak3,
        toml: ignore2,
        yaml: ignore2,
        definition: ignore2,
        footnoteDefinition: ignore2
      };
    }
  });

  // node_modules/mdast-util-to-hast/lib/footer.js
  function defaultFootnoteBackContent(_2, rereferenceIndex) {
    const result = [{ type: "text", value: "\u21A9" }];
    if (rereferenceIndex > 1) {
      result.push({
        type: "element",
        tagName: "sup",
        properties: {},
        children: [{ type: "text", value: String(rereferenceIndex) }]
      });
    }
    return result;
  }
  function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {
    return "Back to reference " + (referenceIndex + 1) + (rereferenceIndex > 1 ? "-" + rereferenceIndex : "");
  }
  function footer(state) {
    const clobberPrefix = typeof state.options.clobberPrefix === "string" ? state.options.clobberPrefix : "user-content-";
    const footnoteBackContent = state.options.footnoteBackContent || defaultFootnoteBackContent;
    const footnoteBackLabel = state.options.footnoteBackLabel || defaultFootnoteBackLabel;
    const footnoteLabel = state.options.footnoteLabel || "Footnotes";
    const footnoteLabelTagName = state.options.footnoteLabelTagName || "h2";
    const footnoteLabelProperties = state.options.footnoteLabelProperties || {
      className: ["sr-only"]
    };
    const listItems = [];
    let referenceIndex = -1;
    while (++referenceIndex < state.footnoteOrder.length) {
      const definition3 = state.footnoteById.get(
        state.footnoteOrder[referenceIndex]
      );
      if (!definition3) {
        continue;
      }
      const content5 = state.all(definition3);
      const id2 = String(definition3.identifier).toUpperCase();
      const safeId = normalizeUri(id2.toLowerCase());
      let rereferenceIndex = 0;
      const backReferences = [];
      const counts = state.footnoteCounts.get(id2);
      while (counts !== void 0 && ++rereferenceIndex <= counts) {
        if (backReferences.length > 0) {
          backReferences.push({ type: "text", value: " " });
        }
        let children = typeof footnoteBackContent === "string" ? footnoteBackContent : footnoteBackContent(referenceIndex, rereferenceIndex);
        if (typeof children === "string") {
          children = { type: "text", value: children };
        }
        backReferences.push({
          type: "element",
          tagName: "a",
          properties: {
            href: "#" + clobberPrefix + "fnref-" + safeId + (rereferenceIndex > 1 ? "-" + rereferenceIndex : ""),
            dataFootnoteBackref: "",
            ariaLabel: typeof footnoteBackLabel === "string" ? footnoteBackLabel : footnoteBackLabel(referenceIndex, rereferenceIndex),
            className: ["data-footnote-backref"]
          },
          children: Array.isArray(children) ? children : [children]
        });
      }
      const tail = content5[content5.length - 1];
      if (tail && tail.type === "element" && tail.tagName === "p") {
        const tailTail = tail.children[tail.children.length - 1];
        if (tailTail && tailTail.type === "text") {
          tailTail.value += " ";
        } else {
          tail.children.push({ type: "text", value: " " });
        }
        tail.children.push(...backReferences);
      } else {
        content5.push(...backReferences);
      }
      const listItem4 = {
        type: "element",
        tagName: "li",
        properties: { id: clobberPrefix + "fn-" + safeId },
        children: state.wrap(content5, true)
      };
      state.patch(definition3, listItem4);
      listItems.push(listItem4);
    }
    if (listItems.length === 0) {
      return;
    }
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: true, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: footnoteLabelTagName,
          properties: {
            ...esm_default(footnoteLabelProperties),
            id: "footnote-label"
          },
          children: [{ type: "text", value: footnoteLabel }]
        },
        { type: "text", value: "\n" },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: state.wrap(listItems, true)
        },
        { type: "text", value: "\n" }
      ]
    };
  }
  var init_footer = __esm({
    "node_modules/mdast-util-to-hast/lib/footer.js"() {
      init_esm();
      init_micromark_util_sanitize_uri();
    }
  });

  // node_modules/mdast-util-to-hast/lib/state.js
  function createState2(tree, options2) {
    const settings = options2 || emptyOptions8;
    const definitionById = /* @__PURE__ */ new Map();
    const footnoteById = /* @__PURE__ */ new Map();
    const footnoteCounts = /* @__PURE__ */ new Map();
    const handlers4 = { ...handlers2, ...settings.handlers };
    const state = {
      all: all10,
      applyData,
      definitionById,
      footnoteById,
      footnoteCounts,
      footnoteOrder: [],
      handlers: handlers4,
      one: one6,
      options: settings,
      patch: patch3,
      wrap: wrap3
    };
    visit(tree, function(node2) {
      if (node2.type === "definition" || node2.type === "footnoteDefinition") {
        const map9 = node2.type === "definition" ? definitionById : footnoteById;
        const id2 = String(node2.identifier).toUpperCase();
        if (!map9.has(id2)) {
          map9.set(id2, node2);
        }
      }
    });
    return state;
    function one6(node2, parent) {
      const type = node2.type;
      const handle4 = state.handlers[type];
      if (own11.call(state.handlers, type) && handle4) {
        return handle4(state, node2, parent);
      }
      if (state.options.passThrough && state.options.passThrough.includes(type)) {
        if ("children" in node2) {
          const { children, ...shallow } = node2;
          const result = esm_default(shallow);
          result.children = state.all(node2);
          return result;
        }
        return esm_default(node2);
      }
      const unknown3 = state.options.unknownHandler || defaultUnknownHandler;
      return unknown3(state, node2, parent);
    }
    function all10(parent) {
      const values = [];
      if ("children" in parent) {
        const nodes = parent.children;
        let index3 = -1;
        while (++index3 < nodes.length) {
          const result = state.one(nodes[index3], parent);
          if (result) {
            if (index3 && nodes[index3 - 1].type === "break") {
              if (!Array.isArray(result) && result.type === "text") {
                result.value = trimMarkdownSpaceStart(result.value);
              }
              if (!Array.isArray(result) && result.type === "element") {
                const head2 = result.children[0];
                if (head2 && head2.type === "text") {
                  head2.value = trimMarkdownSpaceStart(head2.value);
                }
              }
            }
            if (Array.isArray(result)) {
              values.push(...result);
            } else {
              values.push(result);
            }
          }
        }
      }
      return values;
    }
  }
  function patch3(from4, to2) {
    if (from4.position) to2.position = position3(from4);
  }
  function applyData(from4, to2) {
    let result = to2;
    if (from4 && from4.data) {
      const hName = from4.data.hName;
      const hChildren = from4.data.hChildren;
      const hProperties = from4.data.hProperties;
      if (typeof hName === "string") {
        if (result.type === "element") {
          result.tagName = hName;
        } else {
          const children = "children" in result ? result.children : [result];
          result = { type: "element", tagName: hName, properties: {}, children };
        }
      }
      if (result.type === "element" && hProperties) {
        Object.assign(result.properties, esm_default(hProperties));
      }
      if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
        result.children = hChildren;
      }
    }
    return result;
  }
  function defaultUnknownHandler(state, node2) {
    const data = node2.data || {};
    const result = "value" in node2 && !(own11.call(data, "hProperties") || own11.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
      type: "element",
      tagName: "div",
      properties: {},
      children: state.all(node2)
    };
    state.patch(node2, result);
    return state.applyData(node2, result);
  }
  function wrap3(nodes, loose) {
    const result = [];
    let index3 = -1;
    if (loose) {
      result.push({ type: "text", value: "\n" });
    }
    while (++index3 < nodes.length) {
      if (index3) result.push({ type: "text", value: "\n" });
      result.push(nodes[index3]);
    }
    if (loose && nodes.length > 0) {
      result.push({ type: "text", value: "\n" });
    }
    return result;
  }
  function trimMarkdownSpaceStart(value) {
    let index3 = 0;
    let code5 = value.charCodeAt(index3);
    while (code5 === 9 || code5 === 32) {
      index3++;
      code5 = value.charCodeAt(index3);
    }
    return value.slice(index3);
  }
  var own11, emptyOptions8;
  var init_state2 = __esm({
    "node_modules/mdast-util-to-hast/lib/state.js"() {
      init_esm();
      init_unist_util_visit();
      init_unist_util_position();
      init_handlers2();
      own11 = {}.hasOwnProperty;
      emptyOptions8 = {};
    }
  });

  // node_modules/mdast-util-to-hast/lib/index.js
  function toHast(tree, options2) {
    const state = createState2(tree, options2);
    const node2 = state.one(tree, void 0);
    const foot = footer(state);
    const result = Array.isArray(node2) ? { type: "root", children: node2 } : node2 || { type: "root", children: [] };
    if (foot) {
      ok("children" in result);
      result.children.push({ type: "text", value: "\n" }, foot);
    }
    return result;
  }
  var init_lib47 = __esm({
    "node_modules/mdast-util-to-hast/lib/index.js"() {
      init_default();
      init_footer();
      init_state2();
    }
  });

  // node_modules/mdast-util-to-hast/index.js
  var init_mdast_util_to_hast = __esm({
    "node_modules/mdast-util-to-hast/index.js"() {
      init_handlers2();
      init_lib47();
      init_footer();
    }
  });

  // node_modules/remark-rehype/lib/index.js
  function remarkRehype(destination, options2) {
    if (destination && "run" in destination) {
      return async function(tree, file) {
        const hastTree = (
          /** @type {HastRoot} */
          toHast(tree, { file, ...options2 })
        );
        await destination.run(hastTree, file);
      };
    }
    return function(tree, file) {
      return (
        /** @type {HastRoot} */
        toHast(tree, { file, ...destination || options2 })
      );
    };
  }
  var init_lib48 = __esm({
    "node_modules/remark-rehype/lib/index.js"() {
      init_mdast_util_to_hast();
    }
  });

  // node_modules/remark-rehype/index.js
  var remark_rehype_exports = {};
  __export(remark_rehype_exports, {
    default: () => remarkRehype,
    defaultFootnoteBackContent: () => defaultFootnoteBackContent,
    defaultFootnoteBackLabel: () => defaultFootnoteBackLabel,
    defaultHandlers: () => handlers2
  });
  var init_remark_rehype = __esm({
    "node_modules/remark-rehype/index.js"() {
      init_mdast_util_to_hast();
      init_lib48();
    }
  });

  // node_modules/html-whitespace-sensitive-tag-names/lib/index.js
  var whitespaceSensitiveTagNames;
  var init_lib49 = __esm({
    "node_modules/html-whitespace-sensitive-tag-names/lib/index.js"() {
      whitespaceSensitiveTagNames = [
        "pre",
        "script",
        "style",
        "textarea"
      ];
    }
  });

  // node_modules/html-whitespace-sensitive-tag-names/index.js
  var init_html_whitespace_sensitive_tag_names = __esm({
    "node_modules/html-whitespace-sensitive-tag-names/index.js"() {
      init_lib49();
    }
  });

  // node_modules/hast-util-format/lib/index.js
  function format(tree, options2) {
    const settings = options2 || emptyOptions9;
    const state = {
      blanks: settings.blanks || [],
      head: false,
      indentInitial: settings.indentInitial !== false,
      indent: typeof settings.indent === "number" ? " ".repeat(settings.indent) : typeof settings.indent === "string" ? settings.indent : "  "
    };
    minifyWhitespace(tree, { newlines: true });
    visitParents(tree, visitor);
    function visitor(node2, parents) {
      if (!("children" in node2)) {
        return;
      }
      if (node2.type === "element" && node2.tagName === "head") {
        state.head = true;
      }
      if (state.head && node2.type === "element" && node2.tagName === "body") {
        state.head = false;
      }
      if (node2.type === "element" && whitespaceSensitiveTagNames.includes(node2.tagName)) {
        return SKIP;
      }
      if (node2.children.length === 0 || !padding(state, node2)) {
        return;
      }
      let level = parents.length;
      if (!state.indentInitial) {
        level--;
      }
      let eol2 = false;
      for (const child of node2.children) {
        if (child.type === "comment" || child.type === "text") {
          if (child.value.includes("\n")) {
            eol2 = true;
          }
          child.value = child.value.replace(
            / *\n/g,
            "$&" + state.indent.repeat(level)
          );
        }
      }
      const result = [];
      let previous3;
      for (const child of node2.children) {
        if (padding(state, child) || eol2 && !previous3) {
          addBreak(result, level, child);
          eol2 = true;
        }
        previous3 = child;
        result.push(child);
      }
      if (previous3 && (eol2 || padding(state, previous3))) {
        if (whitespace(previous3)) {
          result.pop();
          previous3 = result[result.length - 1];
        }
        addBreak(result, level - 1);
      }
      node2.children = result;
    }
    function addBreak(list7, level, next2) {
      const tail = list7[list7.length - 1];
      const previous3 = tail && whitespace(tail) ? list7[list7.length - 2] : tail;
      const replace4 = (blank(state, previous3) && blank(state, next2) ? "\n\n" : "\n") + state.indent.repeat(Math.max(level, 0));
      if (tail && tail.type === "text") {
        tail.value = whitespace(tail) ? replace4 : tail.value + replace4;
      } else {
        list7.push({ type: "text", value: replace4 });
      }
    }
  }
  function blank(state, node2) {
    return Boolean(
      node2 && node2.type === "element" && state.blanks.length > 0 && state.blanks.includes(node2.tagName)
    );
  }
  function padding(state, node2) {
    return node2.type === "root" || (node2.type === "element" ? state.head || node2.tagName === "script" || embedded(node2) || !phrasing(node2) : false);
  }
  var emptyOptions9;
  var init_lib50 = __esm({
    "node_modules/hast-util-format/lib/index.js"() {
      init_hast_util_embedded();
      init_hast_util_minify_whitespace();
      init_hast_util_phrasing();
      init_hast_util_whitespace();
      init_html_whitespace_sensitive_tag_names();
      init_unist_util_visit_parents();
      emptyOptions9 = {};
    }
  });

  // node_modules/hast-util-format/index.js
  var init_hast_util_format = __esm({
    "node_modules/hast-util-format/index.js"() {
      init_lib50();
    }
  });

  // node_modules/rehype-format/lib/index.js
  function rehypeFormat(options2) {
    return function(tree) {
      format(tree, options2);
    };
  }
  var init_lib51 = __esm({
    "node_modules/rehype-format/lib/index.js"() {
      init_hast_util_format();
    }
  });

  // node_modules/rehype-format/index.js
  var rehype_format_exports = {};
  __export(rehype_format_exports, {
    default: () => rehypeFormat
  });
  var init_rehype_format = __esm({
    "node_modules/rehype-format/index.js"() {
      init_lib51();
    }
  });

  // node_modules/emoji-mart/dist/module.js
  var module_exports = {};
  __export(module_exports, {
    Data: () => $7adb23b0109cc36a$export$2d0294657ab35f1b,
    Emoji: () => $331b4160623139bf$export$2e2bcd8739ae039,
    FrequentlyUsed: () => $b22cfd0a55410b4f$export$2e2bcd8739ae039,
    I18n: () => $7adb23b0109cc36a$export$dbe3113d60765c1a,
    Picker: () => $efa000751917694d$export$2e2bcd8739ae039,
    SafeFlags: () => $e6eae5155b87f591$export$bcb25aa587e9cb13,
    SearchIndex: () => $c4d155af13ad4d4b$export$2e2bcd8739ae039,
    Store: () => $f72b75cf796873c7$export$2e2bcd8739ae039,
    getEmojiDataFromNative: () => $693b183b0a78708f$export$5ef5574deca44bc0,
    init: () => $7adb23b0109cc36a$export$2cd8252107eb640b
  });
  function $parcel$interopDefault(a2) {
    return a2 && a2.__esModule ? a2.default : a2;
  }
  function $c770c458706daa72$export$2e2bcd8739ae039(obj, key2, value) {
    if (key2 in obj) Object.defineProperty(obj, key2, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    else obj[key2] = value;
    return obj;
  }
  function $fb96b826c0c5f37a$var$a(n1, l1) {
    for (var u1 in l1) n1[u1] = l1[u1];
    return n1;
  }
  function $fb96b826c0c5f37a$var$h(n2) {
    var l2 = n2.parentNode;
    l2 && l2.removeChild(n2);
  }
  function $fb96b826c0c5f37a$export$c8a8987d4410bf2d(l3, u2, i1) {
    var t1, r1, o1, f1 = {};
    for (o1 in u2) "key" == o1 ? t1 = u2[o1] : "ref" == o1 ? r1 = u2[o1] : f1[o1] = u2[o1];
    if (arguments.length > 2 && (f1.children = arguments.length > 3 ? $fb96b826c0c5f37a$var$n.call(arguments, 2) : i1), "function" == typeof l3 && null != l3.defaultProps) for (o1 in l3.defaultProps) void 0 === f1[o1] && (f1[o1] = l3.defaultProps[o1]);
    return $fb96b826c0c5f37a$var$y(l3, f1, t1, r1, null);
  }
  function $fb96b826c0c5f37a$var$y(n3, i2, t2, r2, o2) {
    var f2 = {
      type: n3,
      props: i2,
      key: t2,
      ref: r2,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == o2 ? ++$fb96b826c0c5f37a$var$u : o2
    };
    return null == o2 && null != $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode && $fb96b826c0c5f37a$export$41c562ebe57d11e2.vnode(f2), f2;
  }
  function $fb96b826c0c5f37a$export$7d1e3a5e95ceca43() {
    return {
      current: null
    };
  }
  function $fb96b826c0c5f37a$export$ffb0004e005737fa(n4) {
    return n4.children;
  }
  function $fb96b826c0c5f37a$export$16fa2f45be04daa8(n5, l4) {
    this.props = n5, this.context = l4;
  }
  function $fb96b826c0c5f37a$var$k(n6, l5) {
    if (null == l5) return n6.__ ? $fb96b826c0c5f37a$var$k(n6.__, n6.__.__k.indexOf(n6) + 1) : null;
    for (var u3; l5 < n6.__k.length; l5++) if (null != (u3 = n6.__k[l5]) && null != u3.__e) return u3.__e;
    return "function" == typeof n6.type ? $fb96b826c0c5f37a$var$k(n6) : null;
  }
  function $fb96b826c0c5f37a$var$b(n7) {
    var l6, u4;
    if (null != (n7 = n7.__) && null != n7.__c) {
      for (n7.__e = n7.__c.base = null, l6 = 0; l6 < n7.__k.length; l6++) if (null != (u4 = n7.__k[l6]) && null != u4.__e) {
        n7.__e = n7.__c.base = u4.__e;
        break;
      }
      return $fb96b826c0c5f37a$var$b(n7);
    }
  }
  function $fb96b826c0c5f37a$var$m(n8) {
    (!n8.__d && (n8.__d = true) && $fb96b826c0c5f37a$var$t.push(n8) && !$fb96b826c0c5f37a$var$g.__r++ || $fb96b826c0c5f37a$var$o !== $fb96b826c0c5f37a$export$41c562ebe57d11e2.debounceRendering) && (($fb96b826c0c5f37a$var$o = $fb96b826c0c5f37a$export$41c562ebe57d11e2.debounceRendering) || $fb96b826c0c5f37a$var$r)($fb96b826c0c5f37a$var$g);
  }
  function $fb96b826c0c5f37a$var$g() {
    for (var n9; $fb96b826c0c5f37a$var$g.__r = $fb96b826c0c5f37a$var$t.length; ) n9 = $fb96b826c0c5f37a$var$t.sort(function(n10, l7) {
      return n10.__v.__b - l7.__v.__b;
    }), $fb96b826c0c5f37a$var$t = [], n9.some(function(n11) {
      var l8, u5, i3, t3, r3, o3;
      n11.__d && (r3 = (t3 = (l8 = n11).__v).__e, (o3 = l8.__P) && (u5 = [], (i3 = $fb96b826c0c5f37a$var$a({}, t3)).__v = t3.__v + 1, $fb96b826c0c5f37a$var$j(o3, t3, i3, l8.__n, void 0 !== o3.ownerSVGElement, null != t3.__h ? [
        r3
      ] : null, u5, null == r3 ? $fb96b826c0c5f37a$var$k(t3) : r3, t3.__h), $fb96b826c0c5f37a$var$z(u5, t3), t3.__e != r3 && $fb96b826c0c5f37a$var$b(t3)));
    });
  }
  function $fb96b826c0c5f37a$var$w(n12, l9, u6, i4, t4, r4, o4, f3, s1, a1) {
    var h1, v1, p1, _1, b1, m1, g1, w1 = i4 && i4.__k || $fb96b826c0c5f37a$var$c, A1 = w1.length;
    for (u6.__k = [], h1 = 0; h1 < l9.length; h1++) if (null != (_1 = u6.__k[h1] = null == (_1 = l9[h1]) || "boolean" == typeof _1 ? null : "string" == typeof _1 || "number" == typeof _1 || "bigint" == typeof _1 ? $fb96b826c0c5f37a$var$y(null, _1, null, null, _1) : Array.isArray(_1) ? $fb96b826c0c5f37a$var$y($fb96b826c0c5f37a$export$ffb0004e005737fa, {
      children: _1
    }, null, null, null) : _1.__b > 0 ? $fb96b826c0c5f37a$var$y(_1.type, _1.props, _1.key, null, _1.__v) : _1)) {
      if (_1.__ = u6, _1.__b = u6.__b + 1, null === (p1 = w1[h1]) || p1 && _1.key == p1.key && _1.type === p1.type) w1[h1] = void 0;
      else for (v1 = 0; v1 < A1; v1++) {
        if ((p1 = w1[v1]) && _1.key == p1.key && _1.type === p1.type) {
          w1[v1] = void 0;
          break;
        }
        p1 = null;
      }
      $fb96b826c0c5f37a$var$j(n12, _1, p1 = p1 || $fb96b826c0c5f37a$var$e, t4, r4, o4, f3, s1, a1), b1 = _1.__e, (v1 = _1.ref) && p1.ref != v1 && (g1 || (g1 = []), p1.ref && g1.push(p1.ref, null, _1), g1.push(v1, _1.__c || b1, _1)), null != b1 ? (null == m1 && (m1 = b1), "function" == typeof _1.type && _1.__k === p1.__k ? _1.__d = s1 = $fb96b826c0c5f37a$var$x(_1, s1, n12) : s1 = $fb96b826c0c5f37a$var$P(n12, _1, p1, w1, b1, s1), "function" == typeof u6.type && (u6.__d = s1)) : s1 && p1.__e == s1 && s1.parentNode != n12 && (s1 = $fb96b826c0c5f37a$var$k(p1));
    }
    for (u6.__e = m1, h1 = A1; h1--; ) null != w1[h1] && ("function" == typeof u6.type && null != w1[h1].__e && w1[h1].__e == u6.__d && (u6.__d = $fb96b826c0c5f37a$var$k(i4, h1 + 1)), $fb96b826c0c5f37a$var$N(w1[h1], w1[h1]));
    if (g1) for (h1 = 0; h1 < g1.length; h1++) $fb96b826c0c5f37a$var$M(g1[h1], g1[++h1], g1[++h1]);
  }
  function $fb96b826c0c5f37a$var$x(n13, l10, u7) {
    for (var i5, t5 = n13.__k, r5 = 0; t5 && r5 < t5.length; r5++) (i5 = t5[r5]) && (i5.__ = n13, l10 = "function" == typeof i5.type ? $fb96b826c0c5f37a$var$x(i5, l10, u7) : $fb96b826c0c5f37a$var$P(u7, i5, i5, t5, i5.__e, l10));
    return l10;
  }
  function $fb96b826c0c5f37a$export$47e4c5b300681277(n14, l11) {
    return l11 = l11 || [], null == n14 || "boolean" == typeof n14 || (Array.isArray(n14) ? n14.some(function(n15) {
      $fb96b826c0c5f37a$export$47e4c5b300681277(n15, l11);
    }) : l11.push(n14)), l11;
  }
  function $fb96b826c0c5f37a$var$P(n16, l12, u8, i6, t6, r6) {
    var o5, f4, e1;
    if (void 0 !== l12.__d) o5 = l12.__d, l12.__d = void 0;
    else if (null == u8 || t6 != r6 || null == t6.parentNode) n: if (null == r6 || r6.parentNode !== n16) n16.appendChild(t6), o5 = null;
    else {
      for (f4 = r6, e1 = 0; (f4 = f4.nextSibling) && e1 < i6.length; e1 += 2) if (f4 == t6) break n;
      n16.insertBefore(t6, r6), o5 = r6;
    }
    return void 0 !== o5 ? o5 : t6.nextSibling;
  }
  function $fb96b826c0c5f37a$var$C(n17, l13, u9, i7, t7) {
    var r7;
    for (r7 in u9) "children" === r7 || "key" === r7 || r7 in l13 || $fb96b826c0c5f37a$var$H(n17, r7, null, u9[r7], i7);
    for (r7 in l13) t7 && "function" != typeof l13[r7] || "children" === r7 || "key" === r7 || "value" === r7 || "checked" === r7 || u9[r7] === l13[r7] || $fb96b826c0c5f37a$var$H(n17, r7, l13[r7], u9[r7], i7);
  }
  function $fb96b826c0c5f37a$var$$(n18, l14, u10) {
    "-" === l14[0] ? n18.setProperty(l14, u10) : n18[l14] = null == u10 ? "" : "number" != typeof u10 || $fb96b826c0c5f37a$var$s.test(l14) ? u10 : u10 + "px";
  }
  function $fb96b826c0c5f37a$var$H(n19, l15, u11, i8, t8) {
    var r8;
    n: if ("style" === l15) {
      if ("string" == typeof u11) n19.style.cssText = u11;
      else {
        if ("string" == typeof i8 && (n19.style.cssText = i8 = ""), i8) for (l15 in i8) u11 && l15 in u11 || $fb96b826c0c5f37a$var$$(n19.style, l15, "");
        if (u11) for (l15 in u11) i8 && u11[l15] === i8[l15] || $fb96b826c0c5f37a$var$$(n19.style, l15, u11[l15]);
      }
    } else if ("o" === l15[0] && "n" === l15[1]) r8 = l15 !== (l15 = l15.replace(/Capture$/, "")), l15 = l15.toLowerCase() in n19 ? l15.toLowerCase().slice(2) : l15.slice(2), n19.l || (n19.l = {}), n19.l[l15 + r8] = u11, u11 ? i8 || n19.addEventListener(l15, r8 ? $fb96b826c0c5f37a$var$T : $fb96b826c0c5f37a$var$I, r8) : n19.removeEventListener(l15, r8 ? $fb96b826c0c5f37a$var$T : $fb96b826c0c5f37a$var$I, r8);
    else if ("dangerouslySetInnerHTML" !== l15) {
      if (t8) l15 = l15.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
      else if ("href" !== l15 && "list" !== l15 && "form" !== l15 && "tabIndex" !== l15 && "download" !== l15 && l15 in n19) try {
        n19[l15] = null == u11 ? "" : u11;
        break n;
      } catch (n) {
      }
      "function" == typeof u11 || (null != u11 && (false !== u11 || "a" === l15[0] && "r" === l15[1]) ? n19.setAttribute(l15, u11) : n19.removeAttribute(l15));
    }
  }
  function $fb96b826c0c5f37a$var$I(n20) {
    this.l[n20.type + false]($fb96b826c0c5f37a$export$41c562ebe57d11e2.event ? $fb96b826c0c5f37a$export$41c562ebe57d11e2.event(n20) : n20);
  }
  function $fb96b826c0c5f37a$var$T(n21) {
    this.l[n21.type + true]($fb96b826c0c5f37a$export$41c562ebe57d11e2.event ? $fb96b826c0c5f37a$export$41c562ebe57d11e2.event(n21) : n21);
  }
  function $fb96b826c0c5f37a$var$j(n22, u12, i9, t9, r9, o6, f5, e2, c1) {
    var s2, h2, v2, y1, p22, k1, b2, m2, g2, x1, A2, P1 = u12.type;
    if (void 0 !== u12.constructor) return null;
    null != i9.__h && (c1 = i9.__h, e2 = u12.__e = i9.__e, u12.__h = null, o6 = [
      e2
    ]), (s2 = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__b) && s2(u12);
    try {
      n: if ("function" == typeof P1) {
        if (m2 = u12.props, g2 = (s2 = P1.contextType) && t9[s2.__c], x1 = s2 ? g2 ? g2.props.value : s2.__ : t9, i9.__c ? b2 = (h2 = u12.__c = i9.__c).__ = h2.__E : ("prototype" in P1 && P1.prototype.render ? u12.__c = h2 = new P1(m2, x1) : (u12.__c = h2 = new $fb96b826c0c5f37a$export$16fa2f45be04daa8(m2, x1), h2.constructor = P1, h2.render = $fb96b826c0c5f37a$var$O), g2 && g2.sub(h2), h2.props = m2, h2.state || (h2.state = {}), h2.context = x1, h2.__n = t9, v2 = h2.__d = true, h2.__h = []), null == h2.__s && (h2.__s = h2.state), null != P1.getDerivedStateFromProps && (h2.__s == h2.state && (h2.__s = $fb96b826c0c5f37a$var$a({}, h2.__s)), $fb96b826c0c5f37a$var$a(h2.__s, P1.getDerivedStateFromProps(m2, h2.__s))), y1 = h2.props, p22 = h2.state, v2) null == P1.getDerivedStateFromProps && null != h2.componentWillMount && h2.componentWillMount(), null != h2.componentDidMount && h2.__h.push(h2.componentDidMount);
        else {
          if (null == P1.getDerivedStateFromProps && m2 !== y1 && null != h2.componentWillReceiveProps && h2.componentWillReceiveProps(m2, x1), !h2.__e && null != h2.shouldComponentUpdate && false === h2.shouldComponentUpdate(m2, h2.__s, x1) || u12.__v === i9.__v) {
            h2.props = m2, h2.state = h2.__s, u12.__v !== i9.__v && (h2.__d = false), h2.__v = u12, u12.__e = i9.__e, u12.__k = i9.__k, u12.__k.forEach(function(n23) {
              n23 && (n23.__ = u12);
            }), h2.__h.length && f5.push(h2);
            break n;
          }
          null != h2.componentWillUpdate && h2.componentWillUpdate(m2, h2.__s, x1), null != h2.componentDidUpdate && h2.__h.push(function() {
            h2.componentDidUpdate(y1, p22, k1);
          });
        }
        h2.context = x1, h2.props = m2, h2.state = h2.__s, (s2 = $fb96b826c0c5f37a$export$41c562ebe57d11e2.__r) && s2(u12), h2.__d = false, h2.__v = u12, h2.__P = n22, s2 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s, null != h2.getChildContext && (t9 = $fb96b826c0c5f37a$var$a($fb96b826c0c5f37a$var$a({}, t9), h2.getChildContext())), v2 || null == h2.getSnapshotBeforeUpdate || (k1 = h2.getSnapshotBeforeUpdate(y1, p22)), A2 = null != s2 && s2.type === $fb96b826c0c5f37a$export$ffb0004e005737fa && null == s2.key ? s2.props.children : s2, $fb96b826c0c5f37a$var$w(n22, Array.isArray(A2) ? A2 : [
          A2
        ], u12, i9, t9, r9, o6, f5, e2, c1), h2.base = u12.__e, u12.__h = null, h2.__h.length && f5.push(h2), b2 && (h2.__E = h2.__ = null), h2.__e = false;
      } else null == o6 && u12.__v === i9.__v ? (u12.__k = i9.__k, u12.__e = i9.__e) : u12.__e = $fb96b826c0c5f37a$var$L(i9.__e, u12, i9, t9, r9, o6, f5, c1);
      (s2 = $fb96b826c0c5f37a$export$41c562ebe57d11e2.diffed) && s2(u12);
    } catch (n24) {
      u12.__v = null, (c1 || null != o6) && (u12.__e = e2, u12.__h = !!c1, o6[o6.indexOf(e2)] = null), $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n24, u12, i9);
    }
  }
  function $fb96b826c0c5f37a$var$z(n25, u13) {
    $fb96b826c0c5f37a$export$41c562ebe57d11e2.__c && $fb96b826c0c5f37a$export$41c562ebe57d11e2.__c(u13, n25), n25.some(function(u14) {
      try {
        n25 = u14.__h, u14.__h = [], n25.some(function(n26) {
          n26.call(u14);
        });
      } catch (n27) {
        $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n27, u14.__v);
      }
    });
  }
  function $fb96b826c0c5f37a$var$L(l16, u15, i10, t10, r10, o7, f6, c2) {
    var s3, a2, v3, y2 = i10.props, p32 = u15.props, d1 = u15.type, _2 = 0;
    if ("svg" === d1 && (r10 = true), null != o7) {
      for (; _2 < o7.length; _2++) if ((s3 = o7[_2]) && "setAttribute" in s3 == !!d1 && (d1 ? s3.localName === d1 : 3 === s3.nodeType)) {
        l16 = s3, o7[_2] = null;
        break;
      }
    }
    if (null == l16) {
      if (null === d1) return document.createTextNode(p32);
      l16 = r10 ? document.createElementNS("http://www.w3.org/2000/svg", d1) : document.createElement(d1, p32.is && p32), o7 = null, c2 = false;
    }
    if (null === d1) y2 === p32 || c2 && l16.data === p32 || (l16.data = p32);
    else {
      if (o7 = o7 && $fb96b826c0c5f37a$var$n.call(l16.childNodes), a2 = (y2 = i10.props || $fb96b826c0c5f37a$var$e).dangerouslySetInnerHTML, v3 = p32.dangerouslySetInnerHTML, !c2) {
        if (null != o7) for (y2 = {}, _2 = 0; _2 < l16.attributes.length; _2++) y2[l16.attributes[_2].name] = l16.attributes[_2].value;
        (v3 || a2) && (v3 && (a2 && v3.__html == a2.__html || v3.__html === l16.innerHTML) || (l16.innerHTML = v3 && v3.__html || ""));
      }
      if ($fb96b826c0c5f37a$var$C(l16, p32, y2, r10, c2), v3) u15.__k = [];
      else if (_2 = u15.props.children, $fb96b826c0c5f37a$var$w(l16, Array.isArray(_2) ? _2 : [
        _2
      ], u15, i10, t10, r10 && "foreignObject" !== d1, o7, f6, o7 ? o7[0] : i10.__k && $fb96b826c0c5f37a$var$k(i10, 0), c2), null != o7) for (_2 = o7.length; _2--; ) null != o7[_2] && $fb96b826c0c5f37a$var$h(o7[_2]);
      c2 || ("value" in p32 && void 0 !== (_2 = p32.value) && (_2 !== y2.value || _2 !== l16.value || "progress" === d1 && !_2) && $fb96b826c0c5f37a$var$H(l16, "value", _2, y2.value, false), "checked" in p32 && void 0 !== (_2 = p32.checked) && _2 !== l16.checked && $fb96b826c0c5f37a$var$H(l16, "checked", _2, y2.checked, false));
    }
    return l16;
  }
  function $fb96b826c0c5f37a$var$M(n28, u16, i11) {
    try {
      "function" == typeof n28 ? n28(u16) : n28.current = u16;
    } catch (n29) {
      $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n29, i11);
    }
  }
  function $fb96b826c0c5f37a$var$N(n30, u17, i12) {
    var t11, r11;
    if ($fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount && $fb96b826c0c5f37a$export$41c562ebe57d11e2.unmount(n30), (t11 = n30.ref) && (t11.current && t11.current !== n30.__e || $fb96b826c0c5f37a$var$M(t11, null, u17)), null != (t11 = n30.__c)) {
      if (t11.componentWillUnmount) try {
        t11.componentWillUnmount();
      } catch (n31) {
        $fb96b826c0c5f37a$export$41c562ebe57d11e2.__e(n31, u17);
      }
      t11.base = t11.__P = null;
    }
    if (t11 = n30.__k) for (r11 = 0; r11 < t11.length; r11++) t11[r11] && $fb96b826c0c5f37a$var$N(t11[r11], u17, "function" != typeof n30.type);
    i12 || null == n30.__e || $fb96b826c0c5f37a$var$h(n30.__e), n30.__e = n30.__d = void 0;
  }
  function $fb96b826c0c5f37a$var$O(n32, l, u18) {
    return this.constructor(n32, u18);
  }
  function $fb96b826c0c5f37a$export$b3890eb0ae9dca99(u19, i13, t12) {
    var r12, o8, f7;
    $fb96b826c0c5f37a$export$41c562ebe57d11e2.__ && $fb96b826c0c5f37a$export$41c562ebe57d11e2.__(u19, i13), o8 = (r12 = "function" == typeof t12) ? null : t12 && t12.__k || i13.__k, f7 = [], $fb96b826c0c5f37a$var$j(i13, u19 = (!r12 && t12 || i13).__k = $fb96b826c0c5f37a$export$c8a8987d4410bf2d($fb96b826c0c5f37a$export$ffb0004e005737fa, null, [
      u19
    ]), o8 || $fb96b826c0c5f37a$var$e, $fb96b826c0c5f37a$var$e, void 0 !== i13.ownerSVGElement, !r12 && t12 ? [
      t12
    ] : o8 ? null : i13.firstChild ? $fb96b826c0c5f37a$var$n.call(i13.childNodes) : null, f7, !r12 && t12 ? t12 : o8 ? o8.__e : i13.firstChild, r12), $fb96b826c0c5f37a$var$z(f7, u19);
  }
  function $fb96b826c0c5f37a$export$fa8d919ba61d84db(n33, l17) {
    $fb96b826c0c5f37a$export$b3890eb0ae9dca99(n33, l17, $fb96b826c0c5f37a$export$fa8d919ba61d84db);
  }
  function $fb96b826c0c5f37a$export$e530037191fcd5d7(l18, u20, i14) {
    var t13, r13, o9, f8 = $fb96b826c0c5f37a$var$a({}, l18.props);
    for (o9 in u20) "key" == o9 ? t13 = u20[o9] : "ref" == o9 ? r13 = u20[o9] : f8[o9] = u20[o9];
    return arguments.length > 2 && (f8.children = arguments.length > 3 ? $fb96b826c0c5f37a$var$n.call(arguments, 2) : i14), $fb96b826c0c5f37a$var$y(l18.type, f8, t13 || l18.key, r13 || l18.ref, null);
  }
  function $fb96b826c0c5f37a$export$fd42f52fd3ae1109(n34, l19) {
    var u21 = {
      __c: l19 = "__cC" + $fb96b826c0c5f37a$var$f++,
      __: n34,
      Consumer: function(n35, l20) {
        return n35.children(l20);
      },
      Provider: function(n36) {
        var u22, i15;
        return this.getChildContext || (u22 = [], (i15 = {})[l19] = this, this.getChildContext = function() {
          return i15;
        }, this.shouldComponentUpdate = function(n37) {
          this.props.value !== n37.value && u22.some($fb96b826c0c5f37a$var$m);
        }, this.sub = function(n38) {
          u22.push(n38);
          var l21 = n38.componentWillUnmount;
          n38.componentWillUnmount = function() {
            u22.splice(u22.indexOf(n38), 1), l21 && l21.call(n38);
          };
        }), n36.children;
      }
    };
    return u21.Provider.__ = u21.Consumer.contextType = u21;
  }
  function $bd9dd35321b03dd4$export$34b9dba7ce09269b(_1, e1, n, t2, f) {
    var l, s2, u = {};
    for (s2 in e1) "ref" == s2 ? l = e1[s2] : u[s2] = e1[s2];
    var a2 = {
      type: _1,
      props: u,
      key: n,
      ref: l,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: --$bd9dd35321b03dd4$var$o,
      __source: t2,
      __self: f
    };
    if ("function" == typeof _1 && (l = _1.defaultProps)) for (s2 in l) void 0 === u[s2] && (u[s2] = l[s2]);
    return (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).vnode && (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).vnode(a2), a2;
  }
  function $f72b75cf796873c7$var$set(key2, value) {
    try {
      window.localStorage[`emoji-mart.${key2}`] = JSON.stringify(value);
    } catch (error) {
    }
  }
  function $f72b75cf796873c7$var$get(key2) {
    try {
      const value = window.localStorage[`emoji-mart.${key2}`];
      if (value) return JSON.parse(value);
    } catch (error) {
    }
  }
  function $c84d045dcc34faf5$var$latestVersion() {
    for (const { v: v2, emoji: emoji2 } of $c84d045dcc34faf5$var$VERSIONS) {
      if ($c84d045dcc34faf5$var$isSupported(emoji2)) return v2;
    }
  }
  function $c84d045dcc34faf5$var$noCountryFlags() {
    if ($c84d045dcc34faf5$var$isSupported("\u{1F1E8}\u{1F1E6}")) return false;
    return true;
  }
  function $c84d045dcc34faf5$var$isSupported(emoji2) {
    if ($c84d045dcc34faf5$var$CACHE.has(emoji2)) return $c84d045dcc34faf5$var$CACHE.get(emoji2);
    const supported = $c84d045dcc34faf5$var$isEmojiSupported(emoji2);
    $c84d045dcc34faf5$var$CACHE.set(emoji2, supported);
    return supported;
  }
  function $b22cfd0a55410b4f$var$add(emoji2) {
    $b22cfd0a55410b4f$var$Index || ($b22cfd0a55410b4f$var$Index = (0, $f72b75cf796873c7$export$2e2bcd8739ae039).get("frequently") || {});
    const emojiId = emoji2.id || emoji2;
    if (!emojiId) return;
    $b22cfd0a55410b4f$var$Index[emojiId] || ($b22cfd0a55410b4f$var$Index[emojiId] = 0);
    $b22cfd0a55410b4f$var$Index[emojiId] += 1;
    (0, $f72b75cf796873c7$export$2e2bcd8739ae039).set("last", emojiId);
    (0, $f72b75cf796873c7$export$2e2bcd8739ae039).set("frequently", $b22cfd0a55410b4f$var$Index);
  }
  function $b22cfd0a55410b4f$var$get({ maxFrequentRows, perLine }) {
    if (!maxFrequentRows) return [];
    $b22cfd0a55410b4f$var$Index || ($b22cfd0a55410b4f$var$Index = (0, $f72b75cf796873c7$export$2e2bcd8739ae039).get("frequently"));
    let emojiIds = [];
    if (!$b22cfd0a55410b4f$var$Index) {
      $b22cfd0a55410b4f$var$Index = {};
      for (let i in $b22cfd0a55410b4f$var$DEFAULTS.slice(0, perLine)) {
        const emojiId = $b22cfd0a55410b4f$var$DEFAULTS[i];
        $b22cfd0a55410b4f$var$Index[emojiId] = perLine - i;
        emojiIds.push(emojiId);
      }
      return emojiIds;
    }
    const max2 = maxFrequentRows * perLine;
    const last2 = (0, $f72b75cf796873c7$export$2e2bcd8739ae039).get("last");
    for (let emojiId in $b22cfd0a55410b4f$var$Index) emojiIds.push(emojiId);
    emojiIds.sort((a2, b) => {
      const aScore = $b22cfd0a55410b4f$var$Index[b];
      const bScore = $b22cfd0a55410b4f$var$Index[a2];
      if (aScore == bScore) return a2.localeCompare(b);
      return aScore - bScore;
    });
    if (emojiIds.length > max2) {
      const removedIds = emojiIds.slice(max2);
      emojiIds = emojiIds.slice(0, max2);
      for (let removedId of removedIds) {
        if (removedId == last2) continue;
        delete $b22cfd0a55410b4f$var$Index[removedId];
      }
      if (last2 && emojiIds.indexOf(last2) == -1) {
        delete $b22cfd0a55410b4f$var$Index[emojiIds[emojiIds.length - 1]];
        emojiIds.splice(-1, 1, last2);
      }
      (0, $f72b75cf796873c7$export$2e2bcd8739ae039).set("frequently", $b22cfd0a55410b4f$var$Index);
    }
    return emojiIds;
  }
  async function $7adb23b0109cc36a$var$fetchJSON(src) {
    if ($7adb23b0109cc36a$var$fetchCache[src]) return $7adb23b0109cc36a$var$fetchCache[src];
    const response = await fetch(src);
    const json = await response.json();
    $7adb23b0109cc36a$var$fetchCache[src] = json;
    return json;
  }
  function $7adb23b0109cc36a$export$2cd8252107eb640b(options2, { caller } = {}) {
    $7adb23b0109cc36a$var$promise || ($7adb23b0109cc36a$var$promise = new Promise((resolve3) => {
      $7adb23b0109cc36a$var$initCallback = resolve3;
    }));
    if (options2) $7adb23b0109cc36a$var$_init(options2);
    else if (caller && !$7adb23b0109cc36a$var$initialized) console.warn(`\`${caller}\` requires data to be initialized first. Promise will be pending until \`init\` is called.`);
    return $7adb23b0109cc36a$var$promise;
  }
  async function $7adb23b0109cc36a$var$_init(props) {
    $7adb23b0109cc36a$var$initialized = true;
    let { emojiVersion, set: set2, locale } = props;
    emojiVersion || (emojiVersion = (0, $b247ea80b67298d5$export$2e2bcd8739ae039).emojiVersion.value);
    set2 || (set2 = (0, $b247ea80b67298d5$export$2e2bcd8739ae039).set.value);
    locale || (locale = (0, $b247ea80b67298d5$export$2e2bcd8739ae039).locale.value);
    if (!$7adb23b0109cc36a$export$2d0294657ab35f1b) {
      $7adb23b0109cc36a$export$2d0294657ab35f1b = (typeof props.data === "function" ? await props.data() : props.data) || await $7adb23b0109cc36a$var$fetchJSON(`https://cdn.jsdelivr.net/npm/@emoji-mart/data@latest/sets/${emojiVersion}/${set2}.json`);
      $7adb23b0109cc36a$export$2d0294657ab35f1b.emoticons = {};
      $7adb23b0109cc36a$export$2d0294657ab35f1b.natives = {};
      $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.unshift({
        id: "frequent",
        emojis: []
      });
      for (const alias in $7adb23b0109cc36a$export$2d0294657ab35f1b.aliases) {
        const emojiId = $7adb23b0109cc36a$export$2d0294657ab35f1b.aliases[alias];
        const emoji2 = $7adb23b0109cc36a$export$2d0294657ab35f1b.emojis[emojiId];
        if (!emoji2) continue;
        emoji2.aliases || (emoji2.aliases = []);
        emoji2.aliases.push(alias);
      }
      $7adb23b0109cc36a$export$2d0294657ab35f1b.originalCategories = $7adb23b0109cc36a$export$2d0294657ab35f1b.categories;
    } else $7adb23b0109cc36a$export$2d0294657ab35f1b.categories = $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.filter((c) => {
      const isCustom = !!c.name;
      if (!isCustom) return true;
      return false;
    });
    $7adb23b0109cc36a$export$dbe3113d60765c1a = (typeof props.i18n === "function" ? await props.i18n() : props.i18n) || (locale == "en" ? (0, /* @__PURE__ */ $parcel$interopDefault($8d50d93417ef682a$exports)) : await $7adb23b0109cc36a$var$fetchJSON(`https://cdn.jsdelivr.net/npm/@emoji-mart/data@latest/i18n/${locale}.json`));
    if (props.custom) for (let i in props.custom) {
      i = parseInt(i);
      const category = props.custom[i];
      const prevCategory = props.custom[i - 1];
      if (!category.emojis || !category.emojis.length) continue;
      category.id || (category.id = `custom_${i + 1}`);
      category.name || (category.name = $7adb23b0109cc36a$export$dbe3113d60765c1a.categories.custom);
      if (prevCategory && !category.icon) category.target = prevCategory.target || prevCategory;
      $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.push(category);
      for (const emoji2 of category.emojis) $7adb23b0109cc36a$export$2d0294657ab35f1b.emojis[emoji2.id] = emoji2;
    }
    if (props.categories) $7adb23b0109cc36a$export$2d0294657ab35f1b.categories = $7adb23b0109cc36a$export$2d0294657ab35f1b.originalCategories.filter((c) => {
      return props.categories.indexOf(c.id) != -1;
    }).sort((c1, c2) => {
      const i1 = props.categories.indexOf(c1.id);
      const i2 = props.categories.indexOf(c2.id);
      return i1 - i2;
    });
    let latestVersionSupport = null;
    let noCountryFlags = null;
    if (set2 == "native") {
      latestVersionSupport = (0, $c84d045dcc34faf5$export$2e2bcd8739ae039).latestVersion();
      noCountryFlags = props.noCountryFlags || (0, $c84d045dcc34faf5$export$2e2bcd8739ae039).noCountryFlags();
    }
    let categoryIndex = $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.length;
    let resetSearchIndex = false;
    while (categoryIndex--) {
      const category = $7adb23b0109cc36a$export$2d0294657ab35f1b.categories[categoryIndex];
      if (category.id == "frequent") {
        let { maxFrequentRows, perLine } = props;
        maxFrequentRows = maxFrequentRows >= 0 ? maxFrequentRows : (0, $b247ea80b67298d5$export$2e2bcd8739ae039).maxFrequentRows.value;
        perLine || (perLine = (0, $b247ea80b67298d5$export$2e2bcd8739ae039).perLine.value);
        category.emojis = (0, $b22cfd0a55410b4f$export$2e2bcd8739ae039).get({
          maxFrequentRows,
          perLine
        });
      }
      if (!category.emojis || !category.emojis.length) {
        $7adb23b0109cc36a$export$2d0294657ab35f1b.categories.splice(categoryIndex, 1);
        continue;
      }
      const { categoryIcons } = props;
      if (categoryIcons) {
        const icon = categoryIcons[category.id];
        if (icon && !category.icon) category.icon = icon;
      }
      let emojiIndex = category.emojis.length;
      while (emojiIndex--) {
        const emojiId = category.emojis[emojiIndex];
        const emoji2 = emojiId.id ? emojiId : $7adb23b0109cc36a$export$2d0294657ab35f1b.emojis[emojiId];
        const ignore3 = () => {
          category.emojis.splice(emojiIndex, 1);
        };
        if (!emoji2 || props.exceptEmojis && props.exceptEmojis.includes(emoji2.id)) {
          ignore3();
          continue;
        }
        if (latestVersionSupport && emoji2.version > latestVersionSupport) {
          ignore3();
          continue;
        }
        if (noCountryFlags && category.id == "flags") {
          if (!(0, $e6eae5155b87f591$export$bcb25aa587e9cb13).includes(emoji2.id)) {
            ignore3();
            continue;
          }
        }
        if (!emoji2.search) {
          resetSearchIndex = true;
          emoji2.search = "," + [
            [
              emoji2.id,
              false
            ],
            [
              emoji2.name,
              true
            ],
            [
              emoji2.keywords,
              false
            ],
            [
              emoji2.emoticons,
              false
            ]
          ].map(([strings, split3]) => {
            if (!strings) return;
            return (Array.isArray(strings) ? strings : [
              strings
            ]).map((string3) => {
              return (split3 ? string3.split(/[-|_|\s]+/) : [
                string3
              ]).map((s2) => s2.toLowerCase());
            }).flat();
          }).flat().filter((a2) => a2 && a2.trim()).join(",");
          if (emoji2.emoticons) for (const emoticon of emoji2.emoticons) {
            if ($7adb23b0109cc36a$export$2d0294657ab35f1b.emoticons[emoticon]) continue;
            $7adb23b0109cc36a$export$2d0294657ab35f1b.emoticons[emoticon] = emoji2.id;
          }
          let skinIndex = 0;
          for (const skin of emoji2.skins) {
            if (!skin) continue;
            skinIndex++;
            const { native } = skin;
            if (native) {
              $7adb23b0109cc36a$export$2d0294657ab35f1b.natives[native] = emoji2.id;
              emoji2.search += `,${native}`;
            }
            const skinShortcodes = skinIndex == 1 ? "" : `:skin-tone-${skinIndex}:`;
            skin.shortcodes = `:${emoji2.id}:${skinShortcodes}`;
          }
        }
      }
    }
    if (resetSearchIndex) (0, $c4d155af13ad4d4b$export$2e2bcd8739ae039).reset();
    $7adb23b0109cc36a$var$initCallback();
  }
  function $7adb23b0109cc36a$export$75fe5f91d452f94b(props, defaultProps, element7) {
    props || (props = {});
    const _props = {};
    for (let k in defaultProps) _props[k] = $7adb23b0109cc36a$export$88c9ddb45cea7241(k, props, defaultProps, element7);
    return _props;
  }
  function $7adb23b0109cc36a$export$88c9ddb45cea7241(propName, props, defaultProps, element7) {
    const defaults3 = defaultProps[propName];
    let value = element7 && element7.getAttribute(propName) || (props[propName] != null && props[propName] != void 0 ? props[propName] : null);
    if (!defaults3) return value;
    if (value != null && defaults3.value && typeof defaults3.value != typeof value) {
      if (typeof defaults3.value == "boolean") value = value == "false" ? false : true;
      else value = defaults3.value.constructor(value);
    }
    if (defaults3.transform && value) value = defaults3.transform(value);
    if (value == null || defaults3.choices && defaults3.choices.indexOf(value) == -1) value = defaults3.value;
    return value;
  }
  function $c4d155af13ad4d4b$var$get(emojiId) {
    if (emojiId.id) return emojiId;
    return (0, $7adb23b0109cc36a$export$2d0294657ab35f1b).emojis[emojiId] || (0, $7adb23b0109cc36a$export$2d0294657ab35f1b).emojis[(0, $7adb23b0109cc36a$export$2d0294657ab35f1b).aliases[emojiId]] || (0, $7adb23b0109cc36a$export$2d0294657ab35f1b).emojis[(0, $7adb23b0109cc36a$export$2d0294657ab35f1b).natives[emojiId]];
  }
  function $c4d155af13ad4d4b$var$reset() {
    $c4d155af13ad4d4b$var$Pool = null;
  }
  async function $c4d155af13ad4d4b$var$search(value, { maxResults, caller } = {}) {
    if (!value || !value.trim().length) return null;
    maxResults || (maxResults = 90);
    await (0, $7adb23b0109cc36a$export$2cd8252107eb640b)(null, {
      caller: caller || "SearchIndex.search"
    });
    const values = value.toLowerCase().replace(/(\w)-/, "$1 ").split(/[\s|,]+/).filter((word, i, words) => {
      return word.trim() && words.indexOf(word) == i;
    });
    if (!values.length) return;
    let pool = $c4d155af13ad4d4b$var$Pool || ($c4d155af13ad4d4b$var$Pool = Object.values((0, $7adb23b0109cc36a$export$2d0294657ab35f1b).emojis));
    let results, scores;
    for (const value1 of values) {
      if (!pool.length) break;
      results = [];
      scores = {};
      for (const emoji2 of pool) {
        if (!emoji2.search) continue;
        const score = emoji2.search.indexOf(`,${value1}`);
        if (score == -1) continue;
        results.push(emoji2);
        scores[emoji2.id] || (scores[emoji2.id] = 0);
        scores[emoji2.id] += emoji2.id == value1 ? 0 : score + 1;
      }
      pool = results;
    }
    if (results.length < 2) return results;
    results.sort((a2, b) => {
      const aScore = scores[a2.id];
      const bScore = scores[b.id];
      if (aScore == bScore) return a2.id.localeCompare(b.id);
      return aScore - bScore;
    });
    if (results.length > maxResults) results = results.slice(0, maxResults);
    return results;
  }
  function $693b183b0a78708f$export$9cb4719e2e525b7a(a2, b) {
    return Array.isArray(a2) && Array.isArray(b) && a2.length === b.length && a2.every((val, index3) => val == b[index3]);
  }
  async function $693b183b0a78708f$export$e772c8ff12451969(frames = 1) {
    for (let _2 in [
      ...Array(frames).keys()
    ]) await new Promise(requestAnimationFrame);
  }
  function $693b183b0a78708f$export$d10ac59fbe52a745(emoji2, { skinIndex = 0 } = {}) {
    const skin = emoji2.skins[skinIndex] || (() => {
      skinIndex = 0;
      return emoji2.skins[skinIndex];
    })();
    const emojiData = {
      id: emoji2.id,
      name: emoji2.name,
      native: skin.native,
      unified: skin.unified,
      keywords: emoji2.keywords,
      shortcodes: skin.shortcodes || emoji2.shortcodes
    };
    if (emoji2.skins.length > 1) emojiData.skin = skinIndex + 1;
    if (skin.src) emojiData.src = skin.src;
    if (emoji2.aliases && emoji2.aliases.length) emojiData.aliases = emoji2.aliases;
    if (emoji2.emoticons && emoji2.emoticons.length) emojiData.emoticons = emoji2.emoticons;
    return emojiData;
  }
  async function $693b183b0a78708f$export$5ef5574deca44bc0(nativeString) {
    const results = await (0, $c4d155af13ad4d4b$export$2e2bcd8739ae039).search(nativeString, {
      maxResults: 1,
      caller: "getEmojiDataFromNative"
    });
    if (!results || !results.length) return null;
    const emoji2 = results[0];
    let skinIndex = 0;
    for (let skin of emoji2.skins) {
      if (skin.native == nativeString) break;
      skinIndex++;
    }
    return $693b183b0a78708f$export$d10ac59fbe52a745(emoji2, {
      skinIndex
    });
  }
  function $254755d3f438722f$export$2e2bcd8739ae039(props) {
    let { id: id2, skin, emoji: emoji2 } = props;
    if (props.shortcodes) {
      const matches2 = props.shortcodes.match((0, $c4d155af13ad4d4b$export$2e2bcd8739ae039).SHORTCODES_REGEX);
      if (matches2) {
        id2 = matches2[1];
        if (matches2[2]) skin = matches2[2];
      }
    }
    emoji2 || (emoji2 = (0, $c4d155af13ad4d4b$export$2e2bcd8739ae039).get(id2 || props.native));
    if (!emoji2) return props.fallback;
    const emojiSkin = emoji2.skins[skin - 1] || emoji2.skins[0];
    const imageSrc = emojiSkin.src || (props.set != "native" && !props.spritesheet ? typeof props.getImageURL === "function" ? props.getImageURL(props.set, emojiSkin.unified) : `https://cdn.jsdelivr.net/npm/emoji-datasource-${props.set}@15.0.1/img/${props.set}/64/${emojiSkin.unified}.png` : void 0);
    const spritesheetSrc = typeof props.getSpritesheetURL === "function" ? props.getSpritesheetURL(props.set) : `https://cdn.jsdelivr.net/npm/emoji-datasource-${props.set}@15.0.1/img/${props.set}/sheets-256/64.png`;
    return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("span", {
      class: "emoji-mart-emoji",
      "data-emoji-set": props.set,
      children: imageSrc ? /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("img", {
        style: {
          maxWidth: props.size || "1em",
          maxHeight: props.size || "1em",
          display: "inline-block"
        },
        alt: emojiSkin.native || emojiSkin.shortcodes,
        src: imageSrc
      }) : props.set == "native" ? /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("span", {
        style: {
          fontSize: props.size,
          fontFamily: '"EmojiMart", "Segoe UI Emoji", "Segoe UI Symbol", "Segoe UI", "Apple Color Emoji", "Twemoji Mozilla", "Noto Color Emoji", "Android Emoji"'
        },
        children: emojiSkin.native
      }) : /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("span", {
        style: {
          display: "block",
          width: props.size,
          height: props.size,
          backgroundImage: `url(${spritesheetSrc})`,
          backgroundSize: `${100 * (0, $7adb23b0109cc36a$export$2d0294657ab35f1b).sheet.cols}% ${100 * (0, $7adb23b0109cc36a$export$2d0294657ab35f1b).sheet.rows}%`,
          backgroundPosition: `${100 / ((0, $7adb23b0109cc36a$export$2d0294657ab35f1b).sheet.cols - 1) * emojiSkin.x}% ${100 / ((0, $7adb23b0109cc36a$export$2d0294657ab35f1b).sheet.rows - 1) * emojiSkin.y}%`
        }
      })
    });
  }
  function $1a9a8ef576b7773d$var$m(t1, r1) {
    (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__h && (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__h($1a9a8ef576b7773d$var$u, t1, $1a9a8ef576b7773d$var$o || r1), $1a9a8ef576b7773d$var$o = 0;
    var i1 = $1a9a8ef576b7773d$var$u.__H || ($1a9a8ef576b7773d$var$u.__H = {
      __: [],
      __h: []
    });
    return t1 >= i1.__.length && i1.__.push({}), i1.__[t1];
  }
  function $1a9a8ef576b7773d$export$60241385465d0a34(n1) {
    return $1a9a8ef576b7773d$var$o = 1, $1a9a8ef576b7773d$export$13e3392192263954($1a9a8ef576b7773d$var$w, n1);
  }
  function $1a9a8ef576b7773d$export$13e3392192263954(n2, r2, o1) {
    var i2 = $1a9a8ef576b7773d$var$m($1a9a8ef576b7773d$var$t++, 2);
    return i2.t = n2, i2.__c || (i2.__ = [
      o1 ? o1(r2) : $1a9a8ef576b7773d$var$w(void 0, r2),
      function(n3) {
        var t2 = i2.t(i2.__[0], n3);
        i2.__[0] !== t2 && (i2.__ = [
          t2,
          i2.__[1]
        ], i2.__c.setState({}));
      }
    ], i2.__c = $1a9a8ef576b7773d$var$u), i2.__;
  }
  function $1a9a8ef576b7773d$export$6d9c69b0de29b591(r3, o2) {
    var i3 = $1a9a8ef576b7773d$var$m($1a9a8ef576b7773d$var$t++, 3);
    !(0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__s && $1a9a8ef576b7773d$var$k(i3.__H, o2) && (i3.__ = r3, i3.__H = o2, $1a9a8ef576b7773d$var$u.__H.__h.push(i3));
  }
  function $1a9a8ef576b7773d$export$e5c5a5f917a5871c(r4, o3) {
    var i4 = $1a9a8ef576b7773d$var$m($1a9a8ef576b7773d$var$t++, 4);
    !(0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__s && $1a9a8ef576b7773d$var$k(i4.__H, o3) && (i4.__ = r4, i4.__H = o3, $1a9a8ef576b7773d$var$u.__h.push(i4));
  }
  function $1a9a8ef576b7773d$export$b8f5890fc79d6aca(n4) {
    return $1a9a8ef576b7773d$var$o = 5, $1a9a8ef576b7773d$export$1538c33de8887b59(function() {
      return {
        current: n4
      };
    }, []);
  }
  function $1a9a8ef576b7773d$export$d5a552a76deda3c2(n5, t3, u1) {
    $1a9a8ef576b7773d$var$o = 6, $1a9a8ef576b7773d$export$e5c5a5f917a5871c(function() {
      "function" == typeof n5 ? n5(t3()) : n5 && (n5.current = t3());
    }, null == u1 ? u1 : u1.concat(n5));
  }
  function $1a9a8ef576b7773d$export$1538c33de8887b59(n6, u2) {
    var r5 = $1a9a8ef576b7773d$var$m($1a9a8ef576b7773d$var$t++, 7);
    return $1a9a8ef576b7773d$var$k(r5.__H, u2) && (r5.__ = n6(), r5.__H = u2, r5.__h = n6), r5.__;
  }
  function $1a9a8ef576b7773d$export$35808ee640e87ca7(n7, t4) {
    return $1a9a8ef576b7773d$var$o = 8, $1a9a8ef576b7773d$export$1538c33de8887b59(function() {
      return n7;
    }, t4);
  }
  function $1a9a8ef576b7773d$export$fae74005e78b1a27(n8) {
    var r6 = $1a9a8ef576b7773d$var$u.context[n8.__c], o4 = $1a9a8ef576b7773d$var$m($1a9a8ef576b7773d$var$t++, 9);
    return o4.c = n8, r6 ? (null == o4.__ && (o4.__ = true, r6.sub($1a9a8ef576b7773d$var$u)), r6.props.value) : n8.__;
  }
  function $1a9a8ef576b7773d$export$dc8fbce3eb94dc1e(t5, u3) {
    (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).useDebugValue && (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).useDebugValue(u3 ? u3(t5) : t5);
  }
  function $1a9a8ef576b7773d$export$c052f6604b7d51fe(n9) {
    var r7 = $1a9a8ef576b7773d$var$m($1a9a8ef576b7773d$var$t++, 10), o5 = $1a9a8ef576b7773d$export$60241385465d0a34();
    return r7.__ = n9, $1a9a8ef576b7773d$var$u.componentDidCatch || ($1a9a8ef576b7773d$var$u.componentDidCatch = function(n10) {
      r7.__ && r7.__(n10), o5[1](n10);
    }), [
      o5[0],
      function() {
        o5[1](void 0);
      }
    ];
  }
  function $1a9a8ef576b7773d$var$x() {
    var t6;
    for ($1a9a8ef576b7773d$var$i.sort(function(n11, t7) {
      return n11.__v.__b - t7.__v.__b;
    }); t6 = $1a9a8ef576b7773d$var$i.pop(); ) if (t6.__P) try {
      t6.__H.__h.forEach($1a9a8ef576b7773d$var$g), t6.__H.__h.forEach($1a9a8ef576b7773d$var$j), t6.__H.__h = [];
    } catch (u4) {
      t6.__H.__h = [], (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__e(u4, t6.__v);
    }
  }
  function $1a9a8ef576b7773d$var$g(n19) {
    var t13 = $1a9a8ef576b7773d$var$u, r12 = n19.__c;
    "function" == typeof r12 && (n19.__c = void 0, r12()), $1a9a8ef576b7773d$var$u = t13;
  }
  function $1a9a8ef576b7773d$var$j(n20) {
    var t14 = $1a9a8ef576b7773d$var$u;
    n20.__c = n20.__(), $1a9a8ef576b7773d$var$u = t14;
  }
  function $1a9a8ef576b7773d$var$k(n21, t15) {
    return !n21 || n21.length !== t15.length || t15.some(function(t16, u8) {
      return t16 !== n21[u8];
    });
  }
  function $1a9a8ef576b7773d$var$w(n22, t17) {
    return "function" == typeof t17 ? t17(n22) : t17;
  }
  function $dc040a17866866fa$var$S(n1, t1) {
    for (var e1 in t1) n1[e1] = t1[e1];
    return n1;
  }
  function $dc040a17866866fa$var$C(n2, t2) {
    for (var e2 in n2) if ("__source" !== e2 && !(e2 in t2)) return true;
    for (var r1 in t2) if ("__source" !== r1 && n2[r1] !== t2[r1]) return true;
    return false;
  }
  function $dc040a17866866fa$export$221d75b3f55bb0bd(n3) {
    this.props = n3;
  }
  function $dc040a17866866fa$export$7c73462e0d25e514(n4, t3) {
    function e3(n5) {
      var e4 = this.props.ref, r3 = e4 == n5.ref;
      return !r3 && e4 && (e4.call ? e4(null) : e4.current = null), t3 ? !t3(this.props, n5) || !r3 : $dc040a17866866fa$var$C(this.props, n5);
    }
    function r2(t4) {
      return this.shouldComponentUpdate = e3, (0, $fb96b826c0c5f37a$export$c8a8987d4410bf2d)(n4, t4);
    }
    return r2.displayName = "Memo(" + (n4.displayName || n4.name) + ")", r2.prototype.isReactComponent = true, r2.__f = true, r2;
  }
  function $dc040a17866866fa$export$257a8862b851cb5b(n8) {
    function t6(t7, e5) {
      var r4 = $dc040a17866866fa$var$S({}, t7);
      return delete r4.ref, n8(r4, (e5 = t7.ref || e5) && ("object" != typeof e5 || "current" in e5) ? e5 : null);
    }
    return t6.$$typeof = $dc040a17866866fa$var$R, t6.render = t6, t6.prototype.isReactComponent = t6.__f = true, t6.displayName = "ForwardRef(" + (n8.displayName || n8.name) + ")", t6;
  }
  function $dc040a17866866fa$export$74bf444e3cd11ea5() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function $dc040a17866866fa$var$U(n13) {
    var t11 = n13.__.__c;
    return t11 && t11.__e && t11.__e(n13);
  }
  function $dc040a17866866fa$export$488013bae63b21da(n14) {
    var t12, e7, r6;
    function u2(u3) {
      if (t12 || (t12 = n14()).then(function(n15) {
        e7 = n15.default || n15;
      }, function(n16) {
        r6 = n16;
      }), r6) throw r6;
      if (!e7) throw t12;
      return (0, $fb96b826c0c5f37a$export$c8a8987d4410bf2d)(e7, u3);
    }
    return u2.displayName = "Lazy", u2.__f = true, u2;
  }
  function $dc040a17866866fa$export$998bcd577473dd93() {
    this.u = null, this.o = null;
  }
  function $dc040a17866866fa$var$D(n27) {
    return this.getChildContext = function() {
      return n27.context;
    }, n27.children;
  }
  function $dc040a17866866fa$var$I(n28) {
    var t23 = this, e15 = n28.i;
    t23.componentWillUnmount = function() {
      (0, $fb96b826c0c5f37a$export$b3890eb0ae9dca99)(null, t23.l), t23.l = null, t23.i = null;
    }, t23.i && t23.i !== e15 && t23.componentWillUnmount(), n28.__v ? (t23.l || (t23.i = e15, t23.l = {
      nodeType: 1,
      parentNode: e15,
      childNodes: [],
      appendChild: function(n29) {
        this.childNodes.push(n29), t23.i.appendChild(n29);
      },
      insertBefore: function(n30, e) {
        this.childNodes.push(n30), t23.i.appendChild(n30);
      },
      removeChild: function(n31) {
        this.childNodes.splice(this.childNodes.indexOf(n31) >>> 1, 1), t23.i.removeChild(n31);
      }
    }), (0, $fb96b826c0c5f37a$export$b3890eb0ae9dca99)((0, $fb96b826c0c5f37a$export$c8a8987d4410bf2d)($dc040a17866866fa$var$D, {
      context: t23.context
    }, n28.__v), t23.l)) : t23.l && t23.componentWillUnmount();
  }
  function $dc040a17866866fa$export$d39a5bbd09211389(n32, t24) {
    return (0, $fb96b826c0c5f37a$export$c8a8987d4410bf2d)($dc040a17866866fa$var$I, {
      __v: n32,
      i: t24
    });
  }
  function $dc040a17866866fa$export$b3890eb0ae9dca99(n37, t28, e19) {
    return null == t28.__k && (t28.textContent = ""), (0, $fb96b826c0c5f37a$export$b3890eb0ae9dca99)(n37, t28), "function" == typeof e19 && e19(), n37 ? n37.__c : null;
  }
  function $dc040a17866866fa$export$fa8d919ba61d84db(n38, t29, e20) {
    return (0, $fb96b826c0c5f37a$export$fa8d919ba61d84db)(n38, t29), "function" == typeof e20 && e20(), n38 ? n38.__c : null;
  }
  function $dc040a17866866fa$var$Z() {
  }
  function $dc040a17866866fa$var$Y() {
    return this.cancelBubble;
  }
  function $dc040a17866866fa$var$q() {
    return this.defaultPrevented;
  }
  function $dc040a17866866fa$export$d38cd72104c1f0e9(n46) {
    return (0, $fb96b826c0c5f37a$export$c8a8987d4410bf2d).bind(null, n46);
  }
  function $dc040a17866866fa$export$a8257692ac88316c(n47) {
    return !!n47 && n47.$$typeof === $dc040a17866866fa$var$j;
  }
  function $dc040a17866866fa$export$e530037191fcd5d7(n48) {
    return $dc040a17866866fa$export$a8257692ac88316c(n48) ? (0, $fb96b826c0c5f37a$export$e530037191fcd5d7).apply(null, arguments) : n48;
  }
  function $dc040a17866866fa$export$502457920280e6be(n49) {
    return !!n49.__k && ((0, $fb96b826c0c5f37a$export$b3890eb0ae9dca99)(null, n49), true);
  }
  function $dc040a17866866fa$export$466bfc07425424d5(n50) {
    return n50 && (n50.base || 1 === n50.nodeType && n50) || null;
  }
  var $fb96b826c0c5f37a$var$n, $fb96b826c0c5f37a$export$41c562ebe57d11e2, $fb96b826c0c5f37a$var$u, $fb96b826c0c5f37a$export$a8257692ac88316c, $fb96b826c0c5f37a$var$t, $fb96b826c0c5f37a$var$r, $fb96b826c0c5f37a$var$o, $fb96b826c0c5f37a$var$f, $fb96b826c0c5f37a$var$e, $fb96b826c0c5f37a$var$c, $fb96b826c0c5f37a$var$s, $bd9dd35321b03dd4$var$o, $f72b75cf796873c7$export$2e2bcd8739ae039, $c84d045dcc34faf5$var$CACHE, $c84d045dcc34faf5$var$VERSIONS, $c84d045dcc34faf5$var$isEmojiSupported, $c84d045dcc34faf5$export$2e2bcd8739ae039, $b22cfd0a55410b4f$var$DEFAULTS, $b22cfd0a55410b4f$var$Index, $b22cfd0a55410b4f$export$2e2bcd8739ae039, $8d50d93417ef682a$exports, $b247ea80b67298d5$export$2e2bcd8739ae039, $7adb23b0109cc36a$export$dbe3113d60765c1a, $7adb23b0109cc36a$export$2d0294657ab35f1b, $7adb23b0109cc36a$var$fetchCache, $7adb23b0109cc36a$var$promise, $7adb23b0109cc36a$var$initiated, $7adb23b0109cc36a$var$initCallback, $7adb23b0109cc36a$var$initialized, $c4d155af13ad4d4b$var$SHORTCODES_REGEX, $c4d155af13ad4d4b$var$Pool, $c4d155af13ad4d4b$export$2e2bcd8739ae039, $e6eae5155b87f591$export$bcb25aa587e9cb13, $fcccfb36ed0cde68$var$categories, $fcccfb36ed0cde68$var$search, $fcccfb36ed0cde68$export$2e2bcd8739ae039, $6f57cc9cd54c5aaa$var$WindowHTMLElement, $6f57cc9cd54c5aaa$export$2e2bcd8739ae039, $26f27c338a96b1a6$export$2e2bcd8739ae039, $3d90f6e46fb2dd47$export$2e2bcd8739ae039, $331b4160623139bf$export$2e2bcd8739ae039, $1a9a8ef576b7773d$var$t, $1a9a8ef576b7773d$var$u, $1a9a8ef576b7773d$var$r, $1a9a8ef576b7773d$var$o, $1a9a8ef576b7773d$var$i, $1a9a8ef576b7773d$var$c, $1a9a8ef576b7773d$var$f, $1a9a8ef576b7773d$var$e, $1a9a8ef576b7773d$var$a, $1a9a8ef576b7773d$var$v, $1a9a8ef576b7773d$var$b, $dc040a17866866fa$var$w, $dc040a17866866fa$var$R, $dc040a17866866fa$var$N, $dc040a17866866fa$export$dca3b0875bd9a954, $dc040a17866866fa$var$A, $dc040a17866866fa$var$O, $dc040a17866866fa$var$T, $dc040a17866866fa$var$j, $dc040a17866866fa$var$P, $dc040a17866866fa$var$V, $dc040a17866866fa$var$z, $dc040a17866866fa$var$H, $dc040a17866866fa$var$G, $dc040a17866866fa$var$J, $dc040a17866866fa$var$K, $dc040a17866866fa$var$Q, $dc040a17866866fa$export$ae55be85d98224ed, $dc040a17866866fa$export$83d89fbfd8236492, $dc040a17866866fa$export$c78a37762a8d58e1, $dc040a17866866fa$export$cd75ccfd720a3cd4, $dc040a17866866fa$export$5f8d39834fd61797, $dc040a17866866fa$export$2e2bcd8739ae039, $ec8c39fdad15601a$var$THEME_ICONS, $ec8c39fdad15601a$export$2e2bcd8739ae039, $e0d4dda61265ff1e$export$2e2bcd8739ae039, $89bd6bb200cc8fef$var$Performance, $89bd6bb200cc8fef$export$2e2bcd8739ae039, $efa000751917694d$export$2e2bcd8739ae039, $329d53ba9fd7125f$exports;
  var init_module = __esm({
    "node_modules/emoji-mart/dist/module.js"() {
      $fb96b826c0c5f37a$var$e = {}, $fb96b826c0c5f37a$var$c = [], $fb96b826c0c5f37a$var$s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
      $fb96b826c0c5f37a$var$n = $fb96b826c0c5f37a$var$c.slice, $fb96b826c0c5f37a$export$41c562ebe57d11e2 = {
        __e: function(n39, l22) {
          for (var u23, i16, t14; l22 = l22.__; ) if ((u23 = l22.__c) && !u23.__) try {
            if ((i16 = u23.constructor) && null != i16.getDerivedStateFromError && (u23.setState(i16.getDerivedStateFromError(n39)), t14 = u23.__d), null != u23.componentDidCatch && (u23.componentDidCatch(n39), t14 = u23.__d), t14) return u23.__E = u23;
          } catch (l23) {
            n39 = l23;
          }
          throw n39;
        }
      }, $fb96b826c0c5f37a$var$u = 0, $fb96b826c0c5f37a$export$a8257692ac88316c = function(n40) {
        return null != n40 && void 0 === n40.constructor;
      }, $fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype.setState = function(n41, l24) {
        var u24;
        u24 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = $fb96b826c0c5f37a$var$a({}, this.state), "function" == typeof n41 && (n41 = n41($fb96b826c0c5f37a$var$a({}, u24), this.props)), n41 && $fb96b826c0c5f37a$var$a(u24, n41), null != n41 && this.__v && (l24 && this.__h.push(l24), $fb96b826c0c5f37a$var$m(this));
      }, $fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype.forceUpdate = function(n42) {
        this.__v && (this.__e = true, n42 && this.__h.push(n42), $fb96b826c0c5f37a$var$m(this));
      }, $fb96b826c0c5f37a$export$16fa2f45be04daa8.prototype.render = $fb96b826c0c5f37a$export$ffb0004e005737fa, $fb96b826c0c5f37a$var$t = [], $fb96b826c0c5f37a$var$r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $fb96b826c0c5f37a$var$g.__r = 0, $fb96b826c0c5f37a$var$f = 0;
      $bd9dd35321b03dd4$var$o = 0;
      $f72b75cf796873c7$export$2e2bcd8739ae039 = {
        set: $f72b75cf796873c7$var$set,
        get: $f72b75cf796873c7$var$get
      };
      $c84d045dcc34faf5$var$CACHE = /* @__PURE__ */ new Map();
      $c84d045dcc34faf5$var$VERSIONS = [
        {
          v: 15,
          emoji: "\u{1FAE8}"
        },
        {
          v: 14,
          emoji: "\u{1FAE0}"
        },
        {
          v: 13.1,
          emoji: "\u{1F636}\u200D\u{1F32B}\uFE0F"
        },
        {
          v: 13,
          emoji: "\u{1F978}"
        },
        {
          v: 12.1,
          emoji: "\u{1F9D1}\u200D\u{1F9B0}"
        },
        {
          v: 12,
          emoji: "\u{1F971}"
        },
        {
          v: 11,
          emoji: "\u{1F970}"
        },
        {
          v: 5,
          emoji: "\u{1F929}"
        },
        {
          v: 4,
          emoji: "\u{1F471}\u200D\u2640\uFE0F"
        },
        {
          v: 3,
          emoji: "\u{1F923}"
        },
        {
          v: 2,
          emoji: "\u{1F44B}\u{1F3FB}"
        },
        {
          v: 1,
          emoji: "\u{1F643}"
        }
      ];
      $c84d045dcc34faf5$var$isEmojiSupported = (() => {
        let ctx = null;
        try {
          if (!navigator.userAgent.includes("jsdom")) ctx = document.createElement("canvas").getContext("2d", {
            willReadFrequently: true
          });
        } catch {
        }
        if (!ctx) return () => false;
        const CANVAS_HEIGHT = 25;
        const CANVAS_WIDTH = 20;
        const textSize = Math.floor(CANVAS_HEIGHT / 2);
        ctx.font = textSize + "px Arial, Sans-Serif";
        ctx.textBaseline = "top";
        ctx.canvas.width = CANVAS_WIDTH * 2;
        ctx.canvas.height = CANVAS_HEIGHT;
        return (unicode) => {
          ctx.clearRect(0, 0, CANVAS_WIDTH * 2, CANVAS_HEIGHT);
          ctx.fillStyle = "#FF0000";
          ctx.fillText(unicode, 0, 22);
          ctx.fillStyle = "#0000FF";
          ctx.fillText(unicode, CANVAS_WIDTH, 22);
          const a2 = ctx.getImageData(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT).data;
          const count = a2.length;
          let i = 0;
          for (; i < count && !a2[i + 3]; i += 4) ;
          if (i >= count) return false;
          const x = CANVAS_WIDTH + i / 4 % CANVAS_WIDTH;
          const y = Math.floor(i / 4 / CANVAS_WIDTH);
          const b = ctx.getImageData(x, y, 1, 1).data;
          if (a2[i] !== b[0] || a2[i + 2] !== b[2]) return false;
          if (ctx.measureText(unicode).width >= CANVAS_WIDTH) return false;
          return true;
        };
      })();
      $c84d045dcc34faf5$export$2e2bcd8739ae039 = {
        latestVersion: $c84d045dcc34faf5$var$latestVersion,
        noCountryFlags: $c84d045dcc34faf5$var$noCountryFlags
      };
      $b22cfd0a55410b4f$var$DEFAULTS = [
        "+1",
        "grinning",
        "kissing_heart",
        "heart_eyes",
        "laughing",
        "stuck_out_tongue_winking_eye",
        "sweat_smile",
        "joy",
        "scream",
        "disappointed",
        "unamused",
        "weary",
        "sob",
        "sunglasses",
        "heart"
      ];
      $b22cfd0a55410b4f$var$Index = null;
      $b22cfd0a55410b4f$export$2e2bcd8739ae039 = {
        add: $b22cfd0a55410b4f$var$add,
        get: $b22cfd0a55410b4f$var$get,
        DEFAULTS: $b22cfd0a55410b4f$var$DEFAULTS
      };
      $8d50d93417ef682a$exports = {};
      $8d50d93417ef682a$exports = JSON.parse('{"search":"Search","search_no_results_1":"Oh no!","search_no_results_2":"That emoji couldn\u2019t be found","pick":"Pick an emoji\u2026","add_custom":"Add custom emoji","categories":{"activity":"Activity","custom":"Custom","flags":"Flags","foods":"Food & Drink","frequent":"Frequently used","nature":"Animals & Nature","objects":"Objects","people":"Smileys & People","places":"Travel & Places","search":"Search Results","symbols":"Symbols"},"skins":{"1":"Default","2":"Light","3":"Medium-Light","4":"Medium","5":"Medium-Dark","6":"Dark","choose":"Choose default skin tone"}}');
      $b247ea80b67298d5$export$2e2bcd8739ae039 = {
        autoFocus: {
          value: false
        },
        dynamicWidth: {
          value: false
        },
        emojiButtonColors: {
          value: null
        },
        emojiButtonRadius: {
          value: "100%"
        },
        emojiButtonSize: {
          value: 36
        },
        emojiSize: {
          value: 24
        },
        emojiVersion: {
          value: 15,
          choices: [
            1,
            2,
            3,
            4,
            5,
            11,
            12,
            12.1,
            13,
            13.1,
            14,
            15
          ]
        },
        exceptEmojis: {
          value: []
        },
        icons: {
          value: "auto",
          choices: [
            "auto",
            "outline",
            "solid"
          ]
        },
        locale: {
          value: "en",
          choices: [
            "en",
            "ar",
            "be",
            "cs",
            "de",
            "es",
            "fa",
            "fi",
            "fr",
            "hi",
            "it",
            "ja",
            "ko",
            "nl",
            "pl",
            "pt",
            "ru",
            "sa",
            "tr",
            "uk",
            "vi",
            "zh"
          ]
        },
        maxFrequentRows: {
          value: 4
        },
        navPosition: {
          value: "top",
          choices: [
            "top",
            "bottom",
            "none"
          ]
        },
        noCountryFlags: {
          value: false
        },
        noResultsEmoji: {
          value: null
        },
        perLine: {
          value: 9
        },
        previewEmoji: {
          value: null
        },
        previewPosition: {
          value: "bottom",
          choices: [
            "top",
            "bottom",
            "none"
          ]
        },
        searchPosition: {
          value: "sticky",
          choices: [
            "sticky",
            "static",
            "none"
          ]
        },
        set: {
          value: "native",
          choices: [
            "native",
            "apple",
            "facebook",
            "google",
            "twitter"
          ]
        },
        skin: {
          value: 1,
          choices: [
            1,
            2,
            3,
            4,
            5,
            6
          ]
        },
        skinTonePosition: {
          value: "preview",
          choices: [
            "preview",
            "search",
            "none"
          ]
        },
        theme: {
          value: "auto",
          choices: [
            "auto",
            "light",
            "dark"
          ]
        },
        // Data
        categories: null,
        categoryIcons: null,
        custom: null,
        data: null,
        i18n: null,
        // Callbacks
        getImageURL: null,
        getSpritesheetURL: null,
        onAddCustomEmoji: null,
        onClickOutside: null,
        onEmojiSelect: null,
        // Deprecated
        stickySearch: {
          deprecated: true,
          value: true
        }
      };
      $7adb23b0109cc36a$export$dbe3113d60765c1a = null;
      $7adb23b0109cc36a$export$2d0294657ab35f1b = null;
      $7adb23b0109cc36a$var$fetchCache = {};
      $7adb23b0109cc36a$var$promise = null;
      $7adb23b0109cc36a$var$initiated = false;
      $7adb23b0109cc36a$var$initCallback = null;
      $7adb23b0109cc36a$var$initialized = false;
      $c4d155af13ad4d4b$var$SHORTCODES_REGEX = /^(?:\:([^\:]+)\:)(?:\:skin-tone-(\d)\:)?$/;
      $c4d155af13ad4d4b$var$Pool = null;
      $c4d155af13ad4d4b$export$2e2bcd8739ae039 = {
        search: $c4d155af13ad4d4b$var$search,
        get: $c4d155af13ad4d4b$var$get,
        reset: $c4d155af13ad4d4b$var$reset,
        SHORTCODES_REGEX: $c4d155af13ad4d4b$var$SHORTCODES_REGEX
      };
      $e6eae5155b87f591$export$bcb25aa587e9cb13 = [
        "checkered_flag",
        "crossed_flags",
        "pirate_flag",
        "rainbow-flag",
        "transgender_flag",
        "triangular_flag_on_post",
        "waving_black_flag",
        "waving_white_flag"
      ];
      $fcccfb36ed0cde68$var$categories = {
        activity: {
          outline: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M12 0C5.373 0 0 5.372 0 12c0 6.627 5.373 12 12 12 6.628 0 12-5.373 12-12 0-6.628-5.372-12-12-12m9.949 11H17.05c.224-2.527 1.232-4.773 1.968-6.113A9.966 9.966 0 0 1 21.949 11M13 11V2.051a9.945 9.945 0 0 1 4.432 1.564c-.858 1.491-2.156 4.22-2.392 7.385H13zm-2 0H8.961c-.238-3.165-1.536-5.894-2.393-7.385A9.95 9.95 0 0 1 11 2.051V11zm0 2v8.949a9.937 9.937 0 0 1-4.432-1.564c.857-1.492 2.155-4.221 2.393-7.385H11zm4.04 0c.236 3.164 1.534 5.893 2.392 7.385A9.92 9.92 0 0 1 13 21.949V13h2.04zM4.982 4.887C5.718 6.227 6.726 8.473 6.951 11h-4.9a9.977 9.977 0 0 1 2.931-6.113M2.051 13h4.9c-.226 2.527-1.233 4.771-1.969 6.113A9.972 9.972 0 0 1 2.051 13m16.967 6.113c-.735-1.342-1.744-3.586-1.968-6.113h4.899a9.961 9.961 0 0 1-2.931 6.113"
            })
          }),
          solid: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 512 512",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M16.17 337.5c0 44.98 7.565 83.54 13.98 107.9C35.22 464.3 50.46 496 174.9 496c9.566 0 19.59-.4707 29.84-1.271L17.33 307.3C16.53 317.6 16.17 327.7 16.17 337.5zM495.8 174.5c0-44.98-7.565-83.53-13.98-107.9c-4.688-17.54-18.34-31.23-36.04-35.95C435.5 27.91 392.9 16 337 16c-9.564 0-19.59 .4707-29.84 1.271l187.5 187.5C495.5 194.4 495.8 184.3 495.8 174.5zM26.77 248.8l236.3 236.3c142-36.1 203.9-150.4 222.2-221.1L248.9 26.87C106.9 62.96 45.07 177.2 26.77 248.8zM256 335.1c0 9.141-7.474 16-16 16c-4.094 0-8.188-1.564-11.31-4.689L164.7 283.3C161.6 280.2 160 276.1 160 271.1c0-8.529 6.865-16 16-16c4.095 0 8.189 1.562 11.31 4.688l64.01 64C254.4 327.8 256 331.9 256 335.1zM304 287.1c0 9.141-7.474 16-16 16c-4.094 0-8.188-1.564-11.31-4.689L212.7 235.3C209.6 232.2 208 228.1 208 223.1c0-9.141 7.473-16 16-16c4.094 0 8.188 1.562 11.31 4.688l64.01 64.01C302.5 279.8 304 283.9 304 287.1zM256 175.1c0-9.141 7.473-16 16-16c4.094 0 8.188 1.562 11.31 4.688l64.01 64.01c3.125 3.125 4.688 7.219 4.688 11.31c0 9.133-7.468 16-16 16c-4.094 0-8.189-1.562-11.31-4.688l-64.01-64.01C257.6 184.2 256 180.1 256 175.1z"
            })
          })
        },
        custom: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 448 512",
          children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
            d: "M417.1 368c-5.937 10.27-16.69 16-27.75 16c-5.422 0-10.92-1.375-15.97-4.281L256 311.4V448c0 17.67-14.33 32-31.1 32S192 465.7 192 448V311.4l-118.3 68.29C68.67 382.6 63.17 384 57.75 384c-11.06 0-21.81-5.734-27.75-16c-8.828-15.31-3.594-34.88 11.72-43.72L159.1 256L41.72 187.7C26.41 178.9 21.17 159.3 29.1 144C36.63 132.5 49.26 126.7 61.65 128.2C65.78 128.7 69.88 130.1 73.72 132.3L192 200.6V64c0-17.67 14.33-32 32-32S256 46.33 256 64v136.6l118.3-68.29c3.838-2.213 7.939-3.539 12.07-4.051C398.7 126.7 411.4 132.5 417.1 144c8.828 15.31 3.594 34.88-11.72 43.72L288 256l118.3 68.28C421.6 333.1 426.8 352.7 417.1 368z"
          })
        }),
        flags: {
          outline: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M0 0l6.084 24H8L1.916 0zM21 5h-4l-1-4H4l3 12h3l1 4h13L21 5zM6.563 3h7.875l2 8H8.563l-2-8zm8.832 10l-2.856 1.904L12.063 13h3.332zM19 13l-1.5-6h1.938l2 8H16l3-2z"
            })
          }),
          solid: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 512 512",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M64 496C64 504.8 56.75 512 48 512h-32C7.25 512 0 504.8 0 496V32c0-17.75 14.25-32 32-32s32 14.25 32 32V496zM476.3 0c-6.365 0-13.01 1.35-19.34 4.233c-45.69 20.86-79.56 27.94-107.8 27.94c-59.96 0-94.81-31.86-163.9-31.87C160.9 .3055 131.6 4.867 96 15.75v350.5c32-9.984 59.87-14.1 84.85-14.1c73.63 0 124.9 31.78 198.6 31.78c31.91 0 68.02-5.971 111.1-23.09C504.1 355.9 512 344.4 512 332.1V30.73C512 11.1 495.3 0 476.3 0z"
            })
          })
        },
        foods: {
          outline: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M17 4.978c-1.838 0-2.876.396-3.68.934.513-1.172 1.768-2.934 4.68-2.934a1 1 0 0 0 0-2c-2.921 0-4.629 1.365-5.547 2.512-.064.078-.119.162-.18.244C11.73 1.838 10.798.023 9.207.023 8.579.022 7.85.306 7 .978 5.027 2.54 5.329 3.902 6.492 4.999 3.609 5.222 0 7.352 0 12.969c0 4.582 4.961 11.009 9 11.009 1.975 0 2.371-.486 3-1 .629.514 1.025 1 3 1 4.039 0 9-6.418 9-11 0-5.953-4.055-8-7-8M8.242 2.546c.641-.508.943-.523.965-.523.426.169.975 1.405 1.357 3.055-1.527-.629-2.741-1.352-2.98-1.846.059-.112.241-.356.658-.686M15 21.978c-1.08 0-1.21-.109-1.559-.402l-.176-.146c-.367-.302-.816-.452-1.266-.452s-.898.15-1.266.452l-.176.146c-.347.292-.477.402-1.557.402-2.813 0-7-5.389-7-9.009 0-5.823 4.488-5.991 5-5.991 1.939 0 2.484.471 3.387 1.251l.323.276a1.995 1.995 0 0 0 2.58 0l.323-.276c.902-.78 1.447-1.251 3.387-1.251.512 0 5 .168 5 6 0 3.617-4.187 9-7 9"
            })
          }),
          solid: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 512 512",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M481.9 270.1C490.9 279.1 496 291.3 496 304C496 316.7 490.9 328.9 481.9 337.9C472.9 346.9 460.7 352 448 352H64C51.27 352 39.06 346.9 30.06 337.9C21.06 328.9 16 316.7 16 304C16 291.3 21.06 279.1 30.06 270.1C39.06 261.1 51.27 256 64 256H448C460.7 256 472.9 261.1 481.9 270.1zM475.3 388.7C478.3 391.7 480 395.8 480 400V416C480 432.1 473.3 449.3 461.3 461.3C449.3 473.3 432.1 480 416 480H96C79.03 480 62.75 473.3 50.75 461.3C38.74 449.3 32 432.1 32 416V400C32 395.8 33.69 391.7 36.69 388.7C39.69 385.7 43.76 384 48 384H464C468.2 384 472.3 385.7 475.3 388.7zM50.39 220.8C45.93 218.6 42.03 215.5 38.97 211.6C35.91 207.7 33.79 203.2 32.75 198.4C31.71 193.5 31.8 188.5 32.99 183.7C54.98 97.02 146.5 32 256 32C365.5 32 457 97.02 479 183.7C480.2 188.5 480.3 193.5 479.2 198.4C478.2 203.2 476.1 207.7 473 211.6C469.1 215.5 466.1 218.6 461.6 220.8C457.2 222.9 452.3 224 447.3 224H64.67C59.73 224 54.84 222.9 50.39 220.8zM372.7 116.7C369.7 119.7 368 123.8 368 128C368 131.2 368.9 134.3 370.7 136.9C372.5 139.5 374.1 141.6 377.9 142.8C380.8 143.1 384 144.3 387.1 143.7C390.2 143.1 393.1 141.6 395.3 139.3C397.6 137.1 399.1 134.2 399.7 131.1C400.3 128 399.1 124.8 398.8 121.9C397.6 118.1 395.5 116.5 392.9 114.7C390.3 112.9 387.2 111.1 384 111.1C379.8 111.1 375.7 113.7 372.7 116.7V116.7zM244.7 84.69C241.7 87.69 240 91.76 240 96C240 99.16 240.9 102.3 242.7 104.9C244.5 107.5 246.1 109.6 249.9 110.8C252.8 111.1 256 112.3 259.1 111.7C262.2 111.1 265.1 109.6 267.3 107.3C269.6 105.1 271.1 102.2 271.7 99.12C272.3 96.02 271.1 92.8 270.8 89.88C269.6 86.95 267.5 84.45 264.9 82.7C262.3 80.94 259.2 79.1 256 79.1C251.8 79.1 247.7 81.69 244.7 84.69V84.69zM116.7 116.7C113.7 119.7 112 123.8 112 128C112 131.2 112.9 134.3 114.7 136.9C116.5 139.5 118.1 141.6 121.9 142.8C124.8 143.1 128 144.3 131.1 143.7C134.2 143.1 137.1 141.6 139.3 139.3C141.6 137.1 143.1 134.2 143.7 131.1C144.3 128 143.1 124.8 142.8 121.9C141.6 118.1 139.5 116.5 136.9 114.7C134.3 112.9 131.2 111.1 128 111.1C123.8 111.1 119.7 113.7 116.7 116.7L116.7 116.7z"
            })
          })
        },
        frequent: {
          outline: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            children: [
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
                d: "M13 4h-2l-.001 7H9v2h2v2h2v-2h4v-2h-4z"
              }),
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
                d: "M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0m0 22C6.486 22 2 17.514 2 12S6.486 2 12 2s10 4.486 10 10-4.486 10-10 10"
              })
            ]
          }),
          solid: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 512 512",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512zM232 256C232 264 236 271.5 242.7 275.1L338.7 339.1C349.7 347.3 364.6 344.3 371.1 333.3C379.3 322.3 376.3 307.4 365.3 300L280 243.2V120C280 106.7 269.3 96 255.1 96C242.7 96 231.1 106.7 231.1 120L232 256z"
            })
          })
        },
        nature: {
          outline: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            children: [
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
                d: "M15.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 15.5 8M8.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 8.5 8"
              }),
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
                d: "M18.933 0h-.027c-.97 0-2.138.787-3.018 1.497-1.274-.374-2.612-.51-3.887-.51-1.285 0-2.616.133-3.874.517C7.245.79 6.069 0 5.093 0h-.027C3.352 0 .07 2.67.002 7.026c-.039 2.479.276 4.238 1.04 5.013.254.258.882.677 1.295.882.191 3.177.922 5.238 2.536 6.38.897.637 2.187.949 3.2 1.102C8.04 20.6 8 20.795 8 21c0 1.773 2.35 3 4 3 1.648 0 4-1.227 4-3 0-.201-.038-.393-.072-.586 2.573-.385 5.435-1.877 5.925-7.587.396-.22.887-.568 1.104-.788.763-.774 1.079-2.534 1.04-5.013C23.929 2.67 20.646 0 18.933 0M3.223 9.135c-.237.281-.837 1.155-.884 1.238-.15-.41-.368-1.349-.337-3.291.051-3.281 2.478-4.972 3.091-5.031.256.015.731.27 1.265.646-1.11 1.171-2.275 2.915-2.352 5.125-.133.546-.398.858-.783 1.313M12 22c-.901 0-1.954-.693-2-1 0-.654.475-1.236 1-1.602V20a1 1 0 1 0 2 0v-.602c.524.365 1 .947 1 1.602-.046.307-1.099 1-2 1m3-3.48v.02a4.752 4.752 0 0 0-1.262-1.02c1.092-.516 2.239-1.334 2.239-2.217 0-1.842-1.781-2.195-3.977-2.195-2.196 0-3.978.354-3.978 2.195 0 .883 1.148 1.701 2.238 2.217A4.8 4.8 0 0 0 9 18.539v-.025c-1-.076-2.182-.281-2.973-.842-1.301-.92-1.838-3.045-1.853-6.478l.023-.041c.496-.826 1.49-1.45 1.804-3.102 0-2.047 1.357-3.631 2.362-4.522C9.37 3.178 10.555 3 11.948 3c1.447 0 2.685.192 3.733.57 1 .9 2.316 2.465 2.316 4.48.313 1.651 1.307 2.275 1.803 3.102.035.058.068.117.102.178-.059 5.967-1.949 7.01-4.902 7.19m6.628-8.202c-.037-.065-.074-.13-.113-.195a7.587 7.587 0 0 0-.739-.987c-.385-.455-.648-.768-.782-1.313-.076-2.209-1.241-3.954-2.353-5.124.531-.376 1.004-.63 1.261-.647.636.071 3.044 1.764 3.096 5.031.027 1.81-.347 3.218-.37 3.235"
              })
            ]
          }),
          solid: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 576 512",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M332.7 19.85C334.6 8.395 344.5 0 356.1 0C363.6 0 370.6 3.52 375.1 9.502L392 32H444.1C456.8 32 469.1 37.06 478.1 46.06L496 64H552C565.3 64 576 74.75 576 88V112C576 156.2 540.2 192 496 192H426.7L421.6 222.5L309.6 158.5L332.7 19.85zM448 64C439.2 64 432 71.16 432 80C432 88.84 439.2 96 448 96C456.8 96 464 88.84 464 80C464 71.16 456.8 64 448 64zM416 256.1V480C416 497.7 401.7 512 384 512H352C334.3 512 320 497.7 320 480V364.8C295.1 377.1 268.8 384 240 384C211.2 384 184 377.1 160 364.8V480C160 497.7 145.7 512 128 512H96C78.33 512 64 497.7 64 480V249.8C35.23 238.9 12.64 214.5 4.836 183.3L.9558 167.8C-3.331 150.6 7.094 133.2 24.24 128.1C41.38 124.7 58.76 135.1 63.05 152.2L66.93 167.8C70.49 182 83.29 191.1 97.97 191.1H303.8L416 256.1z"
            })
          })
        },
        objects: {
          outline: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            children: [
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
                d: "M12 0a9 9 0 0 0-5 16.482V21s2.035 3 5 3 5-3 5-3v-4.518A9 9 0 0 0 12 0zm0 2c3.86 0 7 3.141 7 7s-3.14 7-7 7-7-3.141-7-7 3.14-7 7-7zM9 17.477c.94.332 1.946.523 3 .523s2.06-.19 3-.523v.834c-.91.436-1.925.689-3 .689a6.924 6.924 0 0 1-3-.69v-.833zm.236 3.07A8.854 8.854 0 0 0 12 21c.965 0 1.888-.167 2.758-.451C14.155 21.173 13.153 22 12 22c-1.102 0-2.117-.789-2.764-1.453z"
              }),
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
                d: "M14.745 12.449h-.004c-.852-.024-1.188-.858-1.577-1.824-.421-1.061-.703-1.561-1.182-1.566h-.009c-.481 0-.783.497-1.235 1.537-.436.982-.801 1.811-1.636 1.791l-.276-.043c-.565-.171-.853-.691-1.284-1.794-.125-.313-.202-.632-.27-.913-.051-.213-.127-.53-.195-.634C7.067 9.004 7.039 9 6.99 9A1 1 0 0 1 7 7h.01c1.662.017 2.015 1.373 2.198 2.134.486-.981 1.304-2.058 2.797-2.075 1.531.018 2.28 1.153 2.731 2.141l.002-.008C14.944 8.424 15.327 7 16.979 7h.032A1 1 0 1 1 17 9h-.011c-.149.076-.256.474-.319.709a6.484 6.484 0 0 1-.311.951c-.429.973-.79 1.789-1.614 1.789"
              })
            ]
          }),
          solid: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 384 512",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M112.1 454.3c0 6.297 1.816 12.44 5.284 17.69l17.14 25.69c5.25 7.875 17.17 14.28 26.64 14.28h61.67c9.438 0 21.36-6.401 26.61-14.28l17.08-25.68c2.938-4.438 5.348-12.37 5.348-17.7L272 415.1h-160L112.1 454.3zM191.4 .0132C89.44 .3257 16 82.97 16 175.1c0 44.38 16.44 84.84 43.56 115.8c16.53 18.84 42.34 58.23 52.22 91.45c.0313 .25 .0938 .5166 .125 .7823h160.2c.0313-.2656 .0938-.5166 .125-.7823c9.875-33.22 35.69-72.61 52.22-91.45C351.6 260.8 368 220.4 368 175.1C368 78.61 288.9-.2837 191.4 .0132zM192 96.01c-44.13 0-80 35.89-80 79.1C112 184.8 104.8 192 96 192S80 184.8 80 176c0-61.76 50.25-111.1 112-111.1c8.844 0 16 7.159 16 16S200.8 96.01 192 96.01z"
            })
          })
        },
        people: {
          outline: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            children: [
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
                d: "M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0m0 22C6.486 22 2 17.514 2 12S6.486 2 12 2s10 4.486 10 10-4.486 10-10 10"
              }),
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
                d: "M8 7a2 2 0 1 0-.001 3.999A2 2 0 0 0 8 7M16 7a2 2 0 1 0-.001 3.999A2 2 0 0 0 16 7M15.232 15c-.693 1.195-1.87 2-3.349 2-1.477 0-2.655-.805-3.347-2H15m3-2H6a6 6 0 1 0 12 0"
              })
            ]
          }),
          solid: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 512 512",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256zM256 432C332.1 432 396.2 382 415.2 314.1C419.1 300.4 407.8 288 393.6 288H118.4C104.2 288 92.92 300.4 96.76 314.1C115.8 382 179.9 432 256 432V432zM176.4 160C158.7 160 144.4 174.3 144.4 192C144.4 209.7 158.7 224 176.4 224C194 224 208.4 209.7 208.4 192C208.4 174.3 194 160 176.4 160zM336.4 224C354 224 368.4 209.7 368.4 192C368.4 174.3 354 160 336.4 160C318.7 160 304.4 174.3 304.4 192C304.4 209.7 318.7 224 336.4 224z"
            })
          })
        },
        places: {
          outline: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            children: [
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
                d: "M6.5 12C5.122 12 4 13.121 4 14.5S5.122 17 6.5 17 9 15.879 9 14.5 7.878 12 6.5 12m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5M17.5 12c-1.378 0-2.5 1.121-2.5 2.5s1.122 2.5 2.5 2.5 2.5-1.121 2.5-2.5-1.122-2.5-2.5-2.5m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5"
              }),
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
                d: "M22.482 9.494l-1.039-.346L21.4 9h.6c.552 0 1-.439 1-.992 0-.006-.003-.008-.003-.008H23c0-1-.889-2-1.984-2h-.642l-.731-1.717C19.262 3.012 18.091 2 16.764 2H7.236C5.909 2 4.738 3.012 4.357 4.283L3.626 6h-.642C1.889 6 1 7 1 8h.003S1 8.002 1 8.008C1 8.561 1.448 9 2 9h.6l-.043.148-1.039.346a2.001 2.001 0 0 0-1.359 2.097l.751 7.508a1 1 0 0 0 .994.901H3v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h6v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h1.096a.999.999 0 0 0 .994-.901l.751-7.508a2.001 2.001 0 0 0-1.359-2.097M6.273 4.857C6.402 4.43 6.788 4 7.236 4h9.527c.448 0 .834.43.963.857L19.313 9H4.688l1.585-4.143zM7 21H5v-1h2v1zm12 0h-2v-1h2v1zm2.189-3H2.811l-.662-6.607L3 11h18l.852.393L21.189 18z"
              })
            ]
          }),
          solid: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 512 512",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M39.61 196.8L74.8 96.29C88.27 57.78 124.6 32 165.4 32H346.6C387.4 32 423.7 57.78 437.2 96.29L472.4 196.8C495.6 206.4 512 229.3 512 256V448C512 465.7 497.7 480 480 480H448C430.3 480 416 465.7 416 448V400H96V448C96 465.7 81.67 480 64 480H32C14.33 480 0 465.7 0 448V256C0 229.3 16.36 206.4 39.61 196.8V196.8zM109.1 192H402.9L376.8 117.4C372.3 104.6 360.2 96 346.6 96H165.4C151.8 96 139.7 104.6 135.2 117.4L109.1 192zM96 256C78.33 256 64 270.3 64 288C64 305.7 78.33 320 96 320C113.7 320 128 305.7 128 288C128 270.3 113.7 256 96 256zM416 320C433.7 320 448 305.7 448 288C448 270.3 433.7 256 416 256C398.3 256 384 270.3 384 288C384 305.7 398.3 320 416 320z"
            })
          })
        },
        symbols: {
          outline: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M0 0h11v2H0zM4 11h3V6h4V4H0v2h4zM15.5 17c1.381 0 2.5-1.116 2.5-2.493s-1.119-2.493-2.5-2.493S13 13.13 13 14.507 14.119 17 15.5 17m0-2.986c.276 0 .5.222.5.493 0 .272-.224.493-.5.493s-.5-.221-.5-.493.224-.493.5-.493M21.5 19.014c-1.381 0-2.5 1.116-2.5 2.493S20.119 24 21.5 24s2.5-1.116 2.5-2.493-1.119-2.493-2.5-2.493m0 2.986a.497.497 0 0 1-.5-.493c0-.271.224-.493.5-.493s.5.222.5.493a.497.497 0 0 1-.5.493M22 13l-9 9 1.513 1.5 8.99-9.009zM17 11c2.209 0 4-1.119 4-2.5V2s.985-.161 1.498.949C23.01 4.055 23 6 23 6s1-1.119 1-3.135C24-.02 21 0 21 0h-2v6.347A5.853 5.853 0 0 0 17 6c-2.209 0-4 1.119-4 2.5s1.791 2.5 4 2.5M10.297 20.482l-1.475-1.585a47.54 47.54 0 0 1-1.442 1.129c-.307-.288-.989-1.016-2.045-2.183.902-.836 1.479-1.466 1.729-1.892s.376-.871.376-1.336c0-.592-.273-1.178-.818-1.759-.546-.581-1.329-.871-2.349-.871-1.008 0-1.79.293-2.344.879-.556.587-.832 1.181-.832 1.784 0 .813.419 1.748 1.256 2.805-.847.614-1.444 1.208-1.794 1.784a3.465 3.465 0 0 0-.523 1.833c0 .857.308 1.56.924 2.107.616.549 1.423.823 2.42.823 1.173 0 2.444-.379 3.813-1.137L8.235 24h2.819l-2.09-2.383 1.333-1.135zm-6.736-6.389a1.02 1.02 0 0 1 .73-.286c.31 0 .559.085.747.254a.849.849 0 0 1 .283.659c0 .518-.419 1.112-1.257 1.784-.536-.651-.805-1.231-.805-1.742a.901.901 0 0 1 .302-.669M3.74 22c-.427 0-.778-.116-1.057-.349-.279-.232-.418-.487-.418-.766 0-.594.509-1.288 1.527-2.083.968 1.134 1.717 1.946 2.248 2.438-.921.507-1.686.76-2.3.76"
            })
          }),
          solid: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 512 512",
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
              d: "M500.3 7.251C507.7 13.33 512 22.41 512 31.1V175.1C512 202.5 483.3 223.1 447.1 223.1C412.7 223.1 383.1 202.5 383.1 175.1C383.1 149.5 412.7 127.1 447.1 127.1V71.03L351.1 90.23V207.1C351.1 234.5 323.3 255.1 287.1 255.1C252.7 255.1 223.1 234.5 223.1 207.1C223.1 181.5 252.7 159.1 287.1 159.1V63.1C287.1 48.74 298.8 35.61 313.7 32.62L473.7 .6198C483.1-1.261 492.9 1.173 500.3 7.251H500.3zM74.66 303.1L86.5 286.2C92.43 277.3 102.4 271.1 113.1 271.1H174.9C185.6 271.1 195.6 277.3 201.5 286.2L213.3 303.1H239.1C266.5 303.1 287.1 325.5 287.1 351.1V463.1C287.1 490.5 266.5 511.1 239.1 511.1H47.1C21.49 511.1-.0019 490.5-.0019 463.1V351.1C-.0019 325.5 21.49 303.1 47.1 303.1H74.66zM143.1 359.1C117.5 359.1 95.1 381.5 95.1 407.1C95.1 434.5 117.5 455.1 143.1 455.1C170.5 455.1 191.1 434.5 191.1 407.1C191.1 381.5 170.5 359.1 143.1 359.1zM440.3 367.1H496C502.7 367.1 508.6 372.1 510.1 378.4C513.3 384.6 511.6 391.7 506.5 396L378.5 508C372.9 512.1 364.6 513.3 358.6 508.9C352.6 504.6 350.3 496.6 353.3 489.7L391.7 399.1H336C329.3 399.1 323.4 395.9 321 389.6C318.7 383.4 320.4 376.3 325.5 371.1L453.5 259.1C459.1 255 467.4 254.7 473.4 259.1C479.4 263.4 481.6 271.4 478.7 278.3L440.3 367.1zM116.7 219.1L19.85 119.2C-8.112 90.26-6.614 42.31 24.85 15.34C51.82-8.137 93.26-3.642 118.2 21.83L128.2 32.32L137.7 21.83C162.7-3.642 203.6-8.137 231.6 15.34C262.6 42.31 264.1 90.26 236.1 119.2L139.7 219.1C133.2 225.6 122.7 225.6 116.7 219.1H116.7z"
            })
          })
        }
      };
      $fcccfb36ed0cde68$var$search = {
        loupe: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 20 20",
          children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
            d: "M12.9 14.32a8 8 0 1 1 1.41-1.41l5.35 5.33-1.42 1.42-5.33-5.34zM8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12z"
          })
        }),
        delete: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("svg", {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 20 20",
          children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("path", {
            d: "M10 8.586L2.929 1.515 1.515 2.929 8.586 10l-7.071 7.071 1.414 1.414L10 11.414l7.071 7.071 1.414-1.414L11.414 10l7.071-7.071-1.414-1.414L10 8.586z"
          })
        })
      };
      $fcccfb36ed0cde68$export$2e2bcd8739ae039 = {
        categories: $fcccfb36ed0cde68$var$categories,
        search: $fcccfb36ed0cde68$var$search
      };
      $6f57cc9cd54c5aaa$var$WindowHTMLElement = typeof window !== "undefined" && window.HTMLElement ? window.HTMLElement : Object;
      $6f57cc9cd54c5aaa$export$2e2bcd8739ae039 = class extends $6f57cc9cd54c5aaa$var$WindowHTMLElement {
        static get observedAttributes() {
          return Object.keys(this.Props);
        }
        update(props = {}) {
          for (let k in props) this.attributeChangedCallback(k, null, props[k]);
        }
        attributeChangedCallback(attr, _2, newValue) {
          if (!this.component) return;
          const value = (0, $7adb23b0109cc36a$export$88c9ddb45cea7241)(attr, {
            [attr]: newValue
          }, this.constructor.Props, this);
          if (this.component.componentWillReceiveProps) this.component.componentWillReceiveProps({
            [attr]: value
          });
          else {
            this.component.props[attr] = value;
            this.component.forceUpdate();
          }
        }
        disconnectedCallback() {
          this.disconnected = true;
          if (this.component && this.component.unregister) this.component.unregister();
        }
        constructor(props = {}) {
          super();
          this.props = props;
          if (props.parent || props.ref) {
            let ref = null;
            const parent = props.parent || (ref = props.ref && props.ref.current);
            if (ref) ref.innerHTML = "";
            if (parent) parent.appendChild(this);
          }
        }
      };
      $26f27c338a96b1a6$export$2e2bcd8739ae039 = class extends (0, $6f57cc9cd54c5aaa$export$2e2bcd8739ae039) {
        setShadow() {
          this.attachShadow({
            mode: "open"
          });
        }
        injectStyles(styles) {
          if (!styles) return;
          const style3 = document.createElement("style");
          style3.textContent = styles;
          this.shadowRoot.insertBefore(style3, this.shadowRoot.firstChild);
        }
        constructor(props, { styles } = {}) {
          super(props);
          this.setShadow();
          this.injectStyles(styles);
        }
      };
      $3d90f6e46fb2dd47$export$2e2bcd8739ae039 = {
        fallback: "",
        id: "",
        native: "",
        shortcodes: "",
        size: {
          value: "",
          transform: (value) => {
            if (!/\D/.test(value)) return `${value}px`;
            return value;
          }
        },
        // Shared
        set: (0, $b247ea80b67298d5$export$2e2bcd8739ae039).set,
        skin: (0, $b247ea80b67298d5$export$2e2bcd8739ae039).skin
      };
      $331b4160623139bf$export$2e2bcd8739ae039 = class extends (0, $6f57cc9cd54c5aaa$export$2e2bcd8739ae039) {
        async connectedCallback() {
          const props = (0, $7adb23b0109cc36a$export$75fe5f91d452f94b)(this.props, (0, $3d90f6e46fb2dd47$export$2e2bcd8739ae039), this);
          props.element = this;
          props.ref = (component) => {
            this.component = component;
          };
          await (0, $7adb23b0109cc36a$export$2cd8252107eb640b)();
          if (this.disconnected) return;
          (0, $fb96b826c0c5f37a$export$b3890eb0ae9dca99)(/* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)((0, $254755d3f438722f$export$2e2bcd8739ae039), {
            ...props
          }), this);
        }
        constructor(props) {
          super(props);
        }
      };
      (0, $c770c458706daa72$export$2e2bcd8739ae039)($331b4160623139bf$export$2e2bcd8739ae039, "Props", (0, $3d90f6e46fb2dd47$export$2e2bcd8739ae039));
      if (typeof customElements !== "undefined" && !customElements.get("em-emoji")) customElements.define("em-emoji", $331b4160623139bf$export$2e2bcd8739ae039);
      $1a9a8ef576b7773d$var$o = 0, $1a9a8ef576b7773d$var$i = [], $1a9a8ef576b7773d$var$c = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__b, $1a9a8ef576b7773d$var$f = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__r, $1a9a8ef576b7773d$var$e = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).diffed, $1a9a8ef576b7773d$var$a = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__c, $1a9a8ef576b7773d$var$v = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).unmount;
      (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__b = function(n12) {
        $1a9a8ef576b7773d$var$u = null, $1a9a8ef576b7773d$var$c && $1a9a8ef576b7773d$var$c(n12);
      }, (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__r = function(n13) {
        $1a9a8ef576b7773d$var$f && $1a9a8ef576b7773d$var$f(n13), $1a9a8ef576b7773d$var$t = 0;
        var r8 = ($1a9a8ef576b7773d$var$u = n13.__c).__H;
        r8 && (r8.__h.forEach($1a9a8ef576b7773d$var$g), r8.__h.forEach($1a9a8ef576b7773d$var$j), r8.__h = []);
      }, (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).diffed = function(t8) {
        $1a9a8ef576b7773d$var$e && $1a9a8ef576b7773d$var$e(t8);
        var o6 = t8.__c;
        o6 && o6.__H && o6.__H.__h.length && (1 !== $1a9a8ef576b7773d$var$i.push(o6) && $1a9a8ef576b7773d$var$r === (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).requestAnimationFrame || (($1a9a8ef576b7773d$var$r = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).requestAnimationFrame) || function(n14) {
          var t9, u5 = function() {
            clearTimeout(r9), $1a9a8ef576b7773d$var$b && cancelAnimationFrame(t9), setTimeout(n14);
          }, r9 = setTimeout(u5, 100);
          $1a9a8ef576b7773d$var$b && (t9 = requestAnimationFrame(u5));
        })($1a9a8ef576b7773d$var$x)), $1a9a8ef576b7773d$var$u = null;
      }, (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__c = function(t10, u6) {
        u6.some(function(t11) {
          try {
            t11.__h.forEach($1a9a8ef576b7773d$var$g), t11.__h = t11.__h.filter(function(n15) {
              return !n15.__ || $1a9a8ef576b7773d$var$j(n15);
            });
          } catch (r10) {
            u6.some(function(n16) {
              n16.__h && (n16.__h = []);
            }), u6 = [], (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__e(r10, t11.__v);
          }
        }), $1a9a8ef576b7773d$var$a && $1a9a8ef576b7773d$var$a(t10, u6);
      }, (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).unmount = function(t12) {
        $1a9a8ef576b7773d$var$v && $1a9a8ef576b7773d$var$v(t12);
        var u7, r11 = t12.__c;
        r11 && r11.__H && (r11.__H.__.forEach(function(n17) {
          try {
            $1a9a8ef576b7773d$var$g(n17);
          } catch (n18) {
            u7 = n18;
          }
        }), u7 && (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__e(u7, r11.__v));
      };
      $1a9a8ef576b7773d$var$b = "function" == typeof requestAnimationFrame;
      ($dc040a17866866fa$export$221d75b3f55bb0bd.prototype = new (0, $fb96b826c0c5f37a$export$16fa2f45be04daa8)()).isPureReactComponent = true, $dc040a17866866fa$export$221d75b3f55bb0bd.prototype.shouldComponentUpdate = function(n6, t5) {
        return $dc040a17866866fa$var$C(this.props, n6) || $dc040a17866866fa$var$C(this.state, t5);
      };
      $dc040a17866866fa$var$w = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__b;
      (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__b = function(n7) {
        n7.type && n7.type.__f && n7.ref && (n7.props.ref = n7.ref, n7.ref = null), $dc040a17866866fa$var$w && $dc040a17866866fa$var$w(n7);
      };
      $dc040a17866866fa$var$R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
      $dc040a17866866fa$var$N = function(n9, t8) {
        return null == n9 ? null : (0, $fb96b826c0c5f37a$export$47e4c5b300681277)((0, $fb96b826c0c5f37a$export$47e4c5b300681277)(n9).map(t8));
      }, $dc040a17866866fa$export$dca3b0875bd9a954 = {
        map: $dc040a17866866fa$var$N,
        forEach: $dc040a17866866fa$var$N,
        count: function(n10) {
          return n10 ? (0, $fb96b826c0c5f37a$export$47e4c5b300681277)(n10).length : 0;
        },
        only: function(n11) {
          var t9 = (0, $fb96b826c0c5f37a$export$47e4c5b300681277)(n11);
          if (1 !== t9.length) throw "Children.only";
          return t9[0];
        },
        toArray: (0, $fb96b826c0c5f37a$export$47e4c5b300681277)
      }, $dc040a17866866fa$var$A = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__e;
      (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__e = function(n12, t10, e6) {
        if (n12.then) {
          for (var r5, u1 = t10; u1 = u1.__; ) if ((r5 = u1.__c) && r5.__c) return null == t10.__e && (t10.__e = e6.__e, t10.__k = e6.__k), r5.__c(n12, t10);
        }
        $dc040a17866866fa$var$A(n12, t10, e6);
      };
      $dc040a17866866fa$var$O = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).unmount;
      (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).unmount = function(n17) {
        var t13 = n17.__c;
        t13 && t13.__R && t13.__R(), t13 && true === n17.__h && (n17.type = null), $dc040a17866866fa$var$O && $dc040a17866866fa$var$O(n17);
      }, ($dc040a17866866fa$export$74bf444e3cd11ea5.prototype = new (0, $fb96b826c0c5f37a$export$16fa2f45be04daa8)()).__c = function(n18, t14) {
        var e8 = t14.__c, r7 = this;
        null == r7.t && (r7.t = []), r7.t.push(e8);
        var u4 = $dc040a17866866fa$var$U(r7.__v), o1 = false, i1 = function() {
          o1 || (o1 = true, e8.__R = null, u4 ? u4(l1) : l1());
        };
        e8.__R = i1;
        var l1 = function() {
          if (!--r7.__u) {
            if (r7.state.__e) {
              var n19 = r7.state.__e;
              r7.__v.__k[0] = function n22(t17, e9, r8) {
                return t17 && (t17.__v = null, t17.__k = t17.__k && t17.__k.map(function(t18) {
                  return n22(t18, e9, r8);
                }), t17.__c && t17.__c.__P === e9 && (t17.__e && r8.insertBefore(t17.__e, t17.__d), t17.__c.__e = true, t17.__c.__P = r8)), t17;
              }(n19, n19.__c.__P, n19.__c.__O);
            }
            var t15;
            for (r7.setState({
              __e: r7.__b = null
            }); t15 = r7.t.pop(); ) t15.forceUpdate();
          }
        }, c1 = true === t14.__h;
        r7.__u++ || c1 || r7.setState({
          __e: r7.__b = r7.__v.__k[0]
        }), n18.then(i1, i1);
      }, $dc040a17866866fa$export$74bf444e3cd11ea5.prototype.componentWillUnmount = function() {
        this.t = [];
      }, $dc040a17866866fa$export$74bf444e3cd11ea5.prototype.render = function(n23, t19) {
        if (this.__b) {
          if (this.__v.__k) {
            var e10 = document.createElement("div"), r9 = this.__v.__k[0].__c;
            this.__v.__k[0] = function n24(t20, e13, r12) {
              return t20 && (t20.__c && t20.__c.__H && (t20.__c.__H.__.forEach(function(n25) {
                "function" == typeof n25.__c && n25.__c();
              }), t20.__c.__H = null), null != (t20 = $dc040a17866866fa$var$S({}, t20)).__c && (t20.__c.__P === r12 && (t20.__c.__P = e13), t20.__c = null), t20.__k = t20.__k && t20.__k.map(function(t21) {
                return n24(t21, e13, r12);
              })), t20;
            }(this.__b, e10, r9.__O = r9.__P);
          }
          this.__b = null;
        }
        var u5 = t19.__e && (0, $fb96b826c0c5f37a$export$c8a8987d4410bf2d)((0, $fb96b826c0c5f37a$export$ffb0004e005737fa), null, n23.fallback);
        return u5 && (u5.__h = null), [
          (0, $fb96b826c0c5f37a$export$c8a8987d4410bf2d)((0, $fb96b826c0c5f37a$export$ffb0004e005737fa), null, t19.__e ? null : n23.children),
          u5
        ];
      };
      $dc040a17866866fa$var$T = function(n26, t22, e14) {
        if (++e14[1] === e14[0] && n26.o.delete(t22), n26.props.revealOrder && ("t" !== n26.props.revealOrder[0] || !n26.o.size)) for (e14 = n26.u; e14; ) {
          for (; e14.length > 3; ) e14.pop()();
          if (e14[1] < e14[0]) break;
          n26.u = e14 = e14[2];
        }
      };
      ($dc040a17866866fa$export$998bcd577473dd93.prototype = new (0, $fb96b826c0c5f37a$export$16fa2f45be04daa8)()).__e = function(n33) {
        var t25 = this, e16 = $dc040a17866866fa$var$U(t25.__v), r13 = t25.o.get(n33);
        return r13[0]++, function(u6) {
          var o2 = function() {
            t25.props.revealOrder ? (r13.push(u6), $dc040a17866866fa$var$T(t25, n33, r13)) : u6();
          };
          e16 ? e16(o2) : o2();
        };
      }, $dc040a17866866fa$export$998bcd577473dd93.prototype.render = function(n34) {
        this.u = null, this.o = /* @__PURE__ */ new Map();
        var t26 = (0, $fb96b826c0c5f37a$export$47e4c5b300681277)(n34.children);
        n34.revealOrder && "b" === n34.revealOrder[0] && t26.reverse();
        for (var e17 = t26.length; e17--; ) this.o.set(t26[e17], this.u = [
          1,
          0,
          this.u
        ]);
        return n34.children;
      }, $dc040a17866866fa$export$998bcd577473dd93.prototype.componentDidUpdate = $dc040a17866866fa$export$998bcd577473dd93.prototype.componentDidMount = function() {
        var n35 = this;
        this.o.forEach(function(t27, e18) {
          $dc040a17866866fa$var$T(n35, e18, t27);
        });
      };
      $dc040a17866866fa$var$j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, $dc040a17866866fa$var$P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, $dc040a17866866fa$var$V = "undefined" != typeof document, $dc040a17866866fa$var$z = function(n36) {
        return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n36);
      };
      (0, $fb96b826c0c5f37a$export$16fa2f45be04daa8).prototype.isReactComponent = {}, [
        "componentWillMount",
        "componentWillReceiveProps",
        "componentWillUpdate"
      ].forEach(function(n39) {
        Object.defineProperty((0, $fb96b826c0c5f37a$export$16fa2f45be04daa8).prototype, n39, {
          configurable: true,
          get: function() {
            return this["UNSAFE_" + n39];
          },
          set: function(t30) {
            Object.defineProperty(this, n39, {
              configurable: true,
              writable: true,
              value: t30
            });
          }
        });
      });
      $dc040a17866866fa$var$H = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).event;
      (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).event = function(n40) {
        return $dc040a17866866fa$var$H && (n40 = $dc040a17866866fa$var$H(n40)), n40.persist = $dc040a17866866fa$var$Z, n40.isPropagationStopped = $dc040a17866866fa$var$Y, n40.isDefaultPrevented = $dc040a17866866fa$var$q, n40.nativeEvent = n40;
      };
      $dc040a17866866fa$var$J = {
        configurable: true,
        get: function() {
          return this.class;
        }
      }, $dc040a17866866fa$var$K = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).vnode;
      (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).vnode = function(n41) {
        var t31 = n41.type, e21 = n41.props, r14 = e21;
        if ("string" == typeof t31) {
          var u7 = -1 === t31.indexOf("-");
          for (var o3 in r14 = {}, e21) {
            var i2 = e21[o3];
            $dc040a17866866fa$var$V && "children" === o3 && "noscript" === t31 || "value" === o3 && "defaultValue" in e21 && null == i2 || ("defaultValue" === o3 && "value" in e21 && null == e21.value ? o3 = "value" : "download" === o3 && true === i2 ? i2 = "" : /ondoubleclick/i.test(o3) ? o3 = "ondblclick" : /^onchange(textarea|input)/i.test(o3 + t31) && !$dc040a17866866fa$var$z(e21.type) ? o3 = "oninput" : /^onfocus$/i.test(o3) ? o3 = "onfocusin" : /^onblur$/i.test(o3) ? o3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp)/.test(o3) ? o3 = o3.toLowerCase() : u7 && $dc040a17866866fa$var$P.test(o3) ? o3 = o3.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === i2 && (i2 = void 0), r14[o3] = i2);
          }
          "select" == t31 && r14.multiple && Array.isArray(r14.value) && (r14.value = (0, $fb96b826c0c5f37a$export$47e4c5b300681277)(e21.children).forEach(function(n42) {
            n42.props.selected = -1 != r14.value.indexOf(n42.props.value);
          })), "select" == t31 && null != r14.defaultValue && (r14.value = (0, $fb96b826c0c5f37a$export$47e4c5b300681277)(e21.children).forEach(function(n43) {
            n43.props.selected = r14.multiple ? -1 != r14.defaultValue.indexOf(n43.props.value) : r14.defaultValue == n43.props.value;
          })), n41.props = r14, e21.class != e21.className && ($dc040a17866866fa$var$J.enumerable = "className" in e21, null != e21.className && (r14.class = e21.className), Object.defineProperty(r14, "className", $dc040a17866866fa$var$J));
        }
        n41.$$typeof = $dc040a17866866fa$var$j, $dc040a17866866fa$var$K && $dc040a17866866fa$var$K(n41);
      };
      $dc040a17866866fa$var$Q = (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__r;
      (0, $fb96b826c0c5f37a$export$41c562ebe57d11e2).__r = function(n44) {
        $dc040a17866866fa$var$Q && $dc040a17866866fa$var$Q(n44), $dc040a17866866fa$var$G = n44.__c;
      };
      $dc040a17866866fa$export$ae55be85d98224ed = {
        ReactCurrentDispatcher: {
          current: {
            readContext: function(n45) {
              return $dc040a17866866fa$var$G.__n[n45.__c].props.value;
            }
          }
        }
      }, $dc040a17866866fa$export$83d89fbfd8236492 = "17.0.2";
      $dc040a17866866fa$export$c78a37762a8d58e1 = function(n51, t32) {
        return n51(t32);
      }, $dc040a17866866fa$export$cd75ccfd720a3cd4 = function(n52, t33) {
        return n52(t33);
      }, $dc040a17866866fa$export$5f8d39834fd61797 = (0, $fb96b826c0c5f37a$export$ffb0004e005737fa);
      $dc040a17866866fa$export$2e2bcd8739ae039 = {
        useState: (0, $1a9a8ef576b7773d$export$60241385465d0a34),
        useReducer: (0, $1a9a8ef576b7773d$export$13e3392192263954),
        useEffect: (0, $1a9a8ef576b7773d$export$6d9c69b0de29b591),
        useLayoutEffect: (0, $1a9a8ef576b7773d$export$e5c5a5f917a5871c),
        useRef: (0, $1a9a8ef576b7773d$export$b8f5890fc79d6aca),
        useImperativeHandle: (0, $1a9a8ef576b7773d$export$d5a552a76deda3c2),
        useMemo: (0, $1a9a8ef576b7773d$export$1538c33de8887b59),
        useCallback: (0, $1a9a8ef576b7773d$export$35808ee640e87ca7),
        useContext: (0, $1a9a8ef576b7773d$export$fae74005e78b1a27),
        useDebugValue: (0, $1a9a8ef576b7773d$export$dc8fbce3eb94dc1e),
        version: "17.0.2",
        Children: $dc040a17866866fa$export$dca3b0875bd9a954,
        render: $dc040a17866866fa$export$b3890eb0ae9dca99,
        hydrate: $dc040a17866866fa$export$fa8d919ba61d84db,
        unmountComponentAtNode: $dc040a17866866fa$export$502457920280e6be,
        createPortal: $dc040a17866866fa$export$d39a5bbd09211389,
        createElement: (0, $fb96b826c0c5f37a$export$c8a8987d4410bf2d),
        createContext: (0, $fb96b826c0c5f37a$export$fd42f52fd3ae1109),
        createFactory: $dc040a17866866fa$export$d38cd72104c1f0e9,
        cloneElement: $dc040a17866866fa$export$e530037191fcd5d7,
        createRef: (0, $fb96b826c0c5f37a$export$7d1e3a5e95ceca43),
        Fragment: (0, $fb96b826c0c5f37a$export$ffb0004e005737fa),
        isValidElement: $dc040a17866866fa$export$a8257692ac88316c,
        findDOMNode: $dc040a17866866fa$export$466bfc07425424d5,
        Component: (0, $fb96b826c0c5f37a$export$16fa2f45be04daa8),
        PureComponent: $dc040a17866866fa$export$221d75b3f55bb0bd,
        memo: $dc040a17866866fa$export$7c73462e0d25e514,
        forwardRef: $dc040a17866866fa$export$257a8862b851cb5b,
        flushSync: $dc040a17866866fa$export$cd75ccfd720a3cd4,
        unstable_batchedUpdates: $dc040a17866866fa$export$c78a37762a8d58e1,
        StrictMode: (0, $fb96b826c0c5f37a$export$ffb0004e005737fa),
        Suspense: $dc040a17866866fa$export$74bf444e3cd11ea5,
        SuspenseList: $dc040a17866866fa$export$998bcd577473dd93,
        lazy: $dc040a17866866fa$export$488013bae63b21da,
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: $dc040a17866866fa$export$ae55be85d98224ed
      };
      $ec8c39fdad15601a$var$THEME_ICONS = {
        light: "outline",
        dark: "solid"
      };
      $ec8c39fdad15601a$export$2e2bcd8739ae039 = class extends (0, $dc040a17866866fa$export$221d75b3f55bb0bd) {
        renderIcon(category) {
          const { icon } = category;
          if (icon) {
            if (icon.svg) return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("span", {
              class: "flex",
              dangerouslySetInnerHTML: {
                __html: icon.svg
              }
            });
            if (icon.src) return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("img", {
              src: icon.src
            });
          }
          const categoryIcons = (0, $fcccfb36ed0cde68$export$2e2bcd8739ae039).categories[category.id] || (0, $fcccfb36ed0cde68$export$2e2bcd8739ae039).categories.custom;
          const style3 = this.props.icons == "auto" ? $ec8c39fdad15601a$var$THEME_ICONS[this.props.theme] : this.props.icons;
          return categoryIcons[style3] || categoryIcons;
        }
        render() {
          let selectedCategoryIndex = null;
          return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("nav", {
            id: "nav",
            class: "padding",
            "data-position": this.props.position,
            dir: this.props.dir,
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
              class: "flex relative",
              children: [
                this.categories.map((category, i) => {
                  const title = category.name || (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).categories[category.id];
                  const selected = !this.props.unfocused && category.id == this.state.categoryId;
                  if (selected) selectedCategoryIndex = i;
                  return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("button", {
                    "aria-label": title,
                    "aria-selected": selected || void 0,
                    title,
                    type: "button",
                    class: "flex flex-grow flex-center",
                    onMouseDown: (e) => e.preventDefault(),
                    onClick: () => {
                      this.props.onClick({
                        category,
                        i
                      });
                    },
                    children: this.renderIcon(category)
                  });
                }),
                /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                  class: "bar",
                  style: {
                    width: `${100 / this.categories.length}%`,
                    opacity: selectedCategoryIndex == null ? 0 : 1,
                    transform: this.props.dir === "rtl" ? `scaleX(-1) translateX(${selectedCategoryIndex * 100}%)` : `translateX(${selectedCategoryIndex * 100}%)`
                  }
                })
              ]
            })
          });
        }
        constructor() {
          super();
          this.categories = (0, $7adb23b0109cc36a$export$2d0294657ab35f1b).categories.filter((category) => {
            return !category.target;
          });
          this.state = {
            categoryId: this.categories[0].id
          };
        }
      };
      $e0d4dda61265ff1e$export$2e2bcd8739ae039 = class extends (0, $dc040a17866866fa$export$221d75b3f55bb0bd) {
        shouldComponentUpdate(nextProps) {
          for (let k in nextProps) {
            if (k == "children") continue;
            if (nextProps[k] != this.props[k]) return true;
          }
          return false;
        }
        render() {
          return this.props.children;
        }
      };
      $89bd6bb200cc8fef$var$Performance = {
        rowsPerRender: 10
      };
      $89bd6bb200cc8fef$export$2e2bcd8739ae039 = class extends (0, $fb96b826c0c5f37a$export$16fa2f45be04daa8) {
        getInitialState(props = this.props) {
          return {
            skin: (0, $f72b75cf796873c7$export$2e2bcd8739ae039).get("skin") || props.skin,
            theme: this.initTheme(props.theme)
          };
        }
        componentWillMount() {
          this.dir = (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).rtl ? "rtl" : "ltr";
          this.refs = {
            menu: (0, $fb96b826c0c5f37a$export$7d1e3a5e95ceca43)(),
            navigation: (0, $fb96b826c0c5f37a$export$7d1e3a5e95ceca43)(),
            scroll: (0, $fb96b826c0c5f37a$export$7d1e3a5e95ceca43)(),
            search: (0, $fb96b826c0c5f37a$export$7d1e3a5e95ceca43)(),
            searchInput: (0, $fb96b826c0c5f37a$export$7d1e3a5e95ceca43)(),
            skinToneButton: (0, $fb96b826c0c5f37a$export$7d1e3a5e95ceca43)(),
            skinToneRadio: (0, $fb96b826c0c5f37a$export$7d1e3a5e95ceca43)()
          };
          this.initGrid();
          if (this.props.stickySearch == false && this.props.searchPosition == "sticky") {
            console.warn("[EmojiMart] Deprecation warning: `stickySearch` has been renamed `searchPosition`.");
            this.props.searchPosition = "static";
          }
        }
        componentDidMount() {
          this.register();
          this.shadowRoot = this.base.parentNode;
          if (this.props.autoFocus) {
            const { searchInput } = this.refs;
            if (searchInput.current) searchInput.current.focus();
          }
        }
        componentWillReceiveProps(nextProps) {
          this.nextState || (this.nextState = {});
          for (const k1 in nextProps) this.nextState[k1] = nextProps[k1];
          clearTimeout(this.nextStateTimer);
          this.nextStateTimer = setTimeout(() => {
            let requiresGridReset = false;
            for (const k in this.nextState) {
              this.props[k] = this.nextState[k];
              if (k === "custom" || k === "categories") requiresGridReset = true;
            }
            delete this.nextState;
            const nextState = this.getInitialState();
            if (requiresGridReset) return this.reset(nextState);
            this.setState(nextState);
          });
        }
        componentWillUnmount() {
          this.unregister();
        }
        async reset(nextState = {}) {
          await (0, $7adb23b0109cc36a$export$2cd8252107eb640b)(this.props);
          this.initGrid();
          this.unobserve();
          this.setState(nextState, () => {
            this.observeCategories();
            this.observeRows();
          });
        }
        register() {
          document.addEventListener("click", this.handleClickOutside);
          this.observe();
        }
        unregister() {
          document.removeEventListener("click", this.handleClickOutside);
          this.darkMedia?.removeEventListener("change", this.darkMediaCallback);
          this.unobserve();
        }
        observe() {
          this.observeCategories();
          this.observeRows();
        }
        unobserve({ except = [] } = {}) {
          if (!Array.isArray(except)) except = [
            except
          ];
          for (const observer of this.observers) {
            if (except.includes(observer)) continue;
            observer.disconnect();
          }
          this.observers = [].concat(except);
        }
        initGrid() {
          const { categories } = (0, $7adb23b0109cc36a$export$2d0294657ab35f1b);
          this.refs.categories = /* @__PURE__ */ new Map();
          const navKey = (0, $7adb23b0109cc36a$export$2d0294657ab35f1b).categories.map((category) => category.id).join(",");
          if (this.navKey && this.navKey != navKey) this.refs.scroll.current && (this.refs.scroll.current.scrollTop = 0);
          this.navKey = navKey;
          this.grid = [];
          this.grid.setsize = 0;
          const addRow2 = (rows, category) => {
            const row2 = [];
            row2.__categoryId = category.id;
            row2.__index = rows.length;
            this.grid.push(row2);
            const rowIndex = this.grid.length - 1;
            const rowRef = rowIndex % $89bd6bb200cc8fef$var$Performance.rowsPerRender ? {} : (0, $fb96b826c0c5f37a$export$7d1e3a5e95ceca43)();
            rowRef.index = rowIndex;
            rowRef.posinset = this.grid.setsize + 1;
            rows.push(rowRef);
            return row2;
          };
          for (let category1 of categories) {
            const rows = [];
            let row2 = addRow2(rows, category1);
            for (let emoji2 of category1.emojis) {
              if (row2.length == this.getPerLine()) row2 = addRow2(rows, category1);
              this.grid.setsize += 1;
              row2.push(emoji2);
            }
            this.refs.categories.set(category1.id, {
              root: (0, $fb96b826c0c5f37a$export$7d1e3a5e95ceca43)(),
              rows
            });
          }
        }
        initTheme(theme) {
          if (theme != "auto") return theme;
          if (!this.darkMedia) {
            this.darkMedia = matchMedia("(prefers-color-scheme: dark)");
            if (this.darkMedia.media.match(/^not/)) return "light";
            this.darkMedia.addEventListener("change", this.darkMediaCallback);
          }
          return this.darkMedia.matches ? "dark" : "light";
        }
        initDynamicPerLine(props = this.props) {
          if (!props.dynamicWidth) return;
          const { element: element7, emojiButtonSize } = props;
          const calculatePerLine = () => {
            const { width } = element7.getBoundingClientRect();
            return Math.floor(width / emojiButtonSize);
          };
          const observer = new ResizeObserver(() => {
            this.unobserve({
              except: observer
            });
            this.setState({
              perLine: calculatePerLine()
            }, () => {
              this.initGrid();
              this.forceUpdate(() => {
                this.observeCategories();
                this.observeRows();
              });
            });
          });
          observer.observe(element7);
          this.observers.push(observer);
          return calculatePerLine();
        }
        getPerLine() {
          return this.state.perLine || this.props.perLine;
        }
        getEmojiByPos([p1, p22]) {
          const grid = this.state.searchResults || this.grid;
          const emoji2 = grid[p1] && grid[p1][p22];
          if (!emoji2) return;
          return (0, $c4d155af13ad4d4b$export$2e2bcd8739ae039).get(emoji2);
        }
        observeCategories() {
          const navigation = this.refs.navigation.current;
          if (!navigation) return;
          const visibleCategories = /* @__PURE__ */ new Map();
          const setFocusedCategory = (categoryId) => {
            if (categoryId != navigation.state.categoryId) navigation.setState({
              categoryId
            });
          };
          const observerOptions = {
            root: this.refs.scroll.current,
            threshold: [
              0,
              1
            ]
          };
          const observer = new IntersectionObserver((entries) => {
            for (const entry of entries) {
              const id2 = entry.target.dataset.id;
              visibleCategories.set(id2, entry.intersectionRatio);
            }
            const ratios = [
              ...visibleCategories
            ];
            for (const [id2, ratio] of ratios) if (ratio) {
              setFocusedCategory(id2);
              break;
            }
          }, observerOptions);
          for (const { root: root6 } of this.refs.categories.values()) observer.observe(root6.current);
          this.observers.push(observer);
        }
        observeRows() {
          const visibleRows = {
            ...this.state.visibleRows
          };
          const observer = new IntersectionObserver((entries) => {
            for (const entry of entries) {
              const index3 = parseInt(entry.target.dataset.index);
              if (entry.isIntersecting) visibleRows[index3] = true;
              else delete visibleRows[index3];
            }
            this.setState({
              visibleRows
            });
          }, {
            root: this.refs.scroll.current,
            rootMargin: `${this.props.emojiButtonSize * ($89bd6bb200cc8fef$var$Performance.rowsPerRender + 5)}px 0px ${this.props.emojiButtonSize * $89bd6bb200cc8fef$var$Performance.rowsPerRender}px`
          });
          for (const { rows } of this.refs.categories.values()) {
            for (const row2 of rows) if (row2.current) observer.observe(row2.current);
          }
          this.observers.push(observer);
        }
        preventDefault(e) {
          e.preventDefault();
        }
        unfocusSearch() {
          const input2 = this.refs.searchInput.current;
          if (!input2) return;
          input2.blur();
        }
        navigate({ e, input: input2, left, right, up, down }) {
          const grid = this.state.searchResults || this.grid;
          if (!grid.length) return;
          let [p1, p22] = this.state.pos;
          const pos = (() => {
            if (p1 == 0) {
              if (p22 == 0 && !e.repeat && (left || up)) return null;
            }
            if (p1 == -1) {
              if (!e.repeat && (right || down) && input2.selectionStart == input2.value.length) return [
                0,
                0
              ];
              return null;
            }
            if (left || right) {
              let row2 = grid[p1];
              const increment2 = left ? -1 : 1;
              p22 += increment2;
              if (!row2[p22]) {
                p1 += increment2;
                row2 = grid[p1];
                if (!row2) {
                  p1 = left ? 0 : grid.length - 1;
                  p22 = left ? 0 : grid[p1].length - 1;
                  return [
                    p1,
                    p22
                  ];
                }
                p22 = left ? row2.length - 1 : 0;
              }
              return [
                p1,
                p22
              ];
            }
            if (up || down) {
              p1 += up ? -1 : 1;
              const row2 = grid[p1];
              if (!row2) {
                p1 = up ? 0 : grid.length - 1;
                p22 = up ? 0 : grid[p1].length - 1;
                return [
                  p1,
                  p22
                ];
              }
              if (!row2[p22]) p22 = row2.length - 1;
              return [
                p1,
                p22
              ];
            }
          })();
          if (pos) e.preventDefault();
          else {
            if (this.state.pos[0] > -1) this.setState({
              pos: [
                -1,
                -1
              ]
            });
            return;
          }
          this.setState({
            pos,
            keyboard: true
          }, () => {
            this.scrollTo({
              row: pos[0]
            });
          });
        }
        scrollTo({ categoryId, row: row2 }) {
          const grid = this.state.searchResults || this.grid;
          if (!grid.length) return;
          const scroll = this.refs.scroll.current;
          const scrollRect = scroll.getBoundingClientRect();
          let scrollTop = 0;
          if (row2 >= 0) categoryId = grid[row2].__categoryId;
          if (categoryId) {
            const ref = this.refs[categoryId] || this.refs.categories.get(categoryId).root;
            const categoryRect = ref.current.getBoundingClientRect();
            scrollTop = categoryRect.top - (scrollRect.top - scroll.scrollTop) + 1;
          }
          if (row2 >= 0) {
            if (!row2) scrollTop = 0;
            else {
              const rowIndex = grid[row2].__index;
              const rowTop = scrollTop + rowIndex * this.props.emojiButtonSize;
              const rowBot = rowTop + this.props.emojiButtonSize + this.props.emojiButtonSize * 0.88;
              if (rowTop < scroll.scrollTop) scrollTop = rowTop;
              else if (rowBot > scroll.scrollTop + scrollRect.height) scrollTop = rowBot - scrollRect.height;
              else return;
            }
          }
          this.ignoreMouse();
          scroll.scrollTop = scrollTop;
        }
        ignoreMouse() {
          this.mouseIsIgnored = true;
          clearTimeout(this.ignoreMouseTimer);
          this.ignoreMouseTimer = setTimeout(() => {
            delete this.mouseIsIgnored;
          }, 100);
        }
        handleEmojiOver(pos) {
          if (this.mouseIsIgnored || this.state.showSkins) return;
          this.setState({
            pos: pos || [
              -1,
              -1
            ],
            keyboard: false
          });
        }
        handleEmojiClick({ e, emoji: emoji2, pos }) {
          if (!this.props.onEmojiSelect) return;
          if (!emoji2 && pos) emoji2 = this.getEmojiByPos(pos);
          if (emoji2) {
            const emojiData = (0, $693b183b0a78708f$export$d10ac59fbe52a745)(emoji2, {
              skinIndex: this.state.skin - 1
            });
            if (this.props.maxFrequentRows) (0, $b22cfd0a55410b4f$export$2e2bcd8739ae039).add(emojiData, this.props);
            this.props.onEmojiSelect(emojiData, e);
          }
        }
        closeSkins() {
          if (!this.state.showSkins) return;
          this.setState({
            showSkins: null,
            tempSkin: null
          });
          this.base.removeEventListener("click", this.handleBaseClick);
          this.base.removeEventListener("keydown", this.handleBaseKeydown);
        }
        handleSkinMouseOver(tempSkin) {
          this.setState({
            tempSkin
          });
        }
        handleSkinClick(skin) {
          this.ignoreMouse();
          this.closeSkins();
          this.setState({
            skin,
            tempSkin: null
          });
          (0, $f72b75cf796873c7$export$2e2bcd8739ae039).set("skin", skin);
        }
        renderNav() {
          return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)((0, $ec8c39fdad15601a$export$2e2bcd8739ae039), {
            ref: this.refs.navigation,
            icons: this.props.icons,
            theme: this.state.theme,
            dir: this.dir,
            unfocused: !!this.state.searchResults,
            position: this.props.navPosition,
            onClick: this.handleCategoryClick
          }, this.navKey);
        }
        renderPreview() {
          const emoji2 = this.getEmojiByPos(this.state.pos);
          const noSearchResults = this.state.searchResults && !this.state.searchResults.length;
          return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
            id: "preview",
            class: "flex flex-middle",
            dir: this.dir,
            "data-position": this.props.previewPosition,
            children: [
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                class: "flex flex-middle flex-grow",
                children: [
                  /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                    class: "flex flex-auto flex-middle flex-center",
                    style: {
                      height: this.props.emojiButtonSize,
                      fontSize: this.props.emojiButtonSize
                    },
                    children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)((0, $254755d3f438722f$export$2e2bcd8739ae039), {
                      emoji: emoji2,
                      id: noSearchResults ? this.props.noResultsEmoji || "cry" : this.props.previewEmoji || (this.props.previewPosition == "top" ? "point_down" : "point_up"),
                      set: this.props.set,
                      size: this.props.emojiButtonSize,
                      skin: this.state.tempSkin || this.state.skin,
                      spritesheet: true,
                      getSpritesheetURL: this.props.getSpritesheetURL
                    })
                  }),
                  /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                    class: `margin-${this.dir[0]}`,
                    children: emoji2 || noSearchResults ? /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                      class: `padding-${this.dir[2]} align-${this.dir[0]}`,
                      children: [
                        /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                          class: "preview-title ellipsis",
                          children: emoji2 ? emoji2.name : (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).search_no_results_1
                        }),
                        /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                          class: "preview-subtitle ellipsis color-c",
                          children: emoji2 ? emoji2.skins[0].shortcodes : (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).search_no_results_2
                        })
                      ]
                    }) : /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                      class: "preview-placeholder color-c",
                      children: (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).pick
                    })
                  })
                ]
              }),
              !emoji2 && this.props.skinTonePosition == "preview" && this.renderSkinToneButton()
            ]
          });
        }
        renderEmojiButton(emoji2, { pos, posinset, grid }) {
          const size2 = this.props.emojiButtonSize;
          const skin = this.state.tempSkin || this.state.skin;
          const emojiSkin = emoji2.skins[skin - 1] || emoji2.skins[0];
          const native = emojiSkin.native;
          const selected = (0, $693b183b0a78708f$export$9cb4719e2e525b7a)(this.state.pos, pos);
          const key2 = pos.concat(emoji2.id).join("");
          return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)((0, $e0d4dda61265ff1e$export$2e2bcd8739ae039), {
            selected,
            skin,
            size: size2,
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("button", {
              "aria-label": native,
              "aria-selected": selected || void 0,
              "aria-posinset": posinset,
              "aria-setsize": grid.setsize,
              "data-keyboard": this.state.keyboard,
              title: this.props.previewPosition == "none" ? emoji2.name : void 0,
              type: "button",
              class: "flex flex-center flex-middle",
              tabindex: "-1",
              onClick: (e) => this.handleEmojiClick({
                e,
                emoji: emoji2
              }),
              onMouseEnter: () => this.handleEmojiOver(pos),
              onMouseLeave: () => this.handleEmojiOver(),
              style: {
                width: this.props.emojiButtonSize,
                height: this.props.emojiButtonSize,
                fontSize: this.props.emojiSize,
                lineHeight: 0
              },
              children: [
                /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                  "aria-hidden": "true",
                  class: "background",
                  style: {
                    borderRadius: this.props.emojiButtonRadius,
                    backgroundColor: this.props.emojiButtonColors ? this.props.emojiButtonColors[(posinset - 1) % this.props.emojiButtonColors.length] : void 0
                  }
                }),
                /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)((0, $254755d3f438722f$export$2e2bcd8739ae039), {
                  emoji: emoji2,
                  set: this.props.set,
                  size: this.props.emojiSize,
                  skin,
                  spritesheet: true,
                  getSpritesheetURL: this.props.getSpritesheetURL
                })
              ]
            })
          }, key2);
        }
        renderSearch() {
          const renderSkinTone = this.props.previewPosition == "none" || this.props.skinTonePosition == "search";
          return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
            children: [
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                class: "spacer"
              }),
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                class: "flex flex-middle",
                children: [
                  /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                    class: "search relative flex-grow",
                    children: [
                      /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("input", {
                        type: "search",
                        ref: this.refs.searchInput,
                        placeholder: (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).search,
                        onClick: this.handleSearchClick,
                        onInput: this.handleSearchInput,
                        onKeyDown: this.handleSearchKeyDown,
                        autoComplete: "off"
                      }),
                      /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("span", {
                        class: "icon loupe flex",
                        children: (0, $fcccfb36ed0cde68$export$2e2bcd8739ae039).search.loupe
                      }),
                      this.state.searchResults && /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("button", {
                        title: "Clear",
                        "aria-label": "Clear",
                        type: "button",
                        class: "icon delete flex",
                        onClick: this.clearSearch,
                        onMouseDown: this.preventDefault,
                        children: (0, $fcccfb36ed0cde68$export$2e2bcd8739ae039).search.delete
                      })
                    ]
                  }),
                  renderSkinTone && this.renderSkinToneButton()
                ]
              })
            ]
          });
        }
        renderSearchResults() {
          const { searchResults } = this.state;
          if (!searchResults) return null;
          return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
            class: "category",
            ref: this.refs.search,
            children: [
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                class: `sticky padding-small align-${this.dir[0]}`,
                children: (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).categories.search
              }),
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                children: !searchResults.length ? /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                  class: `padding-small align-${this.dir[0]}`,
                  children: this.props.onAddCustomEmoji && /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("a", {
                    onClick: this.props.onAddCustomEmoji,
                    children: (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).add_custom
                  })
                }) : searchResults.map((row2, i) => {
                  return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                    class: "flex",
                    children: row2.map((emoji2, ii2) => {
                      return this.renderEmojiButton(emoji2, {
                        pos: [
                          i,
                          ii2
                        ],
                        posinset: i * this.props.perLine + ii2 + 1,
                        grid: searchResults
                      });
                    })
                  });
                })
              })
            ]
          });
        }
        renderCategories() {
          const { categories } = (0, $7adb23b0109cc36a$export$2d0294657ab35f1b);
          const hidden2 = !!this.state.searchResults;
          const perLine = this.getPerLine();
          return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
            style: {
              visibility: hidden2 ? "hidden" : void 0,
              display: hidden2 ? "none" : void 0,
              height: "100%"
            },
            children: categories.map((category) => {
              const { root: root6, rows } = this.refs.categories.get(category.id);
              return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                "data-id": category.target ? category.target.id : category.id,
                class: "category",
                ref: root6,
                children: [
                  /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                    class: `sticky padding-small align-${this.dir[0]}`,
                    children: category.name || (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).categories[category.id]
                  }),
                  /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                    class: "relative",
                    style: {
                      height: rows.length * this.props.emojiButtonSize
                    },
                    children: rows.map((row2, i) => {
                      const targetRow = row2.index - row2.index % $89bd6bb200cc8fef$var$Performance.rowsPerRender;
                      const visible = this.state.visibleRows[targetRow];
                      const ref = "current" in row2 ? row2 : void 0;
                      if (!visible && !ref) return null;
                      const start = i * perLine;
                      const end = start + perLine;
                      const emojiIds = category.emojis.slice(start, end);
                      if (emojiIds.length < perLine) emojiIds.push(...new Array(perLine - emojiIds.length));
                      return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                        "data-index": row2.index,
                        ref,
                        class: "flex row",
                        style: {
                          top: i * this.props.emojiButtonSize
                        },
                        children: visible && emojiIds.map((emojiId, ii2) => {
                          if (!emojiId) return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                            style: {
                              width: this.props.emojiButtonSize,
                              height: this.props.emojiButtonSize
                            }
                          });
                          const emoji2 = (0, $c4d155af13ad4d4b$export$2e2bcd8739ae039).get(emojiId);
                          return this.renderEmojiButton(emoji2, {
                            pos: [
                              row2.index,
                              ii2
                            ],
                            posinset: row2.posinset + ii2,
                            grid: this.grid
                          });
                        })
                      }, row2.index);
                    })
                  })
                ]
              });
            })
          });
        }
        renderSkinToneButton() {
          if (this.props.skinTonePosition == "none") return null;
          return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
            class: "flex flex-auto flex-center flex-middle",
            style: {
              position: "relative",
              width: this.props.emojiButtonSize,
              height: this.props.emojiButtonSize
            },
            children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("button", {
              type: "button",
              ref: this.refs.skinToneButton,
              class: "skin-tone-button flex flex-auto flex-center flex-middle",
              "aria-selected": this.state.showSkins ? "" : void 0,
              "aria-label": (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).skins.choose,
              title: (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).skins.choose,
              onClick: this.openSkins,
              style: {
                width: this.props.emojiSize,
                height: this.props.emojiSize
              },
              children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("span", {
                class: `skin-tone skin-tone-${this.state.skin}`
              })
            })
          });
        }
        renderLiveRegion() {
          const emoji2 = this.getEmojiByPos(this.state.pos);
          const contents = emoji2 ? emoji2.name : "";
          return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
            "aria-live": "polite",
            class: "sr-only",
            children: contents
          });
        }
        renderSkins() {
          const skinToneButton = this.refs.skinToneButton.current;
          const skinToneButtonRect = skinToneButton.getBoundingClientRect();
          const baseRect = this.base.getBoundingClientRect();
          const position4 = {};
          if (this.dir == "ltr") position4.right = baseRect.right - skinToneButtonRect.right - 3;
          else position4.left = skinToneButtonRect.left - baseRect.left - 3;
          if (this.props.previewPosition == "bottom" && this.props.skinTonePosition == "preview") position4.bottom = baseRect.bottom - skinToneButtonRect.top + 6;
          else {
            position4.top = skinToneButtonRect.bottom - baseRect.top + 3;
            position4.bottom = "auto";
          }
          return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
            ref: this.refs.menu,
            role: "radiogroup",
            dir: this.dir,
            "aria-label": (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).skins.choose,
            class: "menu hidden",
            "data-position": position4.top ? "top" : "bottom",
            style: position4,
            children: [
              ...Array(6).keys()
            ].map((i) => {
              const skin = i + 1;
              const checked = this.state.skin == skin;
              return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                children: [
                  /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("input", {
                    type: "radio",
                    name: "skin-tone",
                    value: skin,
                    "aria-label": (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).skins[skin],
                    ref: checked ? this.refs.skinToneRadio : null,
                    defaultChecked: checked,
                    onChange: () => this.handleSkinMouseOver(skin),
                    onKeyDown: (e) => {
                      if (e.code == "Enter" || e.code == "Space" || e.code == "Tab") {
                        e.preventDefault();
                        this.handleSkinClick(skin);
                      }
                    }
                  }),
                  /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("button", {
                    "aria-hidden": "true",
                    tabindex: "-1",
                    onClick: () => this.handleSkinClick(skin),
                    onMouseEnter: () => this.handleSkinMouseOver(skin),
                    onMouseLeave: () => this.handleSkinMouseOver(),
                    class: "option flex flex-grow flex-middle",
                    children: [
                      /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("span", {
                        class: `skin-tone skin-tone-${skin}`
                      }),
                      /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("span", {
                        class: "margin-small-lr",
                        children: (0, $7adb23b0109cc36a$export$dbe3113d60765c1a).skins[skin]
                      })
                    ]
                  })
                ]
              });
            })
          });
        }
        render() {
          const lineWidth = this.props.perLine * this.props.emojiButtonSize;
          return /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("section", {
            id: "root",
            class: "flex flex-column",
            dir: this.dir,
            style: {
              width: this.props.dynamicWidth ? "100%" : `calc(${lineWidth}px + (var(--padding) + var(--sidebar-width)))`
            },
            "data-emoji-set": this.props.set,
            "data-theme": this.state.theme,
            "data-menu": this.state.showSkins ? "" : void 0,
            children: [
              this.props.previewPosition == "top" && this.renderPreview(),
              this.props.navPosition == "top" && this.renderNav(),
              this.props.searchPosition == "sticky" && /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                class: "padding-lr",
                children: this.renderSearch()
              }),
              /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                ref: this.refs.scroll,
                class: "scroll flex-grow padding-lr",
                children: /* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)("div", {
                  style: {
                    width: this.props.dynamicWidth ? "100%" : lineWidth,
                    height: "100%"
                  },
                  children: [
                    this.props.searchPosition == "static" && this.renderSearch(),
                    this.renderSearchResults(),
                    this.renderCategories()
                  ]
                })
              }),
              this.props.navPosition == "bottom" && this.renderNav(),
              this.props.previewPosition == "bottom" && this.renderPreview(),
              this.state.showSkins && this.renderSkins(),
              this.renderLiveRegion()
            ]
          });
        }
        constructor(props) {
          super();
          (0, $c770c458706daa72$export$2e2bcd8739ae039)(this, "darkMediaCallback", () => {
            if (this.props.theme != "auto") return;
            this.setState({
              theme: this.darkMedia.matches ? "dark" : "light"
            });
          });
          (0, $c770c458706daa72$export$2e2bcd8739ae039)(this, "handleClickOutside", (e) => {
            const { element: element7 } = this.props;
            if (e.target != element7) {
              if (this.state.showSkins) this.closeSkins();
              if (this.props.onClickOutside) this.props.onClickOutside(e);
            }
          });
          (0, $c770c458706daa72$export$2e2bcd8739ae039)(this, "handleBaseClick", (e) => {
            if (!this.state.showSkins) return;
            if (!e.target.closest(".menu")) {
              e.preventDefault();
              e.stopImmediatePropagation();
              this.closeSkins();
            }
          });
          (0, $c770c458706daa72$export$2e2bcd8739ae039)(this, "handleBaseKeydown", (e) => {
            if (!this.state.showSkins) return;
            if (e.key == "Escape") {
              e.preventDefault();
              e.stopImmediatePropagation();
              this.closeSkins();
            }
          });
          (0, $c770c458706daa72$export$2e2bcd8739ae039)(this, "handleSearchClick", () => {
            const emoji2 = this.getEmojiByPos(this.state.pos);
            if (!emoji2) return;
            this.setState({
              pos: [
                -1,
                -1
              ]
            });
          });
          (0, $c770c458706daa72$export$2e2bcd8739ae039)(this, "handleSearchInput", async () => {
            const input2 = this.refs.searchInput.current;
            if (!input2) return;
            const { value } = input2;
            const searchResults = await (0, $c4d155af13ad4d4b$export$2e2bcd8739ae039).search(value);
            const afterRender = () => {
              if (!this.refs.scroll.current) return;
              this.refs.scroll.current.scrollTop = 0;
            };
            if (!searchResults) return this.setState({
              searchResults,
              pos: [
                -1,
                -1
              ]
            }, afterRender);
            const pos = input2.selectionStart == input2.value.length ? [
              0,
              0
            ] : [
              -1,
              -1
            ];
            const grid = [];
            grid.setsize = searchResults.length;
            let row2 = null;
            for (let emoji2 of searchResults) {
              if (!grid.length || row2.length == this.getPerLine()) {
                row2 = [];
                row2.__categoryId = "search";
                row2.__index = grid.length;
                grid.push(row2);
              }
              row2.push(emoji2);
            }
            this.ignoreMouse();
            this.setState({
              searchResults: grid,
              pos
            }, afterRender);
          });
          (0, $c770c458706daa72$export$2e2bcd8739ae039)(this, "handleSearchKeyDown", (e) => {
            const input2 = e.currentTarget;
            e.stopImmediatePropagation();
            switch (e.key) {
              case "ArrowLeft":
                this.navigate({
                  e,
                  input: input2,
                  left: true
                });
                break;
              case "ArrowRight":
                this.navigate({
                  e,
                  input: input2,
                  right: true
                });
                break;
              case "ArrowUp":
                this.navigate({
                  e,
                  input: input2,
                  up: true
                });
                break;
              case "ArrowDown":
                this.navigate({
                  e,
                  input: input2,
                  down: true
                });
                break;
              case "Enter":
                e.preventDefault();
                this.handleEmojiClick({
                  e,
                  pos: this.state.pos
                });
                break;
              case "Escape":
                e.preventDefault();
                if (this.state.searchResults) this.clearSearch();
                else this.unfocusSearch();
                break;
              default:
                break;
            }
          });
          (0, $c770c458706daa72$export$2e2bcd8739ae039)(this, "clearSearch", () => {
            const input2 = this.refs.searchInput.current;
            if (!input2) return;
            input2.value = "";
            input2.focus();
            this.handleSearchInput();
          });
          (0, $c770c458706daa72$export$2e2bcd8739ae039)(this, "handleCategoryClick", ({ category, i }) => {
            this.scrollTo(i == 0 ? {
              row: -1
            } : {
              categoryId: category.id
            });
          });
          (0, $c770c458706daa72$export$2e2bcd8739ae039)(this, "openSkins", (e) => {
            const { currentTarget } = e;
            const rect = currentTarget.getBoundingClientRect();
            this.setState({
              showSkins: rect
            }, async () => {
              await (0, $693b183b0a78708f$export$e772c8ff12451969)(2);
              const menu = this.refs.menu.current;
              if (!menu) return;
              menu.classList.remove("hidden");
              this.refs.skinToneRadio.current.focus();
              this.base.addEventListener("click", this.handleBaseClick, true);
              this.base.addEventListener("keydown", this.handleBaseKeydown, true);
            });
          });
          this.observers = [];
          this.state = {
            pos: [
              -1,
              -1
            ],
            perLine: this.initDynamicPerLine(props),
            visibleRows: {
              0: true
            },
            ...this.getInitialState(props)
          };
        }
      };
      $efa000751917694d$export$2e2bcd8739ae039 = class extends (0, $26f27c338a96b1a6$export$2e2bcd8739ae039) {
        async connectedCallback() {
          const props = (0, $7adb23b0109cc36a$export$75fe5f91d452f94b)(this.props, (0, $b247ea80b67298d5$export$2e2bcd8739ae039), this);
          props.element = this;
          props.ref = (component) => {
            this.component = component;
          };
          await (0, $7adb23b0109cc36a$export$2cd8252107eb640b)(props);
          if (this.disconnected) return;
          (0, $fb96b826c0c5f37a$export$b3890eb0ae9dca99)(/* @__PURE__ */ (0, $bd9dd35321b03dd4$export$34b9dba7ce09269b)((0, $89bd6bb200cc8fef$export$2e2bcd8739ae039), {
            ...props
          }), this.shadowRoot);
        }
        constructor(props) {
          super(props, {
            styles: (0, /* @__PURE__ */ $parcel$interopDefault($329d53ba9fd7125f$exports))
          });
        }
      };
      (0, $c770c458706daa72$export$2e2bcd8739ae039)($efa000751917694d$export$2e2bcd8739ae039, "Props", (0, $b247ea80b67298d5$export$2e2bcd8739ae039));
      if (typeof customElements !== "undefined" && !customElements.get("em-emoji-picker")) customElements.define("em-emoji-picker", $efa000751917694d$export$2e2bcd8739ae039);
      $329d53ba9fd7125f$exports = {};
      $329d53ba9fd7125f$exports = ':host {\n  width: min-content;\n  height: 435px;\n  min-height: 230px;\n  border-radius: var(--border-radius);\n  box-shadow: var(--shadow);\n  --border-radius: 10px;\n  --category-icon-size: 18px;\n  --font-family: -apple-system, BlinkMacSystemFont, "Helvetica Neue", sans-serif;\n  --font-size: 15px;\n  --preview-placeholder-size: 21px;\n  --preview-title-size: 1.1em;\n  --preview-subtitle-size: .9em;\n  --shadow-color: 0deg 0% 0%;\n  --shadow: .3px .5px 2.7px hsl(var(--shadow-color) / .14), .4px .8px 1px -3.2px hsl(var(--shadow-color) / .14), 1px 2px 2.5px -4.5px hsl(var(--shadow-color) / .14);\n  display: flex;\n}\n\n[data-theme="light"] {\n  --em-rgb-color: var(--rgb-color, 34, 36, 39);\n  --em-rgb-accent: var(--rgb-accent, 34, 102, 237);\n  --em-rgb-background: var(--rgb-background, 255, 255, 255);\n  --em-rgb-input: var(--rgb-input, 255, 255, 255);\n  --em-color-border: var(--color-border, rgba(0, 0, 0, .05));\n  --em-color-border-over: var(--color-border-over, rgba(0, 0, 0, .1));\n}\n\n[data-theme="dark"] {\n  --em-rgb-color: var(--rgb-color, 222, 222, 221);\n  --em-rgb-accent: var(--rgb-accent, 58, 130, 247);\n  --em-rgb-background: var(--rgb-background, 21, 22, 23);\n  --em-rgb-input: var(--rgb-input, 0, 0, 0);\n  --em-color-border: var(--color-border, rgba(255, 255, 255, .1));\n  --em-color-border-over: var(--color-border-over, rgba(255, 255, 255, .2));\n}\n\n#root {\n  --color-a: rgb(var(--em-rgb-color));\n  --color-b: rgba(var(--em-rgb-color), .65);\n  --color-c: rgba(var(--em-rgb-color), .45);\n  --padding: 12px;\n  --padding-small: calc(var(--padding) / 2);\n  --sidebar-width: 16px;\n  --duration: 225ms;\n  --duration-fast: 125ms;\n  --duration-instant: 50ms;\n  --easing: cubic-bezier(.4, 0, .2, 1);\n  width: 100%;\n  text-align: left;\n  border-radius: var(--border-radius);\n  background-color: rgb(var(--em-rgb-background));\n  position: relative;\n}\n\n@media (prefers-reduced-motion) {\n  #root {\n    --duration: 0;\n    --duration-fast: 0;\n    --duration-instant: 0;\n  }\n}\n\n#root[data-menu] button {\n  cursor: auto;\n}\n\n#root[data-menu] .menu button {\n  cursor: pointer;\n}\n\n:host, #root, input, button {\n  color: rgb(var(--em-rgb-color));\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  line-height: normal;\n}\n\n*, :before, :after {\n  box-sizing: border-box;\n  min-width: 0;\n  margin: 0;\n  padding: 0;\n}\n\n.relative {\n  position: relative;\n}\n\n.flex {\n  display: flex;\n}\n\n.flex-auto {\n  flex: none;\n}\n\n.flex-center {\n  justify-content: center;\n}\n\n.flex-column {\n  flex-direction: column;\n}\n\n.flex-grow {\n  flex: auto;\n}\n\n.flex-middle {\n  align-items: center;\n}\n\n.flex-wrap {\n  flex-wrap: wrap;\n}\n\n.padding {\n  padding: var(--padding);\n}\n\n.padding-t {\n  padding-top: var(--padding);\n}\n\n.padding-lr {\n  padding-left: var(--padding);\n  padding-right: var(--padding);\n}\n\n.padding-r {\n  padding-right: var(--padding);\n}\n\n.padding-small {\n  padding: var(--padding-small);\n}\n\n.padding-small-b {\n  padding-bottom: var(--padding-small);\n}\n\n.padding-small-lr {\n  padding-left: var(--padding-small);\n  padding-right: var(--padding-small);\n}\n\n.margin {\n  margin: var(--padding);\n}\n\n.margin-r {\n  margin-right: var(--padding);\n}\n\n.margin-l {\n  margin-left: var(--padding);\n}\n\n.margin-small-l {\n  margin-left: var(--padding-small);\n}\n\n.margin-small-lr {\n  margin-left: var(--padding-small);\n  margin-right: var(--padding-small);\n}\n\n.align-l {\n  text-align: left;\n}\n\n.align-r {\n  text-align: right;\n}\n\n.color-a {\n  color: var(--color-a);\n}\n\n.color-b {\n  color: var(--color-b);\n}\n\n.color-c {\n  color: var(--color-c);\n}\n\n.ellipsis {\n  white-space: nowrap;\n  max-width: 100%;\n  width: auto;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n\n.sr-only {\n  width: 1px;\n  height: 1px;\n  position: absolute;\n  top: auto;\n  left: -10000px;\n  overflow: hidden;\n}\n\na {\n  cursor: pointer;\n  color: rgb(var(--em-rgb-accent));\n}\n\na:hover {\n  text-decoration: underline;\n}\n\n.spacer {\n  height: 10px;\n}\n\n[dir="rtl"] .scroll {\n  padding-left: 0;\n  padding-right: var(--padding);\n}\n\n.scroll {\n  padding-right: 0;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n\n.scroll::-webkit-scrollbar {\n  width: var(--sidebar-width);\n  height: var(--sidebar-width);\n}\n\n.scroll::-webkit-scrollbar-track {\n  border: 0;\n}\n\n.scroll::-webkit-scrollbar-button {\n  width: 0;\n  height: 0;\n  display: none;\n}\n\n.scroll::-webkit-scrollbar-corner {\n  background-color: rgba(0, 0, 0, 0);\n}\n\n.scroll::-webkit-scrollbar-thumb {\n  min-height: 20%;\n  min-height: 65px;\n  border: 4px solid rgb(var(--em-rgb-background));\n  border-radius: 8px;\n}\n\n.scroll::-webkit-scrollbar-thumb:hover {\n  background-color: var(--em-color-border-over) !important;\n}\n\n.scroll:hover::-webkit-scrollbar-thumb {\n  background-color: var(--em-color-border);\n}\n\n.sticky {\n  z-index: 1;\n  background-color: rgba(var(--em-rgb-background), .9);\n  -webkit-backdrop-filter: blur(4px);\n  backdrop-filter: blur(4px);\n  font-weight: 500;\n  position: sticky;\n  top: -1px;\n}\n\n[dir="rtl"] .search input[type="search"] {\n  padding: 10px 2.2em 10px 2em;\n}\n\n[dir="rtl"] .search .loupe {\n  left: auto;\n  right: .7em;\n}\n\n[dir="rtl"] .search .delete {\n  left: .7em;\n  right: auto;\n}\n\n.search {\n  z-index: 2;\n  position: relative;\n}\n\n.search input, .search button {\n  font-size: calc(var(--font-size)  - 1px);\n}\n\n.search input[type="search"] {\n  width: 100%;\n  background-color: var(--em-color-border);\n  transition-duration: var(--duration);\n  transition-property: background-color, box-shadow;\n  transition-timing-function: var(--easing);\n  border: 0;\n  border-radius: 10px;\n  outline: 0;\n  padding: 10px 2em 10px 2.2em;\n  display: block;\n}\n\n.search input[type="search"]::-ms-input-placeholder {\n  color: inherit;\n  opacity: .6;\n}\n\n.search input[type="search"]::placeholder {\n  color: inherit;\n  opacity: .6;\n}\n\n.search input[type="search"], .search input[type="search"]::-webkit-search-decoration, .search input[type="search"]::-webkit-search-cancel-button, .search input[type="search"]::-webkit-search-results-button, .search input[type="search"]::-webkit-search-results-decoration {\n  -webkit-appearance: none;\n  -ms-appearance: none;\n  appearance: none;\n}\n\n.search input[type="search"]:focus {\n  background-color: rgb(var(--em-rgb-input));\n  box-shadow: inset 0 0 0 1px rgb(var(--em-rgb-accent)), 0 1px 3px rgba(65, 69, 73, .2);\n}\n\n.search .icon {\n  z-index: 1;\n  color: rgba(var(--em-rgb-color), .7);\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n\n.search .loupe {\n  pointer-events: none;\n  left: .7em;\n}\n\n.search .delete {\n  right: .7em;\n}\n\nsvg {\n  fill: currentColor;\n  width: 1em;\n  height: 1em;\n}\n\nbutton {\n  -webkit-appearance: none;\n  -ms-appearance: none;\n  appearance: none;\n  cursor: pointer;\n  color: currentColor;\n  background-color: rgba(0, 0, 0, 0);\n  border: 0;\n}\n\n#nav {\n  z-index: 2;\n  padding-top: 12px;\n  padding-bottom: 12px;\n  padding-right: var(--sidebar-width);\n  position: relative;\n}\n\n#nav button {\n  color: var(--color-b);\n  transition: color var(--duration) var(--easing);\n}\n\n#nav button:hover {\n  color: var(--color-a);\n}\n\n#nav svg, #nav img {\n  width: var(--category-icon-size);\n  height: var(--category-icon-size);\n}\n\n#nav[dir="rtl"] .bar {\n  left: auto;\n  right: 0;\n}\n\n#nav .bar {\n  width: 100%;\n  height: 3px;\n  background-color: rgb(var(--em-rgb-accent));\n  transition: transform var(--duration) var(--easing);\n  border-radius: 3px 3px 0 0;\n  position: absolute;\n  bottom: -12px;\n  left: 0;\n}\n\n#nav button[aria-selected] {\n  color: rgb(var(--em-rgb-accent));\n}\n\n#preview {\n  z-index: 2;\n  padding: calc(var(--padding)  + 4px) var(--padding);\n  padding-right: var(--sidebar-width);\n  position: relative;\n}\n\n#preview .preview-placeholder {\n  font-size: var(--preview-placeholder-size);\n}\n\n#preview .preview-title {\n  font-size: var(--preview-title-size);\n}\n\n#preview .preview-subtitle {\n  font-size: var(--preview-subtitle-size);\n}\n\n#nav:before, #preview:before {\n  content: "";\n  height: 2px;\n  position: absolute;\n  left: 0;\n  right: 0;\n}\n\n#nav[data-position="top"]:before, #preview[data-position="top"]:before {\n  background: linear-gradient(to bottom, var(--em-color-border), transparent);\n  top: 100%;\n}\n\n#nav[data-position="bottom"]:before, #preview[data-position="bottom"]:before {\n  background: linear-gradient(to top, var(--em-color-border), transparent);\n  bottom: 100%;\n}\n\n.category:last-child {\n  min-height: calc(100% + 1px);\n}\n\n.category button {\n  font-family: -apple-system, BlinkMacSystemFont, Helvetica Neue, sans-serif;\n  position: relative;\n}\n\n.category button > * {\n  position: relative;\n}\n\n.category button .background {\n  opacity: 0;\n  background-color: var(--em-color-border);\n  transition: opacity var(--duration-fast) var(--easing) var(--duration-instant);\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.category button:hover .background {\n  transition-duration: var(--duration-instant);\n  transition-delay: 0s;\n}\n\n.category button[aria-selected] .background {\n  opacity: 1;\n}\n\n.category button[data-keyboard] .background {\n  transition: none;\n}\n\n.row {\n  width: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n\n.skin-tone-button {\n  border: 1px solid rgba(0, 0, 0, 0);\n  border-radius: 100%;\n}\n\n.skin-tone-button:hover {\n  border-color: var(--em-color-border);\n}\n\n.skin-tone-button:active .skin-tone {\n  transform: scale(.85) !important;\n}\n\n.skin-tone-button .skin-tone {\n  transition: transform var(--duration) var(--easing);\n}\n\n.skin-tone-button[aria-selected] {\n  background-color: var(--em-color-border);\n  border-top-color: rgba(0, 0, 0, .05);\n  border-bottom-color: rgba(0, 0, 0, 0);\n  border-left-width: 0;\n  border-right-width: 0;\n}\n\n.skin-tone-button[aria-selected] .skin-tone {\n  transform: scale(.9);\n}\n\n.menu {\n  z-index: 2;\n  white-space: nowrap;\n  border: 1px solid var(--em-color-border);\n  background-color: rgba(var(--em-rgb-background), .9);\n  -webkit-backdrop-filter: blur(4px);\n  backdrop-filter: blur(4px);\n  transition-property: opacity, transform;\n  transition-duration: var(--duration);\n  transition-timing-function: var(--easing);\n  border-radius: 10px;\n  padding: 4px;\n  position: absolute;\n  box-shadow: 1px 1px 5px rgba(0, 0, 0, .05);\n}\n\n.menu.hidden {\n  opacity: 0;\n}\n\n.menu[data-position="bottom"] {\n  transform-origin: 100% 100%;\n}\n\n.menu[data-position="bottom"].hidden {\n  transform: scale(.9)rotate(-3deg)translateY(5%);\n}\n\n.menu[data-position="top"] {\n  transform-origin: 100% 0;\n}\n\n.menu[data-position="top"].hidden {\n  transform: scale(.9)rotate(3deg)translateY(-5%);\n}\n\n.menu input[type="radio"] {\n  clip: rect(0 0 0 0);\n  width: 1px;\n  height: 1px;\n  border: 0;\n  margin: 0;\n  padding: 0;\n  position: absolute;\n  overflow: hidden;\n}\n\n.menu input[type="radio"]:checked + .option {\n  box-shadow: 0 0 0 2px rgb(var(--em-rgb-accent));\n}\n\n.option {\n  width: 100%;\n  border-radius: 6px;\n  padding: 4px 6px;\n}\n\n.option:hover {\n  color: #fff;\n  background-color: rgb(var(--em-rgb-accent));\n}\n\n.skin-tone {\n  width: 16px;\n  height: 16px;\n  border-radius: 100%;\n  display: inline-block;\n  position: relative;\n  overflow: hidden;\n}\n\n.skin-tone:after {\n  content: "";\n  mix-blend-mode: overlay;\n  background: linear-gradient(rgba(255, 255, 255, .2), rgba(0, 0, 0, 0));\n  border: 1px solid rgba(0, 0, 0, .8);\n  border-radius: 100%;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  box-shadow: inset 0 -2px 3px #000, inset 0 1px 2px #fff;\n}\n\n.skin-tone-1 {\n  background-color: #ffc93a;\n}\n\n.skin-tone-2 {\n  background-color: #ffdab7;\n}\n\n.skin-tone-3 {\n  background-color: #e7b98f;\n}\n\n.skin-tone-4 {\n  background-color: #c88c61;\n}\n\n.skin-tone-5 {\n  background-color: #a46134;\n}\n\n.skin-tone-6 {\n  background-color: #5d4437;\n}\n\n[data-index] {\n  justify-content: space-between;\n}\n\n[data-emoji-set="twitter"] .skin-tone:after {\n  box-shadow: none;\n  border-color: rgba(0, 0, 0, .5);\n}\n\n[data-emoji-set="twitter"] .skin-tone-1 {\n  background-color: #fade72;\n}\n\n[data-emoji-set="twitter"] .skin-tone-2 {\n  background-color: #f3dfd0;\n}\n\n[data-emoji-set="twitter"] .skin-tone-3 {\n  background-color: #eed3a8;\n}\n\n[data-emoji-set="twitter"] .skin-tone-4 {\n  background-color: #cfad8d;\n}\n\n[data-emoji-set="twitter"] .skin-tone-5 {\n  background-color: #a8805d;\n}\n\n[data-emoji-set="twitter"] .skin-tone-6 {\n  background-color: #765542;\n}\n\n[data-emoji-set="google"] .skin-tone:after {\n  box-shadow: inset 0 0 2px 2px rgba(0, 0, 0, .4);\n}\n\n[data-emoji-set="google"] .skin-tone-1 {\n  background-color: #f5c748;\n}\n\n[data-emoji-set="google"] .skin-tone-2 {\n  background-color: #f1d5aa;\n}\n\n[data-emoji-set="google"] .skin-tone-3 {\n  background-color: #d4b48d;\n}\n\n[data-emoji-set="google"] .skin-tone-4 {\n  background-color: #aa876b;\n}\n\n[data-emoji-set="google"] .skin-tone-5 {\n  background-color: #916544;\n}\n\n[data-emoji-set="google"] .skin-tone-6 {\n  background-color: #61493f;\n}\n\n[data-emoji-set="facebook"] .skin-tone:after {\n  border-color: rgba(0, 0, 0, .4);\n  box-shadow: inset 0 -2px 3px #000, inset 0 1px 4px #fff;\n}\n\n[data-emoji-set="facebook"] .skin-tone-1 {\n  background-color: #f5c748;\n}\n\n[data-emoji-set="facebook"] .skin-tone-2 {\n  background-color: #f1d5aa;\n}\n\n[data-emoji-set="facebook"] .skin-tone-3 {\n  background-color: #d4b48d;\n}\n\n[data-emoji-set="facebook"] .skin-tone-4 {\n  background-color: #aa876b;\n}\n\n[data-emoji-set="facebook"] .skin-tone-5 {\n  background-color: #916544;\n}\n\n[data-emoji-set="facebook"] .skin-tone-6 {\n  background-color: #61493f;\n}\n\n';
    }
  });

  // node_modules/@emoji-mart/data/sets/15/native.json
  var require_native = __commonJS({
    "node_modules/@emoji-mart/data/sets/15/native.json"(exports, module) {
      module.exports = { categories: [{ id: "people", emojis: ["grinning", "smiley", "smile", "grin", "laughing", "sweat_smile", "rolling_on_the_floor_laughing", "joy", "slightly_smiling_face", "upside_down_face", "melting_face", "wink", "blush", "innocent", "smiling_face_with_3_hearts", "heart_eyes", "star-struck", "kissing_heart", "kissing", "relaxed", "kissing_closed_eyes", "kissing_smiling_eyes", "smiling_face_with_tear", "yum", "stuck_out_tongue", "stuck_out_tongue_winking_eye", "zany_face", "stuck_out_tongue_closed_eyes", "money_mouth_face", "hugging_face", "face_with_hand_over_mouth", "face_with_open_eyes_and_hand_over_mouth", "face_with_peeking_eye", "shushing_face", "thinking_face", "saluting_face", "zipper_mouth_face", "face_with_raised_eyebrow", "neutral_face", "expressionless", "no_mouth", "dotted_line_face", "face_in_clouds", "smirk", "unamused", "face_with_rolling_eyes", "grimacing", "face_exhaling", "lying_face", "shaking_face", "relieved", "pensive", "sleepy", "drooling_face", "sleeping", "mask", "face_with_thermometer", "face_with_head_bandage", "nauseated_face", "face_vomiting", "sneezing_face", "hot_face", "cold_face", "woozy_face", "dizzy_face", "face_with_spiral_eyes", "exploding_head", "face_with_cowboy_hat", "partying_face", "disguised_face", "sunglasses", "nerd_face", "face_with_monocle", "confused", "face_with_diagonal_mouth", "worried", "slightly_frowning_face", "white_frowning_face", "open_mouth", "hushed", "astonished", "flushed", "pleading_face", "face_holding_back_tears", "frowning", "anguished", "fearful", "cold_sweat", "disappointed_relieved", "cry", "sob", "scream", "confounded", "persevere", "disappointed", "sweat", "weary", "tired_face", "yawning_face", "triumph", "rage", "angry", "face_with_symbols_on_mouth", "smiling_imp", "imp", "skull", "skull_and_crossbones", "hankey", "clown_face", "japanese_ogre", "japanese_goblin", "ghost", "alien", "space_invader", "wave", "raised_back_of_hand", "raised_hand_with_fingers_splayed", "hand", "spock-hand", "rightwards_hand", "leftwards_hand", "palm_down_hand", "palm_up_hand", "leftwards_pushing_hand", "rightwards_pushing_hand", "ok_hand", "pinched_fingers", "pinching_hand", "v", "crossed_fingers", "hand_with_index_finger_and_thumb_crossed", "i_love_you_hand_sign", "the_horns", "call_me_hand", "point_left", "point_right", "point_up_2", "middle_finger", "point_down", "point_up", "index_pointing_at_the_viewer", "+1", "-1", "fist", "facepunch", "left-facing_fist", "right-facing_fist", "clap", "raised_hands", "heart_hands", "open_hands", "palms_up_together", "handshake", "pray", "writing_hand", "nail_care", "selfie", "muscle", "mechanical_arm", "mechanical_leg", "leg", "foot", "ear", "ear_with_hearing_aid", "nose", "brain", "anatomical_heart", "lungs", "tooth", "bone", "eyes", "eye", "tongue", "lips", "biting_lip", "baby", "child", "boy", "girl", "adult", "person_with_blond_hair", "man", "bearded_person", "man_with_beard", "woman_with_beard", "red_haired_man", "curly_haired_man", "white_haired_man", "bald_man", "woman", "red_haired_woman", "red_haired_person", "curly_haired_woman", "curly_haired_person", "white_haired_woman", "white_haired_person", "bald_woman", "bald_person", "blond-haired-woman", "blond-haired-man", "older_adult", "older_man", "older_woman", "person_frowning", "man-frowning", "woman-frowning", "person_with_pouting_face", "man-pouting", "woman-pouting", "no_good", "man-gesturing-no", "woman-gesturing-no", "ok_woman", "man-gesturing-ok", "woman-gesturing-ok", "information_desk_person", "man-tipping-hand", "woman-tipping-hand", "raising_hand", "man-raising-hand", "woman-raising-hand", "deaf_person", "deaf_man", "deaf_woman", "bow", "man-bowing", "woman-bowing", "face_palm", "man-facepalming", "woman-facepalming", "shrug", "man-shrugging", "woman-shrugging", "health_worker", "male-doctor", "female-doctor", "student", "male-student", "female-student", "teacher", "male-teacher", "female-teacher", "judge", "male-judge", "female-judge", "farmer", "male-farmer", "female-farmer", "cook", "male-cook", "female-cook", "mechanic", "male-mechanic", "female-mechanic", "factory_worker", "male-factory-worker", "female-factory-worker", "office_worker", "male-office-worker", "female-office-worker", "scientist", "male-scientist", "female-scientist", "technologist", "male-technologist", "female-technologist", "singer", "male-singer", "female-singer", "artist", "male-artist", "female-artist", "pilot", "male-pilot", "female-pilot", "astronaut", "male-astronaut", "female-astronaut", "firefighter", "male-firefighter", "female-firefighter", "cop", "male-police-officer", "female-police-officer", "sleuth_or_spy", "male-detective", "female-detective", "guardsman", "male-guard", "female-guard", "ninja", "construction_worker", "male-construction-worker", "female-construction-worker", "person_with_crown", "prince", "princess", "man_with_turban", "man-wearing-turban", "woman-wearing-turban", "man_with_gua_pi_mao", "person_with_headscarf", "person_in_tuxedo", "man_in_tuxedo", "woman_in_tuxedo", "bride_with_veil", "man_with_veil", "woman_with_veil", "pregnant_woman", "pregnant_man", "pregnant_person", "breast-feeding", "woman_feeding_baby", "man_feeding_baby", "person_feeding_baby", "angel", "santa", "mrs_claus", "mx_claus", "superhero", "male_superhero", "female_superhero", "supervillain", "male_supervillain", "female_supervillain", "mage", "male_mage", "female_mage", "fairy", "male_fairy", "female_fairy", "vampire", "male_vampire", "female_vampire", "merperson", "merman", "mermaid", "elf", "male_elf", "female_elf", "genie", "male_genie", "female_genie", "zombie", "male_zombie", "female_zombie", "troll", "massage", "man-getting-massage", "woman-getting-massage", "haircut", "man-getting-haircut", "woman-getting-haircut", "walking", "man-walking", "woman-walking", "standing_person", "man_standing", "woman_standing", "kneeling_person", "man_kneeling", "woman_kneeling", "person_with_probing_cane", "man_with_probing_cane", "woman_with_probing_cane", "person_in_motorized_wheelchair", "man_in_motorized_wheelchair", "woman_in_motorized_wheelchair", "person_in_manual_wheelchair", "man_in_manual_wheelchair", "woman_in_manual_wheelchair", "runner", "man-running", "woman-running", "dancer", "man_dancing", "man_in_business_suit_levitating", "dancers", "men-with-bunny-ears-partying", "women-with-bunny-ears-partying", "person_in_steamy_room", "man_in_steamy_room", "woman_in_steamy_room", "person_climbing", "man_climbing", "woman_climbing", "fencer", "horse_racing", "skier", "snowboarder", "golfer", "man-golfing", "woman-golfing", "surfer", "man-surfing", "woman-surfing", "rowboat", "man-rowing-boat", "woman-rowing-boat", "swimmer", "man-swimming", "woman-swimming", "person_with_ball", "man-bouncing-ball", "woman-bouncing-ball", "weight_lifter", "man-lifting-weights", "woman-lifting-weights", "bicyclist", "man-biking", "woman-biking", "mountain_bicyclist", "man-mountain-biking", "woman-mountain-biking", "person_doing_cartwheel", "man-cartwheeling", "woman-cartwheeling", "wrestlers", "man-wrestling", "woman-wrestling", "water_polo", "man-playing-water-polo", "woman-playing-water-polo", "handball", "man-playing-handball", "woman-playing-handball", "juggling", "man-juggling", "woman-juggling", "person_in_lotus_position", "man_in_lotus_position", "woman_in_lotus_position", "bath", "sleeping_accommodation", "people_holding_hands", "two_women_holding_hands", "man_and_woman_holding_hands", "two_men_holding_hands", "couplekiss", "woman-kiss-man", "man-kiss-man", "woman-kiss-woman", "couple_with_heart", "woman-heart-man", "man-heart-man", "woman-heart-woman", "family", "man-woman-boy", "man-woman-girl", "man-woman-girl-boy", "man-woman-boy-boy", "man-woman-girl-girl", "man-man-boy", "man-man-girl", "man-man-girl-boy", "man-man-boy-boy", "man-man-girl-girl", "woman-woman-boy", "woman-woman-girl", "woman-woman-girl-boy", "woman-woman-boy-boy", "woman-woman-girl-girl", "man-boy", "man-boy-boy", "man-girl", "man-girl-boy", "man-girl-girl", "woman-boy", "woman-boy-boy", "woman-girl", "woman-girl-boy", "woman-girl-girl", "speaking_head_in_silhouette", "bust_in_silhouette", "busts_in_silhouette", "people_hugging", "footprints", "robot_face", "smiley_cat", "smile_cat", "joy_cat", "heart_eyes_cat", "smirk_cat", "kissing_cat", "scream_cat", "crying_cat_face", "pouting_cat", "see_no_evil", "hear_no_evil", "speak_no_evil", "love_letter", "cupid", "gift_heart", "sparkling_heart", "heartpulse", "heartbeat", "revolving_hearts", "two_hearts", "heart_decoration", "heavy_heart_exclamation_mark_ornament", "broken_heart", "heart_on_fire", "mending_heart", "heart", "pink_heart", "orange_heart", "yellow_heart", "green_heart", "blue_heart", "light_blue_heart", "purple_heart", "brown_heart", "black_heart", "grey_heart", "white_heart", "kiss", "100", "anger", "boom", "dizzy", "sweat_drops", "dash", "hole", "speech_balloon", "eye-in-speech-bubble", "left_speech_bubble", "right_anger_bubble", "thought_balloon", "zzz"] }, { id: "nature", emojis: ["monkey_face", "monkey", "gorilla", "orangutan", "dog", "dog2", "guide_dog", "service_dog", "poodle", "wolf", "fox_face", "raccoon", "cat", "cat2", "black_cat", "lion_face", "tiger", "tiger2", "leopard", "horse", "moose", "donkey", "racehorse", "unicorn_face", "zebra_face", "deer", "bison", "cow", "ox", "water_buffalo", "cow2", "pig", "pig2", "boar", "pig_nose", "ram", "sheep", "goat", "dromedary_camel", "camel", "llama", "giraffe_face", "elephant", "mammoth", "rhinoceros", "hippopotamus", "mouse", "mouse2", "rat", "hamster", "rabbit", "rabbit2", "chipmunk", "beaver", "hedgehog", "bat", "bear", "polar_bear", "koala", "panda_face", "sloth", "otter", "skunk", "kangaroo", "badger", "feet", "turkey", "chicken", "rooster", "hatching_chick", "baby_chick", "hatched_chick", "bird", "penguin", "dove_of_peace", "eagle", "duck", "swan", "owl", "dodo", "feather", "flamingo", "peacock", "parrot", "wing", "black_bird", "goose", "frog", "crocodile", "turtle", "lizard", "snake", "dragon_face", "dragon", "sauropod", "t-rex", "whale", "whale2", "dolphin", "seal", "fish", "tropical_fish", "blowfish", "shark", "octopus", "shell", "coral", "jellyfish", "snail", "butterfly", "bug", "ant", "bee", "beetle", "ladybug", "cricket", "cockroach", "spider", "spider_web", "scorpion", "mosquito", "fly", "worm", "microbe", "bouquet", "cherry_blossom", "white_flower", "lotus", "rosette", "rose", "wilted_flower", "hibiscus", "sunflower", "blossom", "tulip", "hyacinth", "seedling", "potted_plant", "evergreen_tree", "deciduous_tree", "palm_tree", "cactus", "ear_of_rice", "herb", "shamrock", "four_leaf_clover", "maple_leaf", "fallen_leaf", "leaves", "empty_nest", "nest_with_eggs", "mushroom"] }, { id: "foods", emojis: ["grapes", "melon", "watermelon", "tangerine", "lemon", "banana", "pineapple", "mango", "apple", "green_apple", "pear", "peach", "cherries", "strawberry", "blueberries", "kiwifruit", "tomato", "olive", "coconut", "avocado", "eggplant", "potato", "carrot", "corn", "hot_pepper", "bell_pepper", "cucumber", "leafy_green", "broccoli", "garlic", "onion", "peanuts", "beans", "chestnut", "ginger_root", "pea_pod", "bread", "croissant", "baguette_bread", "flatbread", "pretzel", "bagel", "pancakes", "waffle", "cheese_wedge", "meat_on_bone", "poultry_leg", "cut_of_meat", "bacon", "hamburger", "fries", "pizza", "hotdog", "sandwich", "taco", "burrito", "tamale", "stuffed_flatbread", "falafel", "egg", "fried_egg", "shallow_pan_of_food", "stew", "fondue", "bowl_with_spoon", "green_salad", "popcorn", "butter", "salt", "canned_food", "bento", "rice_cracker", "rice_ball", "rice", "curry", "ramen", "spaghetti", "sweet_potato", "oden", "sushi", "fried_shrimp", "fish_cake", "moon_cake", "dango", "dumpling", "fortune_cookie", "takeout_box", "crab", "lobster", "shrimp", "squid", "oyster", "icecream", "shaved_ice", "ice_cream", "doughnut", "cookie", "birthday", "cake", "cupcake", "pie", "chocolate_bar", "candy", "lollipop", "custard", "honey_pot", "baby_bottle", "glass_of_milk", "coffee", "teapot", "tea", "sake", "champagne", "wine_glass", "cocktail", "tropical_drink", "beer", "beers", "clinking_glasses", "tumbler_glass", "pouring_liquid", "cup_with_straw", "bubble_tea", "beverage_box", "mate_drink", "ice_cube", "chopsticks", "knife_fork_plate", "fork_and_knife", "spoon", "hocho", "jar", "amphora"] }, { id: "activity", emojis: ["jack_o_lantern", "christmas_tree", "fireworks", "sparkler", "firecracker", "sparkles", "balloon", "tada", "confetti_ball", "tanabata_tree", "bamboo", "dolls", "flags", "wind_chime", "rice_scene", "red_envelope", "ribbon", "gift", "reminder_ribbon", "admission_tickets", "ticket", "medal", "trophy", "sports_medal", "first_place_medal", "second_place_medal", "third_place_medal", "soccer", "baseball", "softball", "basketball", "volleyball", "football", "rugby_football", "tennis", "flying_disc", "bowling", "cricket_bat_and_ball", "field_hockey_stick_and_ball", "ice_hockey_stick_and_puck", "lacrosse", "table_tennis_paddle_and_ball", "badminton_racquet_and_shuttlecock", "boxing_glove", "martial_arts_uniform", "goal_net", "golf", "ice_skate", "fishing_pole_and_fish", "diving_mask", "running_shirt_with_sash", "ski", "sled", "curling_stone", "dart", "yo-yo", "kite", "gun", "8ball", "crystal_ball", "magic_wand", "video_game", "joystick", "slot_machine", "game_die", "jigsaw", "teddy_bear", "pinata", "mirror_ball", "nesting_dolls", "spades", "hearts", "diamonds", "clubs", "chess_pawn", "black_joker", "mahjong", "flower_playing_cards", "performing_arts", "frame_with_picture", "art", "thread", "sewing_needle", "yarn", "knot"] }, { id: "places", emojis: ["earth_africa", "earth_americas", "earth_asia", "globe_with_meridians", "world_map", "japan", "compass", "snow_capped_mountain", "mountain", "volcano", "mount_fuji", "camping", "beach_with_umbrella", "desert", "desert_island", "national_park", "stadium", "classical_building", "building_construction", "bricks", "rock", "wood", "hut", "house_buildings", "derelict_house_building", "house", "house_with_garden", "office", "post_office", "european_post_office", "hospital", "bank", "hotel", "love_hotel", "convenience_store", "school", "department_store", "factory", "japanese_castle", "european_castle", "wedding", "tokyo_tower", "statue_of_liberty", "church", "mosque", "hindu_temple", "synagogue", "shinto_shrine", "kaaba", "fountain", "tent", "foggy", "night_with_stars", "cityscape", "sunrise_over_mountains", "sunrise", "city_sunset", "city_sunrise", "bridge_at_night", "hotsprings", "carousel_horse", "playground_slide", "ferris_wheel", "roller_coaster", "barber", "circus_tent", "steam_locomotive", "railway_car", "bullettrain_side", "bullettrain_front", "train2", "metro", "light_rail", "station", "tram", "monorail", "mountain_railway", "train", "bus", "oncoming_bus", "trolleybus", "minibus", "ambulance", "fire_engine", "police_car", "oncoming_police_car", "taxi", "oncoming_taxi", "car", "oncoming_automobile", "blue_car", "pickup_truck", "truck", "articulated_lorry", "tractor", "racing_car", "racing_motorcycle", "motor_scooter", "manual_wheelchair", "motorized_wheelchair", "auto_rickshaw", "bike", "scooter", "skateboard", "roller_skate", "busstop", "motorway", "railway_track", "oil_drum", "fuelpump", "wheel", "rotating_light", "traffic_light", "vertical_traffic_light", "octagonal_sign", "construction", "anchor", "ring_buoy", "boat", "canoe", "speedboat", "passenger_ship", "ferry", "motor_boat", "ship", "airplane", "small_airplane", "airplane_departure", "airplane_arriving", "parachute", "seat", "helicopter", "suspension_railway", "mountain_cableway", "aerial_tramway", "satellite", "rocket", "flying_saucer", "bellhop_bell", "luggage", "hourglass", "hourglass_flowing_sand", "watch", "alarm_clock", "stopwatch", "timer_clock", "mantelpiece_clock", "clock12", "clock1230", "clock1", "clock130", "clock2", "clock230", "clock3", "clock330", "clock4", "clock430", "clock5", "clock530", "clock6", "clock630", "clock7", "clock730", "clock8", "clock830", "clock9", "clock930", "clock10", "clock1030", "clock11", "clock1130", "new_moon", "waxing_crescent_moon", "first_quarter_moon", "moon", "full_moon", "waning_gibbous_moon", "last_quarter_moon", "waning_crescent_moon", "crescent_moon", "new_moon_with_face", "first_quarter_moon_with_face", "last_quarter_moon_with_face", "thermometer", "sunny", "full_moon_with_face", "sun_with_face", "ringed_planet", "star", "star2", "stars", "milky_way", "cloud", "partly_sunny", "thunder_cloud_and_rain", "mostly_sunny", "barely_sunny", "partly_sunny_rain", "rain_cloud", "snow_cloud", "lightning", "tornado", "fog", "wind_blowing_face", "cyclone", "rainbow", "closed_umbrella", "umbrella", "umbrella_with_rain_drops", "umbrella_on_ground", "zap", "snowflake", "snowman", "snowman_without_snow", "comet", "fire", "droplet", "ocean"] }, { id: "objects", emojis: ["eyeglasses", "dark_sunglasses", "goggles", "lab_coat", "safety_vest", "necktie", "shirt", "jeans", "scarf", "gloves", "coat", "socks", "dress", "kimono", "sari", "one-piece_swimsuit", "briefs", "shorts", "bikini", "womans_clothes", "folding_hand_fan", "purse", "handbag", "pouch", "shopping_bags", "school_satchel", "thong_sandal", "mans_shoe", "athletic_shoe", "hiking_boot", "womans_flat_shoe", "high_heel", "sandal", "ballet_shoes", "boot", "hair_pick", "crown", "womans_hat", "tophat", "mortar_board", "billed_cap", "military_helmet", "helmet_with_white_cross", "prayer_beads", "lipstick", "ring", "gem", "mute", "speaker", "sound", "loud_sound", "loudspeaker", "mega", "postal_horn", "bell", "no_bell", "musical_score", "musical_note", "notes", "studio_microphone", "level_slider", "control_knobs", "microphone", "headphones", "radio", "saxophone", "accordion", "guitar", "musical_keyboard", "trumpet", "violin", "banjo", "drum_with_drumsticks", "long_drum", "maracas", "flute", "iphone", "calling", "phone", "telephone_receiver", "pager", "fax", "battery", "low_battery", "electric_plug", "computer", "desktop_computer", "printer", "keyboard", "three_button_mouse", "trackball", "minidisc", "floppy_disk", "cd", "dvd", "abacus", "movie_camera", "film_frames", "film_projector", "clapper", "tv", "camera", "camera_with_flash", "video_camera", "vhs", "mag", "mag_right", "candle", "bulb", "flashlight", "izakaya_lantern", "diya_lamp", "notebook_with_decorative_cover", "closed_book", "book", "green_book", "blue_book", "orange_book", "books", "notebook", "ledger", "page_with_curl", "scroll", "page_facing_up", "newspaper", "rolled_up_newspaper", "bookmark_tabs", "bookmark", "label", "moneybag", "coin", "yen", "dollar", "euro", "pound", "money_with_wings", "credit_card", "receipt", "chart", "email", "e-mail", "incoming_envelope", "envelope_with_arrow", "outbox_tray", "inbox_tray", "package", "mailbox", "mailbox_closed", "mailbox_with_mail", "mailbox_with_no_mail", "postbox", "ballot_box_with_ballot", "pencil2", "black_nib", "lower_left_fountain_pen", "lower_left_ballpoint_pen", "lower_left_paintbrush", "lower_left_crayon", "memo", "briefcase", "file_folder", "open_file_folder", "card_index_dividers", "date", "calendar", "spiral_note_pad", "spiral_calendar_pad", "card_index", "chart_with_upwards_trend", "chart_with_downwards_trend", "bar_chart", "clipboard", "pushpin", "round_pushpin", "paperclip", "linked_paperclips", "straight_ruler", "triangular_ruler", "scissors", "card_file_box", "file_cabinet", "wastebasket", "lock", "unlock", "lock_with_ink_pen", "closed_lock_with_key", "key", "old_key", "hammer", "axe", "pick", "hammer_and_pick", "hammer_and_wrench", "dagger_knife", "crossed_swords", "bomb", "boomerang", "bow_and_arrow", "shield", "carpentry_saw", "wrench", "screwdriver", "nut_and_bolt", "gear", "compression", "scales", "probing_cane", "link", "chains", "hook", "toolbox", "magnet", "ladder", "alembic", "test_tube", "petri_dish", "dna", "microscope", "telescope", "satellite_antenna", "syringe", "drop_of_blood", "pill", "adhesive_bandage", "crutch", "stethoscope", "x-ray", "door", "elevator", "mirror", "window", "bed", "couch_and_lamp", "chair", "toilet", "plunger", "shower", "bathtub", "mouse_trap", "razor", "lotion_bottle", "safety_pin", "broom", "basket", "roll_of_paper", "bucket", "soap", "bubbles", "toothbrush", "sponge", "fire_extinguisher", "shopping_trolley", "smoking", "coffin", "headstone", "funeral_urn", "nazar_amulet", "hamsa", "moyai", "placard", "identification_card"] }, { id: "symbols", emojis: ["atm", "put_litter_in_its_place", "potable_water", "wheelchair", "mens", "womens", "restroom", "baby_symbol", "wc", "passport_control", "customs", "baggage_claim", "left_luggage", "warning", "children_crossing", "no_entry", "no_entry_sign", "no_bicycles", "no_smoking", "do_not_litter", "non-potable_water", "no_pedestrians", "no_mobile_phones", "underage", "radioactive_sign", "biohazard_sign", "arrow_up", "arrow_upper_right", "arrow_right", "arrow_lower_right", "arrow_down", "arrow_lower_left", "arrow_left", "arrow_upper_left", "arrow_up_down", "left_right_arrow", "leftwards_arrow_with_hook", "arrow_right_hook", "arrow_heading_up", "arrow_heading_down", "arrows_clockwise", "arrows_counterclockwise", "back", "end", "on", "soon", "top", "place_of_worship", "atom_symbol", "om_symbol", "star_of_david", "wheel_of_dharma", "yin_yang", "latin_cross", "orthodox_cross", "star_and_crescent", "peace_symbol", "menorah_with_nine_branches", "six_pointed_star", "khanda", "aries", "taurus", "gemini", "cancer", "leo", "virgo", "libra", "scorpius", "sagittarius", "capricorn", "aquarius", "pisces", "ophiuchus", "twisted_rightwards_arrows", "repeat", "repeat_one", "arrow_forward", "fast_forward", "black_right_pointing_double_triangle_with_vertical_bar", "black_right_pointing_triangle_with_double_vertical_bar", "arrow_backward", "rewind", "black_left_pointing_double_triangle_with_vertical_bar", "arrow_up_small", "arrow_double_up", "arrow_down_small", "arrow_double_down", "double_vertical_bar", "black_square_for_stop", "black_circle_for_record", "eject", "cinema", "low_brightness", "high_brightness", "signal_strength", "wireless", "vibration_mode", "mobile_phone_off", "female_sign", "male_sign", "transgender_symbol", "heavy_multiplication_x", "heavy_plus_sign", "heavy_minus_sign", "heavy_division_sign", "heavy_equals_sign", "infinity", "bangbang", "interrobang", "question", "grey_question", "grey_exclamation", "exclamation", "wavy_dash", "currency_exchange", "heavy_dollar_sign", "medical_symbol", "recycle", "fleur_de_lis", "trident", "name_badge", "beginner", "o", "white_check_mark", "ballot_box_with_check", "heavy_check_mark", "x", "negative_squared_cross_mark", "curly_loop", "loop", "part_alternation_mark", "eight_spoked_asterisk", "eight_pointed_black_star", "sparkle", "copyright", "registered", "tm", "hash", "keycap_star", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "keycap_ten", "capital_abcd", "abcd", "1234", "symbols", "abc", "a", "ab", "b", "cl", "cool", "free", "information_source", "id", "m", "new", "ng", "o2", "ok", "parking", "sos", "up", "vs", "koko", "sa", "u6708", "u6709", "u6307", "ideograph_advantage", "u5272", "u7121", "u7981", "accept", "u7533", "u5408", "u7a7a", "congratulations", "secret", "u55b6", "u6e80", "red_circle", "large_orange_circle", "large_yellow_circle", "large_green_circle", "large_blue_circle", "large_purple_circle", "large_brown_circle", "black_circle", "white_circle", "large_red_square", "large_orange_square", "large_yellow_square", "large_green_square", "large_blue_square", "large_purple_square", "large_brown_square", "black_large_square", "white_large_square", "black_medium_square", "white_medium_square", "black_medium_small_square", "white_medium_small_square", "black_small_square", "white_small_square", "large_orange_diamond", "large_blue_diamond", "small_orange_diamond", "small_blue_diamond", "small_red_triangle", "small_red_triangle_down", "diamond_shape_with_a_dot_inside", "radio_button", "white_square_button", "black_square_button"] }, { id: "flags", emojis: ["checkered_flag", "cn", "crossed_flags", "de", "es", "flag-ac", "flag-ad", "flag-ae", "flag-af", "flag-ag", "flag-ai", "flag-al", "flag-am", "flag-ao", "flag-aq", "flag-ar", "flag-as", "flag-at", "flag-au", "flag-aw", "flag-ax", "flag-az", "flag-ba", "flag-bb", "flag-bd", "flag-be", "flag-bf", "flag-bg", "flag-bh", "flag-bi", "flag-bj", "flag-bl", "flag-bm", "flag-bn", "flag-bo", "flag-bq", "flag-br", "flag-bs", "flag-bt", "flag-bv", "flag-bw", "flag-by", "flag-bz", "flag-ca", "flag-cc", "flag-cd", "flag-cf", "flag-cg", "flag-ch", "flag-ci", "flag-ck", "flag-cl", "flag-cm", "flag-co", "flag-cp", "flag-cr", "flag-cu", "flag-cv", "flag-cw", "flag-cx", "flag-cy", "flag-cz", "flag-dg", "flag-dj", "flag-dk", "flag-dm", "flag-do", "flag-dz", "flag-ea", "flag-ec", "flag-ee", "flag-eg", "flag-eh", "flag-england", "flag-er", "flag-et", "flag-eu", "flag-fi", "flag-fj", "flag-fk", "flag-fm", "flag-fo", "flag-ga", "flag-gd", "flag-ge", "flag-gf", "flag-gg", "flag-gh", "flag-gi", "flag-gl", "flag-gm", "flag-gn", "flag-gp", "flag-gq", "flag-gr", "flag-gs", "flag-gt", "flag-gu", "flag-gw", "flag-gy", "flag-hk", "flag-hm", "flag-hn", "flag-hr", "flag-ht", "flag-hu", "flag-ic", "flag-id", "flag-ie", "flag-il", "flag-im", "flag-in", "flag-io", "flag-iq", "flag-ir", "flag-is", "flag-je", "flag-jm", "flag-jo", "flag-ke", "flag-kg", "flag-kh", "flag-ki", "flag-km", "flag-kn", "flag-kp", "flag-kw", "flag-ky", "flag-kz", "flag-la", "flag-lb", "flag-lc", "flag-li", "flag-lk", "flag-lr", "flag-ls", "flag-lt", "flag-lu", "flag-lv", "flag-ly", "flag-ma", "flag-mc", "flag-md", "flag-me", "flag-mf", "flag-mg", "flag-mh", "flag-mk", "flag-ml", "flag-mm", "flag-mn", "flag-mo", "flag-mp", "flag-mq", "flag-mr", "flag-ms", "flag-mt", "flag-mu", "flag-mv", "flag-mw", "flag-mx", "flag-my", "flag-mz", "flag-na", "flag-nc", "flag-ne", "flag-nf", "flag-ng", "flag-ni", "flag-nl", "flag-no", "flag-np", "flag-nr", "flag-nu", "flag-nz", "flag-om", "flag-pa", "flag-pe", "flag-pf", "flag-pg", "flag-ph", "flag-pk", "flag-pl", "flag-pm", "flag-pn", "flag-pr", "flag-ps", "flag-pt", "flag-pw", "flag-py", "flag-qa", "flag-re", "flag-ro", "flag-rs", "flag-rw", "flag-sa", "flag-sb", "flag-sc", "flag-scotland", "flag-sd", "flag-se", "flag-sg", "flag-sh", "flag-si", "flag-sj", "flag-sk", "flag-sl", "flag-sm", "flag-sn", "flag-so", "flag-sr", "flag-ss", "flag-st", "flag-sv", "flag-sx", "flag-sy", "flag-sz", "flag-ta", "flag-tc", "flag-td", "flag-tf", "flag-tg", "flag-th", "flag-tj", "flag-tk", "flag-tl", "flag-tm", "flag-tn", "flag-to", "flag-tr", "flag-tt", "flag-tv", "flag-tw", "flag-tz", "flag-ua", "flag-ug", "flag-um", "flag-un", "flag-uy", "flag-uz", "flag-va", "flag-vc", "flag-ve", "flag-vg", "flag-vi", "flag-vn", "flag-vu", "flag-wales", "flag-wf", "flag-ws", "flag-xk", "flag-ye", "flag-yt", "flag-za", "flag-zm", "flag-zw", "fr", "gb", "it", "jp", "kr", "pirate_flag", "rainbow-flag", "ru", "transgender_flag", "triangular_flag_on_post", "us", "waving_black_flag", "waving_white_flag"] }], emojis: { "100": { id: "100", name: "Hundred Points", keywords: ["100", "score", "perfect", "numbers", "century", "exam", "quiz", "test", "pass"], skins: [{ unified: "1f4af", native: "\u{1F4AF}" }], version: 1 }, "1234": { id: "1234", name: "Input Numbers", keywords: ["1234", "blue", "square", "1", "2", "3", "4"], skins: [{ unified: "1f522", native: "\u{1F522}" }], version: 1 }, grinning: { id: "grinning", name: "Grinning Face", emoticons: [":D"], keywords: ["smile", "happy", "joy", ":D", "grin"], skins: [{ unified: "1f600", native: "\u{1F600}" }], version: 1 }, smiley: { id: "smiley", name: "Grinning Face with Big Eyes", emoticons: [":)", "=)", "=-)"], keywords: ["smiley", "happy", "joy", "haha", ":D", ":)", "smile", "funny"], skins: [{ unified: "1f603", native: "\u{1F603}" }], version: 1 }, smile: { id: "smile", name: "Grinning Face with Smiling Eyes", emoticons: [":)", "C:", "c:", ":D", ":-D"], keywords: ["smile", "happy", "joy", "funny", "haha", "laugh", "like", ":D", ":)"], skins: [{ unified: "1f604", native: "\u{1F604}" }], version: 1 }, grin: { id: "grin", name: "Beaming Face with Smiling Eyes", keywords: ["grin", "happy", "smile", "joy", "kawaii"], skins: [{ unified: "1f601", native: "\u{1F601}" }], version: 1 }, laughing: { id: "laughing", name: "Grinning Squinting Face", emoticons: [":>", ":->"], keywords: ["laughing", "satisfied", "happy", "joy", "lol", "haha", "glad", "XD", "laugh"], skins: [{ unified: "1f606", native: "\u{1F606}" }], version: 1 }, sweat_smile: { id: "sweat_smile", name: "Grinning Face with Sweat", keywords: ["smile", "hot", "happy", "laugh", "relief"], skins: [{ unified: "1f605", native: "\u{1F605}" }], version: 1 }, rolling_on_the_floor_laughing: { id: "rolling_on_the_floor_laughing", name: "Rolling on the Floor Laughing", keywords: ["face", "lol", "haha", "rofl"], skins: [{ unified: "1f923", native: "\u{1F923}" }], version: 3 }, joy: { id: "joy", name: "Face with Tears of Joy", keywords: ["cry", "weep", "happy", "happytears", "haha"], skins: [{ unified: "1f602", native: "\u{1F602}" }], version: 1 }, slightly_smiling_face: { id: "slightly_smiling_face", name: "Slightly Smiling Face", emoticons: [":)", "(:", ":-)"], keywords: ["smile"], skins: [{ unified: "1f642", native: "\u{1F642}" }], version: 1 }, upside_down_face: { id: "upside_down_face", name: "Upside-Down Face", keywords: ["upside", "down", "flipped", "silly", "smile"], skins: [{ unified: "1f643", native: "\u{1F643}" }], version: 1 }, melting_face: { id: "melting_face", name: "Melting Face", keywords: ["hot", "heat"], skins: [{ unified: "1fae0", native: "\u{1FAE0}" }], version: 14 }, wink: { id: "wink", name: "Winking Face", emoticons: [";)", ";-)"], keywords: ["wink", "happy", "mischievous", "secret", ";)", "smile", "eye"], skins: [{ unified: "1f609", native: "\u{1F609}" }], version: 1 }, blush: { id: "blush", name: "Smiling Face with Smiling Eyes", emoticons: [":)"], keywords: ["blush", "smile", "happy", "flushed", "crush", "embarrassed", "shy", "joy"], skins: [{ unified: "1f60a", native: "\u{1F60A}" }], version: 1 }, innocent: { id: "innocent", name: "Smiling Face with Halo", keywords: ["innocent", "angel", "heaven"], skins: [{ unified: "1f607", native: "\u{1F607}" }], version: 1 }, smiling_face_with_3_hearts: { id: "smiling_face_with_3_hearts", name: "Smiling Face with Hearts", keywords: ["3", "love", "like", "affection", "valentines", "infatuation", "crush", "adore"], skins: [{ unified: "1f970", native: "\u{1F970}" }], version: 11 }, heart_eyes: { id: "heart_eyes", name: "Smiling Face with Heart-Eyes", keywords: ["heart", "eyes", "love", "like", "affection", "valentines", "infatuation", "crush"], skins: [{ unified: "1f60d", native: "\u{1F60D}" }], version: 1 }, "star-struck": { id: "star-struck", name: "Star-Struck", keywords: ["star", "struck", "grinning", "face", "with", "eyes", "smile", "starry"], skins: [{ unified: "1f929", native: "\u{1F929}" }], version: 5 }, kissing_heart: { id: "kissing_heart", name: "Face Blowing a Kiss", emoticons: [":*", ":-*"], keywords: ["kissing", "heart", "love", "like", "affection", "valentines", "infatuation"], skins: [{ unified: "1f618", native: "\u{1F618}" }], version: 1 }, kissing: { id: "kissing", name: "Kissing Face", keywords: ["love", "like", "3", "valentines", "infatuation", "kiss"], skins: [{ unified: "1f617", native: "\u{1F617}" }], version: 1 }, relaxed: { id: "relaxed", name: "Smiling Face", keywords: ["relaxed", "blush", "massage", "happiness"], skins: [{ unified: "263a-fe0f", native: "\u263A\uFE0F" }], version: 1 }, kissing_closed_eyes: { id: "kissing_closed_eyes", name: "Kissing Face with Closed Eyes", keywords: ["love", "like", "affection", "valentines", "infatuation", "kiss"], skins: [{ unified: "1f61a", native: "\u{1F61A}" }], version: 1 }, kissing_smiling_eyes: { id: "kissing_smiling_eyes", name: "Kissing Face with Smiling Eyes", keywords: ["affection", "valentines", "infatuation", "kiss"], skins: [{ unified: "1f619", native: "\u{1F619}" }], version: 1 }, smiling_face_with_tear: { id: "smiling_face_with_tear", name: "Smiling Face with Tear", keywords: ["sad", "cry", "pretend"], skins: [{ unified: "1f972", native: "\u{1F972}" }], version: 13 }, yum: { id: "yum", name: "Face Savoring Food", keywords: ["yum", "happy", "joy", "tongue", "smile", "silly", "yummy", "nom", "delicious", "savouring"], skins: [{ unified: "1f60b", native: "\u{1F60B}" }], version: 1 }, stuck_out_tongue: { id: "stuck_out_tongue", name: "Face with Tongue", emoticons: [":p", ":-p", ":P", ":-P", ":b", ":-b"], keywords: ["stuck", "out", "prank", "childish", "playful", "mischievous", "smile"], skins: [{ unified: "1f61b", native: "\u{1F61B}" }], version: 1 }, stuck_out_tongue_winking_eye: { id: "stuck_out_tongue_winking_eye", name: "Winking Face with Tongue", emoticons: [";p", ";-p", ";b", ";-b", ";P", ";-P"], keywords: ["stuck", "out", "eye", "prank", "childish", "playful", "mischievous", "smile", "wink"], skins: [{ unified: "1f61c", native: "\u{1F61C}" }], version: 1 }, zany_face: { id: "zany_face", name: "Zany Face", keywords: ["grinning", "with", "one", "large", "and", "small", "eye", "goofy", "crazy"], skins: [{ unified: "1f92a", native: "\u{1F92A}" }], version: 5 }, stuck_out_tongue_closed_eyes: { id: "stuck_out_tongue_closed_eyes", name: "Squinting Face with Tongue", keywords: ["stuck", "out", "closed", "eyes", "prank", "playful", "mischievous", "smile"], skins: [{ unified: "1f61d", native: "\u{1F61D}" }], version: 1 }, money_mouth_face: { id: "money_mouth_face", name: "Money-Mouth Face", keywords: ["money", "mouth", "rich", "dollar"], skins: [{ unified: "1f911", native: "\u{1F911}" }], version: 1 }, hugging_face: { id: "hugging_face", name: "Hugging Face", keywords: ["smile", "hug"], skins: [{ unified: "1f917", native: "\u{1F917}" }], version: 1 }, face_with_hand_over_mouth: { id: "face_with_hand_over_mouth", name: "Face with Hand over Mouth", keywords: ["smiling", "eyes", "and", "covering", "whoops", "shock", "surprise"], skins: [{ unified: "1f92d", native: "\u{1F92D}" }], version: 5 }, face_with_open_eyes_and_hand_over_mouth: { id: "face_with_open_eyes_and_hand_over_mouth", name: "Face with Open Eyes and Hand over Mouth", keywords: ["silence", "secret", "shock", "surprise"], skins: [{ unified: "1fae2", native: "\u{1FAE2}" }], version: 14 }, face_with_peeking_eye: { id: "face_with_peeking_eye", name: "Face with Peeking Eye", keywords: ["scared", "frightening", "embarrassing", "shy"], skins: [{ unified: "1fae3", native: "\u{1FAE3}" }], version: 14 }, shushing_face: { id: "shushing_face", name: "Shushing Face", keywords: ["with", "finger", "covering", "closed", "lips", "quiet", "shhh"], skins: [{ unified: "1f92b", native: "\u{1F92B}" }], version: 5 }, thinking_face: { id: "thinking_face", name: "Thinking Face", keywords: ["hmmm", "think", "consider"], skins: [{ unified: "1f914", native: "\u{1F914}" }], version: 1 }, saluting_face: { id: "saluting_face", name: "Saluting Face", keywords: ["respect", "salute"], skins: [{ unified: "1fae1", native: "\u{1FAE1}" }], version: 14 }, zipper_mouth_face: { id: "zipper_mouth_face", name: "Zipper-Mouth Face", keywords: ["zipper", "mouth", "sealed", "secret"], skins: [{ unified: "1f910", native: "\u{1F910}" }], version: 1 }, face_with_raised_eyebrow: { id: "face_with_raised_eyebrow", name: "Face with Raised Eyebrow", keywords: ["one", "distrust", "scepticism", "disapproval", "disbelief", "surprise"], skins: [{ unified: "1f928", native: "\u{1F928}" }], version: 5 }, neutral_face: { id: "neutral_face", name: "Neutral Face", emoticons: [":|", ":-|"], keywords: ["indifference", "meh", ":", ""], skins: [{ unified: "1f610", native: "\u{1F610}" }], version: 1 }, expressionless: { id: "expressionless", name: "Expressionless Face", emoticons: ["-_-"], keywords: ["indifferent", "-", "", "meh", "deadpan"], skins: [{ unified: "1f611", native: "\u{1F611}" }], version: 1 }, no_mouth: { id: "no_mouth", name: "Face Without Mouth", keywords: ["no", "hellokitty"], skins: [{ unified: "1f636", native: "\u{1F636}" }], version: 1 }, dotted_line_face: { id: "dotted_line_face", name: "Dotted Line Face", keywords: ["invisible", "lonely", "isolation", "depression"], skins: [{ unified: "1fae5", native: "\u{1FAE5}" }], version: 14 }, face_in_clouds: { id: "face_in_clouds", name: "Face in Clouds", keywords: ["shower", "steam", "dream"], skins: [{ unified: "1f636-200d-1f32b-fe0f", native: "\u{1F636}\u200D\u{1F32B}\uFE0F" }], version: 13.1 }, smirk: { id: "smirk", name: "Smirking Face", keywords: ["smirk", "smile", "mean", "prank", "smug", "sarcasm"], skins: [{ unified: "1f60f", native: "\u{1F60F}" }], version: 1 }, unamused: { id: "unamused", name: "Unamused Face", emoticons: [":("], keywords: ["indifference", "bored", "straight", "serious", "sarcasm", "unimpressed", "skeptical", "dubious", "side", "eye"], skins: [{ unified: "1f612", native: "\u{1F612}" }], version: 1 }, face_with_rolling_eyes: { id: "face_with_rolling_eyes", name: "Face with Rolling Eyes", keywords: ["eyeroll", "frustrated"], skins: [{ unified: "1f644", native: "\u{1F644}" }], version: 1 }, grimacing: { id: "grimacing", name: "Grimacing Face", keywords: ["grimace", "teeth"], skins: [{ unified: "1f62c", native: "\u{1F62C}" }], version: 1 }, face_exhaling: { id: "face_exhaling", name: "Face Exhaling", keywords: ["relieve", "relief", "tired", "sigh"], skins: [{ unified: "1f62e-200d-1f4a8", native: "\u{1F62E}\u200D\u{1F4A8}" }], version: 13.1 }, lying_face: { id: "lying_face", name: "Lying Face", keywords: ["lie", "pinocchio"], skins: [{ unified: "1f925", native: "\u{1F925}" }], version: 3 }, shaking_face: { id: "shaking_face", name: "Shaking Face", keywords: ["dizzy", "shock", "blurry", "earthquake"], skins: [{ unified: "1fae8", native: "\u{1FAE8}" }], version: 15 }, relieved: { id: "relieved", name: "Relieved Face", keywords: ["relaxed", "phew", "massage", "happiness"], skins: [{ unified: "1f60c", native: "\u{1F60C}" }], version: 1 }, pensive: { id: "pensive", name: "Pensive Face", keywords: ["sad", "depressed", "upset"], skins: [{ unified: "1f614", native: "\u{1F614}" }], version: 1 }, sleepy: { id: "sleepy", name: "Sleepy Face", keywords: ["tired", "rest", "nap"], skins: [{ unified: "1f62a", native: "\u{1F62A}" }], version: 1 }, drooling_face: { id: "drooling_face", name: "Drooling Face", keywords: [], skins: [{ unified: "1f924", native: "\u{1F924}" }], version: 3 }, sleeping: { id: "sleeping", name: "Sleeping Face", keywords: ["tired", "sleepy", "night", "zzz"], skins: [{ unified: "1f634", native: "\u{1F634}" }], version: 1 }, mask: { id: "mask", name: "Face with Medical Mask", keywords: ["sick", "ill", "disease", "covid"], skins: [{ unified: "1f637", native: "\u{1F637}" }], version: 1 }, face_with_thermometer: { id: "face_with_thermometer", name: "Face with Thermometer", keywords: ["sick", "temperature", "cold", "fever", "covid"], skins: [{ unified: "1f912", native: "\u{1F912}" }], version: 1 }, face_with_head_bandage: { id: "face_with_head_bandage", name: "Face with Head-Bandage", keywords: ["head", "bandage", "injured", "clumsy", "hurt"], skins: [{ unified: "1f915", native: "\u{1F915}" }], version: 1 }, nauseated_face: { id: "nauseated_face", name: "Nauseated Face", keywords: ["vomit", "gross", "green", "sick", "throw", "up", "ill"], skins: [{ unified: "1f922", native: "\u{1F922}" }], version: 3 }, face_vomiting: { id: "face_vomiting", name: "Face Vomiting", keywords: ["with", "open", "mouth", "sick"], skins: [{ unified: "1f92e", native: "\u{1F92E}" }], version: 5 }, sneezing_face: { id: "sneezing_face", name: "Sneezing Face", keywords: ["gesundheit", "sneeze", "sick", "allergy"], skins: [{ unified: "1f927", native: "\u{1F927}" }], version: 3 }, hot_face: { id: "hot_face", name: "Hot Face", keywords: ["feverish", "heat", "red", "sweating"], skins: [{ unified: "1f975", native: "\u{1F975}" }], version: 11 }, cold_face: { id: "cold_face", name: "Cold Face", keywords: ["blue", "freezing", "frozen", "frostbite", "icicles"], skins: [{ unified: "1f976", native: "\u{1F976}" }], version: 11 }, woozy_face: { id: "woozy_face", name: "Woozy Face", keywords: ["dizzy", "intoxicated", "tipsy", "wavy"], skins: [{ unified: "1f974", native: "\u{1F974}" }], version: 11 }, dizzy_face: { id: "dizzy_face", name: "Dizzy Face", keywords: ["spent", "unconscious", "xox"], skins: [{ unified: "1f635", native: "\u{1F635}" }], version: 1 }, face_with_spiral_eyes: { id: "face_with_spiral_eyes", name: "Face with Spiral Eyes", keywords: ["sick", "ill", "confused", "nauseous", "nausea"], skins: [{ unified: "1f635-200d-1f4ab", native: "\u{1F635}\u200D\u{1F4AB}" }], version: 13.1 }, exploding_head: { id: "exploding_head", name: "Exploding Head", keywords: ["shocked", "face", "with", "mind", "blown"], skins: [{ unified: "1f92f", native: "\u{1F92F}" }], version: 5 }, face_with_cowboy_hat: { id: "face_with_cowboy_hat", name: "Cowboy Hat Face", keywords: ["with", "cowgirl"], skins: [{ unified: "1f920", native: "\u{1F920}" }], version: 3 }, partying_face: { id: "partying_face", name: "Partying Face", keywords: ["celebration", "woohoo"], skins: [{ unified: "1f973", native: "\u{1F973}" }], version: 11 }, disguised_face: { id: "disguised_face", name: "Disguised Face", keywords: ["pretent", "brows", "glasses", "moustache"], skins: [{ unified: "1f978", native: "\u{1F978}" }], version: 13 }, sunglasses: { id: "sunglasses", name: "Smiling Face with Sunglasses", emoticons: ["8)"], keywords: ["cool", "smile", "summer", "beach", "sunglass"], skins: [{ unified: "1f60e", native: "\u{1F60E}" }], version: 1 }, nerd_face: { id: "nerd_face", name: "Nerd Face", keywords: ["nerdy", "geek", "dork"], skins: [{ unified: "1f913", native: "\u{1F913}" }], version: 1 }, face_with_monocle: { id: "face_with_monocle", name: "Face with Monocle", keywords: ["stuffy", "wealthy"], skins: [{ unified: "1f9d0", native: "\u{1F9D0}" }], version: 5 }, confused: { id: "confused", name: "Confused Face", emoticons: [":\\", ":-\\", ":/", ":-/"], keywords: ["indifference", "huh", "weird", "hmmm", ":/"], skins: [{ unified: "1f615", native: "\u{1F615}" }], version: 1 }, face_with_diagonal_mouth: { id: "face_with_diagonal_mouth", name: "Face with Diagonal Mouth", keywords: ["skeptic", "confuse", "frustrated", "indifferent"], skins: [{ unified: "1fae4", native: "\u{1FAE4}" }], version: 14 }, worried: { id: "worried", name: "Worried Face", keywords: ["concern", "nervous", ":("], skins: [{ unified: "1f61f", native: "\u{1F61F}" }], version: 1 }, slightly_frowning_face: { id: "slightly_frowning_face", name: "Slightly Frowning Face", keywords: ["disappointed", "sad", "upset"], skins: [{ unified: "1f641", native: "\u{1F641}" }], version: 1 }, white_frowning_face: { id: "white_frowning_face", name: "Frowning Face", keywords: ["white", "sad", "upset", "frown"], skins: [{ unified: "2639-fe0f", native: "\u2639\uFE0F" }], version: 1 }, open_mouth: { id: "open_mouth", name: "Face with Open Mouth", emoticons: [":o", ":-o", ":O", ":-O"], keywords: ["surprise", "impressed", "wow", "whoa", ":O"], skins: [{ unified: "1f62e", native: "\u{1F62E}" }], version: 1 }, hushed: { id: "hushed", name: "Hushed Face", keywords: ["woo", "shh"], skins: [{ unified: "1f62f", native: "\u{1F62F}" }], version: 1 }, astonished: { id: "astonished", name: "Astonished Face", keywords: ["xox", "surprised", "poisoned"], skins: [{ unified: "1f632", native: "\u{1F632}" }], version: 1 }, flushed: { id: "flushed", name: "Flushed Face", keywords: ["blush", "shy", "flattered"], skins: [{ unified: "1f633", native: "\u{1F633}" }], version: 1 }, pleading_face: { id: "pleading_face", name: "Pleading Face", keywords: ["begging", "mercy", "cry", "tears", "sad", "grievance"], skins: [{ unified: "1f97a", native: "\u{1F97A}" }], version: 11 }, face_holding_back_tears: { id: "face_holding_back_tears", name: "Face Holding Back Tears", keywords: ["touched", "gratitude", "cry"], skins: [{ unified: "1f979", native: "\u{1F979}" }], version: 14 }, frowning: { id: "frowning", name: "Frowning Face with Open Mouth", keywords: ["aw", "what"], skins: [{ unified: "1f626", native: "\u{1F626}" }], version: 1 }, anguished: { id: "anguished", name: "Anguished Face", emoticons: ["D:"], keywords: ["stunned", "nervous"], skins: [{ unified: "1f627", native: "\u{1F627}" }], version: 1 }, fearful: { id: "fearful", name: "Fearful Face", keywords: ["scared", "terrified", "nervous"], skins: [{ unified: "1f628", native: "\u{1F628}" }], version: 1 }, cold_sweat: { id: "cold_sweat", name: "Anxious Face with Sweat", keywords: ["cold", "nervous"], skins: [{ unified: "1f630", native: "\u{1F630}" }], version: 1 }, disappointed_relieved: { id: "disappointed_relieved", name: "Sad but Relieved Face", keywords: ["disappointed", "phew", "sweat", "nervous"], skins: [{ unified: "1f625", native: "\u{1F625}" }], version: 1 }, cry: { id: "cry", name: "Crying Face", emoticons: [":'("], keywords: ["cry", "tears", "sad", "depressed", "upset", ":'("], skins: [{ unified: "1f622", native: "\u{1F622}" }], version: 1 }, sob: { id: "sob", name: "Loudly Crying Face", emoticons: [":'("], keywords: ["sob", "cry", "tears", "sad", "upset", "depressed"], skins: [{ unified: "1f62d", native: "\u{1F62D}" }], version: 1 }, scream: { id: "scream", name: "Face Screaming in Fear", keywords: ["scream", "munch", "scared", "omg"], skins: [{ unified: "1f631", native: "\u{1F631}" }], version: 1 }, confounded: { id: "confounded", name: "Confounded Face", keywords: ["confused", "sick", "unwell", "oops", ":S"], skins: [{ unified: "1f616", native: "\u{1F616}" }], version: 1 }, persevere: { id: "persevere", name: "Persevering Face", keywords: ["persevere", "sick", "no", "upset", "oops"], skins: [{ unified: "1f623", native: "\u{1F623}" }], version: 1 }, disappointed: { id: "disappointed", name: "Disappointed Face", emoticons: ["):", ":(", ":-("], keywords: ["sad", "upset", "depressed", ":("], skins: [{ unified: "1f61e", native: "\u{1F61E}" }], version: 1 }, sweat: { id: "sweat", name: "Face with Cold Sweat", keywords: ["downcast", "hot", "sad", "tired", "exercise"], skins: [{ unified: "1f613", native: "\u{1F613}" }], version: 1 }, weary: { id: "weary", name: "Weary Face", keywords: ["tired", "sleepy", "sad", "frustrated", "upset"], skins: [{ unified: "1f629", native: "\u{1F629}" }], version: 1 }, tired_face: { id: "tired_face", name: "Tired Face", keywords: ["sick", "whine", "upset", "frustrated"], skins: [{ unified: "1f62b", native: "\u{1F62B}" }], version: 1 }, yawning_face: { id: "yawning_face", name: "Yawning Face", keywords: ["tired", "sleepy"], skins: [{ unified: "1f971", native: "\u{1F971}" }], version: 12 }, triumph: { id: "triumph", name: "Face with Look of Triumph", keywords: ["steam", "from", "nose", "gas", "phew", "proud", "pride"], skins: [{ unified: "1f624", native: "\u{1F624}" }], version: 1 }, rage: { id: "rage", name: "Pouting Face", keywords: ["rage", "angry", "mad", "hate", "despise"], skins: [{ unified: "1f621", native: "\u{1F621}" }], version: 1 }, angry: { id: "angry", name: "Angry Face", emoticons: [">:(", ">:-("], keywords: ["mad", "annoyed", "frustrated"], skins: [{ unified: "1f620", native: "\u{1F620}" }], version: 1 }, face_with_symbols_on_mouth: { id: "face_with_symbols_on_mouth", name: "Face with Symbols on Mouth", keywords: ["serious", "covering", "swearing", "cursing", "cussing", "profanity", "expletive"], skins: [{ unified: "1f92c", native: "\u{1F92C}" }], version: 5 }, smiling_imp: { id: "smiling_imp", name: "Smiling Face with Horns", keywords: ["imp", "devil"], skins: [{ unified: "1f608", native: "\u{1F608}" }], version: 1 }, imp: { id: "imp", name: "Imp", keywords: ["angry", "face", "with", "horns", "devil"], skins: [{ unified: "1f47f", native: "\u{1F47F}" }], version: 1 }, skull: { id: "skull", name: "Skull", keywords: ["dead", "skeleton", "creepy", "death"], skins: [{ unified: "1f480", native: "\u{1F480}" }], version: 1 }, skull_and_crossbones: { id: "skull_and_crossbones", name: "Skull and Crossbones", keywords: ["poison", "danger", "deadly", "scary", "death", "pirate", "evil"], skins: [{ unified: "2620-fe0f", native: "\u2620\uFE0F" }], version: 1 }, hankey: { id: "hankey", name: "Pile of Poo", keywords: ["hankey", "poop", "shit", "shitface", "fail", "turd"], skins: [{ unified: "1f4a9", native: "\u{1F4A9}" }], version: 1 }, clown_face: { id: "clown_face", name: "Clown Face", keywords: [], skins: [{ unified: "1f921", native: "\u{1F921}" }], version: 3 }, japanese_ogre: { id: "japanese_ogre", name: "Ogre", keywords: ["japanese", "monster", "red", "mask", "halloween", "scary", "creepy", "devil", "demon"], skins: [{ unified: "1f479", native: "\u{1F479}" }], version: 1 }, japanese_goblin: { id: "japanese_goblin", name: "Goblin", keywords: ["japanese", "red", "evil", "mask", "monster", "scary", "creepy"], skins: [{ unified: "1f47a", native: "\u{1F47A}" }], version: 1 }, ghost: { id: "ghost", name: "Ghost", keywords: ["halloween", "spooky", "scary"], skins: [{ unified: "1f47b", native: "\u{1F47B}" }], version: 1 }, alien: { id: "alien", name: "Alien", keywords: ["UFO", "paul", "weird", "outer", "space"], skins: [{ unified: "1f47d", native: "\u{1F47D}" }], version: 1 }, space_invader: { id: "space_invader", name: "Alien Monster", keywords: ["space", "invader", "game", "arcade", "play"], skins: [{ unified: "1f47e", native: "\u{1F47E}" }], version: 1 }, robot_face: { id: "robot_face", name: "Robot", keywords: ["face", "computer", "machine", "bot"], skins: [{ unified: "1f916", native: "\u{1F916}" }], version: 1 }, smiley_cat: { id: "smiley_cat", name: "Grinning Cat", keywords: ["smiley", "animal", "cats", "happy", "smile"], skins: [{ unified: "1f63a", native: "\u{1F63A}" }], version: 1 }, smile_cat: { id: "smile_cat", name: "Grinning Cat with Smiling Eyes", keywords: ["smile", "animal", "cats"], skins: [{ unified: "1f638", native: "\u{1F638}" }], version: 1 }, joy_cat: { id: "joy_cat", name: "Cat with Tears of Joy", keywords: ["animal", "cats", "haha", "happy"], skins: [{ unified: "1f639", native: "\u{1F639}" }], version: 1 }, heart_eyes_cat: { id: "heart_eyes_cat", name: "Smiling Cat with Heart-Eyes", keywords: ["heart", "eyes", "animal", "love", "like", "affection", "cats", "valentines"], skins: [{ unified: "1f63b", native: "\u{1F63B}" }], version: 1 }, smirk_cat: { id: "smirk_cat", name: "Cat with Wry Smile", keywords: ["smirk", "animal", "cats"], skins: [{ unified: "1f63c", native: "\u{1F63C}" }], version: 1 }, kissing_cat: { id: "kissing_cat", name: "Kissing Cat", keywords: ["animal", "cats", "kiss"], skins: [{ unified: "1f63d", native: "\u{1F63D}" }], version: 1 }, scream_cat: { id: "scream_cat", name: "Weary Cat", keywords: ["scream", "animal", "cats", "munch", "scared"], skins: [{ unified: "1f640", native: "\u{1F640}" }], version: 1 }, crying_cat_face: { id: "crying_cat_face", name: "Crying Cat", keywords: ["face", "animal", "tears", "weep", "sad", "cats", "upset", "cry"], skins: [{ unified: "1f63f", native: "\u{1F63F}" }], version: 1 }, pouting_cat: { id: "pouting_cat", name: "Pouting Cat", keywords: ["animal", "cats"], skins: [{ unified: "1f63e", native: "\u{1F63E}" }], version: 1 }, see_no_evil: { id: "see_no_evil", name: "See-No-Evil Monkey", keywords: ["see", "no", "evil", "animal", "nature", "haha"], skins: [{ unified: "1f648", native: "\u{1F648}" }], version: 1 }, hear_no_evil: { id: "hear_no_evil", name: "Hear-No-Evil Monkey", keywords: ["hear", "no", "evil", "animal", "nature"], skins: [{ unified: "1f649", native: "\u{1F649}" }], version: 1 }, speak_no_evil: { id: "speak_no_evil", name: "Speak-No-Evil Monkey", keywords: ["speak", "no", "evil", "animal", "nature", "omg"], skins: [{ unified: "1f64a", native: "\u{1F64A}" }], version: 1 }, love_letter: { id: "love_letter", name: "Love Letter", keywords: ["email", "like", "affection", "envelope", "valentines"], skins: [{ unified: "1f48c", native: "\u{1F48C}" }], version: 1 }, cupid: { id: "cupid", name: "Heart with Arrow", keywords: ["cupid", "love", "like", "affection", "valentines"], skins: [{ unified: "1f498", native: "\u{1F498}" }], version: 1 }, gift_heart: { id: "gift_heart", name: "Heart with Ribbon", keywords: ["gift", "love", "valentines"], skins: [{ unified: "1f49d", native: "\u{1F49D}" }], version: 1 }, sparkling_heart: { id: "sparkling_heart", name: "Sparkling Heart", keywords: ["love", "like", "affection", "valentines"], skins: [{ unified: "1f496", native: "\u{1F496}" }], version: 1 }, heartpulse: { id: "heartpulse", name: "Growing Heart", keywords: ["heartpulse", "like", "love", "affection", "valentines", "pink"], skins: [{ unified: "1f497", native: "\u{1F497}" }], version: 1 }, heartbeat: { id: "heartbeat", name: "Beating Heart", keywords: ["heartbeat", "love", "like", "affection", "valentines", "pink"], skins: [{ unified: "1f493", native: "\u{1F493}" }], version: 1 }, revolving_hearts: { id: "revolving_hearts", name: "Revolving Hearts", keywords: ["love", "like", "affection", "valentines"], skins: [{ unified: "1f49e", native: "\u{1F49E}" }], version: 1 }, two_hearts: { id: "two_hearts", name: "Two Hearts", keywords: ["love", "like", "affection", "valentines", "heart"], skins: [{ unified: "1f495", native: "\u{1F495}" }], version: 1 }, heart_decoration: { id: "heart_decoration", name: "Heart Decoration", keywords: ["purple", "square", "love", "like"], skins: [{ unified: "1f49f", native: "\u{1F49F}" }], version: 1 }, heavy_heart_exclamation_mark_ornament: { id: "heavy_heart_exclamation_mark_ornament", name: "Heart Exclamation", keywords: ["heavy", "mark", "ornament", "decoration", "love"], skins: [{ unified: "2763-fe0f", native: "\u2763\uFE0F" }], version: 1 }, broken_heart: { id: "broken_heart", name: "Broken Heart", emoticons: ["</3"], keywords: ["sad", "sorry", "break", "heartbreak"], skins: [{ unified: "1f494", native: "\u{1F494}" }], version: 1 }, heart_on_fire: { id: "heart_on_fire", name: "Heart on Fire", keywords: ["passionate", "enthusiastic"], skins: [{ unified: "2764-fe0f-200d-1f525", native: "\u2764\uFE0F\u200D\u{1F525}" }], version: 13.1 }, mending_heart: { id: "mending_heart", name: "Mending Heart", keywords: ["broken", "bandage", "wounded"], skins: [{ unified: "2764-fe0f-200d-1fa79", native: "\u2764\uFE0F\u200D\u{1FA79}" }], version: 13.1 }, heart: { id: "heart", name: "Red Heart", emoticons: ["<3"], keywords: ["love", "like", "valentines"], skins: [{ unified: "2764-fe0f", native: "\u2764\uFE0F" }], version: 1 }, pink_heart: { id: "pink_heart", name: "Pink Heart", keywords: ["valentines"], skins: [{ unified: "1fa77", native: "\u{1FA77}" }], version: 15 }, orange_heart: { id: "orange_heart", name: "Orange Heart", keywords: ["love", "like", "affection", "valentines"], skins: [{ unified: "1f9e1", native: "\u{1F9E1}" }], version: 5 }, yellow_heart: { id: "yellow_heart", name: "Yellow Heart", emoticons: ["<3"], keywords: ["love", "like", "affection", "valentines"], skins: [{ unified: "1f49b", native: "\u{1F49B}" }], version: 1 }, green_heart: { id: "green_heart", name: "Green Heart", emoticons: ["<3"], keywords: ["love", "like", "affection", "valentines"], skins: [{ unified: "1f49a", native: "\u{1F49A}" }], version: 1 }, blue_heart: { id: "blue_heart", name: "Blue Heart", emoticons: ["<3"], keywords: ["love", "like", "affection", "valentines"], skins: [{ unified: "1f499", native: "\u{1F499}" }], version: 1 }, light_blue_heart: { id: "light_blue_heart", name: "Light Blue Heart", keywords: ["ice", "baby"], skins: [{ unified: "1fa75", native: "\u{1FA75}" }], version: 15 }, purple_heart: { id: "purple_heart", name: "Purple Heart", emoticons: ["<3"], keywords: ["love", "like", "affection", "valentines"], skins: [{ unified: "1f49c", native: "\u{1F49C}" }], version: 1 }, brown_heart: { id: "brown_heart", name: "Brown Heart", keywords: ["coffee"], skins: [{ unified: "1f90e", native: "\u{1F90E}" }], version: 12 }, black_heart: { id: "black_heart", name: "Black Heart", keywords: ["evil"], skins: [{ unified: "1f5a4", native: "\u{1F5A4}" }], version: 3 }, grey_heart: { id: "grey_heart", name: "Grey Heart", keywords: ["silver", "monochrome"], skins: [{ unified: "1fa76", native: "\u{1FA76}" }], version: 15 }, white_heart: { id: "white_heart", name: "White Heart", keywords: ["pure"], skins: [{ unified: "1f90d", native: "\u{1F90D}" }], version: 12 }, kiss: { id: "kiss", name: "Kiss Mark", keywords: ["face", "lips", "love", "like", "affection", "valentines"], skins: [{ unified: "1f48b", native: "\u{1F48B}" }], version: 1 }, anger: { id: "anger", name: "Anger Symbol", keywords: ["angry", "mad"], skins: [{ unified: "1f4a2", native: "\u{1F4A2}" }], version: 1 }, boom: { id: "boom", name: "Collision", keywords: ["boom", "bomb", "explode", "explosion", "blown"], skins: [{ unified: "1f4a5", native: "\u{1F4A5}" }], version: 1 }, dizzy: { id: "dizzy", name: "Dizzy", keywords: ["star", "sparkle", "shoot", "magic"], skins: [{ unified: "1f4ab", native: "\u{1F4AB}" }], version: 1 }, sweat_drops: { id: "sweat_drops", name: "Sweat Droplets", keywords: ["drops", "water", "drip", "oops"], skins: [{ unified: "1f4a6", native: "\u{1F4A6}" }], version: 1 }, dash: { id: "dash", name: "Dash Symbol", keywords: ["dashing", "away", "wind", "air", "fast", "shoo", "fart", "smoke", "puff"], skins: [{ unified: "1f4a8", native: "\u{1F4A8}" }], version: 1 }, hole: { id: "hole", name: "Hole", keywords: ["embarrassing"], skins: [{ unified: "1f573-fe0f", native: "\u{1F573}\uFE0F" }], version: 1 }, speech_balloon: { id: "speech_balloon", name: "Speech Balloon", keywords: ["bubble", "words", "message", "talk", "chatting"], skins: [{ unified: "1f4ac", native: "\u{1F4AC}" }], version: 1 }, "eye-in-speech-bubble": { id: "eye-in-speech-bubble", name: "Eye in Speech Bubble", keywords: ["in-speech-bubble", "info"], skins: [{ unified: "1f441-fe0f-200d-1f5e8-fe0f", native: "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F" }], version: 2 }, left_speech_bubble: { id: "left_speech_bubble", name: "Left Speech Bubble", keywords: ["words", "message", "talk", "chatting"], skins: [{ unified: "1f5e8-fe0f", native: "\u{1F5E8}\uFE0F" }], version: 2 }, right_anger_bubble: { id: "right_anger_bubble", name: "Right Anger Bubble", keywords: ["caption", "speech", "thinking", "mad"], skins: [{ unified: "1f5ef-fe0f", native: "\u{1F5EF}\uFE0F" }], version: 1 }, thought_balloon: { id: "thought_balloon", name: "Thought Balloon", keywords: ["bubble", "cloud", "speech", "thinking", "dream"], skins: [{ unified: "1f4ad", native: "\u{1F4AD}" }], version: 1 }, zzz: { id: "zzz", name: "Zzz", keywords: ["sleepy", "tired", "dream"], skins: [{ unified: "1f4a4", native: "\u{1F4A4}" }], version: 1 }, wave: { id: "wave", name: "Waving Hand", keywords: ["wave", "hands", "gesture", "goodbye", "solong", "farewell", "hello", "hi", "palm"], skins: [{ unified: "1f44b", native: "\u{1F44B}" }, { unified: "1f44b-1f3fb", native: "\u{1F44B}\u{1F3FB}" }, { unified: "1f44b-1f3fc", native: "\u{1F44B}\u{1F3FC}" }, { unified: "1f44b-1f3fd", native: "\u{1F44B}\u{1F3FD}" }, { unified: "1f44b-1f3fe", native: "\u{1F44B}\u{1F3FE}" }, { unified: "1f44b-1f3ff", native: "\u{1F44B}\u{1F3FF}" }], version: 1 }, raised_back_of_hand: { id: "raised_back_of_hand", name: "Raised Back of Hand", keywords: ["fingers", "backhand"], skins: [{ unified: "1f91a", native: "\u{1F91A}" }, { unified: "1f91a-1f3fb", native: "\u{1F91A}\u{1F3FB}" }, { unified: "1f91a-1f3fc", native: "\u{1F91A}\u{1F3FC}" }, { unified: "1f91a-1f3fd", native: "\u{1F91A}\u{1F3FD}" }, { unified: "1f91a-1f3fe", native: "\u{1F91A}\u{1F3FE}" }, { unified: "1f91a-1f3ff", native: "\u{1F91A}\u{1F3FF}" }], version: 3 }, raised_hand_with_fingers_splayed: { id: "raised_hand_with_fingers_splayed", name: "Hand with Fingers Splayed", keywords: ["raised", "palm"], skins: [{ unified: "1f590-fe0f", native: "\u{1F590}\uFE0F" }, { unified: "1f590-1f3fb", native: "\u{1F590}\u{1F3FB}" }, { unified: "1f590-1f3fc", native: "\u{1F590}\u{1F3FC}" }, { unified: "1f590-1f3fd", native: "\u{1F590}\u{1F3FD}" }, { unified: "1f590-1f3fe", native: "\u{1F590}\u{1F3FE}" }, { unified: "1f590-1f3ff", native: "\u{1F590}\u{1F3FF}" }], version: 1 }, hand: { id: "hand", name: "Raised Hand", keywords: ["fingers", "stop", "highfive", "high", "five", "palm", "ban"], skins: [{ unified: "270b", native: "\u270B" }, { unified: "270b-1f3fb", native: "\u270B\u{1F3FB}" }, { unified: "270b-1f3fc", native: "\u270B\u{1F3FC}" }, { unified: "270b-1f3fd", native: "\u270B\u{1F3FD}" }, { unified: "270b-1f3fe", native: "\u270B\u{1F3FE}" }, { unified: "270b-1f3ff", native: "\u270B\u{1F3FF}" }], version: 1 }, "spock-hand": { id: "spock-hand", name: "Vulcan Salute", keywords: ["spock", "hand", "fingers", "star", "trek"], skins: [{ unified: "1f596", native: "\u{1F596}" }, { unified: "1f596-1f3fb", native: "\u{1F596}\u{1F3FB}" }, { unified: "1f596-1f3fc", native: "\u{1F596}\u{1F3FC}" }, { unified: "1f596-1f3fd", native: "\u{1F596}\u{1F3FD}" }, { unified: "1f596-1f3fe", native: "\u{1F596}\u{1F3FE}" }, { unified: "1f596-1f3ff", native: "\u{1F596}\u{1F3FF}" }], version: 1 }, rightwards_hand: { id: "rightwards_hand", name: "Rightwards Hand", keywords: ["palm", "offer"], skins: [{ unified: "1faf1", native: "\u{1FAF1}" }, { unified: "1faf1-1f3fb", native: "\u{1FAF1}\u{1F3FB}" }, { unified: "1faf1-1f3fc", native: "\u{1FAF1}\u{1F3FC}" }, { unified: "1faf1-1f3fd", native: "\u{1FAF1}\u{1F3FD}" }, { unified: "1faf1-1f3fe", native: "\u{1FAF1}\u{1F3FE}" }, { unified: "1faf1-1f3ff", native: "\u{1FAF1}\u{1F3FF}" }], version: 14 }, leftwards_hand: { id: "leftwards_hand", name: "Leftwards Hand", keywords: ["palm", "offer"], skins: [{ unified: "1faf2", native: "\u{1FAF2}" }, { unified: "1faf2-1f3fb", native: "\u{1FAF2}\u{1F3FB}" }, { unified: "1faf2-1f3fc", native: "\u{1FAF2}\u{1F3FC}" }, { unified: "1faf2-1f3fd", native: "\u{1FAF2}\u{1F3FD}" }, { unified: "1faf2-1f3fe", native: "\u{1FAF2}\u{1F3FE}" }, { unified: "1faf2-1f3ff", native: "\u{1FAF2}\u{1F3FF}" }], version: 14 }, palm_down_hand: { id: "palm_down_hand", name: "Palm Down Hand", keywords: ["drop"], skins: [{ unified: "1faf3", native: "\u{1FAF3}" }, { unified: "1faf3-1f3fb", native: "\u{1FAF3}\u{1F3FB}" }, { unified: "1faf3-1f3fc", native: "\u{1FAF3}\u{1F3FC}" }, { unified: "1faf3-1f3fd", native: "\u{1FAF3}\u{1F3FD}" }, { unified: "1faf3-1f3fe", native: "\u{1FAF3}\u{1F3FE}" }, { unified: "1faf3-1f3ff", native: "\u{1FAF3}\u{1F3FF}" }], version: 14 }, palm_up_hand: { id: "palm_up_hand", name: "Palm Up Hand", keywords: ["lift", "offer", "demand"], skins: [{ unified: "1faf4", native: "\u{1FAF4}" }, { unified: "1faf4-1f3fb", native: "\u{1FAF4}\u{1F3FB}" }, { unified: "1faf4-1f3fc", native: "\u{1FAF4}\u{1F3FC}" }, { unified: "1faf4-1f3fd", native: "\u{1FAF4}\u{1F3FD}" }, { unified: "1faf4-1f3fe", native: "\u{1FAF4}\u{1F3FE}" }, { unified: "1faf4-1f3ff", native: "\u{1FAF4}\u{1F3FF}" }], version: 14 }, leftwards_pushing_hand: { id: "leftwards_pushing_hand", name: "Leftwards Pushing Hand", keywords: ["highfive", "high", "five", "pressing", "stop"], skins: [{ unified: "1faf7", native: "\u{1FAF7}" }, { unified: "1faf7-1f3fb", native: "\u{1FAF7}\u{1F3FB}" }, { unified: "1faf7-1f3fc", native: "\u{1FAF7}\u{1F3FC}" }, { unified: "1faf7-1f3fd", native: "\u{1FAF7}\u{1F3FD}" }, { unified: "1faf7-1f3fe", native: "\u{1FAF7}\u{1F3FE}" }, { unified: "1faf7-1f3ff", native: "\u{1FAF7}\u{1F3FF}" }], version: 15 }, rightwards_pushing_hand: { id: "rightwards_pushing_hand", name: "Rightwards Pushing Hand", keywords: ["highfive", "high", "five", "pressing", "stop"], skins: [{ unified: "1faf8", native: "\u{1FAF8}" }, { unified: "1faf8-1f3fb", native: "\u{1FAF8}\u{1F3FB}" }, { unified: "1faf8-1f3fc", native: "\u{1FAF8}\u{1F3FC}" }, { unified: "1faf8-1f3fd", native: "\u{1FAF8}\u{1F3FD}" }, { unified: "1faf8-1f3fe", native: "\u{1FAF8}\u{1F3FE}" }, { unified: "1faf8-1f3ff", native: "\u{1FAF8}\u{1F3FF}" }], version: 15 }, ok_hand: { id: "ok_hand", name: "Ok Hand", keywords: ["fingers", "limbs", "perfect", "okay"], skins: [{ unified: "1f44c", native: "\u{1F44C}" }, { unified: "1f44c-1f3fb", native: "\u{1F44C}\u{1F3FB}" }, { unified: "1f44c-1f3fc", native: "\u{1F44C}\u{1F3FC}" }, { unified: "1f44c-1f3fd", native: "\u{1F44C}\u{1F3FD}" }, { unified: "1f44c-1f3fe", native: "\u{1F44C}\u{1F3FE}" }, { unified: "1f44c-1f3ff", native: "\u{1F44C}\u{1F3FF}" }], version: 1 }, pinched_fingers: { id: "pinched_fingers", name: "Pinched Fingers", keywords: ["size", "tiny", "small"], skins: [{ unified: "1f90c", native: "\u{1F90C}" }, { unified: "1f90c-1f3fb", native: "\u{1F90C}\u{1F3FB}" }, { unified: "1f90c-1f3fc", native: "\u{1F90C}\u{1F3FC}" }, { unified: "1f90c-1f3fd", native: "\u{1F90C}\u{1F3FD}" }, { unified: "1f90c-1f3fe", native: "\u{1F90C}\u{1F3FE}" }, { unified: "1f90c-1f3ff", native: "\u{1F90C}\u{1F3FF}" }], version: 13 }, pinching_hand: { id: "pinching_hand", name: "Pinching Hand", keywords: ["tiny", "small", "size"], skins: [{ unified: "1f90f", native: "\u{1F90F}" }, { unified: "1f90f-1f3fb", native: "\u{1F90F}\u{1F3FB}" }, { unified: "1f90f-1f3fc", native: "\u{1F90F}\u{1F3FC}" }, { unified: "1f90f-1f3fd", native: "\u{1F90F}\u{1F3FD}" }, { unified: "1f90f-1f3fe", native: "\u{1F90F}\u{1F3FE}" }, { unified: "1f90f-1f3ff", native: "\u{1F90F}\u{1F3FF}" }], version: 12 }, v: { id: "v", name: "Victory Hand", keywords: ["v", "fingers", "ohyeah", "peace", "two"], skins: [{ unified: "270c-fe0f", native: "\u270C\uFE0F" }, { unified: "270c-1f3fb", native: "\u270C\u{1F3FB}" }, { unified: "270c-1f3fc", native: "\u270C\u{1F3FC}" }, { unified: "270c-1f3fd", native: "\u270C\u{1F3FD}" }, { unified: "270c-1f3fe", native: "\u270C\u{1F3FE}" }, { unified: "270c-1f3ff", native: "\u270C\u{1F3FF}" }], version: 1 }, crossed_fingers: { id: "crossed_fingers", name: "Crossed Fingers", keywords: ["hand", "with", "index", "and", "middle", "good", "lucky"], skins: [{ unified: "1f91e", native: "\u{1F91E}" }, { unified: "1f91e-1f3fb", native: "\u{1F91E}\u{1F3FB}" }, { unified: "1f91e-1f3fc", native: "\u{1F91E}\u{1F3FC}" }, { unified: "1f91e-1f3fd", native: "\u{1F91E}\u{1F3FD}" }, { unified: "1f91e-1f3fe", native: "\u{1F91E}\u{1F3FE}" }, { unified: "1f91e-1f3ff", native: "\u{1F91E}\u{1F3FF}" }], version: 3 }, hand_with_index_finger_and_thumb_crossed: { id: "hand_with_index_finger_and_thumb_crossed", name: "Hand with Index Finger and Thumb Crossed", keywords: ["heart", "love", "money", "expensive"], skins: [{ unified: "1faf0", native: "\u{1FAF0}" }, { unified: "1faf0-1f3fb", native: "\u{1FAF0}\u{1F3FB}" }, { unified: "1faf0-1f3fc", native: "\u{1FAF0}\u{1F3FC}" }, { unified: "1faf0-1f3fd", native: "\u{1FAF0}\u{1F3FD}" }, { unified: "1faf0-1f3fe", native: "\u{1FAF0}\u{1F3FE}" }, { unified: "1faf0-1f3ff", native: "\u{1FAF0}\u{1F3FF}" }], version: 14 }, i_love_you_hand_sign: { id: "i_love_you_hand_sign", name: "Love-You Gesture", keywords: ["i", "love", "you", "hand", "sign", "fingers"], skins: [{ unified: "1f91f", native: "\u{1F91F}" }, { unified: "1f91f-1f3fb", native: "\u{1F91F}\u{1F3FB}" }, { unified: "1f91f-1f3fc", native: "\u{1F91F}\u{1F3FC}" }, { unified: "1f91f-1f3fd", native: "\u{1F91F}\u{1F3FD}" }, { unified: "1f91f-1f3fe", native: "\u{1F91F}\u{1F3FE}" }, { unified: "1f91f-1f3ff", native: "\u{1F91F}\u{1F3FF}" }], version: 5 }, the_horns: { id: "the_horns", name: "Sign of the Horns", keywords: ["hand", "fingers", "evil", "eye", "rock", "on"], skins: [{ unified: "1f918", native: "\u{1F918}" }, { unified: "1f918-1f3fb", native: "\u{1F918}\u{1F3FB}" }, { unified: "1f918-1f3fc", native: "\u{1F918}\u{1F3FC}" }, { unified: "1f918-1f3fd", native: "\u{1F918}\u{1F3FD}" }, { unified: "1f918-1f3fe", native: "\u{1F918}\u{1F3FE}" }, { unified: "1f918-1f3ff", native: "\u{1F918}\u{1F3FF}" }], version: 1 }, call_me_hand: { id: "call_me_hand", name: "Call Me Hand", keywords: ["hands", "gesture", "shaka"], skins: [{ unified: "1f919", native: "\u{1F919}" }, { unified: "1f919-1f3fb", native: "\u{1F919}\u{1F3FB}" }, { unified: "1f919-1f3fc", native: "\u{1F919}\u{1F3FC}" }, { unified: "1f919-1f3fd", native: "\u{1F919}\u{1F3FD}" }, { unified: "1f919-1f3fe", native: "\u{1F919}\u{1F3FE}" }, { unified: "1f919-1f3ff", native: "\u{1F919}\u{1F3FF}" }], version: 3 }, point_left: { id: "point_left", name: "Backhand Index Pointing Left", keywords: ["point", "direction", "fingers", "hand"], skins: [{ unified: "1f448", native: "\u{1F448}" }, { unified: "1f448-1f3fb", native: "\u{1F448}\u{1F3FB}" }, { unified: "1f448-1f3fc", native: "\u{1F448}\u{1F3FC}" }, { unified: "1f448-1f3fd", native: "\u{1F448}\u{1F3FD}" }, { unified: "1f448-1f3fe", native: "\u{1F448}\u{1F3FE}" }, { unified: "1f448-1f3ff", native: "\u{1F448}\u{1F3FF}" }], version: 1 }, point_right: { id: "point_right", name: "Backhand Index Pointing Right", keywords: ["point", "fingers", "hand", "direction"], skins: [{ unified: "1f449", native: "\u{1F449}" }, { unified: "1f449-1f3fb", native: "\u{1F449}\u{1F3FB}" }, { unified: "1f449-1f3fc", native: "\u{1F449}\u{1F3FC}" }, { unified: "1f449-1f3fd", native: "\u{1F449}\u{1F3FD}" }, { unified: "1f449-1f3fe", native: "\u{1F449}\u{1F3FE}" }, { unified: "1f449-1f3ff", native: "\u{1F449}\u{1F3FF}" }], version: 1 }, point_up_2: { id: "point_up_2", name: "Backhand Index Pointing Up", keywords: ["point", "2", "fingers", "hand", "direction"], skins: [{ unified: "1f446", native: "\u{1F446}" }, { unified: "1f446-1f3fb", native: "\u{1F446}\u{1F3FB}" }, { unified: "1f446-1f3fc", native: "\u{1F446}\u{1F3FC}" }, { unified: "1f446-1f3fd", native: "\u{1F446}\u{1F3FD}" }, { unified: "1f446-1f3fe", native: "\u{1F446}\u{1F3FE}" }, { unified: "1f446-1f3ff", native: "\u{1F446}\u{1F3FF}" }], version: 1 }, middle_finger: { id: "middle_finger", name: "Middle Finger", keywords: ["reversed", "hand", "with", "extended", "fingers", "rude", "flipping"], skins: [{ unified: "1f595", native: "\u{1F595}" }, { unified: "1f595-1f3fb", native: "\u{1F595}\u{1F3FB}" }, { unified: "1f595-1f3fc", native: "\u{1F595}\u{1F3FC}" }, { unified: "1f595-1f3fd", native: "\u{1F595}\u{1F3FD}" }, { unified: "1f595-1f3fe", native: "\u{1F595}\u{1F3FE}" }, { unified: "1f595-1f3ff", native: "\u{1F595}\u{1F3FF}" }], version: 1 }, point_down: { id: "point_down", name: "Backhand Index Pointing Down", keywords: ["point", "fingers", "hand", "direction"], skins: [{ unified: "1f447", native: "\u{1F447}" }, { unified: "1f447-1f3fb", native: "\u{1F447}\u{1F3FB}" }, { unified: "1f447-1f3fc", native: "\u{1F447}\u{1F3FC}" }, { unified: "1f447-1f3fd", native: "\u{1F447}\u{1F3FD}" }, { unified: "1f447-1f3fe", native: "\u{1F447}\u{1F3FE}" }, { unified: "1f447-1f3ff", native: "\u{1F447}\u{1F3FF}" }], version: 1 }, point_up: { id: "point_up", name: "Index Pointing Up", keywords: ["point", "hand", "fingers", "direction"], skins: [{ unified: "261d-fe0f", native: "\u261D\uFE0F" }, { unified: "261d-1f3fb", native: "\u261D\u{1F3FB}" }, { unified: "261d-1f3fc", native: "\u261D\u{1F3FC}" }, { unified: "261d-1f3fd", native: "\u261D\u{1F3FD}" }, { unified: "261d-1f3fe", native: "\u261D\u{1F3FE}" }, { unified: "261d-1f3ff", native: "\u261D\u{1F3FF}" }], version: 1 }, index_pointing_at_the_viewer: { id: "index_pointing_at_the_viewer", name: "Index Pointing at the Viewer", keywords: ["you", "recruit"], skins: [{ unified: "1faf5", native: "\u{1FAF5}" }, { unified: "1faf5-1f3fb", native: "\u{1FAF5}\u{1F3FB}" }, { unified: "1faf5-1f3fc", native: "\u{1FAF5}\u{1F3FC}" }, { unified: "1faf5-1f3fd", native: "\u{1FAF5}\u{1F3FD}" }, { unified: "1faf5-1f3fe", native: "\u{1FAF5}\u{1F3FE}" }, { unified: "1faf5-1f3ff", native: "\u{1FAF5}\u{1F3FF}" }], version: 14 }, "+1": { id: "+1", name: "Thumbs Up", keywords: ["+1", "thumbsup", "yes", "awesome", "good", "agree", "accept", "cool", "hand", "like"], skins: [{ unified: "1f44d", native: "\u{1F44D}" }, { unified: "1f44d-1f3fb", native: "\u{1F44D}\u{1F3FB}" }, { unified: "1f44d-1f3fc", native: "\u{1F44D}\u{1F3FC}" }, { unified: "1f44d-1f3fd", native: "\u{1F44D}\u{1F3FD}" }, { unified: "1f44d-1f3fe", native: "\u{1F44D}\u{1F3FE}" }, { unified: "1f44d-1f3ff", native: "\u{1F44D}\u{1F3FF}" }], version: 1 }, "-1": { id: "-1", name: "Thumbs Down", keywords: ["-1", "thumbsdown", "no", "dislike", "hand"], skins: [{ unified: "1f44e", native: "\u{1F44E}" }, { unified: "1f44e-1f3fb", native: "\u{1F44E}\u{1F3FB}" }, { unified: "1f44e-1f3fc", native: "\u{1F44E}\u{1F3FC}" }, { unified: "1f44e-1f3fd", native: "\u{1F44E}\u{1F3FD}" }, { unified: "1f44e-1f3fe", native: "\u{1F44E}\u{1F3FE}" }, { unified: "1f44e-1f3ff", native: "\u{1F44E}\u{1F3FF}" }], version: 1 }, fist: { id: "fist", name: "Raised Fist", keywords: ["fingers", "hand", "grasp"], skins: [{ unified: "270a", native: "\u270A" }, { unified: "270a-1f3fb", native: "\u270A\u{1F3FB}" }, { unified: "270a-1f3fc", native: "\u270A\u{1F3FC}" }, { unified: "270a-1f3fd", native: "\u270A\u{1F3FD}" }, { unified: "270a-1f3fe", native: "\u270A\u{1F3FE}" }, { unified: "270a-1f3ff", native: "\u270A\u{1F3FF}" }], version: 1 }, facepunch: { id: "facepunch", name: "Oncoming Fist", keywords: ["facepunch", "punch", "angry", "violence", "hit", "attack", "hand"], skins: [{ unified: "1f44a", native: "\u{1F44A}" }, { unified: "1f44a-1f3fb", native: "\u{1F44A}\u{1F3FB}" }, { unified: "1f44a-1f3fc", native: "\u{1F44A}\u{1F3FC}" }, { unified: "1f44a-1f3fd", native: "\u{1F44A}\u{1F3FD}" }, { unified: "1f44a-1f3fe", native: "\u{1F44A}\u{1F3FE}" }, { unified: "1f44a-1f3ff", native: "\u{1F44A}\u{1F3FF}" }], version: 1 }, "left-facing_fist": { id: "left-facing_fist", name: "Left-Facing Fist", keywords: ["left", "facing", "hand", "fistbump"], skins: [{ unified: "1f91b", native: "\u{1F91B}" }, { unified: "1f91b-1f3fb", native: "\u{1F91B}\u{1F3FB}" }, { unified: "1f91b-1f3fc", native: "\u{1F91B}\u{1F3FC}" }, { unified: "1f91b-1f3fd", native: "\u{1F91B}\u{1F3FD}" }, { unified: "1f91b-1f3fe", native: "\u{1F91B}\u{1F3FE}" }, { unified: "1f91b-1f3ff", native: "\u{1F91B}\u{1F3FF}" }], version: 3 }, "right-facing_fist": { id: "right-facing_fist", name: "Right-Facing Fist", keywords: ["right", "facing", "hand", "fistbump"], skins: [{ unified: "1f91c", native: "\u{1F91C}" }, { unified: "1f91c-1f3fb", native: "\u{1F91C}\u{1F3FB}" }, { unified: "1f91c-1f3fc", native: "\u{1F91C}\u{1F3FC}" }, { unified: "1f91c-1f3fd", native: "\u{1F91C}\u{1F3FD}" }, { unified: "1f91c-1f3fe", native: "\u{1F91C}\u{1F3FE}" }, { unified: "1f91c-1f3ff", native: "\u{1F91C}\u{1F3FF}" }], version: 3 }, clap: { id: "clap", name: "Clapping Hands", keywords: ["clap", "praise", "applause", "congrats", "yay"], skins: [{ unified: "1f44f", native: "\u{1F44F}" }, { unified: "1f44f-1f3fb", native: "\u{1F44F}\u{1F3FB}" }, { unified: "1f44f-1f3fc", native: "\u{1F44F}\u{1F3FC}" }, { unified: "1f44f-1f3fd", native: "\u{1F44F}\u{1F3FD}" }, { unified: "1f44f-1f3fe", native: "\u{1F44F}\u{1F3FE}" }, { unified: "1f44f-1f3ff", native: "\u{1F44F}\u{1F3FF}" }], version: 1 }, raised_hands: { id: "raised_hands", name: "Raising Hands", keywords: ["raised", "gesture", "hooray", "yea", "celebration"], skins: [{ unified: "1f64c", native: "\u{1F64C}" }, { unified: "1f64c-1f3fb", native: "\u{1F64C}\u{1F3FB}" }, { unified: "1f64c-1f3fc", native: "\u{1F64C}\u{1F3FC}" }, { unified: "1f64c-1f3fd", native: "\u{1F64C}\u{1F3FD}" }, { unified: "1f64c-1f3fe", native: "\u{1F64C}\u{1F3FE}" }, { unified: "1f64c-1f3ff", native: "\u{1F64C}\u{1F3FF}" }], version: 1 }, heart_hands: { id: "heart_hands", name: "Heart Hands", keywords: ["love", "appreciation", "support"], skins: [{ unified: "1faf6", native: "\u{1FAF6}" }, { unified: "1faf6-1f3fb", native: "\u{1FAF6}\u{1F3FB}" }, { unified: "1faf6-1f3fc", native: "\u{1FAF6}\u{1F3FC}" }, { unified: "1faf6-1f3fd", native: "\u{1FAF6}\u{1F3FD}" }, { unified: "1faf6-1f3fe", native: "\u{1FAF6}\u{1F3FE}" }, { unified: "1faf6-1f3ff", native: "\u{1FAF6}\u{1F3FF}" }], version: 14 }, open_hands: { id: "open_hands", name: "Open Hands", keywords: ["fingers", "butterfly"], skins: [{ unified: "1f450", native: "\u{1F450}" }, { unified: "1f450-1f3fb", native: "\u{1F450}\u{1F3FB}" }, { unified: "1f450-1f3fc", native: "\u{1F450}\u{1F3FC}" }, { unified: "1f450-1f3fd", native: "\u{1F450}\u{1F3FD}" }, { unified: "1f450-1f3fe", native: "\u{1F450}\u{1F3FE}" }, { unified: "1f450-1f3ff", native: "\u{1F450}\u{1F3FF}" }], version: 1 }, palms_up_together: { id: "palms_up_together", name: "Palms Up Together", keywords: ["hands", "gesture", "cupped", "prayer"], skins: [{ unified: "1f932", native: "\u{1F932}" }, { unified: "1f932-1f3fb", native: "\u{1F932}\u{1F3FB}" }, { unified: "1f932-1f3fc", native: "\u{1F932}\u{1F3FC}" }, { unified: "1f932-1f3fd", native: "\u{1F932}\u{1F3FD}" }, { unified: "1f932-1f3fe", native: "\u{1F932}\u{1F3FE}" }, { unified: "1f932-1f3ff", native: "\u{1F932}\u{1F3FF}" }], version: 5 }, handshake: { id: "handshake", name: "Handshake", keywords: ["agreement", "shake"], skins: [{ unified: "1f91d", native: "\u{1F91D}" }, { unified: "1f91d-1f3fb", native: "\u{1F91D}\u{1F3FB}" }, { unified: "1f91d-1f3fc", native: "\u{1F91D}\u{1F3FC}" }, { unified: "1f91d-1f3fd", native: "\u{1F91D}\u{1F3FD}" }, { unified: "1f91d-1f3fe", native: "\u{1F91D}\u{1F3FE}" }, { unified: "1f91d-1f3ff", native: "\u{1F91D}\u{1F3FF}" }], version: 3 }, pray: { id: "pray", name: "Folded Hands", keywords: ["pray", "please", "hope", "wish", "namaste", "highfive", "high", "five", "thank", "you", "thanks", "appreciate"], skins: [{ unified: "1f64f", native: "\u{1F64F}" }, { unified: "1f64f-1f3fb", native: "\u{1F64F}\u{1F3FB}" }, { unified: "1f64f-1f3fc", native: "\u{1F64F}\u{1F3FC}" }, { unified: "1f64f-1f3fd", native: "\u{1F64F}\u{1F3FD}" }, { unified: "1f64f-1f3fe", native: "\u{1F64F}\u{1F3FE}" }, { unified: "1f64f-1f3ff", native: "\u{1F64F}\u{1F3FF}" }], version: 1 }, writing_hand: { id: "writing_hand", name: "Writing Hand", keywords: ["lower", "left", "ballpoint", "pen", "stationery", "write", "compose"], skins: [{ unified: "270d-fe0f", native: "\u270D\uFE0F" }, { unified: "270d-1f3fb", native: "\u270D\u{1F3FB}" }, { unified: "270d-1f3fc", native: "\u270D\u{1F3FC}" }, { unified: "270d-1f3fd", native: "\u270D\u{1F3FD}" }, { unified: "270d-1f3fe", native: "\u270D\u{1F3FE}" }, { unified: "270d-1f3ff", native: "\u270D\u{1F3FF}" }], version: 1 }, nail_care: { id: "nail_care", name: "Nail Polish", keywords: ["care", "beauty", "manicure", "finger", "fashion"], skins: [{ unified: "1f485", native: "\u{1F485}" }, { unified: "1f485-1f3fb", native: "\u{1F485}\u{1F3FB}" }, { unified: "1f485-1f3fc", native: "\u{1F485}\u{1F3FC}" }, { unified: "1f485-1f3fd", native: "\u{1F485}\u{1F3FD}" }, { unified: "1f485-1f3fe", native: "\u{1F485}\u{1F3FE}" }, { unified: "1f485-1f3ff", native: "\u{1F485}\u{1F3FF}" }], version: 1 }, selfie: { id: "selfie", name: "Selfie", keywords: ["camera", "phone"], skins: [{ unified: "1f933", native: "\u{1F933}" }, { unified: "1f933-1f3fb", native: "\u{1F933}\u{1F3FB}" }, { unified: "1f933-1f3fc", native: "\u{1F933}\u{1F3FC}" }, { unified: "1f933-1f3fd", native: "\u{1F933}\u{1F3FD}" }, { unified: "1f933-1f3fe", native: "\u{1F933}\u{1F3FE}" }, { unified: "1f933-1f3ff", native: "\u{1F933}\u{1F3FF}" }], version: 3 }, muscle: { id: "muscle", name: "Flexed Biceps", keywords: ["muscle", "arm", "flex", "hand", "summer", "strong"], skins: [{ unified: "1f4aa", native: "\u{1F4AA}" }, { unified: "1f4aa-1f3fb", native: "\u{1F4AA}\u{1F3FB}" }, { unified: "1f4aa-1f3fc", native: "\u{1F4AA}\u{1F3FC}" }, { unified: "1f4aa-1f3fd", native: "\u{1F4AA}\u{1F3FD}" }, { unified: "1f4aa-1f3fe", native: "\u{1F4AA}\u{1F3FE}" }, { unified: "1f4aa-1f3ff", native: "\u{1F4AA}\u{1F3FF}" }], version: 1 }, mechanical_arm: { id: "mechanical_arm", name: "Mechanical Arm", keywords: ["accessibility"], skins: [{ unified: "1f9be", native: "\u{1F9BE}" }], version: 12 }, mechanical_leg: { id: "mechanical_leg", name: "Mechanical Leg", keywords: ["accessibility"], skins: [{ unified: "1f9bf", native: "\u{1F9BF}" }], version: 12 }, leg: { id: "leg", name: "Leg", keywords: ["kick", "limb"], skins: [{ unified: "1f9b5", native: "\u{1F9B5}" }, { unified: "1f9b5-1f3fb", native: "\u{1F9B5}\u{1F3FB}" }, { unified: "1f9b5-1f3fc", native: "\u{1F9B5}\u{1F3FC}" }, { unified: "1f9b5-1f3fd", native: "\u{1F9B5}\u{1F3FD}" }, { unified: "1f9b5-1f3fe", native: "\u{1F9B5}\u{1F3FE}" }, { unified: "1f9b5-1f3ff", native: "\u{1F9B5}\u{1F3FF}" }], version: 11 }, foot: { id: "foot", name: "Foot", keywords: ["kick", "stomp"], skins: [{ unified: "1f9b6", native: "\u{1F9B6}" }, { unified: "1f9b6-1f3fb", native: "\u{1F9B6}\u{1F3FB}" }, { unified: "1f9b6-1f3fc", native: "\u{1F9B6}\u{1F3FC}" }, { unified: "1f9b6-1f3fd", native: "\u{1F9B6}\u{1F3FD}" }, { unified: "1f9b6-1f3fe", native: "\u{1F9B6}\u{1F3FE}" }, { unified: "1f9b6-1f3ff", native: "\u{1F9B6}\u{1F3FF}" }], version: 11 }, ear: { id: "ear", name: "Ear", keywords: ["face", "hear", "sound", "listen"], skins: [{ unified: "1f442", native: "\u{1F442}" }, { unified: "1f442-1f3fb", native: "\u{1F442}\u{1F3FB}" }, { unified: "1f442-1f3fc", native: "\u{1F442}\u{1F3FC}" }, { unified: "1f442-1f3fd", native: "\u{1F442}\u{1F3FD}" }, { unified: "1f442-1f3fe", native: "\u{1F442}\u{1F3FE}" }, { unified: "1f442-1f3ff", native: "\u{1F442}\u{1F3FF}" }], version: 1 }, ear_with_hearing_aid: { id: "ear_with_hearing_aid", name: "Ear with Hearing Aid", keywords: ["accessibility"], skins: [{ unified: "1f9bb", native: "\u{1F9BB}" }, { unified: "1f9bb-1f3fb", native: "\u{1F9BB}\u{1F3FB}" }, { unified: "1f9bb-1f3fc", native: "\u{1F9BB}\u{1F3FC}" }, { unified: "1f9bb-1f3fd", native: "\u{1F9BB}\u{1F3FD}" }, { unified: "1f9bb-1f3fe", native: "\u{1F9BB}\u{1F3FE}" }, { unified: "1f9bb-1f3ff", native: "\u{1F9BB}\u{1F3FF}" }], version: 12 }, nose: { id: "nose", name: "Nose", keywords: ["smell", "sniff"], skins: [{ unified: "1f443", native: "\u{1F443}" }, { unified: "1f443-1f3fb", native: "\u{1F443}\u{1F3FB}" }, { unified: "1f443-1f3fc", native: "\u{1F443}\u{1F3FC}" }, { unified: "1f443-1f3fd", native: "\u{1F443}\u{1F3FD}" }, { unified: "1f443-1f3fe", native: "\u{1F443}\u{1F3FE}" }, { unified: "1f443-1f3ff", native: "\u{1F443}\u{1F3FF}" }], version: 1 }, brain: { id: "brain", name: "Brain", keywords: ["smart", "intelligent"], skins: [{ unified: "1f9e0", native: "\u{1F9E0}" }], version: 5 }, anatomical_heart: { id: "anatomical_heart", name: "Anatomical Heart", keywords: ["health", "heartbeat"], skins: [{ unified: "1fac0", native: "\u{1FAC0}" }], version: 13 }, lungs: { id: "lungs", name: "Lungs", keywords: ["breathe"], skins: [{ unified: "1fac1", native: "\u{1FAC1}" }], version: 13 }, tooth: { id: "tooth", name: "Tooth", keywords: ["teeth", "dentist"], skins: [{ unified: "1f9b7", native: "\u{1F9B7}" }], version: 11 }, bone: { id: "bone", name: "Bone", keywords: ["skeleton"], skins: [{ unified: "1f9b4", native: "\u{1F9B4}" }], version: 11 }, eyes: { id: "eyes", name: "Eyes", keywords: ["look", "watch", "stalk", "peek", "see"], skins: [{ unified: "1f440", native: "\u{1F440}" }], version: 1 }, eye: { id: "eye", name: "Eye", keywords: ["face", "look", "see", "watch", "stare"], skins: [{ unified: "1f441-fe0f", native: "\u{1F441}\uFE0F" }], version: 1 }, tongue: { id: "tongue", name: "Tongue", keywords: ["mouth", "playful"], skins: [{ unified: "1f445", native: "\u{1F445}" }], version: 1 }, lips: { id: "lips", name: "Mouth", keywords: ["lips", "kiss"], skins: [{ unified: "1f444", native: "\u{1F444}" }], version: 1 }, biting_lip: { id: "biting_lip", name: "Biting Lip", keywords: ["flirt", "sexy", "pain", "worry"], skins: [{ unified: "1fae6", native: "\u{1FAE6}" }], version: 14 }, baby: { id: "baby", name: "Baby", keywords: ["child", "boy", "girl", "toddler"], skins: [{ unified: "1f476", native: "\u{1F476}" }, { unified: "1f476-1f3fb", native: "\u{1F476}\u{1F3FB}" }, { unified: "1f476-1f3fc", native: "\u{1F476}\u{1F3FC}" }, { unified: "1f476-1f3fd", native: "\u{1F476}\u{1F3FD}" }, { unified: "1f476-1f3fe", native: "\u{1F476}\u{1F3FE}" }, { unified: "1f476-1f3ff", native: "\u{1F476}\u{1F3FF}" }], version: 1 }, child: { id: "child", name: "Child", keywords: ["gender", "neutral", "young"], skins: [{ unified: "1f9d2", native: "\u{1F9D2}" }, { unified: "1f9d2-1f3fb", native: "\u{1F9D2}\u{1F3FB}" }, { unified: "1f9d2-1f3fc", native: "\u{1F9D2}\u{1F3FC}" }, { unified: "1f9d2-1f3fd", native: "\u{1F9D2}\u{1F3FD}" }, { unified: "1f9d2-1f3fe", native: "\u{1F9D2}\u{1F3FE}" }, { unified: "1f9d2-1f3ff", native: "\u{1F9D2}\u{1F3FF}" }], version: 5 }, boy: { id: "boy", name: "Boy", keywords: ["man", "male", "guy", "teenager"], skins: [{ unified: "1f466", native: "\u{1F466}" }, { unified: "1f466-1f3fb", native: "\u{1F466}\u{1F3FB}" }, { unified: "1f466-1f3fc", native: "\u{1F466}\u{1F3FC}" }, { unified: "1f466-1f3fd", native: "\u{1F466}\u{1F3FD}" }, { unified: "1f466-1f3fe", native: "\u{1F466}\u{1F3FE}" }, { unified: "1f466-1f3ff", native: "\u{1F466}\u{1F3FF}" }], version: 1 }, girl: { id: "girl", name: "Girl", keywords: ["female", "woman", "teenager"], skins: [{ unified: "1f467", native: "\u{1F467}" }, { unified: "1f467-1f3fb", native: "\u{1F467}\u{1F3FB}" }, { unified: "1f467-1f3fc", native: "\u{1F467}\u{1F3FC}" }, { unified: "1f467-1f3fd", native: "\u{1F467}\u{1F3FD}" }, { unified: "1f467-1f3fe", native: "\u{1F467}\u{1F3FE}" }, { unified: "1f467-1f3ff", native: "\u{1F467}\u{1F3FF}" }], version: 1 }, adult: { id: "adult", name: "Adult", keywords: ["person", "gender", "neutral"], skins: [{ unified: "1f9d1", native: "\u{1F9D1}" }, { unified: "1f9d1-1f3fb", native: "\u{1F9D1}\u{1F3FB}" }, { unified: "1f9d1-1f3fc", native: "\u{1F9D1}\u{1F3FC}" }, { unified: "1f9d1-1f3fd", native: "\u{1F9D1}\u{1F3FD}" }, { unified: "1f9d1-1f3fe", native: "\u{1F9D1}\u{1F3FE}" }, { unified: "1f9d1-1f3ff", native: "\u{1F9D1}\u{1F3FF}" }], version: 5 }, person_with_blond_hair: { id: "person_with_blond_hair", name: "Person Blond Hair", keywords: ["with", "hairstyle"], skins: [{ unified: "1f471", native: "\u{1F471}" }, { unified: "1f471-1f3fb", native: "\u{1F471}\u{1F3FB}" }, { unified: "1f471-1f3fc", native: "\u{1F471}\u{1F3FC}" }, { unified: "1f471-1f3fd", native: "\u{1F471}\u{1F3FD}" }, { unified: "1f471-1f3fe", native: "\u{1F471}\u{1F3FE}" }, { unified: "1f471-1f3ff", native: "\u{1F471}\u{1F3FF}" }], version: 1 }, man: { id: "man", name: "Man", keywords: ["mustache", "father", "dad", "guy", "classy", "sir", "moustache"], skins: [{ unified: "1f468", native: "\u{1F468}" }, { unified: "1f468-1f3fb", native: "\u{1F468}\u{1F3FB}" }, { unified: "1f468-1f3fc", native: "\u{1F468}\u{1F3FC}" }, { unified: "1f468-1f3fd", native: "\u{1F468}\u{1F3FD}" }, { unified: "1f468-1f3fe", native: "\u{1F468}\u{1F3FE}" }, { unified: "1f468-1f3ff", native: "\u{1F468}\u{1F3FF}" }], version: 1 }, bearded_person: { id: "bearded_person", name: "Person Beard", keywords: ["bearded", "man", "bewhiskered"], skins: [{ unified: "1f9d4", native: "\u{1F9D4}" }, { unified: "1f9d4-1f3fb", native: "\u{1F9D4}\u{1F3FB}" }, { unified: "1f9d4-1f3fc", native: "\u{1F9D4}\u{1F3FC}" }, { unified: "1f9d4-1f3fd", native: "\u{1F9D4}\u{1F3FD}" }, { unified: "1f9d4-1f3fe", native: "\u{1F9D4}\u{1F3FE}" }, { unified: "1f9d4-1f3ff", native: "\u{1F9D4}\u{1F3FF}" }], version: 5 }, man_with_beard: { id: "man_with_beard", name: "Man: Beard", keywords: ["man", "with", "facial", "hair"], skins: [{ unified: "1f9d4-200d-2642-fe0f", native: "\u{1F9D4}\u200D\u2642\uFE0F" }, { unified: "1f9d4-1f3fb-200d-2642-fe0f", native: "\u{1F9D4}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9d4-1f3fc-200d-2642-fe0f", native: "\u{1F9D4}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9d4-1f3fd-200d-2642-fe0f", native: "\u{1F9D4}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9d4-1f3fe-200d-2642-fe0f", native: "\u{1F9D4}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9d4-1f3ff-200d-2642-fe0f", native: "\u{1F9D4}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 13.1 }, woman_with_beard: { id: "woman_with_beard", name: "Woman: Beard", keywords: ["woman", "with", "facial", "hair"], skins: [{ unified: "1f9d4-200d-2640-fe0f", native: "\u{1F9D4}\u200D\u2640\uFE0F" }, { unified: "1f9d4-1f3fb-200d-2640-fe0f", native: "\u{1F9D4}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9d4-1f3fc-200d-2640-fe0f", native: "\u{1F9D4}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9d4-1f3fd-200d-2640-fe0f", native: "\u{1F9D4}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9d4-1f3fe-200d-2640-fe0f", native: "\u{1F9D4}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9d4-1f3ff-200d-2640-fe0f", native: "\u{1F9D4}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 13.1 }, red_haired_man: { id: "red_haired_man", name: "Man: Red Hair", keywords: ["haired", "man", "hairstyle"], skins: [{ unified: "1f468-200d-1f9b0", native: "\u{1F468}\u200D\u{1F9B0}" }, { unified: "1f468-1f3fb-200d-1f9b0", native: "\u{1F468}\u{1F3FB}\u200D\u{1F9B0}" }, { unified: "1f468-1f3fc-200d-1f9b0", native: "\u{1F468}\u{1F3FC}\u200D\u{1F9B0}" }, { unified: "1f468-1f3fd-200d-1f9b0", native: "\u{1F468}\u{1F3FD}\u200D\u{1F9B0}" }, { unified: "1f468-1f3fe-200d-1f9b0", native: "\u{1F468}\u{1F3FE}\u200D\u{1F9B0}" }, { unified: "1f468-1f3ff-200d-1f9b0", native: "\u{1F468}\u{1F3FF}\u200D\u{1F9B0}" }], version: 11 }, curly_haired_man: { id: "curly_haired_man", name: "Man: Curly Hair", keywords: ["haired", "man", "hairstyle"], skins: [{ unified: "1f468-200d-1f9b1", native: "\u{1F468}\u200D\u{1F9B1}" }, { unified: "1f468-1f3fb-200d-1f9b1", native: "\u{1F468}\u{1F3FB}\u200D\u{1F9B1}" }, { unified: "1f468-1f3fc-200d-1f9b1", native: "\u{1F468}\u{1F3FC}\u200D\u{1F9B1}" }, { unified: "1f468-1f3fd-200d-1f9b1", native: "\u{1F468}\u{1F3FD}\u200D\u{1F9B1}" }, { unified: "1f468-1f3fe-200d-1f9b1", native: "\u{1F468}\u{1F3FE}\u200D\u{1F9B1}" }, { unified: "1f468-1f3ff-200d-1f9b1", native: "\u{1F468}\u{1F3FF}\u200D\u{1F9B1}" }], version: 11 }, white_haired_man: { id: "white_haired_man", name: "Man: White Hair", keywords: ["haired", "man", "old", "elder"], skins: [{ unified: "1f468-200d-1f9b3", native: "\u{1F468}\u200D\u{1F9B3}" }, { unified: "1f468-1f3fb-200d-1f9b3", native: "\u{1F468}\u{1F3FB}\u200D\u{1F9B3}" }, { unified: "1f468-1f3fc-200d-1f9b3", native: "\u{1F468}\u{1F3FC}\u200D\u{1F9B3}" }, { unified: "1f468-1f3fd-200d-1f9b3", native: "\u{1F468}\u{1F3FD}\u200D\u{1F9B3}" }, { unified: "1f468-1f3fe-200d-1f9b3", native: "\u{1F468}\u{1F3FE}\u200D\u{1F9B3}" }, { unified: "1f468-1f3ff-200d-1f9b3", native: "\u{1F468}\u{1F3FF}\u200D\u{1F9B3}" }], version: 11 }, bald_man: { id: "bald_man", name: "Man: Bald", keywords: ["man", "hairless"], skins: [{ unified: "1f468-200d-1f9b2", native: "\u{1F468}\u200D\u{1F9B2}" }, { unified: "1f468-1f3fb-200d-1f9b2", native: "\u{1F468}\u{1F3FB}\u200D\u{1F9B2}" }, { unified: "1f468-1f3fc-200d-1f9b2", native: "\u{1F468}\u{1F3FC}\u200D\u{1F9B2}" }, { unified: "1f468-1f3fd-200d-1f9b2", native: "\u{1F468}\u{1F3FD}\u200D\u{1F9B2}" }, { unified: "1f468-1f3fe-200d-1f9b2", native: "\u{1F468}\u{1F3FE}\u200D\u{1F9B2}" }, { unified: "1f468-1f3ff-200d-1f9b2", native: "\u{1F468}\u{1F3FF}\u200D\u{1F9B2}" }], version: 11 }, woman: { id: "woman", name: "Woman", keywords: ["female", "girls", "lady"], skins: [{ unified: "1f469", native: "\u{1F469}" }, { unified: "1f469-1f3fb", native: "\u{1F469}\u{1F3FB}" }, { unified: "1f469-1f3fc", native: "\u{1F469}\u{1F3FC}" }, { unified: "1f469-1f3fd", native: "\u{1F469}\u{1F3FD}" }, { unified: "1f469-1f3fe", native: "\u{1F469}\u{1F3FE}" }, { unified: "1f469-1f3ff", native: "\u{1F469}\u{1F3FF}" }], version: 1 }, red_haired_woman: { id: "red_haired_woman", name: "Woman: Red Hair", keywords: ["haired", "woman", "hairstyle"], skins: [{ unified: "1f469-200d-1f9b0", native: "\u{1F469}\u200D\u{1F9B0}" }, { unified: "1f469-1f3fb-200d-1f9b0", native: "\u{1F469}\u{1F3FB}\u200D\u{1F9B0}" }, { unified: "1f469-1f3fc-200d-1f9b0", native: "\u{1F469}\u{1F3FC}\u200D\u{1F9B0}" }, { unified: "1f469-1f3fd-200d-1f9b0", native: "\u{1F469}\u{1F3FD}\u200D\u{1F9B0}" }, { unified: "1f469-1f3fe-200d-1f9b0", native: "\u{1F469}\u{1F3FE}\u200D\u{1F9B0}" }, { unified: "1f469-1f3ff-200d-1f9b0", native: "\u{1F469}\u{1F3FF}\u200D\u{1F9B0}" }], version: 11 }, red_haired_person: { id: "red_haired_person", name: "Person: Red Hair", keywords: ["haired", "person", "hairstyle"], skins: [{ unified: "1f9d1-200d-1f9b0", native: "\u{1F9D1}\u200D\u{1F9B0}" }, { unified: "1f9d1-1f3fb-200d-1f9b0", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F9B0}" }, { unified: "1f9d1-1f3fc-200d-1f9b0", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B0}" }, { unified: "1f9d1-1f3fd-200d-1f9b0", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B0}" }, { unified: "1f9d1-1f3fe-200d-1f9b0", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B0}" }, { unified: "1f9d1-1f3ff-200d-1f9b0", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B0}" }], version: 12.1 }, curly_haired_woman: { id: "curly_haired_woman", name: "Woman: Curly Hair", keywords: ["haired", "woman", "hairstyle"], skins: [{ unified: "1f469-200d-1f9b1", native: "\u{1F469}\u200D\u{1F9B1}" }, { unified: "1f469-1f3fb-200d-1f9b1", native: "\u{1F469}\u{1F3FB}\u200D\u{1F9B1}" }, { unified: "1f469-1f3fc-200d-1f9b1", native: "\u{1F469}\u{1F3FC}\u200D\u{1F9B1}" }, { unified: "1f469-1f3fd-200d-1f9b1", native: "\u{1F469}\u{1F3FD}\u200D\u{1F9B1}" }, { unified: "1f469-1f3fe-200d-1f9b1", native: "\u{1F469}\u{1F3FE}\u200D\u{1F9B1}" }, { unified: "1f469-1f3ff-200d-1f9b1", native: "\u{1F469}\u{1F3FF}\u200D\u{1F9B1}" }], version: 11 }, curly_haired_person: { id: "curly_haired_person", name: "Person: Curly Hair", keywords: ["haired", "person", "hairstyle"], skins: [{ unified: "1f9d1-200d-1f9b1", native: "\u{1F9D1}\u200D\u{1F9B1}" }, { unified: "1f9d1-1f3fb-200d-1f9b1", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F9B1}" }, { unified: "1f9d1-1f3fc-200d-1f9b1", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B1}" }, { unified: "1f9d1-1f3fd-200d-1f9b1", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B1}" }, { unified: "1f9d1-1f3fe-200d-1f9b1", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B1}" }, { unified: "1f9d1-1f3ff-200d-1f9b1", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B1}" }], version: 12.1 }, white_haired_woman: { id: "white_haired_woman", name: "Woman: White Hair", keywords: ["haired", "woman", "old", "elder"], skins: [{ unified: "1f469-200d-1f9b3", native: "\u{1F469}\u200D\u{1F9B3}" }, { unified: "1f469-1f3fb-200d-1f9b3", native: "\u{1F469}\u{1F3FB}\u200D\u{1F9B3}" }, { unified: "1f469-1f3fc-200d-1f9b3", native: "\u{1F469}\u{1F3FC}\u200D\u{1F9B3}" }, { unified: "1f469-1f3fd-200d-1f9b3", native: "\u{1F469}\u{1F3FD}\u200D\u{1F9B3}" }, { unified: "1f469-1f3fe-200d-1f9b3", native: "\u{1F469}\u{1F3FE}\u200D\u{1F9B3}" }, { unified: "1f469-1f3ff-200d-1f9b3", native: "\u{1F469}\u{1F3FF}\u200D\u{1F9B3}" }], version: 11 }, white_haired_person: { id: "white_haired_person", name: "Person: White Hair", keywords: ["haired", "person", "elder", "old"], skins: [{ unified: "1f9d1-200d-1f9b3", native: "\u{1F9D1}\u200D\u{1F9B3}" }, { unified: "1f9d1-1f3fb-200d-1f9b3", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F9B3}" }, { unified: "1f9d1-1f3fc-200d-1f9b3", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B3}" }, { unified: "1f9d1-1f3fd-200d-1f9b3", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B3}" }, { unified: "1f9d1-1f3fe-200d-1f9b3", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B3}" }, { unified: "1f9d1-1f3ff-200d-1f9b3", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B3}" }], version: 12.1 }, bald_woman: { id: "bald_woman", name: "Woman: Bald", keywords: ["woman", "hairless"], skins: [{ unified: "1f469-200d-1f9b2", native: "\u{1F469}\u200D\u{1F9B2}" }, { unified: "1f469-1f3fb-200d-1f9b2", native: "\u{1F469}\u{1F3FB}\u200D\u{1F9B2}" }, { unified: "1f469-1f3fc-200d-1f9b2", native: "\u{1F469}\u{1F3FC}\u200D\u{1F9B2}" }, { unified: "1f469-1f3fd-200d-1f9b2", native: "\u{1F469}\u{1F3FD}\u200D\u{1F9B2}" }, { unified: "1f469-1f3fe-200d-1f9b2", native: "\u{1F469}\u{1F3FE}\u200D\u{1F9B2}" }, { unified: "1f469-1f3ff-200d-1f9b2", native: "\u{1F469}\u{1F3FF}\u200D\u{1F9B2}" }], version: 11 }, bald_person: { id: "bald_person", name: "Person: Bald", keywords: ["person", "hairless"], skins: [{ unified: "1f9d1-200d-1f9b2", native: "\u{1F9D1}\u200D\u{1F9B2}" }, { unified: "1f9d1-1f3fb-200d-1f9b2", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F9B2}" }, { unified: "1f9d1-1f3fc-200d-1f9b2", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F9B2}" }, { unified: "1f9d1-1f3fd-200d-1f9b2", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F9B2}" }, { unified: "1f9d1-1f3fe-200d-1f9b2", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F9B2}" }, { unified: "1f9d1-1f3ff-200d-1f9b2", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F9B2}" }], version: 12.1 }, "blond-haired-woman": { id: "blond-haired-woman", name: "Woman: Blond Hair", keywords: ["haired-woman", "woman", "female", "girl", "blonde", "person"], skins: [{ unified: "1f471-200d-2640-fe0f", native: "\u{1F471}\u200D\u2640\uFE0F" }, { unified: "1f471-1f3fb-200d-2640-fe0f", native: "\u{1F471}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f471-1f3fc-200d-2640-fe0f", native: "\u{1F471}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f471-1f3fd-200d-2640-fe0f", native: "\u{1F471}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f471-1f3fe-200d-2640-fe0f", native: "\u{1F471}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f471-1f3ff-200d-2640-fe0f", native: "\u{1F471}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, "blond-haired-man": { id: "blond-haired-man", name: "Man: Blond Hair", keywords: ["haired-man", "man", "male", "boy", "blonde", "guy", "person"], skins: [{ unified: "1f471-200d-2642-fe0f", native: "\u{1F471}\u200D\u2642\uFE0F" }, { unified: "1f471-1f3fb-200d-2642-fe0f", native: "\u{1F471}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f471-1f3fc-200d-2642-fe0f", native: "\u{1F471}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f471-1f3fd-200d-2642-fe0f", native: "\u{1F471}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f471-1f3fe-200d-2642-fe0f", native: "\u{1F471}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f471-1f3ff-200d-2642-fe0f", native: "\u{1F471}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, older_adult: { id: "older_adult", name: "Older Adult", keywords: ["person", "human", "elder", "senior", "gender", "neutral"], skins: [{ unified: "1f9d3", native: "\u{1F9D3}" }, { unified: "1f9d3-1f3fb", native: "\u{1F9D3}\u{1F3FB}" }, { unified: "1f9d3-1f3fc", native: "\u{1F9D3}\u{1F3FC}" }, { unified: "1f9d3-1f3fd", native: "\u{1F9D3}\u{1F3FD}" }, { unified: "1f9d3-1f3fe", native: "\u{1F9D3}\u{1F3FE}" }, { unified: "1f9d3-1f3ff", native: "\u{1F9D3}\u{1F3FF}" }], version: 5 }, older_man: { id: "older_man", name: "Old Man", keywords: ["older", "human", "male", "men", "elder", "senior"], skins: [{ unified: "1f474", native: "\u{1F474}" }, { unified: "1f474-1f3fb", native: "\u{1F474}\u{1F3FB}" }, { unified: "1f474-1f3fc", native: "\u{1F474}\u{1F3FC}" }, { unified: "1f474-1f3fd", native: "\u{1F474}\u{1F3FD}" }, { unified: "1f474-1f3fe", native: "\u{1F474}\u{1F3FE}" }, { unified: "1f474-1f3ff", native: "\u{1F474}\u{1F3FF}" }], version: 1 }, older_woman: { id: "older_woman", name: "Old Woman", keywords: ["older", "human", "female", "women", "lady", "elder", "senior"], skins: [{ unified: "1f475", native: "\u{1F475}" }, { unified: "1f475-1f3fb", native: "\u{1F475}\u{1F3FB}" }, { unified: "1f475-1f3fc", native: "\u{1F475}\u{1F3FC}" }, { unified: "1f475-1f3fd", native: "\u{1F475}\u{1F3FD}" }, { unified: "1f475-1f3fe", native: "\u{1F475}\u{1F3FE}" }, { unified: "1f475-1f3ff", native: "\u{1F475}\u{1F3FF}" }], version: 1 }, person_frowning: { id: "person_frowning", name: "Person Frowning", keywords: ["worried"], skins: [{ unified: "1f64d", native: "\u{1F64D}" }, { unified: "1f64d-1f3fb", native: "\u{1F64D}\u{1F3FB}" }, { unified: "1f64d-1f3fc", native: "\u{1F64D}\u{1F3FC}" }, { unified: "1f64d-1f3fd", native: "\u{1F64D}\u{1F3FD}" }, { unified: "1f64d-1f3fe", native: "\u{1F64D}\u{1F3FE}" }, { unified: "1f64d-1f3ff", native: "\u{1F64D}\u{1F3FF}" }], version: 1 }, "man-frowning": { id: "man-frowning", name: "Man Frowning", keywords: ["male", "boy", "sad", "depressed", "discouraged", "unhappy"], skins: [{ unified: "1f64d-200d-2642-fe0f", native: "\u{1F64D}\u200D\u2642\uFE0F" }, { unified: "1f64d-1f3fb-200d-2642-fe0f", native: "\u{1F64D}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f64d-1f3fc-200d-2642-fe0f", native: "\u{1F64D}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f64d-1f3fd-200d-2642-fe0f", native: "\u{1F64D}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f64d-1f3fe-200d-2642-fe0f", native: "\u{1F64D}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f64d-1f3ff-200d-2642-fe0f", native: "\u{1F64D}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-frowning": { id: "woman-frowning", name: "Woman Frowning", keywords: ["female", "girl", "sad", "depressed", "discouraged", "unhappy"], skins: [{ unified: "1f64d-200d-2640-fe0f", native: "\u{1F64D}\u200D\u2640\uFE0F" }, { unified: "1f64d-1f3fb-200d-2640-fe0f", native: "\u{1F64D}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f64d-1f3fc-200d-2640-fe0f", native: "\u{1F64D}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f64d-1f3fd-200d-2640-fe0f", native: "\u{1F64D}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f64d-1f3fe-200d-2640-fe0f", native: "\u{1F64D}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f64d-1f3ff-200d-2640-fe0f", native: "\u{1F64D}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, person_with_pouting_face: { id: "person_with_pouting_face", name: "Person Pouting", keywords: ["with", "face", "upset"], skins: [{ unified: "1f64e", native: "\u{1F64E}" }, { unified: "1f64e-1f3fb", native: "\u{1F64E}\u{1F3FB}" }, { unified: "1f64e-1f3fc", native: "\u{1F64E}\u{1F3FC}" }, { unified: "1f64e-1f3fd", native: "\u{1F64E}\u{1F3FD}" }, { unified: "1f64e-1f3fe", native: "\u{1F64E}\u{1F3FE}" }, { unified: "1f64e-1f3ff", native: "\u{1F64E}\u{1F3FF}" }], version: 1 }, "man-pouting": { id: "man-pouting", name: "Man Pouting", keywords: ["male", "boy"], skins: [{ unified: "1f64e-200d-2642-fe0f", native: "\u{1F64E}\u200D\u2642\uFE0F" }, { unified: "1f64e-1f3fb-200d-2642-fe0f", native: "\u{1F64E}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f64e-1f3fc-200d-2642-fe0f", native: "\u{1F64E}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f64e-1f3fd-200d-2642-fe0f", native: "\u{1F64E}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f64e-1f3fe-200d-2642-fe0f", native: "\u{1F64E}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f64e-1f3ff-200d-2642-fe0f", native: "\u{1F64E}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-pouting": { id: "woman-pouting", name: "Woman Pouting", keywords: ["female", "girl"], skins: [{ unified: "1f64e-200d-2640-fe0f", native: "\u{1F64E}\u200D\u2640\uFE0F" }, { unified: "1f64e-1f3fb-200d-2640-fe0f", native: "\u{1F64E}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f64e-1f3fc-200d-2640-fe0f", native: "\u{1F64E}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f64e-1f3fd-200d-2640-fe0f", native: "\u{1F64E}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f64e-1f3fe-200d-2640-fe0f", native: "\u{1F64E}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f64e-1f3ff-200d-2640-fe0f", native: "\u{1F64E}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, no_good: { id: "no_good", name: "Person Gesturing No", keywords: ["good", "decline"], skins: [{ unified: "1f645", native: "\u{1F645}" }, { unified: "1f645-1f3fb", native: "\u{1F645}\u{1F3FB}" }, { unified: "1f645-1f3fc", native: "\u{1F645}\u{1F3FC}" }, { unified: "1f645-1f3fd", native: "\u{1F645}\u{1F3FD}" }, { unified: "1f645-1f3fe", native: "\u{1F645}\u{1F3FE}" }, { unified: "1f645-1f3ff", native: "\u{1F645}\u{1F3FF}" }], version: 1 }, "man-gesturing-no": { id: "man-gesturing-no", name: "Man Gesturing No", keywords: ["gesturing-no", "male", "boy", "nope"], skins: [{ unified: "1f645-200d-2642-fe0f", native: "\u{1F645}\u200D\u2642\uFE0F" }, { unified: "1f645-1f3fb-200d-2642-fe0f", native: "\u{1F645}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f645-1f3fc-200d-2642-fe0f", native: "\u{1F645}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f645-1f3fd-200d-2642-fe0f", native: "\u{1F645}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f645-1f3fe-200d-2642-fe0f", native: "\u{1F645}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f645-1f3ff-200d-2642-fe0f", native: "\u{1F645}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-gesturing-no": { id: "woman-gesturing-no", name: "Woman Gesturing No", keywords: ["gesturing-no", "female", "girl", "nope"], skins: [{ unified: "1f645-200d-2640-fe0f", native: "\u{1F645}\u200D\u2640\uFE0F" }, { unified: "1f645-1f3fb-200d-2640-fe0f", native: "\u{1F645}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f645-1f3fc-200d-2640-fe0f", native: "\u{1F645}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f645-1f3fd-200d-2640-fe0f", native: "\u{1F645}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f645-1f3fe-200d-2640-fe0f", native: "\u{1F645}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f645-1f3ff-200d-2640-fe0f", native: "\u{1F645}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, ok_woman: { id: "ok_woman", name: "Person Gesturing Ok", keywords: ["woman", "agree"], skins: [{ unified: "1f646", native: "\u{1F646}" }, { unified: "1f646-1f3fb", native: "\u{1F646}\u{1F3FB}" }, { unified: "1f646-1f3fc", native: "\u{1F646}\u{1F3FC}" }, { unified: "1f646-1f3fd", native: "\u{1F646}\u{1F3FD}" }, { unified: "1f646-1f3fe", native: "\u{1F646}\u{1F3FE}" }, { unified: "1f646-1f3ff", native: "\u{1F646}\u{1F3FF}" }], version: 1 }, "man-gesturing-ok": { id: "man-gesturing-ok", name: "Man Gesturing Ok", keywords: ["gesturing-ok", "men", "boy", "male", "blue", "human"], skins: [{ unified: "1f646-200d-2642-fe0f", native: "\u{1F646}\u200D\u2642\uFE0F" }, { unified: "1f646-1f3fb-200d-2642-fe0f", native: "\u{1F646}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f646-1f3fc-200d-2642-fe0f", native: "\u{1F646}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f646-1f3fd-200d-2642-fe0f", native: "\u{1F646}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f646-1f3fe-200d-2642-fe0f", native: "\u{1F646}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f646-1f3ff-200d-2642-fe0f", native: "\u{1F646}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-gesturing-ok": { id: "woman-gesturing-ok", name: "Woman Gesturing Ok", keywords: ["gesturing-ok", "women", "girl", "female", "pink", "human"], skins: [{ unified: "1f646-200d-2640-fe0f", native: "\u{1F646}\u200D\u2640\uFE0F" }, { unified: "1f646-1f3fb-200d-2640-fe0f", native: "\u{1F646}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f646-1f3fc-200d-2640-fe0f", native: "\u{1F646}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f646-1f3fd-200d-2640-fe0f", native: "\u{1F646}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f646-1f3fe-200d-2640-fe0f", native: "\u{1F646}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f646-1f3ff-200d-2640-fe0f", native: "\u{1F646}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, information_desk_person: { id: "information_desk_person", name: "Person Tipping Hand", keywords: ["information", "desk"], skins: [{ unified: "1f481", native: "\u{1F481}" }, { unified: "1f481-1f3fb", native: "\u{1F481}\u{1F3FB}" }, { unified: "1f481-1f3fc", native: "\u{1F481}\u{1F3FC}" }, { unified: "1f481-1f3fd", native: "\u{1F481}\u{1F3FD}" }, { unified: "1f481-1f3fe", native: "\u{1F481}\u{1F3FE}" }, { unified: "1f481-1f3ff", native: "\u{1F481}\u{1F3FF}" }], version: 1 }, "man-tipping-hand": { id: "man-tipping-hand", name: "Man Tipping Hand", keywords: ["tipping-hand", "male", "boy", "human", "information"], skins: [{ unified: "1f481-200d-2642-fe0f", native: "\u{1F481}\u200D\u2642\uFE0F" }, { unified: "1f481-1f3fb-200d-2642-fe0f", native: "\u{1F481}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f481-1f3fc-200d-2642-fe0f", native: "\u{1F481}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f481-1f3fd-200d-2642-fe0f", native: "\u{1F481}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f481-1f3fe-200d-2642-fe0f", native: "\u{1F481}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f481-1f3ff-200d-2642-fe0f", native: "\u{1F481}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-tipping-hand": { id: "woman-tipping-hand", name: "Woman Tipping Hand", keywords: ["tipping-hand", "female", "girl", "human", "information"], skins: [{ unified: "1f481-200d-2640-fe0f", native: "\u{1F481}\u200D\u2640\uFE0F" }, { unified: "1f481-1f3fb-200d-2640-fe0f", native: "\u{1F481}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f481-1f3fc-200d-2640-fe0f", native: "\u{1F481}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f481-1f3fd-200d-2640-fe0f", native: "\u{1F481}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f481-1f3fe-200d-2640-fe0f", native: "\u{1F481}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f481-1f3ff-200d-2640-fe0f", native: "\u{1F481}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, raising_hand: { id: "raising_hand", name: "Person Raising Hand", keywords: ["question"], skins: [{ unified: "1f64b", native: "\u{1F64B}" }, { unified: "1f64b-1f3fb", native: "\u{1F64B}\u{1F3FB}" }, { unified: "1f64b-1f3fc", native: "\u{1F64B}\u{1F3FC}" }, { unified: "1f64b-1f3fd", native: "\u{1F64B}\u{1F3FD}" }, { unified: "1f64b-1f3fe", native: "\u{1F64B}\u{1F3FE}" }, { unified: "1f64b-1f3ff", native: "\u{1F64B}\u{1F3FF}" }], version: 1 }, "man-raising-hand": { id: "man-raising-hand", name: "Man Raising Hand", keywords: ["raising-hand", "male", "boy"], skins: [{ unified: "1f64b-200d-2642-fe0f", native: "\u{1F64B}\u200D\u2642\uFE0F" }, { unified: "1f64b-1f3fb-200d-2642-fe0f", native: "\u{1F64B}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f64b-1f3fc-200d-2642-fe0f", native: "\u{1F64B}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f64b-1f3fd-200d-2642-fe0f", native: "\u{1F64B}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f64b-1f3fe-200d-2642-fe0f", native: "\u{1F64B}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f64b-1f3ff-200d-2642-fe0f", native: "\u{1F64B}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-raising-hand": { id: "woman-raising-hand", name: "Woman Raising Hand", keywords: ["raising-hand", "female", "girl"], skins: [{ unified: "1f64b-200d-2640-fe0f", native: "\u{1F64B}\u200D\u2640\uFE0F" }, { unified: "1f64b-1f3fb-200d-2640-fe0f", native: "\u{1F64B}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f64b-1f3fc-200d-2640-fe0f", native: "\u{1F64B}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f64b-1f3fd-200d-2640-fe0f", native: "\u{1F64B}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f64b-1f3fe-200d-2640-fe0f", native: "\u{1F64B}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f64b-1f3ff-200d-2640-fe0f", native: "\u{1F64B}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, deaf_person: { id: "deaf_person", name: "Deaf Person", keywords: ["accessibility"], skins: [{ unified: "1f9cf", native: "\u{1F9CF}" }, { unified: "1f9cf-1f3fb", native: "\u{1F9CF}\u{1F3FB}" }, { unified: "1f9cf-1f3fc", native: "\u{1F9CF}\u{1F3FC}" }, { unified: "1f9cf-1f3fd", native: "\u{1F9CF}\u{1F3FD}" }, { unified: "1f9cf-1f3fe", native: "\u{1F9CF}\u{1F3FE}" }, { unified: "1f9cf-1f3ff", native: "\u{1F9CF}\u{1F3FF}" }], version: 12 }, deaf_man: { id: "deaf_man", name: "Deaf Man", keywords: ["accessibility"], skins: [{ unified: "1f9cf-200d-2642-fe0f", native: "\u{1F9CF}\u200D\u2642\uFE0F" }, { unified: "1f9cf-1f3fb-200d-2642-fe0f", native: "\u{1F9CF}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9cf-1f3fc-200d-2642-fe0f", native: "\u{1F9CF}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9cf-1f3fd-200d-2642-fe0f", native: "\u{1F9CF}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9cf-1f3fe-200d-2642-fe0f", native: "\u{1F9CF}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9cf-1f3ff-200d-2642-fe0f", native: "\u{1F9CF}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 12 }, deaf_woman: { id: "deaf_woman", name: "Deaf Woman", keywords: ["accessibility"], skins: [{ unified: "1f9cf-200d-2640-fe0f", native: "\u{1F9CF}\u200D\u2640\uFE0F" }, { unified: "1f9cf-1f3fb-200d-2640-fe0f", native: "\u{1F9CF}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9cf-1f3fc-200d-2640-fe0f", native: "\u{1F9CF}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9cf-1f3fd-200d-2640-fe0f", native: "\u{1F9CF}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9cf-1f3fe-200d-2640-fe0f", native: "\u{1F9CF}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9cf-1f3ff-200d-2640-fe0f", native: "\u{1F9CF}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 12 }, bow: { id: "bow", name: "Person Bowing", keywords: ["bow", "respectiful"], skins: [{ unified: "1f647", native: "\u{1F647}" }, { unified: "1f647-1f3fb", native: "\u{1F647}\u{1F3FB}" }, { unified: "1f647-1f3fc", native: "\u{1F647}\u{1F3FC}" }, { unified: "1f647-1f3fd", native: "\u{1F647}\u{1F3FD}" }, { unified: "1f647-1f3fe", native: "\u{1F647}\u{1F3FE}" }, { unified: "1f647-1f3ff", native: "\u{1F647}\u{1F3FF}" }], version: 1 }, "man-bowing": { id: "man-bowing", name: "Man Bowing", keywords: ["male", "boy"], skins: [{ unified: "1f647-200d-2642-fe0f", native: "\u{1F647}\u200D\u2642\uFE0F" }, { unified: "1f647-1f3fb-200d-2642-fe0f", native: "\u{1F647}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f647-1f3fc-200d-2642-fe0f", native: "\u{1F647}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f647-1f3fd-200d-2642-fe0f", native: "\u{1F647}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f647-1f3fe-200d-2642-fe0f", native: "\u{1F647}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f647-1f3ff-200d-2642-fe0f", native: "\u{1F647}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-bowing": { id: "woman-bowing", name: "Woman Bowing", keywords: ["female", "girl"], skins: [{ unified: "1f647-200d-2640-fe0f", native: "\u{1F647}\u200D\u2640\uFE0F" }, { unified: "1f647-1f3fb-200d-2640-fe0f", native: "\u{1F647}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f647-1f3fc-200d-2640-fe0f", native: "\u{1F647}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f647-1f3fd-200d-2640-fe0f", native: "\u{1F647}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f647-1f3fe-200d-2640-fe0f", native: "\u{1F647}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f647-1f3ff-200d-2640-fe0f", native: "\u{1F647}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, face_palm: { id: "face_palm", name: "Face Palm", keywords: ["person", "facepalming", "disappointed"], skins: [{ unified: "1f926", native: "\u{1F926}" }, { unified: "1f926-1f3fb", native: "\u{1F926}\u{1F3FB}" }, { unified: "1f926-1f3fc", native: "\u{1F926}\u{1F3FC}" }, { unified: "1f926-1f3fd", native: "\u{1F926}\u{1F3FD}" }, { unified: "1f926-1f3fe", native: "\u{1F926}\u{1F3FE}" }, { unified: "1f926-1f3ff", native: "\u{1F926}\u{1F3FF}" }], version: 3 }, "man-facepalming": { id: "man-facepalming", name: "Man Facepalming", keywords: ["male", "boy", "disbelief"], skins: [{ unified: "1f926-200d-2642-fe0f", native: "\u{1F926}\u200D\u2642\uFE0F" }, { unified: "1f926-1f3fb-200d-2642-fe0f", native: "\u{1F926}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f926-1f3fc-200d-2642-fe0f", native: "\u{1F926}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f926-1f3fd-200d-2642-fe0f", native: "\u{1F926}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f926-1f3fe-200d-2642-fe0f", native: "\u{1F926}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f926-1f3ff-200d-2642-fe0f", native: "\u{1F926}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-facepalming": { id: "woman-facepalming", name: "Woman Facepalming", keywords: ["female", "girl", "disbelief"], skins: [{ unified: "1f926-200d-2640-fe0f", native: "\u{1F926}\u200D\u2640\uFE0F" }, { unified: "1f926-1f3fb-200d-2640-fe0f", native: "\u{1F926}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f926-1f3fc-200d-2640-fe0f", native: "\u{1F926}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f926-1f3fd-200d-2640-fe0f", native: "\u{1F926}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f926-1f3fe-200d-2640-fe0f", native: "\u{1F926}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f926-1f3ff-200d-2640-fe0f", native: "\u{1F926}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, shrug: { id: "shrug", name: "Shrug", keywords: ["person", "shrugging", "regardless"], skins: [{ unified: "1f937", native: "\u{1F937}" }, { unified: "1f937-1f3fb", native: "\u{1F937}\u{1F3FB}" }, { unified: "1f937-1f3fc", native: "\u{1F937}\u{1F3FC}" }, { unified: "1f937-1f3fd", native: "\u{1F937}\u{1F3FD}" }, { unified: "1f937-1f3fe", native: "\u{1F937}\u{1F3FE}" }, { unified: "1f937-1f3ff", native: "\u{1F937}\u{1F3FF}" }], version: 3 }, "man-shrugging": { id: "man-shrugging", name: "Man Shrugging", keywords: ["male", "boy", "confused", "indifferent", "doubt"], skins: [{ unified: "1f937-200d-2642-fe0f", native: "\u{1F937}\u200D\u2642\uFE0F" }, { unified: "1f937-1f3fb-200d-2642-fe0f", native: "\u{1F937}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f937-1f3fc-200d-2642-fe0f", native: "\u{1F937}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f937-1f3fd-200d-2642-fe0f", native: "\u{1F937}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f937-1f3fe-200d-2642-fe0f", native: "\u{1F937}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f937-1f3ff-200d-2642-fe0f", native: "\u{1F937}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-shrugging": { id: "woman-shrugging", name: "Woman Shrugging", keywords: ["female", "girl", "confused", "indifferent", "doubt"], skins: [{ unified: "1f937-200d-2640-fe0f", native: "\u{1F937}\u200D\u2640\uFE0F" }, { unified: "1f937-1f3fb-200d-2640-fe0f", native: "\u{1F937}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f937-1f3fc-200d-2640-fe0f", native: "\u{1F937}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f937-1f3fd-200d-2640-fe0f", native: "\u{1F937}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f937-1f3fe-200d-2640-fe0f", native: "\u{1F937}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f937-1f3ff-200d-2640-fe0f", native: "\u{1F937}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, health_worker: { id: "health_worker", name: "Health Worker", keywords: ["hospital"], skins: [{ unified: "1f9d1-200d-2695-fe0f", native: "\u{1F9D1}\u200D\u2695\uFE0F" }, { unified: "1f9d1-1f3fb-200d-2695-fe0f", native: "\u{1F9D1}\u{1F3FB}\u200D\u2695\uFE0F" }, { unified: "1f9d1-1f3fc-200d-2695-fe0f", native: "\u{1F9D1}\u{1F3FC}\u200D\u2695\uFE0F" }, { unified: "1f9d1-1f3fd-200d-2695-fe0f", native: "\u{1F9D1}\u{1F3FD}\u200D\u2695\uFE0F" }, { unified: "1f9d1-1f3fe-200d-2695-fe0f", native: "\u{1F9D1}\u{1F3FE}\u200D\u2695\uFE0F" }, { unified: "1f9d1-1f3ff-200d-2695-fe0f", native: "\u{1F9D1}\u{1F3FF}\u200D\u2695\uFE0F" }], version: 12.1 }, "male-doctor": { id: "male-doctor", name: "Man Health Worker", keywords: ["male", "doctor", "nurse", "therapist", "healthcare", "human"], skins: [{ unified: "1f468-200d-2695-fe0f", native: "\u{1F468}\u200D\u2695\uFE0F" }, { unified: "1f468-1f3fb-200d-2695-fe0f", native: "\u{1F468}\u{1F3FB}\u200D\u2695\uFE0F" }, { unified: "1f468-1f3fc-200d-2695-fe0f", native: "\u{1F468}\u{1F3FC}\u200D\u2695\uFE0F" }, { unified: "1f468-1f3fd-200d-2695-fe0f", native: "\u{1F468}\u{1F3FD}\u200D\u2695\uFE0F" }, { unified: "1f468-1f3fe-200d-2695-fe0f", native: "\u{1F468}\u{1F3FE}\u200D\u2695\uFE0F" }, { unified: "1f468-1f3ff-200d-2695-fe0f", native: "\u{1F468}\u{1F3FF}\u200D\u2695\uFE0F" }], version: 4 }, "female-doctor": { id: "female-doctor", name: "Woman Health Worker", keywords: ["female", "doctor", "nurse", "therapist", "healthcare", "human"], skins: [{ unified: "1f469-200d-2695-fe0f", native: "\u{1F469}\u200D\u2695\uFE0F" }, { unified: "1f469-1f3fb-200d-2695-fe0f", native: "\u{1F469}\u{1F3FB}\u200D\u2695\uFE0F" }, { unified: "1f469-1f3fc-200d-2695-fe0f", native: "\u{1F469}\u{1F3FC}\u200D\u2695\uFE0F" }, { unified: "1f469-1f3fd-200d-2695-fe0f", native: "\u{1F469}\u{1F3FD}\u200D\u2695\uFE0F" }, { unified: "1f469-1f3fe-200d-2695-fe0f", native: "\u{1F469}\u{1F3FE}\u200D\u2695\uFE0F" }, { unified: "1f469-1f3ff-200d-2695-fe0f", native: "\u{1F469}\u{1F3FF}\u200D\u2695\uFE0F" }], version: 4 }, student: { id: "student", name: "Student", keywords: ["learn"], skins: [{ unified: "1f9d1-200d-1f393", native: "\u{1F9D1}\u200D\u{1F393}" }, { unified: "1f9d1-1f3fb-200d-1f393", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F393}" }, { unified: "1f9d1-1f3fc-200d-1f393", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F393}" }, { unified: "1f9d1-1f3fd-200d-1f393", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F393}" }, { unified: "1f9d1-1f3fe-200d-1f393", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F393}" }, { unified: "1f9d1-1f3ff-200d-1f393", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F393}" }], version: 12.1 }, "male-student": { id: "male-student", name: "Man Student", keywords: ["male", "graduate", "human"], skins: [{ unified: "1f468-200d-1f393", native: "\u{1F468}\u200D\u{1F393}" }, { unified: "1f468-1f3fb-200d-1f393", native: "\u{1F468}\u{1F3FB}\u200D\u{1F393}" }, { unified: "1f468-1f3fc-200d-1f393", native: "\u{1F468}\u{1F3FC}\u200D\u{1F393}" }, { unified: "1f468-1f3fd-200d-1f393", native: "\u{1F468}\u{1F3FD}\u200D\u{1F393}" }, { unified: "1f468-1f3fe-200d-1f393", native: "\u{1F468}\u{1F3FE}\u200D\u{1F393}" }, { unified: "1f468-1f3ff-200d-1f393", native: "\u{1F468}\u{1F3FF}\u200D\u{1F393}" }], version: 4 }, "female-student": { id: "female-student", name: "Woman Student", keywords: ["female", "graduate", "human"], skins: [{ unified: "1f469-200d-1f393", native: "\u{1F469}\u200D\u{1F393}" }, { unified: "1f469-1f3fb-200d-1f393", native: "\u{1F469}\u{1F3FB}\u200D\u{1F393}" }, { unified: "1f469-1f3fc-200d-1f393", native: "\u{1F469}\u{1F3FC}\u200D\u{1F393}" }, { unified: "1f469-1f3fd-200d-1f393", native: "\u{1F469}\u{1F3FD}\u200D\u{1F393}" }, { unified: "1f469-1f3fe-200d-1f393", native: "\u{1F469}\u{1F3FE}\u200D\u{1F393}" }, { unified: "1f469-1f3ff-200d-1f393", native: "\u{1F469}\u{1F3FF}\u200D\u{1F393}" }], version: 4 }, teacher: { id: "teacher", name: "Teacher", keywords: ["professor"], skins: [{ unified: "1f9d1-200d-1f3eb", native: "\u{1F9D1}\u200D\u{1F3EB}" }, { unified: "1f9d1-1f3fb-200d-1f3eb", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F3EB}" }, { unified: "1f9d1-1f3fc-200d-1f3eb", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F3EB}" }, { unified: "1f9d1-1f3fd-200d-1f3eb", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F3EB}" }, { unified: "1f9d1-1f3fe-200d-1f3eb", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F3EB}" }, { unified: "1f9d1-1f3ff-200d-1f3eb", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F3EB}" }], version: 12.1 }, "male-teacher": { id: "male-teacher", name: "Man Teacher", keywords: ["male", "instructor", "professor", "human"], skins: [{ unified: "1f468-200d-1f3eb", native: "\u{1F468}\u200D\u{1F3EB}" }, { unified: "1f468-1f3fb-200d-1f3eb", native: "\u{1F468}\u{1F3FB}\u200D\u{1F3EB}" }, { unified: "1f468-1f3fc-200d-1f3eb", native: "\u{1F468}\u{1F3FC}\u200D\u{1F3EB}" }, { unified: "1f468-1f3fd-200d-1f3eb", native: "\u{1F468}\u{1F3FD}\u200D\u{1F3EB}" }, { unified: "1f468-1f3fe-200d-1f3eb", native: "\u{1F468}\u{1F3FE}\u200D\u{1F3EB}" }, { unified: "1f468-1f3ff-200d-1f3eb", native: "\u{1F468}\u{1F3FF}\u200D\u{1F3EB}" }], version: 4 }, "female-teacher": { id: "female-teacher", name: "Woman Teacher", keywords: ["female", "instructor", "professor", "human"], skins: [{ unified: "1f469-200d-1f3eb", native: "\u{1F469}\u200D\u{1F3EB}" }, { unified: "1f469-1f3fb-200d-1f3eb", native: "\u{1F469}\u{1F3FB}\u200D\u{1F3EB}" }, { unified: "1f469-1f3fc-200d-1f3eb", native: "\u{1F469}\u{1F3FC}\u200D\u{1F3EB}" }, { unified: "1f469-1f3fd-200d-1f3eb", native: "\u{1F469}\u{1F3FD}\u200D\u{1F3EB}" }, { unified: "1f469-1f3fe-200d-1f3eb", native: "\u{1F469}\u{1F3FE}\u200D\u{1F3EB}" }, { unified: "1f469-1f3ff-200d-1f3eb", native: "\u{1F469}\u{1F3FF}\u200D\u{1F3EB}" }], version: 4 }, judge: { id: "judge", name: "Judge", keywords: ["law"], skins: [{ unified: "1f9d1-200d-2696-fe0f", native: "\u{1F9D1}\u200D\u2696\uFE0F" }, { unified: "1f9d1-1f3fb-200d-2696-fe0f", native: "\u{1F9D1}\u{1F3FB}\u200D\u2696\uFE0F" }, { unified: "1f9d1-1f3fc-200d-2696-fe0f", native: "\u{1F9D1}\u{1F3FC}\u200D\u2696\uFE0F" }, { unified: "1f9d1-1f3fd-200d-2696-fe0f", native: "\u{1F9D1}\u{1F3FD}\u200D\u2696\uFE0F" }, { unified: "1f9d1-1f3fe-200d-2696-fe0f", native: "\u{1F9D1}\u{1F3FE}\u200D\u2696\uFE0F" }, { unified: "1f9d1-1f3ff-200d-2696-fe0f", native: "\u{1F9D1}\u{1F3FF}\u200D\u2696\uFE0F" }], version: 12.1 }, "male-judge": { id: "male-judge", name: "Man Judge", keywords: ["male", "justice", "court", "human"], skins: [{ unified: "1f468-200d-2696-fe0f", native: "\u{1F468}\u200D\u2696\uFE0F" }, { unified: "1f468-1f3fb-200d-2696-fe0f", native: "\u{1F468}\u{1F3FB}\u200D\u2696\uFE0F" }, { unified: "1f468-1f3fc-200d-2696-fe0f", native: "\u{1F468}\u{1F3FC}\u200D\u2696\uFE0F" }, { unified: "1f468-1f3fd-200d-2696-fe0f", native: "\u{1F468}\u{1F3FD}\u200D\u2696\uFE0F" }, { unified: "1f468-1f3fe-200d-2696-fe0f", native: "\u{1F468}\u{1F3FE}\u200D\u2696\uFE0F" }, { unified: "1f468-1f3ff-200d-2696-fe0f", native: "\u{1F468}\u{1F3FF}\u200D\u2696\uFE0F" }], version: 4 }, "female-judge": { id: "female-judge", name: "Woman Judge", keywords: ["female", "justice", "court", "human"], skins: [{ unified: "1f469-200d-2696-fe0f", native: "\u{1F469}\u200D\u2696\uFE0F" }, { unified: "1f469-1f3fb-200d-2696-fe0f", native: "\u{1F469}\u{1F3FB}\u200D\u2696\uFE0F" }, { unified: "1f469-1f3fc-200d-2696-fe0f", native: "\u{1F469}\u{1F3FC}\u200D\u2696\uFE0F" }, { unified: "1f469-1f3fd-200d-2696-fe0f", native: "\u{1F469}\u{1F3FD}\u200D\u2696\uFE0F" }, { unified: "1f469-1f3fe-200d-2696-fe0f", native: "\u{1F469}\u{1F3FE}\u200D\u2696\uFE0F" }, { unified: "1f469-1f3ff-200d-2696-fe0f", native: "\u{1F469}\u{1F3FF}\u200D\u2696\uFE0F" }], version: 4 }, farmer: { id: "farmer", name: "Farmer", keywords: ["crops"], skins: [{ unified: "1f9d1-200d-1f33e", native: "\u{1F9D1}\u200D\u{1F33E}" }, { unified: "1f9d1-1f3fb-200d-1f33e", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F33E}" }, { unified: "1f9d1-1f3fc-200d-1f33e", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F33E}" }, { unified: "1f9d1-1f3fd-200d-1f33e", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F33E}" }, { unified: "1f9d1-1f3fe-200d-1f33e", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F33E}" }, { unified: "1f9d1-1f3ff-200d-1f33e", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F33E}" }], version: 12.1 }, "male-farmer": { id: "male-farmer", name: "Man Farmer", keywords: ["male", "rancher", "gardener", "human"], skins: [{ unified: "1f468-200d-1f33e", native: "\u{1F468}\u200D\u{1F33E}" }, { unified: "1f468-1f3fb-200d-1f33e", native: "\u{1F468}\u{1F3FB}\u200D\u{1F33E}" }, { unified: "1f468-1f3fc-200d-1f33e", native: "\u{1F468}\u{1F3FC}\u200D\u{1F33E}" }, { unified: "1f468-1f3fd-200d-1f33e", native: "\u{1F468}\u{1F3FD}\u200D\u{1F33E}" }, { unified: "1f468-1f3fe-200d-1f33e", native: "\u{1F468}\u{1F3FE}\u200D\u{1F33E}" }, { unified: "1f468-1f3ff-200d-1f33e", native: "\u{1F468}\u{1F3FF}\u200D\u{1F33E}" }], version: 4 }, "female-farmer": { id: "female-farmer", name: "Woman Farmer", keywords: ["female", "rancher", "gardener", "human"], skins: [{ unified: "1f469-200d-1f33e", native: "\u{1F469}\u200D\u{1F33E}" }, { unified: "1f469-1f3fb-200d-1f33e", native: "\u{1F469}\u{1F3FB}\u200D\u{1F33E}" }, { unified: "1f469-1f3fc-200d-1f33e", native: "\u{1F469}\u{1F3FC}\u200D\u{1F33E}" }, { unified: "1f469-1f3fd-200d-1f33e", native: "\u{1F469}\u{1F3FD}\u200D\u{1F33E}" }, { unified: "1f469-1f3fe-200d-1f33e", native: "\u{1F469}\u{1F3FE}\u200D\u{1F33E}" }, { unified: "1f469-1f3ff-200d-1f33e", native: "\u{1F469}\u{1F3FF}\u200D\u{1F33E}" }], version: 4 }, cook: { id: "cook", name: "Cook", keywords: ["food", "kitchen", "culinary"], skins: [{ unified: "1f9d1-200d-1f373", native: "\u{1F9D1}\u200D\u{1F373}" }, { unified: "1f9d1-1f3fb-200d-1f373", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F373}" }, { unified: "1f9d1-1f3fc-200d-1f373", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F373}" }, { unified: "1f9d1-1f3fd-200d-1f373", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F373}" }, { unified: "1f9d1-1f3fe-200d-1f373", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F373}" }, { unified: "1f9d1-1f3ff-200d-1f373", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F373}" }], version: 12.1 }, "male-cook": { id: "male-cook", name: "Man Cook", keywords: ["male", "chef", "human"], skins: [{ unified: "1f468-200d-1f373", native: "\u{1F468}\u200D\u{1F373}" }, { unified: "1f468-1f3fb-200d-1f373", native: "\u{1F468}\u{1F3FB}\u200D\u{1F373}" }, { unified: "1f468-1f3fc-200d-1f373", native: "\u{1F468}\u{1F3FC}\u200D\u{1F373}" }, { unified: "1f468-1f3fd-200d-1f373", native: "\u{1F468}\u{1F3FD}\u200D\u{1F373}" }, { unified: "1f468-1f3fe-200d-1f373", native: "\u{1F468}\u{1F3FE}\u200D\u{1F373}" }, { unified: "1f468-1f3ff-200d-1f373", native: "\u{1F468}\u{1F3FF}\u200D\u{1F373}" }], version: 4 }, "female-cook": { id: "female-cook", name: "Woman Cook", keywords: ["female", "chef", "human"], skins: [{ unified: "1f469-200d-1f373", native: "\u{1F469}\u200D\u{1F373}" }, { unified: "1f469-1f3fb-200d-1f373", native: "\u{1F469}\u{1F3FB}\u200D\u{1F373}" }, { unified: "1f469-1f3fc-200d-1f373", native: "\u{1F469}\u{1F3FC}\u200D\u{1F373}" }, { unified: "1f469-1f3fd-200d-1f373", native: "\u{1F469}\u{1F3FD}\u200D\u{1F373}" }, { unified: "1f469-1f3fe-200d-1f373", native: "\u{1F469}\u{1F3FE}\u200D\u{1F373}" }, { unified: "1f469-1f3ff-200d-1f373", native: "\u{1F469}\u{1F3FF}\u200D\u{1F373}" }], version: 4 }, mechanic: { id: "mechanic", name: "Mechanic", keywords: ["worker", "technician"], skins: [{ unified: "1f9d1-200d-1f527", native: "\u{1F9D1}\u200D\u{1F527}" }, { unified: "1f9d1-1f3fb-200d-1f527", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F527}" }, { unified: "1f9d1-1f3fc-200d-1f527", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F527}" }, { unified: "1f9d1-1f3fd-200d-1f527", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F527}" }, { unified: "1f9d1-1f3fe-200d-1f527", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F527}" }, { unified: "1f9d1-1f3ff-200d-1f527", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F527}" }], version: 12.1 }, "male-mechanic": { id: "male-mechanic", name: "Man Mechanic", keywords: ["male", "plumber", "human", "wrench"], skins: [{ unified: "1f468-200d-1f527", native: "\u{1F468}\u200D\u{1F527}" }, { unified: "1f468-1f3fb-200d-1f527", native: "\u{1F468}\u{1F3FB}\u200D\u{1F527}" }, { unified: "1f468-1f3fc-200d-1f527", native: "\u{1F468}\u{1F3FC}\u200D\u{1F527}" }, { unified: "1f468-1f3fd-200d-1f527", native: "\u{1F468}\u{1F3FD}\u200D\u{1F527}" }, { unified: "1f468-1f3fe-200d-1f527", native: "\u{1F468}\u{1F3FE}\u200D\u{1F527}" }, { unified: "1f468-1f3ff-200d-1f527", native: "\u{1F468}\u{1F3FF}\u200D\u{1F527}" }], version: 4 }, "female-mechanic": { id: "female-mechanic", name: "Woman Mechanic", keywords: ["female", "plumber", "human", "wrench"], skins: [{ unified: "1f469-200d-1f527", native: "\u{1F469}\u200D\u{1F527}" }, { unified: "1f469-1f3fb-200d-1f527", native: "\u{1F469}\u{1F3FB}\u200D\u{1F527}" }, { unified: "1f469-1f3fc-200d-1f527", native: "\u{1F469}\u{1F3FC}\u200D\u{1F527}" }, { unified: "1f469-1f3fd-200d-1f527", native: "\u{1F469}\u{1F3FD}\u200D\u{1F527}" }, { unified: "1f469-1f3fe-200d-1f527", native: "\u{1F469}\u{1F3FE}\u200D\u{1F527}" }, { unified: "1f469-1f3ff-200d-1f527", native: "\u{1F469}\u{1F3FF}\u200D\u{1F527}" }], version: 4 }, factory_worker: { id: "factory_worker", name: "Factory Worker", keywords: ["labor"], skins: [{ unified: "1f9d1-200d-1f3ed", native: "\u{1F9D1}\u200D\u{1F3ED}" }, { unified: "1f9d1-1f3fb-200d-1f3ed", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F3ED}" }, { unified: "1f9d1-1f3fc-200d-1f3ed", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F3ED}" }, { unified: "1f9d1-1f3fd-200d-1f3ed", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F3ED}" }, { unified: "1f9d1-1f3fe-200d-1f3ed", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F3ED}" }, { unified: "1f9d1-1f3ff-200d-1f3ed", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F3ED}" }], version: 12.1 }, "male-factory-worker": { id: "male-factory-worker", name: "Man Factory Worker", keywords: ["male", "factory-worker", "assembly", "industrial", "human"], skins: [{ unified: "1f468-200d-1f3ed", native: "\u{1F468}\u200D\u{1F3ED}" }, { unified: "1f468-1f3fb-200d-1f3ed", native: "\u{1F468}\u{1F3FB}\u200D\u{1F3ED}" }, { unified: "1f468-1f3fc-200d-1f3ed", native: "\u{1F468}\u{1F3FC}\u200D\u{1F3ED}" }, { unified: "1f468-1f3fd-200d-1f3ed", native: "\u{1F468}\u{1F3FD}\u200D\u{1F3ED}" }, { unified: "1f468-1f3fe-200d-1f3ed", native: "\u{1F468}\u{1F3FE}\u200D\u{1F3ED}" }, { unified: "1f468-1f3ff-200d-1f3ed", native: "\u{1F468}\u{1F3FF}\u200D\u{1F3ED}" }], version: 4 }, "female-factory-worker": { id: "female-factory-worker", name: "Woman Factory Worker", keywords: ["female", "factory-worker", "assembly", "industrial", "human"], skins: [{ unified: "1f469-200d-1f3ed", native: "\u{1F469}\u200D\u{1F3ED}" }, { unified: "1f469-1f3fb-200d-1f3ed", native: "\u{1F469}\u{1F3FB}\u200D\u{1F3ED}" }, { unified: "1f469-1f3fc-200d-1f3ed", native: "\u{1F469}\u{1F3FC}\u200D\u{1F3ED}" }, { unified: "1f469-1f3fd-200d-1f3ed", native: "\u{1F469}\u{1F3FD}\u200D\u{1F3ED}" }, { unified: "1f469-1f3fe-200d-1f3ed", native: "\u{1F469}\u{1F3FE}\u200D\u{1F3ED}" }, { unified: "1f469-1f3ff-200d-1f3ed", native: "\u{1F469}\u{1F3FF}\u200D\u{1F3ED}" }], version: 4 }, office_worker: { id: "office_worker", name: "Office Worker", keywords: ["business"], skins: [{ unified: "1f9d1-200d-1f4bc", native: "\u{1F9D1}\u200D\u{1F4BC}" }, { unified: "1f9d1-1f3fb-200d-1f4bc", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F4BC}" }, { unified: "1f9d1-1f3fc-200d-1f4bc", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F4BC}" }, { unified: "1f9d1-1f3fd-200d-1f4bc", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F4BC}" }, { unified: "1f9d1-1f3fe-200d-1f4bc", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F4BC}" }, { unified: "1f9d1-1f3ff-200d-1f4bc", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F4BC}" }], version: 12.1 }, "male-office-worker": { id: "male-office-worker", name: "Man Office Worker", keywords: ["male", "office-worker", "business", "manager", "human"], skins: [{ unified: "1f468-200d-1f4bc", native: "\u{1F468}\u200D\u{1F4BC}" }, { unified: "1f468-1f3fb-200d-1f4bc", native: "\u{1F468}\u{1F3FB}\u200D\u{1F4BC}" }, { unified: "1f468-1f3fc-200d-1f4bc", native: "\u{1F468}\u{1F3FC}\u200D\u{1F4BC}" }, { unified: "1f468-1f3fd-200d-1f4bc", native: "\u{1F468}\u{1F3FD}\u200D\u{1F4BC}" }, { unified: "1f468-1f3fe-200d-1f4bc", native: "\u{1F468}\u{1F3FE}\u200D\u{1F4BC}" }, { unified: "1f468-1f3ff-200d-1f4bc", native: "\u{1F468}\u{1F3FF}\u200D\u{1F4BC}" }], version: 4 }, "female-office-worker": { id: "female-office-worker", name: "Woman Office Worker", keywords: ["female", "office-worker", "business", "manager", "human"], skins: [{ unified: "1f469-200d-1f4bc", native: "\u{1F469}\u200D\u{1F4BC}" }, { unified: "1f469-1f3fb-200d-1f4bc", native: "\u{1F469}\u{1F3FB}\u200D\u{1F4BC}" }, { unified: "1f469-1f3fc-200d-1f4bc", native: "\u{1F469}\u{1F3FC}\u200D\u{1F4BC}" }, { unified: "1f469-1f3fd-200d-1f4bc", native: "\u{1F469}\u{1F3FD}\u200D\u{1F4BC}" }, { unified: "1f469-1f3fe-200d-1f4bc", native: "\u{1F469}\u{1F3FE}\u200D\u{1F4BC}" }, { unified: "1f469-1f3ff-200d-1f4bc", native: "\u{1F469}\u{1F3FF}\u200D\u{1F4BC}" }], version: 4 }, scientist: { id: "scientist", name: "Scientist", keywords: ["chemistry"], skins: [{ unified: "1f9d1-200d-1f52c", native: "\u{1F9D1}\u200D\u{1F52C}" }, { unified: "1f9d1-1f3fb-200d-1f52c", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F52C}" }, { unified: "1f9d1-1f3fc-200d-1f52c", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F52C}" }, { unified: "1f9d1-1f3fd-200d-1f52c", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F52C}" }, { unified: "1f9d1-1f3fe-200d-1f52c", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F52C}" }, { unified: "1f9d1-1f3ff-200d-1f52c", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F52C}" }], version: 12.1 }, "male-scientist": { id: "male-scientist", name: "Man Scientist", keywords: ["male", "biologist", "chemist", "engineer", "physicist", "human"], skins: [{ unified: "1f468-200d-1f52c", native: "\u{1F468}\u200D\u{1F52C}" }, { unified: "1f468-1f3fb-200d-1f52c", native: "\u{1F468}\u{1F3FB}\u200D\u{1F52C}" }, { unified: "1f468-1f3fc-200d-1f52c", native: "\u{1F468}\u{1F3FC}\u200D\u{1F52C}" }, { unified: "1f468-1f3fd-200d-1f52c", native: "\u{1F468}\u{1F3FD}\u200D\u{1F52C}" }, { unified: "1f468-1f3fe-200d-1f52c", native: "\u{1F468}\u{1F3FE}\u200D\u{1F52C}" }, { unified: "1f468-1f3ff-200d-1f52c", native: "\u{1F468}\u{1F3FF}\u200D\u{1F52C}" }], version: 4 }, "female-scientist": { id: "female-scientist", name: "Woman Scientist", keywords: ["female", "biologist", "chemist", "engineer", "physicist", "human"], skins: [{ unified: "1f469-200d-1f52c", native: "\u{1F469}\u200D\u{1F52C}" }, { unified: "1f469-1f3fb-200d-1f52c", native: "\u{1F469}\u{1F3FB}\u200D\u{1F52C}" }, { unified: "1f469-1f3fc-200d-1f52c", native: "\u{1F469}\u{1F3FC}\u200D\u{1F52C}" }, { unified: "1f469-1f3fd-200d-1f52c", native: "\u{1F469}\u{1F3FD}\u200D\u{1F52C}" }, { unified: "1f469-1f3fe-200d-1f52c", native: "\u{1F469}\u{1F3FE}\u200D\u{1F52C}" }, { unified: "1f469-1f3ff-200d-1f52c", native: "\u{1F469}\u{1F3FF}\u200D\u{1F52C}" }], version: 4 }, technologist: { id: "technologist", name: "Technologist", keywords: ["computer"], skins: [{ unified: "1f9d1-200d-1f4bb", native: "\u{1F9D1}\u200D\u{1F4BB}" }, { unified: "1f9d1-1f3fb-200d-1f4bb", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F4BB}" }, { unified: "1f9d1-1f3fc-200d-1f4bb", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F4BB}" }, { unified: "1f9d1-1f3fd-200d-1f4bb", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F4BB}" }, { unified: "1f9d1-1f3fe-200d-1f4bb", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F4BB}" }, { unified: "1f9d1-1f3ff-200d-1f4bb", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F4BB}" }], version: 12.1 }, "male-technologist": { id: "male-technologist", name: "Man Technologist", keywords: ["male", "coder", "developer", "engineer", "programmer", "software", "human", "laptop", "computer"], skins: [{ unified: "1f468-200d-1f4bb", native: "\u{1F468}\u200D\u{1F4BB}" }, { unified: "1f468-1f3fb-200d-1f4bb", native: "\u{1F468}\u{1F3FB}\u200D\u{1F4BB}" }, { unified: "1f468-1f3fc-200d-1f4bb", native: "\u{1F468}\u{1F3FC}\u200D\u{1F4BB}" }, { unified: "1f468-1f3fd-200d-1f4bb", native: "\u{1F468}\u{1F3FD}\u200D\u{1F4BB}" }, { unified: "1f468-1f3fe-200d-1f4bb", native: "\u{1F468}\u{1F3FE}\u200D\u{1F4BB}" }, { unified: "1f468-1f3ff-200d-1f4bb", native: "\u{1F468}\u{1F3FF}\u200D\u{1F4BB}" }], version: 4 }, "female-technologist": { id: "female-technologist", name: "Woman Technologist", keywords: ["female", "coder", "developer", "engineer", "programmer", "software", "human", "laptop", "computer"], skins: [{ unified: "1f469-200d-1f4bb", native: "\u{1F469}\u200D\u{1F4BB}" }, { unified: "1f469-1f3fb-200d-1f4bb", native: "\u{1F469}\u{1F3FB}\u200D\u{1F4BB}" }, { unified: "1f469-1f3fc-200d-1f4bb", native: "\u{1F469}\u{1F3FC}\u200D\u{1F4BB}" }, { unified: "1f469-1f3fd-200d-1f4bb", native: "\u{1F469}\u{1F3FD}\u200D\u{1F4BB}" }, { unified: "1f469-1f3fe-200d-1f4bb", native: "\u{1F469}\u{1F3FE}\u200D\u{1F4BB}" }, { unified: "1f469-1f3ff-200d-1f4bb", native: "\u{1F469}\u{1F3FF}\u200D\u{1F4BB}" }], version: 4 }, singer: { id: "singer", name: "Singer", keywords: ["song", "artist", "performer"], skins: [{ unified: "1f9d1-200d-1f3a4", native: "\u{1F9D1}\u200D\u{1F3A4}" }, { unified: "1f9d1-1f3fb-200d-1f3a4", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F3A4}" }, { unified: "1f9d1-1f3fc-200d-1f3a4", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F3A4}" }, { unified: "1f9d1-1f3fd-200d-1f3a4", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F3A4}" }, { unified: "1f9d1-1f3fe-200d-1f3a4", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F3A4}" }, { unified: "1f9d1-1f3ff-200d-1f3a4", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F3A4}" }], version: 12.1 }, "male-singer": { id: "male-singer", name: "Man Singer", keywords: ["male", "rockstar", "entertainer", "human"], skins: [{ unified: "1f468-200d-1f3a4", native: "\u{1F468}\u200D\u{1F3A4}" }, { unified: "1f468-1f3fb-200d-1f3a4", native: "\u{1F468}\u{1F3FB}\u200D\u{1F3A4}" }, { unified: "1f468-1f3fc-200d-1f3a4", native: "\u{1F468}\u{1F3FC}\u200D\u{1F3A4}" }, { unified: "1f468-1f3fd-200d-1f3a4", native: "\u{1F468}\u{1F3FD}\u200D\u{1F3A4}" }, { unified: "1f468-1f3fe-200d-1f3a4", native: "\u{1F468}\u{1F3FE}\u200D\u{1F3A4}" }, { unified: "1f468-1f3ff-200d-1f3a4", native: "\u{1F468}\u{1F3FF}\u200D\u{1F3A4}" }], version: 4 }, "female-singer": { id: "female-singer", name: "Woman Singer", keywords: ["female", "rockstar", "entertainer", "human"], skins: [{ unified: "1f469-200d-1f3a4", native: "\u{1F469}\u200D\u{1F3A4}" }, { unified: "1f469-1f3fb-200d-1f3a4", native: "\u{1F469}\u{1F3FB}\u200D\u{1F3A4}" }, { unified: "1f469-1f3fc-200d-1f3a4", native: "\u{1F469}\u{1F3FC}\u200D\u{1F3A4}" }, { unified: "1f469-1f3fd-200d-1f3a4", native: "\u{1F469}\u{1F3FD}\u200D\u{1F3A4}" }, { unified: "1f469-1f3fe-200d-1f3a4", native: "\u{1F469}\u{1F3FE}\u200D\u{1F3A4}" }, { unified: "1f469-1f3ff-200d-1f3a4", native: "\u{1F469}\u{1F3FF}\u200D\u{1F3A4}" }], version: 4 }, artist: { id: "artist", name: "Artist", keywords: ["painting", "draw", "creativity"], skins: [{ unified: "1f9d1-200d-1f3a8", native: "\u{1F9D1}\u200D\u{1F3A8}" }, { unified: "1f9d1-1f3fb-200d-1f3a8", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F3A8}" }, { unified: "1f9d1-1f3fc-200d-1f3a8", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F3A8}" }, { unified: "1f9d1-1f3fd-200d-1f3a8", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F3A8}" }, { unified: "1f9d1-1f3fe-200d-1f3a8", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F3A8}" }, { unified: "1f9d1-1f3ff-200d-1f3a8", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F3A8}" }], version: 12.1 }, "male-artist": { id: "male-artist", name: "Man Artist", keywords: ["male", "painter", "human"], skins: [{ unified: "1f468-200d-1f3a8", native: "\u{1F468}\u200D\u{1F3A8}" }, { unified: "1f468-1f3fb-200d-1f3a8", native: "\u{1F468}\u{1F3FB}\u200D\u{1F3A8}" }, { unified: "1f468-1f3fc-200d-1f3a8", native: "\u{1F468}\u{1F3FC}\u200D\u{1F3A8}" }, { unified: "1f468-1f3fd-200d-1f3a8", native: "\u{1F468}\u{1F3FD}\u200D\u{1F3A8}" }, { unified: "1f468-1f3fe-200d-1f3a8", native: "\u{1F468}\u{1F3FE}\u200D\u{1F3A8}" }, { unified: "1f468-1f3ff-200d-1f3a8", native: "\u{1F468}\u{1F3FF}\u200D\u{1F3A8}" }], version: 4 }, "female-artist": { id: "female-artist", name: "Woman Artist", keywords: ["female", "painter", "human"], skins: [{ unified: "1f469-200d-1f3a8", native: "\u{1F469}\u200D\u{1F3A8}" }, { unified: "1f469-1f3fb-200d-1f3a8", native: "\u{1F469}\u{1F3FB}\u200D\u{1F3A8}" }, { unified: "1f469-1f3fc-200d-1f3a8", native: "\u{1F469}\u{1F3FC}\u200D\u{1F3A8}" }, { unified: "1f469-1f3fd-200d-1f3a8", native: "\u{1F469}\u{1F3FD}\u200D\u{1F3A8}" }, { unified: "1f469-1f3fe-200d-1f3a8", native: "\u{1F469}\u{1F3FE}\u200D\u{1F3A8}" }, { unified: "1f469-1f3ff-200d-1f3a8", native: "\u{1F469}\u{1F3FF}\u200D\u{1F3A8}" }], version: 4 }, pilot: { id: "pilot", name: "Pilot", keywords: ["fly", "plane", "airplane"], skins: [{ unified: "1f9d1-200d-2708-fe0f", native: "\u{1F9D1}\u200D\u2708\uFE0F" }, { unified: "1f9d1-1f3fb-200d-2708-fe0f", native: "\u{1F9D1}\u{1F3FB}\u200D\u2708\uFE0F" }, { unified: "1f9d1-1f3fc-200d-2708-fe0f", native: "\u{1F9D1}\u{1F3FC}\u200D\u2708\uFE0F" }, { unified: "1f9d1-1f3fd-200d-2708-fe0f", native: "\u{1F9D1}\u{1F3FD}\u200D\u2708\uFE0F" }, { unified: "1f9d1-1f3fe-200d-2708-fe0f", native: "\u{1F9D1}\u{1F3FE}\u200D\u2708\uFE0F" }, { unified: "1f9d1-1f3ff-200d-2708-fe0f", native: "\u{1F9D1}\u{1F3FF}\u200D\u2708\uFE0F" }], version: 12.1 }, "male-pilot": { id: "male-pilot", name: "Man Pilot", keywords: ["male", "aviator", "plane", "human"], skins: [{ unified: "1f468-200d-2708-fe0f", native: "\u{1F468}\u200D\u2708\uFE0F" }, { unified: "1f468-1f3fb-200d-2708-fe0f", native: "\u{1F468}\u{1F3FB}\u200D\u2708\uFE0F" }, { unified: "1f468-1f3fc-200d-2708-fe0f", native: "\u{1F468}\u{1F3FC}\u200D\u2708\uFE0F" }, { unified: "1f468-1f3fd-200d-2708-fe0f", native: "\u{1F468}\u{1F3FD}\u200D\u2708\uFE0F" }, { unified: "1f468-1f3fe-200d-2708-fe0f", native: "\u{1F468}\u{1F3FE}\u200D\u2708\uFE0F" }, { unified: "1f468-1f3ff-200d-2708-fe0f", native: "\u{1F468}\u{1F3FF}\u200D\u2708\uFE0F" }], version: 4 }, "female-pilot": { id: "female-pilot", name: "Woman Pilot", keywords: ["female", "aviator", "plane", "human"], skins: [{ unified: "1f469-200d-2708-fe0f", native: "\u{1F469}\u200D\u2708\uFE0F" }, { unified: "1f469-1f3fb-200d-2708-fe0f", native: "\u{1F469}\u{1F3FB}\u200D\u2708\uFE0F" }, { unified: "1f469-1f3fc-200d-2708-fe0f", native: "\u{1F469}\u{1F3FC}\u200D\u2708\uFE0F" }, { unified: "1f469-1f3fd-200d-2708-fe0f", native: "\u{1F469}\u{1F3FD}\u200D\u2708\uFE0F" }, { unified: "1f469-1f3fe-200d-2708-fe0f", native: "\u{1F469}\u{1F3FE}\u200D\u2708\uFE0F" }, { unified: "1f469-1f3ff-200d-2708-fe0f", native: "\u{1F469}\u{1F3FF}\u200D\u2708\uFE0F" }], version: 4 }, astronaut: { id: "astronaut", name: "Astronaut", keywords: ["outerspace"], skins: [{ unified: "1f9d1-200d-1f680", native: "\u{1F9D1}\u200D\u{1F680}" }, { unified: "1f9d1-1f3fb-200d-1f680", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F680}" }, { unified: "1f9d1-1f3fc-200d-1f680", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F680}" }, { unified: "1f9d1-1f3fd-200d-1f680", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F680}" }, { unified: "1f9d1-1f3fe-200d-1f680", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F680}" }, { unified: "1f9d1-1f3ff-200d-1f680", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F680}" }], version: 12.1 }, "male-astronaut": { id: "male-astronaut", name: "Man Astronaut", keywords: ["male", "space", "rocket", "human"], skins: [{ unified: "1f468-200d-1f680", native: "\u{1F468}\u200D\u{1F680}" }, { unified: "1f468-1f3fb-200d-1f680", native: "\u{1F468}\u{1F3FB}\u200D\u{1F680}" }, { unified: "1f468-1f3fc-200d-1f680", native: "\u{1F468}\u{1F3FC}\u200D\u{1F680}" }, { unified: "1f468-1f3fd-200d-1f680", native: "\u{1F468}\u{1F3FD}\u200D\u{1F680}" }, { unified: "1f468-1f3fe-200d-1f680", native: "\u{1F468}\u{1F3FE}\u200D\u{1F680}" }, { unified: "1f468-1f3ff-200d-1f680", native: "\u{1F468}\u{1F3FF}\u200D\u{1F680}" }], version: 4 }, "female-astronaut": { id: "female-astronaut", name: "Woman Astronaut", keywords: ["female", "space", "rocket", "human"], skins: [{ unified: "1f469-200d-1f680", native: "\u{1F469}\u200D\u{1F680}" }, { unified: "1f469-1f3fb-200d-1f680", native: "\u{1F469}\u{1F3FB}\u200D\u{1F680}" }, { unified: "1f469-1f3fc-200d-1f680", native: "\u{1F469}\u{1F3FC}\u200D\u{1F680}" }, { unified: "1f469-1f3fd-200d-1f680", native: "\u{1F469}\u{1F3FD}\u200D\u{1F680}" }, { unified: "1f469-1f3fe-200d-1f680", native: "\u{1F469}\u{1F3FE}\u200D\u{1F680}" }, { unified: "1f469-1f3ff-200d-1f680", native: "\u{1F469}\u{1F3FF}\u200D\u{1F680}" }], version: 4 }, firefighter: { id: "firefighter", name: "Firefighter", keywords: ["fire"], skins: [{ unified: "1f9d1-200d-1f692", native: "\u{1F9D1}\u200D\u{1F692}" }, { unified: "1f9d1-1f3fb-200d-1f692", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F692}" }, { unified: "1f9d1-1f3fc-200d-1f692", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F692}" }, { unified: "1f9d1-1f3fd-200d-1f692", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F692}" }, { unified: "1f9d1-1f3fe-200d-1f692", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F692}" }, { unified: "1f9d1-1f3ff-200d-1f692", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F692}" }], version: 12.1 }, "male-firefighter": { id: "male-firefighter", name: "Man Firefighter", keywords: ["male", "fireman", "human"], skins: [{ unified: "1f468-200d-1f692", native: "\u{1F468}\u200D\u{1F692}" }, { unified: "1f468-1f3fb-200d-1f692", native: "\u{1F468}\u{1F3FB}\u200D\u{1F692}" }, { unified: "1f468-1f3fc-200d-1f692", native: "\u{1F468}\u{1F3FC}\u200D\u{1F692}" }, { unified: "1f468-1f3fd-200d-1f692", native: "\u{1F468}\u{1F3FD}\u200D\u{1F692}" }, { unified: "1f468-1f3fe-200d-1f692", native: "\u{1F468}\u{1F3FE}\u200D\u{1F692}" }, { unified: "1f468-1f3ff-200d-1f692", native: "\u{1F468}\u{1F3FF}\u200D\u{1F692}" }], version: 4 }, "female-firefighter": { id: "female-firefighter", name: "Woman Firefighter", keywords: ["female", "fireman", "human"], skins: [{ unified: "1f469-200d-1f692", native: "\u{1F469}\u200D\u{1F692}" }, { unified: "1f469-1f3fb-200d-1f692", native: "\u{1F469}\u{1F3FB}\u200D\u{1F692}" }, { unified: "1f469-1f3fc-200d-1f692", native: "\u{1F469}\u{1F3FC}\u200D\u{1F692}" }, { unified: "1f469-1f3fd-200d-1f692", native: "\u{1F469}\u{1F3FD}\u200D\u{1F692}" }, { unified: "1f469-1f3fe-200d-1f692", native: "\u{1F469}\u{1F3FE}\u200D\u{1F692}" }, { unified: "1f469-1f3ff-200d-1f692", native: "\u{1F469}\u{1F3FF}\u200D\u{1F692}" }], version: 4 }, cop: { id: "cop", name: "Police Officer", keywords: ["cop"], skins: [{ unified: "1f46e", native: "\u{1F46E}" }, { unified: "1f46e-1f3fb", native: "\u{1F46E}\u{1F3FB}" }, { unified: "1f46e-1f3fc", native: "\u{1F46E}\u{1F3FC}" }, { unified: "1f46e-1f3fd", native: "\u{1F46E}\u{1F3FD}" }, { unified: "1f46e-1f3fe", native: "\u{1F46E}\u{1F3FE}" }, { unified: "1f46e-1f3ff", native: "\u{1F46E}\u{1F3FF}" }], version: 1 }, "male-police-officer": { id: "male-police-officer", name: "Man Police Officer", keywords: ["male", "police-officer", "law", "legal", "enforcement", "arrest", "911"], skins: [{ unified: "1f46e-200d-2642-fe0f", native: "\u{1F46E}\u200D\u2642\uFE0F" }, { unified: "1f46e-1f3fb-200d-2642-fe0f", native: "\u{1F46E}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f46e-1f3fc-200d-2642-fe0f", native: "\u{1F46E}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f46e-1f3fd-200d-2642-fe0f", native: "\u{1F46E}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f46e-1f3fe-200d-2642-fe0f", native: "\u{1F46E}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f46e-1f3ff-200d-2642-fe0f", native: "\u{1F46E}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "female-police-officer": { id: "female-police-officer", name: "Woman Police Officer", keywords: ["female", "police-officer", "law", "legal", "enforcement", "arrest", "911"], skins: [{ unified: "1f46e-200d-2640-fe0f", native: "\u{1F46E}\u200D\u2640\uFE0F" }, { unified: "1f46e-1f3fb-200d-2640-fe0f", native: "\u{1F46E}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f46e-1f3fc-200d-2640-fe0f", native: "\u{1F46E}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f46e-1f3fd-200d-2640-fe0f", native: "\u{1F46E}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f46e-1f3fe-200d-2640-fe0f", native: "\u{1F46E}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f46e-1f3ff-200d-2640-fe0f", native: "\u{1F46E}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, sleuth_or_spy: { id: "sleuth_or_spy", name: "Detective", keywords: ["sleuth", "or", "spy", "human"], skins: [{ unified: "1f575-fe0f", native: "\u{1F575}\uFE0F" }, { unified: "1f575-1f3fb", native: "\u{1F575}\u{1F3FB}" }, { unified: "1f575-1f3fc", native: "\u{1F575}\u{1F3FC}" }, { unified: "1f575-1f3fd", native: "\u{1F575}\u{1F3FD}" }, { unified: "1f575-1f3fe", native: "\u{1F575}\u{1F3FE}" }, { unified: "1f575-1f3ff", native: "\u{1F575}\u{1F3FF}" }], version: 1 }, "male-detective": { id: "male-detective", name: "Man Detective", keywords: ["male", "crime"], skins: [{ unified: "1f575-fe0f-200d-2642-fe0f", native: "\u{1F575}\uFE0F\u200D\u2642\uFE0F" }, { unified: "1f575-1f3fb-200d-2642-fe0f", native: "\u{1F575}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f575-1f3fc-200d-2642-fe0f", native: "\u{1F575}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f575-1f3fd-200d-2642-fe0f", native: "\u{1F575}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f575-1f3fe-200d-2642-fe0f", native: "\u{1F575}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f575-1f3ff-200d-2642-fe0f", native: "\u{1F575}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "female-detective": { id: "female-detective", name: "Woman Detective", keywords: ["female", "human", "spy"], skins: [{ unified: "1f575-fe0f-200d-2640-fe0f", native: "\u{1F575}\uFE0F\u200D\u2640\uFE0F" }, { unified: "1f575-1f3fb-200d-2640-fe0f", native: "\u{1F575}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f575-1f3fc-200d-2640-fe0f", native: "\u{1F575}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f575-1f3fd-200d-2640-fe0f", native: "\u{1F575}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f575-1f3fe-200d-2640-fe0f", native: "\u{1F575}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f575-1f3ff-200d-2640-fe0f", native: "\u{1F575}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, guardsman: { id: "guardsman", name: "Guard", keywords: ["guardsman", "protect"], skins: [{ unified: "1f482", native: "\u{1F482}" }, { unified: "1f482-1f3fb", native: "\u{1F482}\u{1F3FB}" }, { unified: "1f482-1f3fc", native: "\u{1F482}\u{1F3FC}" }, { unified: "1f482-1f3fd", native: "\u{1F482}\u{1F3FD}" }, { unified: "1f482-1f3fe", native: "\u{1F482}\u{1F3FE}" }, { unified: "1f482-1f3ff", native: "\u{1F482}\u{1F3FF}" }], version: 1 }, "male-guard": { id: "male-guard", name: "Man Guard", keywords: ["male", "uk", "gb", "british", "guy", "royal"], skins: [{ unified: "1f482-200d-2642-fe0f", native: "\u{1F482}\u200D\u2642\uFE0F" }, { unified: "1f482-1f3fb-200d-2642-fe0f", native: "\u{1F482}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f482-1f3fc-200d-2642-fe0f", native: "\u{1F482}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f482-1f3fd-200d-2642-fe0f", native: "\u{1F482}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f482-1f3fe-200d-2642-fe0f", native: "\u{1F482}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f482-1f3ff-200d-2642-fe0f", native: "\u{1F482}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "female-guard": { id: "female-guard", name: "Woman Guard", keywords: ["female", "uk", "gb", "british", "royal"], skins: [{ unified: "1f482-200d-2640-fe0f", native: "\u{1F482}\u200D\u2640\uFE0F" }, { unified: "1f482-1f3fb-200d-2640-fe0f", native: "\u{1F482}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f482-1f3fc-200d-2640-fe0f", native: "\u{1F482}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f482-1f3fd-200d-2640-fe0f", native: "\u{1F482}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f482-1f3fe-200d-2640-fe0f", native: "\u{1F482}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f482-1f3ff-200d-2640-fe0f", native: "\u{1F482}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, ninja: { id: "ninja", name: "Ninja", keywords: ["ninjutsu", "skills", "japanese"], skins: [{ unified: "1f977", native: "\u{1F977}" }, { unified: "1f977-1f3fb", native: "\u{1F977}\u{1F3FB}" }, { unified: "1f977-1f3fc", native: "\u{1F977}\u{1F3FC}" }, { unified: "1f977-1f3fd", native: "\u{1F977}\u{1F3FD}" }, { unified: "1f977-1f3fe", native: "\u{1F977}\u{1F3FE}" }, { unified: "1f977-1f3ff", native: "\u{1F977}\u{1F3FF}" }], version: 13 }, construction_worker: { id: "construction_worker", name: "Construction Worker", keywords: ["labor", "build"], skins: [{ unified: "1f477", native: "\u{1F477}" }, { unified: "1f477-1f3fb", native: "\u{1F477}\u{1F3FB}" }, { unified: "1f477-1f3fc", native: "\u{1F477}\u{1F3FC}" }, { unified: "1f477-1f3fd", native: "\u{1F477}\u{1F3FD}" }, { unified: "1f477-1f3fe", native: "\u{1F477}\u{1F3FE}" }, { unified: "1f477-1f3ff", native: "\u{1F477}\u{1F3FF}" }], version: 1 }, "male-construction-worker": { id: "male-construction-worker", name: "Man Construction Worker", keywords: ["male", "construction-worker", "human", "wip", "guy", "build", "labor"], skins: [{ unified: "1f477-200d-2642-fe0f", native: "\u{1F477}\u200D\u2642\uFE0F" }, { unified: "1f477-1f3fb-200d-2642-fe0f", native: "\u{1F477}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f477-1f3fc-200d-2642-fe0f", native: "\u{1F477}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f477-1f3fd-200d-2642-fe0f", native: "\u{1F477}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f477-1f3fe-200d-2642-fe0f", native: "\u{1F477}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f477-1f3ff-200d-2642-fe0f", native: "\u{1F477}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "female-construction-worker": { id: "female-construction-worker", name: "Woman Construction Worker", keywords: ["female", "construction-worker", "human", "wip", "build", "labor"], skins: [{ unified: "1f477-200d-2640-fe0f", native: "\u{1F477}\u200D\u2640\uFE0F" }, { unified: "1f477-1f3fb-200d-2640-fe0f", native: "\u{1F477}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f477-1f3fc-200d-2640-fe0f", native: "\u{1F477}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f477-1f3fd-200d-2640-fe0f", native: "\u{1F477}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f477-1f3fe-200d-2640-fe0f", native: "\u{1F477}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f477-1f3ff-200d-2640-fe0f", native: "\u{1F477}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, person_with_crown: { id: "person_with_crown", name: "Person with Crown", keywords: ["royalty", "power"], skins: [{ unified: "1fac5", native: "\u{1FAC5}" }, { unified: "1fac5-1f3fb", native: "\u{1FAC5}\u{1F3FB}" }, { unified: "1fac5-1f3fc", native: "\u{1FAC5}\u{1F3FC}" }, { unified: "1fac5-1f3fd", native: "\u{1FAC5}\u{1F3FD}" }, { unified: "1fac5-1f3fe", native: "\u{1FAC5}\u{1F3FE}" }, { unified: "1fac5-1f3ff", native: "\u{1FAC5}\u{1F3FF}" }], version: 14 }, prince: { id: "prince", name: "Prince", keywords: ["boy", "man", "male", "crown", "royal", "king"], skins: [{ unified: "1f934", native: "\u{1F934}" }, { unified: "1f934-1f3fb", native: "\u{1F934}\u{1F3FB}" }, { unified: "1f934-1f3fc", native: "\u{1F934}\u{1F3FC}" }, { unified: "1f934-1f3fd", native: "\u{1F934}\u{1F3FD}" }, { unified: "1f934-1f3fe", native: "\u{1F934}\u{1F3FE}" }, { unified: "1f934-1f3ff", native: "\u{1F934}\u{1F3FF}" }], version: 3 }, princess: { id: "princess", name: "Princess", keywords: ["girl", "woman", "female", "blond", "crown", "royal", "queen"], skins: [{ unified: "1f478", native: "\u{1F478}" }, { unified: "1f478-1f3fb", native: "\u{1F478}\u{1F3FB}" }, { unified: "1f478-1f3fc", native: "\u{1F478}\u{1F3FC}" }, { unified: "1f478-1f3fd", native: "\u{1F478}\u{1F3FD}" }, { unified: "1f478-1f3fe", native: "\u{1F478}\u{1F3FE}" }, { unified: "1f478-1f3ff", native: "\u{1F478}\u{1F3FF}" }], version: 1 }, man_with_turban: { id: "man_with_turban", name: "Man with Turban", keywords: ["person", "wearing", "headdress"], skins: [{ unified: "1f473", native: "\u{1F473}" }, { unified: "1f473-1f3fb", native: "\u{1F473}\u{1F3FB}" }, { unified: "1f473-1f3fc", native: "\u{1F473}\u{1F3FC}" }, { unified: "1f473-1f3fd", native: "\u{1F473}\u{1F3FD}" }, { unified: "1f473-1f3fe", native: "\u{1F473}\u{1F3FE}" }, { unified: "1f473-1f3ff", native: "\u{1F473}\u{1F3FF}" }], version: 1 }, "man-wearing-turban": { id: "man-wearing-turban", name: "Man Wearing Turban", keywords: ["wearing-turban", "male", "indian", "hinduism", "arabs"], skins: [{ unified: "1f473-200d-2642-fe0f", native: "\u{1F473}\u200D\u2642\uFE0F" }, { unified: "1f473-1f3fb-200d-2642-fe0f", native: "\u{1F473}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f473-1f3fc-200d-2642-fe0f", native: "\u{1F473}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f473-1f3fd-200d-2642-fe0f", native: "\u{1F473}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f473-1f3fe-200d-2642-fe0f", native: "\u{1F473}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f473-1f3ff-200d-2642-fe0f", native: "\u{1F473}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-wearing-turban": { id: "woman-wearing-turban", name: "Woman Wearing Turban", keywords: ["wearing-turban", "female", "indian", "hinduism", "arabs"], skins: [{ unified: "1f473-200d-2640-fe0f", native: "\u{1F473}\u200D\u2640\uFE0F" }, { unified: "1f473-1f3fb-200d-2640-fe0f", native: "\u{1F473}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f473-1f3fc-200d-2640-fe0f", native: "\u{1F473}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f473-1f3fd-200d-2640-fe0f", native: "\u{1F473}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f473-1f3fe-200d-2640-fe0f", native: "\u{1F473}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f473-1f3ff-200d-2640-fe0f", native: "\u{1F473}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, man_with_gua_pi_mao: { id: "man_with_gua_pi_mao", name: "Man with Gua Pi Mao", keywords: ["skullcap", "male", "boy", "chinese"], skins: [{ unified: "1f472", native: "\u{1F472}" }, { unified: "1f472-1f3fb", native: "\u{1F472}\u{1F3FB}" }, { unified: "1f472-1f3fc", native: "\u{1F472}\u{1F3FC}" }, { unified: "1f472-1f3fd", native: "\u{1F472}\u{1F3FD}" }, { unified: "1f472-1f3fe", native: "\u{1F472}\u{1F3FE}" }, { unified: "1f472-1f3ff", native: "\u{1F472}\u{1F3FF}" }], version: 1 }, person_with_headscarf: { id: "person_with_headscarf", name: "Woman with Headscarf", keywords: ["person", "female", "hijab", "mantilla", "tichel"], skins: [{ unified: "1f9d5", native: "\u{1F9D5}" }, { unified: "1f9d5-1f3fb", native: "\u{1F9D5}\u{1F3FB}" }, { unified: "1f9d5-1f3fc", native: "\u{1F9D5}\u{1F3FC}" }, { unified: "1f9d5-1f3fd", native: "\u{1F9D5}\u{1F3FD}" }, { unified: "1f9d5-1f3fe", native: "\u{1F9D5}\u{1F3FE}" }, { unified: "1f9d5-1f3ff", native: "\u{1F9D5}\u{1F3FF}" }], version: 5 }, person_in_tuxedo: { id: "person_in_tuxedo", name: "Man in Tuxedo", keywords: ["person", "couple", "marriage", "wedding", "groom"], skins: [{ unified: "1f935", native: "\u{1F935}" }, { unified: "1f935-1f3fb", native: "\u{1F935}\u{1F3FB}" }, { unified: "1f935-1f3fc", native: "\u{1F935}\u{1F3FC}" }, { unified: "1f935-1f3fd", native: "\u{1F935}\u{1F3FD}" }, { unified: "1f935-1f3fe", native: "\u{1F935}\u{1F3FE}" }, { unified: "1f935-1f3ff", native: "\u{1F935}\u{1F3FF}" }], version: 3 }, man_in_tuxedo: { id: "man_in_tuxedo", name: "Man in Tuxedo", keywords: ["formal", "fashion"], skins: [{ unified: "1f935-200d-2642-fe0f", native: "\u{1F935}\u200D\u2642\uFE0F" }, { unified: "1f935-1f3fb-200d-2642-fe0f", native: "\u{1F935}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f935-1f3fc-200d-2642-fe0f", native: "\u{1F935}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f935-1f3fd-200d-2642-fe0f", native: "\u{1F935}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f935-1f3fe-200d-2642-fe0f", native: "\u{1F935}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f935-1f3ff-200d-2642-fe0f", native: "\u{1F935}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 13 }, woman_in_tuxedo: { id: "woman_in_tuxedo", name: "Woman in Tuxedo", keywords: ["formal", "fashion"], skins: [{ unified: "1f935-200d-2640-fe0f", native: "\u{1F935}\u200D\u2640\uFE0F" }, { unified: "1f935-1f3fb-200d-2640-fe0f", native: "\u{1F935}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f935-1f3fc-200d-2640-fe0f", native: "\u{1F935}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f935-1f3fd-200d-2640-fe0f", native: "\u{1F935}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f935-1f3fe-200d-2640-fe0f", native: "\u{1F935}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f935-1f3ff-200d-2640-fe0f", native: "\u{1F935}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 13 }, bride_with_veil: { id: "bride_with_veil", name: "Bride with Veil", keywords: ["couple", "marriage", "wedding", "woman"], skins: [{ unified: "1f470", native: "\u{1F470}" }, { unified: "1f470-1f3fb", native: "\u{1F470}\u{1F3FB}" }, { unified: "1f470-1f3fc", native: "\u{1F470}\u{1F3FC}" }, { unified: "1f470-1f3fd", native: "\u{1F470}\u{1F3FD}" }, { unified: "1f470-1f3fe", native: "\u{1F470}\u{1F3FE}" }, { unified: "1f470-1f3ff", native: "\u{1F470}\u{1F3FF}" }], version: 1 }, man_with_veil: { id: "man_with_veil", name: "Man with Veil", keywords: ["wedding", "marriage"], skins: [{ unified: "1f470-200d-2642-fe0f", native: "\u{1F470}\u200D\u2642\uFE0F" }, { unified: "1f470-1f3fb-200d-2642-fe0f", native: "\u{1F470}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f470-1f3fc-200d-2642-fe0f", native: "\u{1F470}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f470-1f3fd-200d-2642-fe0f", native: "\u{1F470}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f470-1f3fe-200d-2642-fe0f", native: "\u{1F470}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f470-1f3ff-200d-2642-fe0f", native: "\u{1F470}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 13 }, woman_with_veil: { id: "woman_with_veil", name: "Woman with Veil", keywords: ["wedding", "marriage"], skins: [{ unified: "1f470-200d-2640-fe0f", native: "\u{1F470}\u200D\u2640\uFE0F" }, { unified: "1f470-1f3fb-200d-2640-fe0f", native: "\u{1F470}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f470-1f3fc-200d-2640-fe0f", native: "\u{1F470}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f470-1f3fd-200d-2640-fe0f", native: "\u{1F470}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f470-1f3fe-200d-2640-fe0f", native: "\u{1F470}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f470-1f3ff-200d-2640-fe0f", native: "\u{1F470}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 13 }, pregnant_woman: { id: "pregnant_woman", name: "Pregnant Woman", keywords: ["baby"], skins: [{ unified: "1f930", native: "\u{1F930}" }, { unified: "1f930-1f3fb", native: "\u{1F930}\u{1F3FB}" }, { unified: "1f930-1f3fc", native: "\u{1F930}\u{1F3FC}" }, { unified: "1f930-1f3fd", native: "\u{1F930}\u{1F3FD}" }, { unified: "1f930-1f3fe", native: "\u{1F930}\u{1F3FE}" }, { unified: "1f930-1f3ff", native: "\u{1F930}\u{1F3FF}" }], version: 3 }, pregnant_man: { id: "pregnant_man", name: "Pregnant Man", keywords: ["baby", "belly"], skins: [{ unified: "1fac3", native: "\u{1FAC3}" }, { unified: "1fac3-1f3fb", native: "\u{1FAC3}\u{1F3FB}" }, { unified: "1fac3-1f3fc", native: "\u{1FAC3}\u{1F3FC}" }, { unified: "1fac3-1f3fd", native: "\u{1FAC3}\u{1F3FD}" }, { unified: "1fac3-1f3fe", native: "\u{1FAC3}\u{1F3FE}" }, { unified: "1fac3-1f3ff", native: "\u{1FAC3}\u{1F3FF}" }], version: 14 }, pregnant_person: { id: "pregnant_person", name: "Pregnant Person", keywords: ["baby", "belly"], skins: [{ unified: "1fac4", native: "\u{1FAC4}" }, { unified: "1fac4-1f3fb", native: "\u{1FAC4}\u{1F3FB}" }, { unified: "1fac4-1f3fc", native: "\u{1FAC4}\u{1F3FC}" }, { unified: "1fac4-1f3fd", native: "\u{1FAC4}\u{1F3FD}" }, { unified: "1fac4-1f3fe", native: "\u{1FAC4}\u{1F3FE}" }, { unified: "1fac4-1f3ff", native: "\u{1FAC4}\u{1F3FF}" }], version: 14 }, "breast-feeding": { id: "breast-feeding", name: "Breast-Feeding", keywords: ["breast", "feeding", "nursing", "baby"], skins: [{ unified: "1f931", native: "\u{1F931}" }, { unified: "1f931-1f3fb", native: "\u{1F931}\u{1F3FB}" }, { unified: "1f931-1f3fc", native: "\u{1F931}\u{1F3FC}" }, { unified: "1f931-1f3fd", native: "\u{1F931}\u{1F3FD}" }, { unified: "1f931-1f3fe", native: "\u{1F931}\u{1F3FE}" }, { unified: "1f931-1f3ff", native: "\u{1F931}\u{1F3FF}" }], version: 5 }, woman_feeding_baby: { id: "woman_feeding_baby", name: "Woman Feeding Baby", keywords: ["birth", "food"], skins: [{ unified: "1f469-200d-1f37c", native: "\u{1F469}\u200D\u{1F37C}" }, { unified: "1f469-1f3fb-200d-1f37c", native: "\u{1F469}\u{1F3FB}\u200D\u{1F37C}" }, { unified: "1f469-1f3fc-200d-1f37c", native: "\u{1F469}\u{1F3FC}\u200D\u{1F37C}" }, { unified: "1f469-1f3fd-200d-1f37c", native: "\u{1F469}\u{1F3FD}\u200D\u{1F37C}" }, { unified: "1f469-1f3fe-200d-1f37c", native: "\u{1F469}\u{1F3FE}\u200D\u{1F37C}" }, { unified: "1f469-1f3ff-200d-1f37c", native: "\u{1F469}\u{1F3FF}\u200D\u{1F37C}" }], version: 13 }, man_feeding_baby: { id: "man_feeding_baby", name: "Man Feeding Baby", keywords: ["birth", "food"], skins: [{ unified: "1f468-200d-1f37c", native: "\u{1F468}\u200D\u{1F37C}" }, { unified: "1f468-1f3fb-200d-1f37c", native: "\u{1F468}\u{1F3FB}\u200D\u{1F37C}" }, { unified: "1f468-1f3fc-200d-1f37c", native: "\u{1F468}\u{1F3FC}\u200D\u{1F37C}" }, { unified: "1f468-1f3fd-200d-1f37c", native: "\u{1F468}\u{1F3FD}\u200D\u{1F37C}" }, { unified: "1f468-1f3fe-200d-1f37c", native: "\u{1F468}\u{1F3FE}\u200D\u{1F37C}" }, { unified: "1f468-1f3ff-200d-1f37c", native: "\u{1F468}\u{1F3FF}\u200D\u{1F37C}" }], version: 13 }, person_feeding_baby: { id: "person_feeding_baby", name: "Person Feeding Baby", keywords: ["birth", "food"], skins: [{ unified: "1f9d1-200d-1f37c", native: "\u{1F9D1}\u200D\u{1F37C}" }, { unified: "1f9d1-1f3fb-200d-1f37c", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F37C}" }, { unified: "1f9d1-1f3fc-200d-1f37c", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F37C}" }, { unified: "1f9d1-1f3fd-200d-1f37c", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F37C}" }, { unified: "1f9d1-1f3fe-200d-1f37c", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F37C}" }, { unified: "1f9d1-1f3ff-200d-1f37c", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F37C}" }], version: 13 }, angel: { id: "angel", name: "Baby Angel", keywords: ["heaven", "wings", "halo"], skins: [{ unified: "1f47c", native: "\u{1F47C}" }, { unified: "1f47c-1f3fb", native: "\u{1F47C}\u{1F3FB}" }, { unified: "1f47c-1f3fc", native: "\u{1F47C}\u{1F3FC}" }, { unified: "1f47c-1f3fd", native: "\u{1F47C}\u{1F3FD}" }, { unified: "1f47c-1f3fe", native: "\u{1F47C}\u{1F3FE}" }, { unified: "1f47c-1f3ff", native: "\u{1F47C}\u{1F3FF}" }], version: 1 }, santa: { id: "santa", name: "Santa Claus", keywords: ["festival", "man", "male", "xmas", "father", "christmas"], skins: [{ unified: "1f385", native: "\u{1F385}" }, { unified: "1f385-1f3fb", native: "\u{1F385}\u{1F3FB}" }, { unified: "1f385-1f3fc", native: "\u{1F385}\u{1F3FC}" }, { unified: "1f385-1f3fd", native: "\u{1F385}\u{1F3FD}" }, { unified: "1f385-1f3fe", native: "\u{1F385}\u{1F3FE}" }, { unified: "1f385-1f3ff", native: "\u{1F385}\u{1F3FF}" }], version: 1 }, mrs_claus: { id: "mrs_claus", name: "Mrs. Claus", keywords: ["mrs", "mother", "christmas", "woman", "female", "xmas"], skins: [{ unified: "1f936", native: "\u{1F936}" }, { unified: "1f936-1f3fb", native: "\u{1F936}\u{1F3FB}" }, { unified: "1f936-1f3fc", native: "\u{1F936}\u{1F3FC}" }, { unified: "1f936-1f3fd", native: "\u{1F936}\u{1F3FD}" }, { unified: "1f936-1f3fe", native: "\u{1F936}\u{1F3FE}" }, { unified: "1f936-1f3ff", native: "\u{1F936}\u{1F3FF}" }], version: 3 }, mx_claus: { id: "mx_claus", name: "Mx Claus", keywords: ["christmas"], skins: [{ unified: "1f9d1-200d-1f384", native: "\u{1F9D1}\u200D\u{1F384}" }, { unified: "1f9d1-1f3fb-200d-1f384", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F384}" }, { unified: "1f9d1-1f3fc-200d-1f384", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F384}" }, { unified: "1f9d1-1f3fd-200d-1f384", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F384}" }, { unified: "1f9d1-1f3fe-200d-1f384", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F384}" }, { unified: "1f9d1-1f3ff-200d-1f384", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F384}" }], version: 13 }, superhero: { id: "superhero", name: "Superhero", keywords: ["marvel"], skins: [{ unified: "1f9b8", native: "\u{1F9B8}" }, { unified: "1f9b8-1f3fb", native: "\u{1F9B8}\u{1F3FB}" }, { unified: "1f9b8-1f3fc", native: "\u{1F9B8}\u{1F3FC}" }, { unified: "1f9b8-1f3fd", native: "\u{1F9B8}\u{1F3FD}" }, { unified: "1f9b8-1f3fe", native: "\u{1F9B8}\u{1F3FE}" }, { unified: "1f9b8-1f3ff", native: "\u{1F9B8}\u{1F3FF}" }], version: 11 }, male_superhero: { id: "male_superhero", name: "Man Superhero", keywords: ["male", "good", "hero", "superpowers"], skins: [{ unified: "1f9b8-200d-2642-fe0f", native: "\u{1F9B8}\u200D\u2642\uFE0F" }, { unified: "1f9b8-1f3fb-200d-2642-fe0f", native: "\u{1F9B8}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9b8-1f3fc-200d-2642-fe0f", native: "\u{1F9B8}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9b8-1f3fd-200d-2642-fe0f", native: "\u{1F9B8}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9b8-1f3fe-200d-2642-fe0f", native: "\u{1F9B8}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9b8-1f3ff-200d-2642-fe0f", native: "\u{1F9B8}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 11 }, female_superhero: { id: "female_superhero", name: "Woman Superhero", keywords: ["female", "good", "heroine", "superpowers"], skins: [{ unified: "1f9b8-200d-2640-fe0f", native: "\u{1F9B8}\u200D\u2640\uFE0F" }, { unified: "1f9b8-1f3fb-200d-2640-fe0f", native: "\u{1F9B8}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9b8-1f3fc-200d-2640-fe0f", native: "\u{1F9B8}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9b8-1f3fd-200d-2640-fe0f", native: "\u{1F9B8}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9b8-1f3fe-200d-2640-fe0f", native: "\u{1F9B8}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9b8-1f3ff-200d-2640-fe0f", native: "\u{1F9B8}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 11 }, supervillain: { id: "supervillain", name: "Supervillain", keywords: ["marvel"], skins: [{ unified: "1f9b9", native: "\u{1F9B9}" }, { unified: "1f9b9-1f3fb", native: "\u{1F9B9}\u{1F3FB}" }, { unified: "1f9b9-1f3fc", native: "\u{1F9B9}\u{1F3FC}" }, { unified: "1f9b9-1f3fd", native: "\u{1F9B9}\u{1F3FD}" }, { unified: "1f9b9-1f3fe", native: "\u{1F9B9}\u{1F3FE}" }, { unified: "1f9b9-1f3ff", native: "\u{1F9B9}\u{1F3FF}" }], version: 11 }, male_supervillain: { id: "male_supervillain", name: "Man Supervillain", keywords: ["male", "evil", "bad", "criminal", "hero", "superpowers"], skins: [{ unified: "1f9b9-200d-2642-fe0f", native: "\u{1F9B9}\u200D\u2642\uFE0F" }, { unified: "1f9b9-1f3fb-200d-2642-fe0f", native: "\u{1F9B9}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9b9-1f3fc-200d-2642-fe0f", native: "\u{1F9B9}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9b9-1f3fd-200d-2642-fe0f", native: "\u{1F9B9}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9b9-1f3fe-200d-2642-fe0f", native: "\u{1F9B9}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9b9-1f3ff-200d-2642-fe0f", native: "\u{1F9B9}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 11 }, female_supervillain: { id: "female_supervillain", name: "Woman Supervillain", keywords: ["female", "evil", "bad", "criminal", "heroine", "superpowers"], skins: [{ unified: "1f9b9-200d-2640-fe0f", native: "\u{1F9B9}\u200D\u2640\uFE0F" }, { unified: "1f9b9-1f3fb-200d-2640-fe0f", native: "\u{1F9B9}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9b9-1f3fc-200d-2640-fe0f", native: "\u{1F9B9}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9b9-1f3fd-200d-2640-fe0f", native: "\u{1F9B9}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9b9-1f3fe-200d-2640-fe0f", native: "\u{1F9B9}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9b9-1f3ff-200d-2640-fe0f", native: "\u{1F9B9}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 11 }, mage: { id: "mage", name: "Mage", keywords: ["magic"], skins: [{ unified: "1f9d9", native: "\u{1F9D9}" }, { unified: "1f9d9-1f3fb", native: "\u{1F9D9}\u{1F3FB}" }, { unified: "1f9d9-1f3fc", native: "\u{1F9D9}\u{1F3FC}" }, { unified: "1f9d9-1f3fd", native: "\u{1F9D9}\u{1F3FD}" }, { unified: "1f9d9-1f3fe", native: "\u{1F9D9}\u{1F3FE}" }, { unified: "1f9d9-1f3ff", native: "\u{1F9D9}\u{1F3FF}" }], version: 5 }, male_mage: { id: "male_mage", name: "Man Mage", keywords: ["male", "sorcerer"], skins: [{ unified: "1f9d9-200d-2642-fe0f", native: "\u{1F9D9}\u200D\u2642\uFE0F" }, { unified: "1f9d9-1f3fb-200d-2642-fe0f", native: "\u{1F9D9}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9d9-1f3fc-200d-2642-fe0f", native: "\u{1F9D9}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9d9-1f3fd-200d-2642-fe0f", native: "\u{1F9D9}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9d9-1f3fe-200d-2642-fe0f", native: "\u{1F9D9}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9d9-1f3ff-200d-2642-fe0f", native: "\u{1F9D9}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 5 }, female_mage: { id: "female_mage", name: "Woman Mage", keywords: ["female", "witch"], skins: [{ unified: "1f9d9-200d-2640-fe0f", native: "\u{1F9D9}\u200D\u2640\uFE0F" }, { unified: "1f9d9-1f3fb-200d-2640-fe0f", native: "\u{1F9D9}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9d9-1f3fc-200d-2640-fe0f", native: "\u{1F9D9}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9d9-1f3fd-200d-2640-fe0f", native: "\u{1F9D9}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9d9-1f3fe-200d-2640-fe0f", native: "\u{1F9D9}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9d9-1f3ff-200d-2640-fe0f", native: "\u{1F9D9}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 5 }, fairy: { id: "fairy", name: "Fairy", keywords: ["wings", "magical"], skins: [{ unified: "1f9da", native: "\u{1F9DA}" }, { unified: "1f9da-1f3fb", native: "\u{1F9DA}\u{1F3FB}" }, { unified: "1f9da-1f3fc", native: "\u{1F9DA}\u{1F3FC}" }, { unified: "1f9da-1f3fd", native: "\u{1F9DA}\u{1F3FD}" }, { unified: "1f9da-1f3fe", native: "\u{1F9DA}\u{1F3FE}" }, { unified: "1f9da-1f3ff", native: "\u{1F9DA}\u{1F3FF}" }], version: 5 }, male_fairy: { id: "male_fairy", name: "Man Fairy", keywords: ["male"], skins: [{ unified: "1f9da-200d-2642-fe0f", native: "\u{1F9DA}\u200D\u2642\uFE0F" }, { unified: "1f9da-1f3fb-200d-2642-fe0f", native: "\u{1F9DA}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9da-1f3fc-200d-2642-fe0f", native: "\u{1F9DA}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9da-1f3fd-200d-2642-fe0f", native: "\u{1F9DA}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9da-1f3fe-200d-2642-fe0f", native: "\u{1F9DA}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9da-1f3ff-200d-2642-fe0f", native: "\u{1F9DA}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 5 }, female_fairy: { id: "female_fairy", name: "Woman Fairy", keywords: ["female"], skins: [{ unified: "1f9da-200d-2640-fe0f", native: "\u{1F9DA}\u200D\u2640\uFE0F" }, { unified: "1f9da-1f3fb-200d-2640-fe0f", native: "\u{1F9DA}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9da-1f3fc-200d-2640-fe0f", native: "\u{1F9DA}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9da-1f3fd-200d-2640-fe0f", native: "\u{1F9DA}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9da-1f3fe-200d-2640-fe0f", native: "\u{1F9DA}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9da-1f3ff-200d-2640-fe0f", native: "\u{1F9DA}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 5 }, vampire: { id: "vampire", name: "Vampire", keywords: ["blood", "twilight"], skins: [{ unified: "1f9db", native: "\u{1F9DB}" }, { unified: "1f9db-1f3fb", native: "\u{1F9DB}\u{1F3FB}" }, { unified: "1f9db-1f3fc", native: "\u{1F9DB}\u{1F3FC}" }, { unified: "1f9db-1f3fd", native: "\u{1F9DB}\u{1F3FD}" }, { unified: "1f9db-1f3fe", native: "\u{1F9DB}\u{1F3FE}" }, { unified: "1f9db-1f3ff", native: "\u{1F9DB}\u{1F3FF}" }], version: 5 }, male_vampire: { id: "male_vampire", name: "Man Vampire", keywords: ["male", "dracula"], skins: [{ unified: "1f9db-200d-2642-fe0f", native: "\u{1F9DB}\u200D\u2642\uFE0F" }, { unified: "1f9db-1f3fb-200d-2642-fe0f", native: "\u{1F9DB}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9db-1f3fc-200d-2642-fe0f", native: "\u{1F9DB}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9db-1f3fd-200d-2642-fe0f", native: "\u{1F9DB}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9db-1f3fe-200d-2642-fe0f", native: "\u{1F9DB}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9db-1f3ff-200d-2642-fe0f", native: "\u{1F9DB}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 5 }, female_vampire: { id: "female_vampire", name: "Woman Vampire", keywords: ["female"], skins: [{ unified: "1f9db-200d-2640-fe0f", native: "\u{1F9DB}\u200D\u2640\uFE0F" }, { unified: "1f9db-1f3fb-200d-2640-fe0f", native: "\u{1F9DB}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9db-1f3fc-200d-2640-fe0f", native: "\u{1F9DB}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9db-1f3fd-200d-2640-fe0f", native: "\u{1F9DB}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9db-1f3fe-200d-2640-fe0f", native: "\u{1F9DB}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9db-1f3ff-200d-2640-fe0f", native: "\u{1F9DB}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 5 }, merperson: { id: "merperson", name: "Merperson", keywords: ["sea"], skins: [{ unified: "1f9dc", native: "\u{1F9DC}" }, { unified: "1f9dc-1f3fb", native: "\u{1F9DC}\u{1F3FB}" }, { unified: "1f9dc-1f3fc", native: "\u{1F9DC}\u{1F3FC}" }, { unified: "1f9dc-1f3fd", native: "\u{1F9DC}\u{1F3FD}" }, { unified: "1f9dc-1f3fe", native: "\u{1F9DC}\u{1F3FE}" }, { unified: "1f9dc-1f3ff", native: "\u{1F9DC}\u{1F3FF}" }], version: 5 }, merman: { id: "merman", name: "Merman", keywords: ["man", "male", "triton"], skins: [{ unified: "1f9dc-200d-2642-fe0f", native: "\u{1F9DC}\u200D\u2642\uFE0F" }, { unified: "1f9dc-1f3fb-200d-2642-fe0f", native: "\u{1F9DC}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9dc-1f3fc-200d-2642-fe0f", native: "\u{1F9DC}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9dc-1f3fd-200d-2642-fe0f", native: "\u{1F9DC}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9dc-1f3fe-200d-2642-fe0f", native: "\u{1F9DC}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9dc-1f3ff-200d-2642-fe0f", native: "\u{1F9DC}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 5 }, mermaid: { id: "mermaid", name: "Mermaid", keywords: ["woman", "female", "merwoman", "ariel"], skins: [{ unified: "1f9dc-200d-2640-fe0f", native: "\u{1F9DC}\u200D\u2640\uFE0F" }, { unified: "1f9dc-1f3fb-200d-2640-fe0f", native: "\u{1F9DC}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9dc-1f3fc-200d-2640-fe0f", native: "\u{1F9DC}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9dc-1f3fd-200d-2640-fe0f", native: "\u{1F9DC}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9dc-1f3fe-200d-2640-fe0f", native: "\u{1F9DC}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9dc-1f3ff-200d-2640-fe0f", native: "\u{1F9DC}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 5 }, elf: { id: "elf", name: "Elf", keywords: ["magical"], skins: [{ unified: "1f9dd", native: "\u{1F9DD}" }, { unified: "1f9dd-1f3fb", native: "\u{1F9DD}\u{1F3FB}" }, { unified: "1f9dd-1f3fc", native: "\u{1F9DD}\u{1F3FC}" }, { unified: "1f9dd-1f3fd", native: "\u{1F9DD}\u{1F3FD}" }, { unified: "1f9dd-1f3fe", native: "\u{1F9DD}\u{1F3FE}" }, { unified: "1f9dd-1f3ff", native: "\u{1F9DD}\u{1F3FF}" }], version: 5 }, male_elf: { id: "male_elf", name: "Man Elf", keywords: ["male"], skins: [{ unified: "1f9dd-200d-2642-fe0f", native: "\u{1F9DD}\u200D\u2642\uFE0F" }, { unified: "1f9dd-1f3fb-200d-2642-fe0f", native: "\u{1F9DD}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9dd-1f3fc-200d-2642-fe0f", native: "\u{1F9DD}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9dd-1f3fd-200d-2642-fe0f", native: "\u{1F9DD}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9dd-1f3fe-200d-2642-fe0f", native: "\u{1F9DD}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9dd-1f3ff-200d-2642-fe0f", native: "\u{1F9DD}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 5 }, female_elf: { id: "female_elf", name: "Woman Elf", keywords: ["female"], skins: [{ unified: "1f9dd-200d-2640-fe0f", native: "\u{1F9DD}\u200D\u2640\uFE0F" }, { unified: "1f9dd-1f3fb-200d-2640-fe0f", native: "\u{1F9DD}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9dd-1f3fc-200d-2640-fe0f", native: "\u{1F9DD}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9dd-1f3fd-200d-2640-fe0f", native: "\u{1F9DD}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9dd-1f3fe-200d-2640-fe0f", native: "\u{1F9DD}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9dd-1f3ff-200d-2640-fe0f", native: "\u{1F9DD}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 5 }, genie: { id: "genie", name: "Genie", keywords: ["magical", "wishes"], skins: [{ unified: "1f9de", native: "\u{1F9DE}" }], version: 5 }, male_genie: { id: "male_genie", name: "Man Genie", keywords: ["male"], skins: [{ unified: "1f9de-200d-2642-fe0f", native: "\u{1F9DE}\u200D\u2642\uFE0F" }], version: 5 }, female_genie: { id: "female_genie", name: "Woman Genie", keywords: ["female"], skins: [{ unified: "1f9de-200d-2640-fe0f", native: "\u{1F9DE}\u200D\u2640\uFE0F" }], version: 5 }, zombie: { id: "zombie", name: "Zombie", keywords: ["dead"], skins: [{ unified: "1f9df", native: "\u{1F9DF}" }], version: 5 }, male_zombie: { id: "male_zombie", name: "Man Zombie", keywords: ["male", "dracula", "undead", "walking", "dead"], skins: [{ unified: "1f9df-200d-2642-fe0f", native: "\u{1F9DF}\u200D\u2642\uFE0F" }], version: 5 }, female_zombie: { id: "female_zombie", name: "Woman Zombie", keywords: ["female", "undead", "walking", "dead"], skins: [{ unified: "1f9df-200d-2640-fe0f", native: "\u{1F9DF}\u200D\u2640\uFE0F" }], version: 5 }, troll: { id: "troll", name: "Troll", keywords: ["mystical", "monster"], skins: [{ unified: "1f9cc", native: "\u{1F9CC}" }], version: 14 }, massage: { id: "massage", name: "Face Massage", keywords: ["person", "getting", "relax"], skins: [{ unified: "1f486", native: "\u{1F486}" }, { unified: "1f486-1f3fb", native: "\u{1F486}\u{1F3FB}" }, { unified: "1f486-1f3fc", native: "\u{1F486}\u{1F3FC}" }, { unified: "1f486-1f3fd", native: "\u{1F486}\u{1F3FD}" }, { unified: "1f486-1f3fe", native: "\u{1F486}\u{1F3FE}" }, { unified: "1f486-1f3ff", native: "\u{1F486}\u{1F3FF}" }], version: 1 }, "man-getting-massage": { id: "man-getting-massage", name: "Man Getting Massage", keywords: ["getting-massage", "male", "boy", "head"], skins: [{ unified: "1f486-200d-2642-fe0f", native: "\u{1F486}\u200D\u2642\uFE0F" }, { unified: "1f486-1f3fb-200d-2642-fe0f", native: "\u{1F486}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f486-1f3fc-200d-2642-fe0f", native: "\u{1F486}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f486-1f3fd-200d-2642-fe0f", native: "\u{1F486}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f486-1f3fe-200d-2642-fe0f", native: "\u{1F486}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f486-1f3ff-200d-2642-fe0f", native: "\u{1F486}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-getting-massage": { id: "woman-getting-massage", name: "Woman Getting Massage", keywords: ["getting-massage", "female", "girl", "head"], skins: [{ unified: "1f486-200d-2640-fe0f", native: "\u{1F486}\u200D\u2640\uFE0F" }, { unified: "1f486-1f3fb-200d-2640-fe0f", native: "\u{1F486}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f486-1f3fc-200d-2640-fe0f", native: "\u{1F486}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f486-1f3fd-200d-2640-fe0f", native: "\u{1F486}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f486-1f3fe-200d-2640-fe0f", native: "\u{1F486}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f486-1f3ff-200d-2640-fe0f", native: "\u{1F486}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, haircut: { id: "haircut", name: "Haircut", keywords: ["person", "getting", "hairstyle"], skins: [{ unified: "1f487", native: "\u{1F487}" }, { unified: "1f487-1f3fb", native: "\u{1F487}\u{1F3FB}" }, { unified: "1f487-1f3fc", native: "\u{1F487}\u{1F3FC}" }, { unified: "1f487-1f3fd", native: "\u{1F487}\u{1F3FD}" }, { unified: "1f487-1f3fe", native: "\u{1F487}\u{1F3FE}" }, { unified: "1f487-1f3ff", native: "\u{1F487}\u{1F3FF}" }], version: 1 }, "man-getting-haircut": { id: "man-getting-haircut", name: "Man Getting Haircut", keywords: ["getting-haircut", "male", "boy"], skins: [{ unified: "1f487-200d-2642-fe0f", native: "\u{1F487}\u200D\u2642\uFE0F" }, { unified: "1f487-1f3fb-200d-2642-fe0f", native: "\u{1F487}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f487-1f3fc-200d-2642-fe0f", native: "\u{1F487}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f487-1f3fd-200d-2642-fe0f", native: "\u{1F487}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f487-1f3fe-200d-2642-fe0f", native: "\u{1F487}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f487-1f3ff-200d-2642-fe0f", native: "\u{1F487}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-getting-haircut": { id: "woman-getting-haircut", name: "Woman Getting Haircut", keywords: ["getting-haircut", "female", "girl"], skins: [{ unified: "1f487-200d-2640-fe0f", native: "\u{1F487}\u200D\u2640\uFE0F" }, { unified: "1f487-1f3fb-200d-2640-fe0f", native: "\u{1F487}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f487-1f3fc-200d-2640-fe0f", native: "\u{1F487}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f487-1f3fd-200d-2640-fe0f", native: "\u{1F487}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f487-1f3fe-200d-2640-fe0f", native: "\u{1F487}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f487-1f3ff-200d-2640-fe0f", native: "\u{1F487}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, walking: { id: "walking", name: "Pedestrian", keywords: ["walking", "person", "move"], skins: [{ unified: "1f6b6", native: "\u{1F6B6}" }, { unified: "1f6b6-1f3fb", native: "\u{1F6B6}\u{1F3FB}" }, { unified: "1f6b6-1f3fc", native: "\u{1F6B6}\u{1F3FC}" }, { unified: "1f6b6-1f3fd", native: "\u{1F6B6}\u{1F3FD}" }, { unified: "1f6b6-1f3fe", native: "\u{1F6B6}\u{1F3FE}" }, { unified: "1f6b6-1f3ff", native: "\u{1F6B6}\u{1F3FF}" }], version: 1 }, "man-walking": { id: "man-walking", name: "Man Walking", keywords: ["human", "feet", "steps"], skins: [{ unified: "1f6b6-200d-2642-fe0f", native: "\u{1F6B6}\u200D\u2642\uFE0F" }, { unified: "1f6b6-1f3fb-200d-2642-fe0f", native: "\u{1F6B6}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f6b6-1f3fc-200d-2642-fe0f", native: "\u{1F6B6}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f6b6-1f3fd-200d-2642-fe0f", native: "\u{1F6B6}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f6b6-1f3fe-200d-2642-fe0f", native: "\u{1F6B6}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f6b6-1f3ff-200d-2642-fe0f", native: "\u{1F6B6}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-walking": { id: "woman-walking", name: "Woman Walking", keywords: ["human", "feet", "steps", "female"], skins: [{ unified: "1f6b6-200d-2640-fe0f", native: "\u{1F6B6}\u200D\u2640\uFE0F" }, { unified: "1f6b6-1f3fb-200d-2640-fe0f", native: "\u{1F6B6}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f6b6-1f3fc-200d-2640-fe0f", native: "\u{1F6B6}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f6b6-1f3fd-200d-2640-fe0f", native: "\u{1F6B6}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f6b6-1f3fe-200d-2640-fe0f", native: "\u{1F6B6}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f6b6-1f3ff-200d-2640-fe0f", native: "\u{1F6B6}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, standing_person: { id: "standing_person", name: "Standing Person", keywords: ["still"], skins: [{ unified: "1f9cd", native: "\u{1F9CD}" }, { unified: "1f9cd-1f3fb", native: "\u{1F9CD}\u{1F3FB}" }, { unified: "1f9cd-1f3fc", native: "\u{1F9CD}\u{1F3FC}" }, { unified: "1f9cd-1f3fd", native: "\u{1F9CD}\u{1F3FD}" }, { unified: "1f9cd-1f3fe", native: "\u{1F9CD}\u{1F3FE}" }, { unified: "1f9cd-1f3ff", native: "\u{1F9CD}\u{1F3FF}" }], version: 12 }, man_standing: { id: "man_standing", name: "Man Standing", keywords: ["still"], skins: [{ unified: "1f9cd-200d-2642-fe0f", native: "\u{1F9CD}\u200D\u2642\uFE0F" }, { unified: "1f9cd-1f3fb-200d-2642-fe0f", native: "\u{1F9CD}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9cd-1f3fc-200d-2642-fe0f", native: "\u{1F9CD}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9cd-1f3fd-200d-2642-fe0f", native: "\u{1F9CD}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9cd-1f3fe-200d-2642-fe0f", native: "\u{1F9CD}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9cd-1f3ff-200d-2642-fe0f", native: "\u{1F9CD}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 12 }, woman_standing: { id: "woman_standing", name: "Woman Standing", keywords: ["still"], skins: [{ unified: "1f9cd-200d-2640-fe0f", native: "\u{1F9CD}\u200D\u2640\uFE0F" }, { unified: "1f9cd-1f3fb-200d-2640-fe0f", native: "\u{1F9CD}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9cd-1f3fc-200d-2640-fe0f", native: "\u{1F9CD}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9cd-1f3fd-200d-2640-fe0f", native: "\u{1F9CD}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9cd-1f3fe-200d-2640-fe0f", native: "\u{1F9CD}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9cd-1f3ff-200d-2640-fe0f", native: "\u{1F9CD}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 12 }, kneeling_person: { id: "kneeling_person", name: "Kneeling Person", keywords: ["pray", "respectful"], skins: [{ unified: "1f9ce", native: "\u{1F9CE}" }, { unified: "1f9ce-1f3fb", native: "\u{1F9CE}\u{1F3FB}" }, { unified: "1f9ce-1f3fc", native: "\u{1F9CE}\u{1F3FC}" }, { unified: "1f9ce-1f3fd", native: "\u{1F9CE}\u{1F3FD}" }, { unified: "1f9ce-1f3fe", native: "\u{1F9CE}\u{1F3FE}" }, { unified: "1f9ce-1f3ff", native: "\u{1F9CE}\u{1F3FF}" }], version: 12 }, man_kneeling: { id: "man_kneeling", name: "Man Kneeling", keywords: ["pray", "respectful"], skins: [{ unified: "1f9ce-200d-2642-fe0f", native: "\u{1F9CE}\u200D\u2642\uFE0F" }, { unified: "1f9ce-1f3fb-200d-2642-fe0f", native: "\u{1F9CE}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9ce-1f3fc-200d-2642-fe0f", native: "\u{1F9CE}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9ce-1f3fd-200d-2642-fe0f", native: "\u{1F9CE}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9ce-1f3fe-200d-2642-fe0f", native: "\u{1F9CE}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9ce-1f3ff-200d-2642-fe0f", native: "\u{1F9CE}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 12 }, woman_kneeling: { id: "woman_kneeling", name: "Woman Kneeling", keywords: ["respectful", "pray"], skins: [{ unified: "1f9ce-200d-2640-fe0f", native: "\u{1F9CE}\u200D\u2640\uFE0F" }, { unified: "1f9ce-1f3fb-200d-2640-fe0f", native: "\u{1F9CE}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9ce-1f3fc-200d-2640-fe0f", native: "\u{1F9CE}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9ce-1f3fd-200d-2640-fe0f", native: "\u{1F9CE}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9ce-1f3fe-200d-2640-fe0f", native: "\u{1F9CE}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9ce-1f3ff-200d-2640-fe0f", native: "\u{1F9CE}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 12 }, person_with_probing_cane: { id: "person_with_probing_cane", name: "Person with White Cane", keywords: ["probing", "blind"], skins: [{ unified: "1f9d1-200d-1f9af", native: "\u{1F9D1}\u200D\u{1F9AF}" }, { unified: "1f9d1-1f3fb-200d-1f9af", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F9AF}" }, { unified: "1f9d1-1f3fc-200d-1f9af", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F9AF}" }, { unified: "1f9d1-1f3fd-200d-1f9af", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F9AF}" }, { unified: "1f9d1-1f3fe-200d-1f9af", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F9AF}" }, { unified: "1f9d1-1f3ff-200d-1f9af", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F9AF}" }], version: 12.1 }, man_with_probing_cane: { id: "man_with_probing_cane", name: "Man with White Cane", keywords: ["probing", "blind"], skins: [{ unified: "1f468-200d-1f9af", native: "\u{1F468}\u200D\u{1F9AF}" }, { unified: "1f468-1f3fb-200d-1f9af", native: "\u{1F468}\u{1F3FB}\u200D\u{1F9AF}" }, { unified: "1f468-1f3fc-200d-1f9af", native: "\u{1F468}\u{1F3FC}\u200D\u{1F9AF}" }, { unified: "1f468-1f3fd-200d-1f9af", native: "\u{1F468}\u{1F3FD}\u200D\u{1F9AF}" }, { unified: "1f468-1f3fe-200d-1f9af", native: "\u{1F468}\u{1F3FE}\u200D\u{1F9AF}" }, { unified: "1f468-1f3ff-200d-1f9af", native: "\u{1F468}\u{1F3FF}\u200D\u{1F9AF}" }], version: 12 }, woman_with_probing_cane: { id: "woman_with_probing_cane", name: "Woman with White Cane", keywords: ["probing", "blind"], skins: [{ unified: "1f469-200d-1f9af", native: "\u{1F469}\u200D\u{1F9AF}" }, { unified: "1f469-1f3fb-200d-1f9af", native: "\u{1F469}\u{1F3FB}\u200D\u{1F9AF}" }, { unified: "1f469-1f3fc-200d-1f9af", native: "\u{1F469}\u{1F3FC}\u200D\u{1F9AF}" }, { unified: "1f469-1f3fd-200d-1f9af", native: "\u{1F469}\u{1F3FD}\u200D\u{1F9AF}" }, { unified: "1f469-1f3fe-200d-1f9af", native: "\u{1F469}\u{1F3FE}\u200D\u{1F9AF}" }, { unified: "1f469-1f3ff-200d-1f9af", native: "\u{1F469}\u{1F3FF}\u200D\u{1F9AF}" }], version: 12 }, person_in_motorized_wheelchair: { id: "person_in_motorized_wheelchair", name: "Person in Motorized Wheelchair", keywords: ["disability", "accessibility"], skins: [{ unified: "1f9d1-200d-1f9bc", native: "\u{1F9D1}\u200D\u{1F9BC}" }, { unified: "1f9d1-1f3fb-200d-1f9bc", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F9BC}" }, { unified: "1f9d1-1f3fc-200d-1f9bc", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F9BC}" }, { unified: "1f9d1-1f3fd-200d-1f9bc", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F9BC}" }, { unified: "1f9d1-1f3fe-200d-1f9bc", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F9BC}" }, { unified: "1f9d1-1f3ff-200d-1f9bc", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F9BC}" }], version: 12.1 }, man_in_motorized_wheelchair: { id: "man_in_motorized_wheelchair", name: "Man in Motorized Wheelchair", keywords: ["disability", "accessibility"], skins: [{ unified: "1f468-200d-1f9bc", native: "\u{1F468}\u200D\u{1F9BC}" }, { unified: "1f468-1f3fb-200d-1f9bc", native: "\u{1F468}\u{1F3FB}\u200D\u{1F9BC}" }, { unified: "1f468-1f3fc-200d-1f9bc", native: "\u{1F468}\u{1F3FC}\u200D\u{1F9BC}" }, { unified: "1f468-1f3fd-200d-1f9bc", native: "\u{1F468}\u{1F3FD}\u200D\u{1F9BC}" }, { unified: "1f468-1f3fe-200d-1f9bc", native: "\u{1F468}\u{1F3FE}\u200D\u{1F9BC}" }, { unified: "1f468-1f3ff-200d-1f9bc", native: "\u{1F468}\u{1F3FF}\u200D\u{1F9BC}" }], version: 12 }, woman_in_motorized_wheelchair: { id: "woman_in_motorized_wheelchair", name: "Woman in Motorized Wheelchair", keywords: ["disability", "accessibility"], skins: [{ unified: "1f469-200d-1f9bc", native: "\u{1F469}\u200D\u{1F9BC}" }, { unified: "1f469-1f3fb-200d-1f9bc", native: "\u{1F469}\u{1F3FB}\u200D\u{1F9BC}" }, { unified: "1f469-1f3fc-200d-1f9bc", native: "\u{1F469}\u{1F3FC}\u200D\u{1F9BC}" }, { unified: "1f469-1f3fd-200d-1f9bc", native: "\u{1F469}\u{1F3FD}\u200D\u{1F9BC}" }, { unified: "1f469-1f3fe-200d-1f9bc", native: "\u{1F469}\u{1F3FE}\u200D\u{1F9BC}" }, { unified: "1f469-1f3ff-200d-1f9bc", native: "\u{1F469}\u{1F3FF}\u200D\u{1F9BC}" }], version: 12 }, person_in_manual_wheelchair: { id: "person_in_manual_wheelchair", name: "Person in Manual Wheelchair", keywords: ["disability", "accessibility"], skins: [{ unified: "1f9d1-200d-1f9bd", native: "\u{1F9D1}\u200D\u{1F9BD}" }, { unified: "1f9d1-1f3fb-200d-1f9bd", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F9BD}" }, { unified: "1f9d1-1f3fc-200d-1f9bd", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F9BD}" }, { unified: "1f9d1-1f3fd-200d-1f9bd", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F9BD}" }, { unified: "1f9d1-1f3fe-200d-1f9bd", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F9BD}" }, { unified: "1f9d1-1f3ff-200d-1f9bd", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F9BD}" }], version: 12.1 }, man_in_manual_wheelchair: { id: "man_in_manual_wheelchair", name: "Man in Manual Wheelchair", keywords: ["disability", "accessibility"], skins: [{ unified: "1f468-200d-1f9bd", native: "\u{1F468}\u200D\u{1F9BD}" }, { unified: "1f468-1f3fb-200d-1f9bd", native: "\u{1F468}\u{1F3FB}\u200D\u{1F9BD}" }, { unified: "1f468-1f3fc-200d-1f9bd", native: "\u{1F468}\u{1F3FC}\u200D\u{1F9BD}" }, { unified: "1f468-1f3fd-200d-1f9bd", native: "\u{1F468}\u{1F3FD}\u200D\u{1F9BD}" }, { unified: "1f468-1f3fe-200d-1f9bd", native: "\u{1F468}\u{1F3FE}\u200D\u{1F9BD}" }, { unified: "1f468-1f3ff-200d-1f9bd", native: "\u{1F468}\u{1F3FF}\u200D\u{1F9BD}" }], version: 12 }, woman_in_manual_wheelchair: { id: "woman_in_manual_wheelchair", name: "Woman in Manual Wheelchair", keywords: ["disability", "accessibility"], skins: [{ unified: "1f469-200d-1f9bd", native: "\u{1F469}\u200D\u{1F9BD}" }, { unified: "1f469-1f3fb-200d-1f9bd", native: "\u{1F469}\u{1F3FB}\u200D\u{1F9BD}" }, { unified: "1f469-1f3fc-200d-1f9bd", native: "\u{1F469}\u{1F3FC}\u200D\u{1F9BD}" }, { unified: "1f469-1f3fd-200d-1f9bd", native: "\u{1F469}\u{1F3FD}\u200D\u{1F9BD}" }, { unified: "1f469-1f3fe-200d-1f9bd", native: "\u{1F469}\u{1F3FE}\u200D\u{1F9BD}" }, { unified: "1f469-1f3ff-200d-1f9bd", native: "\u{1F469}\u{1F3FF}\u200D\u{1F9BD}" }], version: 12 }, runner: { id: "runner", name: "Runner", keywords: ["running", "person", "move"], skins: [{ unified: "1f3c3", native: "\u{1F3C3}" }, { unified: "1f3c3-1f3fb", native: "\u{1F3C3}\u{1F3FB}" }, { unified: "1f3c3-1f3fc", native: "\u{1F3C3}\u{1F3FC}" }, { unified: "1f3c3-1f3fd", native: "\u{1F3C3}\u{1F3FD}" }, { unified: "1f3c3-1f3fe", native: "\u{1F3C3}\u{1F3FE}" }, { unified: "1f3c3-1f3ff", native: "\u{1F3C3}\u{1F3FF}" }], version: 1 }, "man-running": { id: "man-running", name: "Man Running", keywords: ["walking", "exercise", "race"], skins: [{ unified: "1f3c3-200d-2642-fe0f", native: "\u{1F3C3}\u200D\u2642\uFE0F" }, { unified: "1f3c3-1f3fb-200d-2642-fe0f", native: "\u{1F3C3}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f3c3-1f3fc-200d-2642-fe0f", native: "\u{1F3C3}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f3c3-1f3fd-200d-2642-fe0f", native: "\u{1F3C3}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f3c3-1f3fe-200d-2642-fe0f", native: "\u{1F3C3}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f3c3-1f3ff-200d-2642-fe0f", native: "\u{1F3C3}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-running": { id: "woman-running", name: "Woman Running", keywords: ["walking", "exercise", "race", "female"], skins: [{ unified: "1f3c3-200d-2640-fe0f", native: "\u{1F3C3}\u200D\u2640\uFE0F" }, { unified: "1f3c3-1f3fb-200d-2640-fe0f", native: "\u{1F3C3}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f3c3-1f3fc-200d-2640-fe0f", native: "\u{1F3C3}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f3c3-1f3fd-200d-2640-fe0f", native: "\u{1F3C3}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f3c3-1f3fe-200d-2640-fe0f", native: "\u{1F3C3}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f3c3-1f3ff-200d-2640-fe0f", native: "\u{1F3C3}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, dancer: { id: "dancer", name: "Dancer", keywords: ["woman", "dancing", "female", "girl", "fun"], skins: [{ unified: "1f483", native: "\u{1F483}" }, { unified: "1f483-1f3fb", native: "\u{1F483}\u{1F3FB}" }, { unified: "1f483-1f3fc", native: "\u{1F483}\u{1F3FC}" }, { unified: "1f483-1f3fd", native: "\u{1F483}\u{1F3FD}" }, { unified: "1f483-1f3fe", native: "\u{1F483}\u{1F3FE}" }, { unified: "1f483-1f3ff", native: "\u{1F483}\u{1F3FF}" }], version: 1 }, man_dancing: { id: "man_dancing", name: "Man Dancing", keywords: ["male", "boy", "fun", "dancer"], skins: [{ unified: "1f57a", native: "\u{1F57A}" }, { unified: "1f57a-1f3fb", native: "\u{1F57A}\u{1F3FB}" }, { unified: "1f57a-1f3fc", native: "\u{1F57A}\u{1F3FC}" }, { unified: "1f57a-1f3fd", native: "\u{1F57A}\u{1F3FD}" }, { unified: "1f57a-1f3fe", native: "\u{1F57A}\u{1F3FE}" }, { unified: "1f57a-1f3ff", native: "\u{1F57A}\u{1F3FF}" }], version: 3 }, man_in_business_suit_levitating: { id: "man_in_business_suit_levitating", name: "Person in Suit Levitating", keywords: ["man", "business", "levitate", "hover", "jump"], skins: [{ unified: "1f574-fe0f", native: "\u{1F574}\uFE0F" }, { unified: "1f574-1f3fb", native: "\u{1F574}\u{1F3FB}" }, { unified: "1f574-1f3fc", native: "\u{1F574}\u{1F3FC}" }, { unified: "1f574-1f3fd", native: "\u{1F574}\u{1F3FD}" }, { unified: "1f574-1f3fe", native: "\u{1F574}\u{1F3FE}" }, { unified: "1f574-1f3ff", native: "\u{1F574}\u{1F3FF}" }], version: 1 }, dancers: { id: "dancers", name: "Woman with Bunny Ears", keywords: ["dancers", "people", "perform", "costume"], skins: [{ unified: "1f46f", native: "\u{1F46F}" }], version: 1 }, "men-with-bunny-ears-partying": { id: "men-with-bunny-ears-partying", name: "Men with Bunny Ears", keywords: ["with-bunny-ears-partying", "man", "male", "boys"], skins: [{ unified: "1f46f-200d-2642-fe0f", native: "\u{1F46F}\u200D\u2642\uFE0F" }], version: 4 }, "women-with-bunny-ears-partying": { id: "women-with-bunny-ears-partying", name: "Women with Bunny Ears", keywords: ["with-bunny-ears-partying", "woman", "female", "girls"], skins: [{ unified: "1f46f-200d-2640-fe0f", native: "\u{1F46F}\u200D\u2640\uFE0F" }], version: 4 }, person_in_steamy_room: { id: "person_in_steamy_room", name: "Person in Steamy Room", keywords: ["relax", "spa"], skins: [{ unified: "1f9d6", native: "\u{1F9D6}" }, { unified: "1f9d6-1f3fb", native: "\u{1F9D6}\u{1F3FB}" }, { unified: "1f9d6-1f3fc", native: "\u{1F9D6}\u{1F3FC}" }, { unified: "1f9d6-1f3fd", native: "\u{1F9D6}\u{1F3FD}" }, { unified: "1f9d6-1f3fe", native: "\u{1F9D6}\u{1F3FE}" }, { unified: "1f9d6-1f3ff", native: "\u{1F9D6}\u{1F3FF}" }], version: 5 }, man_in_steamy_room: { id: "man_in_steamy_room", name: "Man in Steamy Room", keywords: ["male", "spa", "steamroom", "sauna"], skins: [{ unified: "1f9d6-200d-2642-fe0f", native: "\u{1F9D6}\u200D\u2642\uFE0F" }, { unified: "1f9d6-1f3fb-200d-2642-fe0f", native: "\u{1F9D6}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9d6-1f3fc-200d-2642-fe0f", native: "\u{1F9D6}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9d6-1f3fd-200d-2642-fe0f", native: "\u{1F9D6}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9d6-1f3fe-200d-2642-fe0f", native: "\u{1F9D6}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9d6-1f3ff-200d-2642-fe0f", native: "\u{1F9D6}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 5 }, woman_in_steamy_room: { id: "woman_in_steamy_room", name: "Woman in Steamy Room", keywords: ["female", "spa", "steamroom", "sauna"], skins: [{ unified: "1f9d6-200d-2640-fe0f", native: "\u{1F9D6}\u200D\u2640\uFE0F" }, { unified: "1f9d6-1f3fb-200d-2640-fe0f", native: "\u{1F9D6}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9d6-1f3fc-200d-2640-fe0f", native: "\u{1F9D6}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9d6-1f3fd-200d-2640-fe0f", native: "\u{1F9D6}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9d6-1f3fe-200d-2640-fe0f", native: "\u{1F9D6}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9d6-1f3ff-200d-2640-fe0f", native: "\u{1F9D6}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 5 }, person_climbing: { id: "person_climbing", name: "Person Climbing", keywords: ["sport"], skins: [{ unified: "1f9d7", native: "\u{1F9D7}" }, { unified: "1f9d7-1f3fb", native: "\u{1F9D7}\u{1F3FB}" }, { unified: "1f9d7-1f3fc", native: "\u{1F9D7}\u{1F3FC}" }, { unified: "1f9d7-1f3fd", native: "\u{1F9D7}\u{1F3FD}" }, { unified: "1f9d7-1f3fe", native: "\u{1F9D7}\u{1F3FE}" }, { unified: "1f9d7-1f3ff", native: "\u{1F9D7}\u{1F3FF}" }], version: 5 }, man_climbing: { id: "man_climbing", name: "Man Climbing", keywords: ["sports", "hobby", "male", "rock"], skins: [{ unified: "1f9d7-200d-2642-fe0f", native: "\u{1F9D7}\u200D\u2642\uFE0F" }, { unified: "1f9d7-1f3fb-200d-2642-fe0f", native: "\u{1F9D7}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9d7-1f3fc-200d-2642-fe0f", native: "\u{1F9D7}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9d7-1f3fd-200d-2642-fe0f", native: "\u{1F9D7}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9d7-1f3fe-200d-2642-fe0f", native: "\u{1F9D7}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9d7-1f3ff-200d-2642-fe0f", native: "\u{1F9D7}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 5 }, woman_climbing: { id: "woman_climbing", name: "Woman Climbing", keywords: ["sports", "hobby", "female", "rock"], skins: [{ unified: "1f9d7-200d-2640-fe0f", native: "\u{1F9D7}\u200D\u2640\uFE0F" }, { unified: "1f9d7-1f3fb-200d-2640-fe0f", native: "\u{1F9D7}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9d7-1f3fc-200d-2640-fe0f", native: "\u{1F9D7}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9d7-1f3fd-200d-2640-fe0f", native: "\u{1F9D7}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9d7-1f3fe-200d-2640-fe0f", native: "\u{1F9D7}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9d7-1f3ff-200d-2640-fe0f", native: "\u{1F9D7}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 5 }, fencer: { id: "fencer", name: "Fencer", keywords: ["person", "fencing", "sports", "sword"], skins: [{ unified: "1f93a", native: "\u{1F93A}" }], version: 3 }, horse_racing: { id: "horse_racing", name: "Horse Racing", keywords: ["animal", "betting", "competition", "gambling", "luck"], skins: [{ unified: "1f3c7", native: "\u{1F3C7}" }, { unified: "1f3c7-1f3fb", native: "\u{1F3C7}\u{1F3FB}" }, { unified: "1f3c7-1f3fc", native: "\u{1F3C7}\u{1F3FC}" }, { unified: "1f3c7-1f3fd", native: "\u{1F3C7}\u{1F3FD}" }, { unified: "1f3c7-1f3fe", native: "\u{1F3C7}\u{1F3FE}" }, { unified: "1f3c7-1f3ff", native: "\u{1F3C7}\u{1F3FF}" }], version: 1 }, skier: { id: "skier", name: "Skier", keywords: ["sports", "winter", "snow"], skins: [{ unified: "26f7-fe0f", native: "\u26F7\uFE0F" }], version: 1 }, snowboarder: { id: "snowboarder", name: "Snowboarder", keywords: ["sports", "winter"], skins: [{ unified: "1f3c2", native: "\u{1F3C2}" }, { unified: "1f3c2-1f3fb", native: "\u{1F3C2}\u{1F3FB}" }, { unified: "1f3c2-1f3fc", native: "\u{1F3C2}\u{1F3FC}" }, { unified: "1f3c2-1f3fd", native: "\u{1F3C2}\u{1F3FD}" }, { unified: "1f3c2-1f3fe", native: "\u{1F3C2}\u{1F3FE}" }, { unified: "1f3c2-1f3ff", native: "\u{1F3C2}\u{1F3FF}" }], version: 1 }, golfer: { id: "golfer", name: "Person Golfing", keywords: ["golfer", "sports", "business"], skins: [{ unified: "1f3cc-fe0f", native: "\u{1F3CC}\uFE0F" }, { unified: "1f3cc-1f3fb", native: "\u{1F3CC}\u{1F3FB}" }, { unified: "1f3cc-1f3fc", native: "\u{1F3CC}\u{1F3FC}" }, { unified: "1f3cc-1f3fd", native: "\u{1F3CC}\u{1F3FD}" }, { unified: "1f3cc-1f3fe", native: "\u{1F3CC}\u{1F3FE}" }, { unified: "1f3cc-1f3ff", native: "\u{1F3CC}\u{1F3FF}" }], version: 1 }, "man-golfing": { id: "man-golfing", name: "Man Golfing", keywords: ["sport"], skins: [{ unified: "1f3cc-fe0f-200d-2642-fe0f", native: "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F" }, { unified: "1f3cc-1f3fb-200d-2642-fe0f", native: "\u{1F3CC}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f3cc-1f3fc-200d-2642-fe0f", native: "\u{1F3CC}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f3cc-1f3fd-200d-2642-fe0f", native: "\u{1F3CC}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f3cc-1f3fe-200d-2642-fe0f", native: "\u{1F3CC}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f3cc-1f3ff-200d-2642-fe0f", native: "\u{1F3CC}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-golfing": { id: "woman-golfing", name: "Woman Golfing", keywords: ["sports", "business", "female"], skins: [{ unified: "1f3cc-fe0f-200d-2640-fe0f", native: "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F" }, { unified: "1f3cc-1f3fb-200d-2640-fe0f", native: "\u{1F3CC}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f3cc-1f3fc-200d-2640-fe0f", native: "\u{1F3CC}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f3cc-1f3fd-200d-2640-fe0f", native: "\u{1F3CC}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f3cc-1f3fe-200d-2640-fe0f", native: "\u{1F3CC}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f3cc-1f3ff-200d-2640-fe0f", native: "\u{1F3CC}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, surfer: { id: "surfer", name: "Surfer", keywords: ["person", "surfing", "sport", "sea"], skins: [{ unified: "1f3c4", native: "\u{1F3C4}" }, { unified: "1f3c4-1f3fb", native: "\u{1F3C4}\u{1F3FB}" }, { unified: "1f3c4-1f3fc", native: "\u{1F3C4}\u{1F3FC}" }, { unified: "1f3c4-1f3fd", native: "\u{1F3C4}\u{1F3FD}" }, { unified: "1f3c4-1f3fe", native: "\u{1F3C4}\u{1F3FE}" }, { unified: "1f3c4-1f3ff", native: "\u{1F3C4}\u{1F3FF}" }], version: 1 }, "man-surfing": { id: "man-surfing", name: "Man Surfing", keywords: ["sports", "ocean", "sea", "summer", "beach"], skins: [{ unified: "1f3c4-200d-2642-fe0f", native: "\u{1F3C4}\u200D\u2642\uFE0F" }, { unified: "1f3c4-1f3fb-200d-2642-fe0f", native: "\u{1F3C4}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f3c4-1f3fc-200d-2642-fe0f", native: "\u{1F3C4}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f3c4-1f3fd-200d-2642-fe0f", native: "\u{1F3C4}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f3c4-1f3fe-200d-2642-fe0f", native: "\u{1F3C4}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f3c4-1f3ff-200d-2642-fe0f", native: "\u{1F3C4}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-surfing": { id: "woman-surfing", name: "Woman Surfing", keywords: ["sports", "ocean", "sea", "summer", "beach", "female"], skins: [{ unified: "1f3c4-200d-2640-fe0f", native: "\u{1F3C4}\u200D\u2640\uFE0F" }, { unified: "1f3c4-1f3fb-200d-2640-fe0f", native: "\u{1F3C4}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f3c4-1f3fc-200d-2640-fe0f", native: "\u{1F3C4}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f3c4-1f3fd-200d-2640-fe0f", native: "\u{1F3C4}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f3c4-1f3fe-200d-2640-fe0f", native: "\u{1F3C4}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f3c4-1f3ff-200d-2640-fe0f", native: "\u{1F3C4}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, rowboat: { id: "rowboat", name: "Rowboat", keywords: ["person", "rowing", "boat", "sport", "move"], skins: [{ unified: "1f6a3", native: "\u{1F6A3}" }, { unified: "1f6a3-1f3fb", native: "\u{1F6A3}\u{1F3FB}" }, { unified: "1f6a3-1f3fc", native: "\u{1F6A3}\u{1F3FC}" }, { unified: "1f6a3-1f3fd", native: "\u{1F6A3}\u{1F3FD}" }, { unified: "1f6a3-1f3fe", native: "\u{1F6A3}\u{1F3FE}" }, { unified: "1f6a3-1f3ff", native: "\u{1F6A3}\u{1F3FF}" }], version: 1 }, "man-rowing-boat": { id: "man-rowing-boat", name: "Man Rowing Boat", keywords: ["rowing-boat", "sports", "hobby", "water", "ship"], skins: [{ unified: "1f6a3-200d-2642-fe0f", native: "\u{1F6A3}\u200D\u2642\uFE0F" }, { unified: "1f6a3-1f3fb-200d-2642-fe0f", native: "\u{1F6A3}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f6a3-1f3fc-200d-2642-fe0f", native: "\u{1F6A3}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f6a3-1f3fd-200d-2642-fe0f", native: "\u{1F6A3}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f6a3-1f3fe-200d-2642-fe0f", native: "\u{1F6A3}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f6a3-1f3ff-200d-2642-fe0f", native: "\u{1F6A3}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-rowing-boat": { id: "woman-rowing-boat", name: "Woman Rowing Boat", keywords: ["rowing-boat", "sports", "hobby", "water", "ship", "female"], skins: [{ unified: "1f6a3-200d-2640-fe0f", native: "\u{1F6A3}\u200D\u2640\uFE0F" }, { unified: "1f6a3-1f3fb-200d-2640-fe0f", native: "\u{1F6A3}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f6a3-1f3fc-200d-2640-fe0f", native: "\u{1F6A3}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f6a3-1f3fd-200d-2640-fe0f", native: "\u{1F6A3}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f6a3-1f3fe-200d-2640-fe0f", native: "\u{1F6A3}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f6a3-1f3ff-200d-2640-fe0f", native: "\u{1F6A3}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, swimmer: { id: "swimmer", name: "Swimmer", keywords: ["person", "swimming", "sport", "pool"], skins: [{ unified: "1f3ca", native: "\u{1F3CA}" }, { unified: "1f3ca-1f3fb", native: "\u{1F3CA}\u{1F3FB}" }, { unified: "1f3ca-1f3fc", native: "\u{1F3CA}\u{1F3FC}" }, { unified: "1f3ca-1f3fd", native: "\u{1F3CA}\u{1F3FD}" }, { unified: "1f3ca-1f3fe", native: "\u{1F3CA}\u{1F3FE}" }, { unified: "1f3ca-1f3ff", native: "\u{1F3CA}\u{1F3FF}" }], version: 1 }, "man-swimming": { id: "man-swimming", name: "Man Swimming", keywords: ["sports", "exercise", "human", "athlete", "water", "summer"], skins: [{ unified: "1f3ca-200d-2642-fe0f", native: "\u{1F3CA}\u200D\u2642\uFE0F" }, { unified: "1f3ca-1f3fb-200d-2642-fe0f", native: "\u{1F3CA}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f3ca-1f3fc-200d-2642-fe0f", native: "\u{1F3CA}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f3ca-1f3fd-200d-2642-fe0f", native: "\u{1F3CA}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f3ca-1f3fe-200d-2642-fe0f", native: "\u{1F3CA}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f3ca-1f3ff-200d-2642-fe0f", native: "\u{1F3CA}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-swimming": { id: "woman-swimming", name: "Woman Swimming", keywords: ["sports", "exercise", "human", "athlete", "water", "summer", "female"], skins: [{ unified: "1f3ca-200d-2640-fe0f", native: "\u{1F3CA}\u200D\u2640\uFE0F" }, { unified: "1f3ca-1f3fb-200d-2640-fe0f", native: "\u{1F3CA}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f3ca-1f3fc-200d-2640-fe0f", native: "\u{1F3CA}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f3ca-1f3fd-200d-2640-fe0f", native: "\u{1F3CA}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f3ca-1f3fe-200d-2640-fe0f", native: "\u{1F3CA}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f3ca-1f3ff-200d-2640-fe0f", native: "\u{1F3CA}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, person_with_ball: { id: "person_with_ball", name: "Person Bouncing Ball", keywords: ["with", "sports", "human"], skins: [{ unified: "26f9-fe0f", native: "\u26F9\uFE0F" }, { unified: "26f9-1f3fb", native: "\u26F9\u{1F3FB}" }, { unified: "26f9-1f3fc", native: "\u26F9\u{1F3FC}" }, { unified: "26f9-1f3fd", native: "\u26F9\u{1F3FD}" }, { unified: "26f9-1f3fe", native: "\u26F9\u{1F3FE}" }, { unified: "26f9-1f3ff", native: "\u26F9\u{1F3FF}" }], version: 1 }, "man-bouncing-ball": { id: "man-bouncing-ball", name: "Man Bouncing Ball", keywords: ["bouncing-ball", "sport"], skins: [{ unified: "26f9-fe0f-200d-2642-fe0f", native: "\u26F9\uFE0F\u200D\u2642\uFE0F" }, { unified: "26f9-1f3fb-200d-2642-fe0f", native: "\u26F9\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "26f9-1f3fc-200d-2642-fe0f", native: "\u26F9\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "26f9-1f3fd-200d-2642-fe0f", native: "\u26F9\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "26f9-1f3fe-200d-2642-fe0f", native: "\u26F9\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "26f9-1f3ff-200d-2642-fe0f", native: "\u26F9\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-bouncing-ball": { id: "woman-bouncing-ball", name: "Woman Bouncing Ball", keywords: ["bouncing-ball", "sports", "human", "female"], skins: [{ unified: "26f9-fe0f-200d-2640-fe0f", native: "\u26F9\uFE0F\u200D\u2640\uFE0F" }, { unified: "26f9-1f3fb-200d-2640-fe0f", native: "\u26F9\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "26f9-1f3fc-200d-2640-fe0f", native: "\u26F9\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "26f9-1f3fd-200d-2640-fe0f", native: "\u26F9\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "26f9-1f3fe-200d-2640-fe0f", native: "\u26F9\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "26f9-1f3ff-200d-2640-fe0f", native: "\u26F9\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, weight_lifter: { id: "weight_lifter", name: "Person Lifting Weights", keywords: ["weight", "lifter", "sports", "training", "exercise"], skins: [{ unified: "1f3cb-fe0f", native: "\u{1F3CB}\uFE0F" }, { unified: "1f3cb-1f3fb", native: "\u{1F3CB}\u{1F3FB}" }, { unified: "1f3cb-1f3fc", native: "\u{1F3CB}\u{1F3FC}" }, { unified: "1f3cb-1f3fd", native: "\u{1F3CB}\u{1F3FD}" }, { unified: "1f3cb-1f3fe", native: "\u{1F3CB}\u{1F3FE}" }, { unified: "1f3cb-1f3ff", native: "\u{1F3CB}\u{1F3FF}" }], version: 1 }, "man-lifting-weights": { id: "man-lifting-weights", name: "Man Lifting Weights", keywords: ["lifting-weights", "sport"], skins: [{ unified: "1f3cb-fe0f-200d-2642-fe0f", native: "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F" }, { unified: "1f3cb-1f3fb-200d-2642-fe0f", native: "\u{1F3CB}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f3cb-1f3fc-200d-2642-fe0f", native: "\u{1F3CB}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f3cb-1f3fd-200d-2642-fe0f", native: "\u{1F3CB}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f3cb-1f3fe-200d-2642-fe0f", native: "\u{1F3CB}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f3cb-1f3ff-200d-2642-fe0f", native: "\u{1F3CB}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-lifting-weights": { id: "woman-lifting-weights", name: "Woman Lifting Weights", keywords: ["lifting-weights", "sports", "training", "exercise", "female"], skins: [{ unified: "1f3cb-fe0f-200d-2640-fe0f", native: "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F" }, { unified: "1f3cb-1f3fb-200d-2640-fe0f", native: "\u{1F3CB}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f3cb-1f3fc-200d-2640-fe0f", native: "\u{1F3CB}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f3cb-1f3fd-200d-2640-fe0f", native: "\u{1F3CB}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f3cb-1f3fe-200d-2640-fe0f", native: "\u{1F3CB}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f3cb-1f3ff-200d-2640-fe0f", native: "\u{1F3CB}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, bicyclist: { id: "bicyclist", name: "Bicyclist", keywords: ["person", "biking", "sport", "move"], skins: [{ unified: "1f6b4", native: "\u{1F6B4}" }, { unified: "1f6b4-1f3fb", native: "\u{1F6B4}\u{1F3FB}" }, { unified: "1f6b4-1f3fc", native: "\u{1F6B4}\u{1F3FC}" }, { unified: "1f6b4-1f3fd", native: "\u{1F6B4}\u{1F3FD}" }, { unified: "1f6b4-1f3fe", native: "\u{1F6B4}\u{1F3FE}" }, { unified: "1f6b4-1f3ff", native: "\u{1F6B4}\u{1F3FF}" }], version: 1 }, "man-biking": { id: "man-biking", name: "Man Biking", keywords: ["sports", "bike", "exercise", "hipster"], skins: [{ unified: "1f6b4-200d-2642-fe0f", native: "\u{1F6B4}\u200D\u2642\uFE0F" }, { unified: "1f6b4-1f3fb-200d-2642-fe0f", native: "\u{1F6B4}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f6b4-1f3fc-200d-2642-fe0f", native: "\u{1F6B4}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f6b4-1f3fd-200d-2642-fe0f", native: "\u{1F6B4}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f6b4-1f3fe-200d-2642-fe0f", native: "\u{1F6B4}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f6b4-1f3ff-200d-2642-fe0f", native: "\u{1F6B4}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-biking": { id: "woman-biking", name: "Woman Biking", keywords: ["sports", "bike", "exercise", "hipster", "female"], skins: [{ unified: "1f6b4-200d-2640-fe0f", native: "\u{1F6B4}\u200D\u2640\uFE0F" }, { unified: "1f6b4-1f3fb-200d-2640-fe0f", native: "\u{1F6B4}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f6b4-1f3fc-200d-2640-fe0f", native: "\u{1F6B4}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f6b4-1f3fd-200d-2640-fe0f", native: "\u{1F6B4}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f6b4-1f3fe-200d-2640-fe0f", native: "\u{1F6B4}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f6b4-1f3ff-200d-2640-fe0f", native: "\u{1F6B4}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, mountain_bicyclist: { id: "mountain_bicyclist", name: "Mountain Bicyclist", keywords: ["person", "biking", "sport", "move"], skins: [{ unified: "1f6b5", native: "\u{1F6B5}" }, { unified: "1f6b5-1f3fb", native: "\u{1F6B5}\u{1F3FB}" }, { unified: "1f6b5-1f3fc", native: "\u{1F6B5}\u{1F3FC}" }, { unified: "1f6b5-1f3fd", native: "\u{1F6B5}\u{1F3FD}" }, { unified: "1f6b5-1f3fe", native: "\u{1F6B5}\u{1F3FE}" }, { unified: "1f6b5-1f3ff", native: "\u{1F6B5}\u{1F3FF}" }], version: 1 }, "man-mountain-biking": { id: "man-mountain-biking", name: "Man Mountain Biking", keywords: ["mountain-biking", "transportation", "sports", "human", "race", "bike"], skins: [{ unified: "1f6b5-200d-2642-fe0f", native: "\u{1F6B5}\u200D\u2642\uFE0F" }, { unified: "1f6b5-1f3fb-200d-2642-fe0f", native: "\u{1F6B5}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f6b5-1f3fc-200d-2642-fe0f", native: "\u{1F6B5}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f6b5-1f3fd-200d-2642-fe0f", native: "\u{1F6B5}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f6b5-1f3fe-200d-2642-fe0f", native: "\u{1F6B5}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f6b5-1f3ff-200d-2642-fe0f", native: "\u{1F6B5}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-mountain-biking": { id: "woman-mountain-biking", name: "Woman Mountain Biking", keywords: ["mountain-biking", "transportation", "sports", "human", "race", "bike", "female"], skins: [{ unified: "1f6b5-200d-2640-fe0f", native: "\u{1F6B5}\u200D\u2640\uFE0F" }, { unified: "1f6b5-1f3fb-200d-2640-fe0f", native: "\u{1F6B5}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f6b5-1f3fc-200d-2640-fe0f", native: "\u{1F6B5}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f6b5-1f3fd-200d-2640-fe0f", native: "\u{1F6B5}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f6b5-1f3fe-200d-2640-fe0f", native: "\u{1F6B5}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f6b5-1f3ff-200d-2640-fe0f", native: "\u{1F6B5}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, person_doing_cartwheel: { id: "person_doing_cartwheel", name: "Person Cartwheeling", keywords: ["doing", "cartwheel", "sport", "gymnastic"], skins: [{ unified: "1f938", native: "\u{1F938}" }, { unified: "1f938-1f3fb", native: "\u{1F938}\u{1F3FB}" }, { unified: "1f938-1f3fc", native: "\u{1F938}\u{1F3FC}" }, { unified: "1f938-1f3fd", native: "\u{1F938}\u{1F3FD}" }, { unified: "1f938-1f3fe", native: "\u{1F938}\u{1F3FE}" }, { unified: "1f938-1f3ff", native: "\u{1F938}\u{1F3FF}" }], version: 3 }, "man-cartwheeling": { id: "man-cartwheeling", name: "Man Cartwheeling", keywords: ["gymnastics"], skins: [{ unified: "1f938-200d-2642-fe0f", native: "\u{1F938}\u200D\u2642\uFE0F" }, { unified: "1f938-1f3fb-200d-2642-fe0f", native: "\u{1F938}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f938-1f3fc-200d-2642-fe0f", native: "\u{1F938}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f938-1f3fd-200d-2642-fe0f", native: "\u{1F938}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f938-1f3fe-200d-2642-fe0f", native: "\u{1F938}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f938-1f3ff-200d-2642-fe0f", native: "\u{1F938}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-cartwheeling": { id: "woman-cartwheeling", name: "Woman Cartwheeling", keywords: ["gymnastics"], skins: [{ unified: "1f938-200d-2640-fe0f", native: "\u{1F938}\u200D\u2640\uFE0F" }, { unified: "1f938-1f3fb-200d-2640-fe0f", native: "\u{1F938}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f938-1f3fc-200d-2640-fe0f", native: "\u{1F938}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f938-1f3fd-200d-2640-fe0f", native: "\u{1F938}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f938-1f3fe-200d-2640-fe0f", native: "\u{1F938}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f938-1f3ff-200d-2640-fe0f", native: "\u{1F938}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, wrestlers: { id: "wrestlers", name: "Wrestlers", keywords: ["people", "wrestling", "sport"], skins: [{ unified: "1f93c", native: "\u{1F93C}" }], version: 3 }, "man-wrestling": { id: "man-wrestling", name: "Men Wrestling", keywords: ["man", "sports", "wrestlers"], skins: [{ unified: "1f93c-200d-2642-fe0f", native: "\u{1F93C}\u200D\u2642\uFE0F" }], version: 4 }, "woman-wrestling": { id: "woman-wrestling", name: "Women Wrestling", keywords: ["woman", "sports", "wrestlers"], skins: [{ unified: "1f93c-200d-2640-fe0f", native: "\u{1F93C}\u200D\u2640\uFE0F" }], version: 4 }, water_polo: { id: "water_polo", name: "Water Polo", keywords: ["person", "playing", "sport"], skins: [{ unified: "1f93d", native: "\u{1F93D}" }, { unified: "1f93d-1f3fb", native: "\u{1F93D}\u{1F3FB}" }, { unified: "1f93d-1f3fc", native: "\u{1F93D}\u{1F3FC}" }, { unified: "1f93d-1f3fd", native: "\u{1F93D}\u{1F3FD}" }, { unified: "1f93d-1f3fe", native: "\u{1F93D}\u{1F3FE}" }, { unified: "1f93d-1f3ff", native: "\u{1F93D}\u{1F3FF}" }], version: 3 }, "man-playing-water-polo": { id: "man-playing-water-polo", name: "Man Playing Water Polo", keywords: ["playing-water-polo", "sports", "pool"], skins: [{ unified: "1f93d-200d-2642-fe0f", native: "\u{1F93D}\u200D\u2642\uFE0F" }, { unified: "1f93d-1f3fb-200d-2642-fe0f", native: "\u{1F93D}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f93d-1f3fc-200d-2642-fe0f", native: "\u{1F93D}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f93d-1f3fd-200d-2642-fe0f", native: "\u{1F93D}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f93d-1f3fe-200d-2642-fe0f", native: "\u{1F93D}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f93d-1f3ff-200d-2642-fe0f", native: "\u{1F93D}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-playing-water-polo": { id: "woman-playing-water-polo", name: "Woman Playing Water Polo", keywords: ["playing-water-polo", "sports", "pool"], skins: [{ unified: "1f93d-200d-2640-fe0f", native: "\u{1F93D}\u200D\u2640\uFE0F" }, { unified: "1f93d-1f3fb-200d-2640-fe0f", native: "\u{1F93D}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f93d-1f3fc-200d-2640-fe0f", native: "\u{1F93D}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f93d-1f3fd-200d-2640-fe0f", native: "\u{1F93D}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f93d-1f3fe-200d-2640-fe0f", native: "\u{1F93D}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f93d-1f3ff-200d-2640-fe0f", native: "\u{1F93D}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, handball: { id: "handball", name: "Handball", keywords: ["person", "playing", "sport"], skins: [{ unified: "1f93e", native: "\u{1F93E}" }, { unified: "1f93e-1f3fb", native: "\u{1F93E}\u{1F3FB}" }, { unified: "1f93e-1f3fc", native: "\u{1F93E}\u{1F3FC}" }, { unified: "1f93e-1f3fd", native: "\u{1F93E}\u{1F3FD}" }, { unified: "1f93e-1f3fe", native: "\u{1F93E}\u{1F3FE}" }, { unified: "1f93e-1f3ff", native: "\u{1F93E}\u{1F3FF}" }], version: 3 }, "man-playing-handball": { id: "man-playing-handball", name: "Man Playing Handball", keywords: ["playing-handball", "sports"], skins: [{ unified: "1f93e-200d-2642-fe0f", native: "\u{1F93E}\u200D\u2642\uFE0F" }, { unified: "1f93e-1f3fb-200d-2642-fe0f", native: "\u{1F93E}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f93e-1f3fc-200d-2642-fe0f", native: "\u{1F93E}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f93e-1f3fd-200d-2642-fe0f", native: "\u{1F93E}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f93e-1f3fe-200d-2642-fe0f", native: "\u{1F93E}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f93e-1f3ff-200d-2642-fe0f", native: "\u{1F93E}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-playing-handball": { id: "woman-playing-handball", name: "Woman Playing Handball", keywords: ["playing-handball", "sports"], skins: [{ unified: "1f93e-200d-2640-fe0f", native: "\u{1F93E}\u200D\u2640\uFE0F" }, { unified: "1f93e-1f3fb-200d-2640-fe0f", native: "\u{1F93E}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f93e-1f3fc-200d-2640-fe0f", native: "\u{1F93E}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f93e-1f3fd-200d-2640-fe0f", native: "\u{1F93E}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f93e-1f3fe-200d-2640-fe0f", native: "\u{1F93E}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f93e-1f3ff-200d-2640-fe0f", native: "\u{1F93E}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, juggling: { id: "juggling", name: "Juggling", keywords: ["person", "performance", "balance"], skins: [{ unified: "1f939", native: "\u{1F939}" }, { unified: "1f939-1f3fb", native: "\u{1F939}\u{1F3FB}" }, { unified: "1f939-1f3fc", native: "\u{1F939}\u{1F3FC}" }, { unified: "1f939-1f3fd", native: "\u{1F939}\u{1F3FD}" }, { unified: "1f939-1f3fe", native: "\u{1F939}\u{1F3FE}" }, { unified: "1f939-1f3ff", native: "\u{1F939}\u{1F3FF}" }], version: 3 }, "man-juggling": { id: "man-juggling", name: "Man Juggling", keywords: ["juggle", "balance", "skill", "multitask"], skins: [{ unified: "1f939-200d-2642-fe0f", native: "\u{1F939}\u200D\u2642\uFE0F" }, { unified: "1f939-1f3fb-200d-2642-fe0f", native: "\u{1F939}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f939-1f3fc-200d-2642-fe0f", native: "\u{1F939}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f939-1f3fd-200d-2642-fe0f", native: "\u{1F939}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f939-1f3fe-200d-2642-fe0f", native: "\u{1F939}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f939-1f3ff-200d-2642-fe0f", native: "\u{1F939}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 4 }, "woman-juggling": { id: "woman-juggling", name: "Woman Juggling", keywords: ["juggle", "balance", "skill", "multitask"], skins: [{ unified: "1f939-200d-2640-fe0f", native: "\u{1F939}\u200D\u2640\uFE0F" }, { unified: "1f939-1f3fb-200d-2640-fe0f", native: "\u{1F939}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f939-1f3fc-200d-2640-fe0f", native: "\u{1F939}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f939-1f3fd-200d-2640-fe0f", native: "\u{1F939}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f939-1f3fe-200d-2640-fe0f", native: "\u{1F939}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f939-1f3ff-200d-2640-fe0f", native: "\u{1F939}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 4 }, person_in_lotus_position: { id: "person_in_lotus_position", name: "Person in Lotus Position", keywords: ["meditate"], skins: [{ unified: "1f9d8", native: "\u{1F9D8}" }, { unified: "1f9d8-1f3fb", native: "\u{1F9D8}\u{1F3FB}" }, { unified: "1f9d8-1f3fc", native: "\u{1F9D8}\u{1F3FC}" }, { unified: "1f9d8-1f3fd", native: "\u{1F9D8}\u{1F3FD}" }, { unified: "1f9d8-1f3fe", native: "\u{1F9D8}\u{1F3FE}" }, { unified: "1f9d8-1f3ff", native: "\u{1F9D8}\u{1F3FF}" }], version: 5 }, man_in_lotus_position: { id: "man_in_lotus_position", name: "Man in Lotus Position", keywords: ["male", "meditation", "yoga", "serenity", "zen", "mindfulness"], skins: [{ unified: "1f9d8-200d-2642-fe0f", native: "\u{1F9D8}\u200D\u2642\uFE0F" }, { unified: "1f9d8-1f3fb-200d-2642-fe0f", native: "\u{1F9D8}\u{1F3FB}\u200D\u2642\uFE0F" }, { unified: "1f9d8-1f3fc-200d-2642-fe0f", native: "\u{1F9D8}\u{1F3FC}\u200D\u2642\uFE0F" }, { unified: "1f9d8-1f3fd-200d-2642-fe0f", native: "\u{1F9D8}\u{1F3FD}\u200D\u2642\uFE0F" }, { unified: "1f9d8-1f3fe-200d-2642-fe0f", native: "\u{1F9D8}\u{1F3FE}\u200D\u2642\uFE0F" }, { unified: "1f9d8-1f3ff-200d-2642-fe0f", native: "\u{1F9D8}\u{1F3FF}\u200D\u2642\uFE0F" }], version: 5 }, woman_in_lotus_position: { id: "woman_in_lotus_position", name: "Woman in Lotus Position", keywords: ["female", "meditation", "yoga", "serenity", "zen", "mindfulness"], skins: [{ unified: "1f9d8-200d-2640-fe0f", native: "\u{1F9D8}\u200D\u2640\uFE0F" }, { unified: "1f9d8-1f3fb-200d-2640-fe0f", native: "\u{1F9D8}\u{1F3FB}\u200D\u2640\uFE0F" }, { unified: "1f9d8-1f3fc-200d-2640-fe0f", native: "\u{1F9D8}\u{1F3FC}\u200D\u2640\uFE0F" }, { unified: "1f9d8-1f3fd-200d-2640-fe0f", native: "\u{1F9D8}\u{1F3FD}\u200D\u2640\uFE0F" }, { unified: "1f9d8-1f3fe-200d-2640-fe0f", native: "\u{1F9D8}\u{1F3FE}\u200D\u2640\uFE0F" }, { unified: "1f9d8-1f3ff-200d-2640-fe0f", native: "\u{1F9D8}\u{1F3FF}\u200D\u2640\uFE0F" }], version: 5 }, bath: { id: "bath", name: "Bath", keywords: ["person", "taking", "clean", "shower", "bathroom"], skins: [{ unified: "1f6c0", native: "\u{1F6C0}" }, { unified: "1f6c0-1f3fb", native: "\u{1F6C0}\u{1F3FB}" }, { unified: "1f6c0-1f3fc", native: "\u{1F6C0}\u{1F3FC}" }, { unified: "1f6c0-1f3fd", native: "\u{1F6C0}\u{1F3FD}" }, { unified: "1f6c0-1f3fe", native: "\u{1F6C0}\u{1F3FE}" }, { unified: "1f6c0-1f3ff", native: "\u{1F6C0}\u{1F3FF}" }], version: 1 }, sleeping_accommodation: { id: "sleeping_accommodation", name: "Person in Bed", keywords: ["sleeping", "accommodation", "rest"], skins: [{ unified: "1f6cc", native: "\u{1F6CC}" }, { unified: "1f6cc-1f3fb", native: "\u{1F6CC}\u{1F3FB}" }, { unified: "1f6cc-1f3fc", native: "\u{1F6CC}\u{1F3FC}" }, { unified: "1f6cc-1f3fd", native: "\u{1F6CC}\u{1F3FD}" }, { unified: "1f6cc-1f3fe", native: "\u{1F6CC}\u{1F3FE}" }, { unified: "1f6cc-1f3ff", native: "\u{1F6CC}\u{1F3FF}" }], version: 1 }, people_holding_hands: { id: "people_holding_hands", name: "People Holding Hands", keywords: ["friendship"], skins: [{ unified: "1f9d1-200d-1f91d-200d-1f9d1", native: "\u{1F9D1}\u200D\u{1F91D}\u200D\u{1F9D1}" }, { unified: "1f9d1-1f3fb-200d-1f91d-200d-1f9d1-1f3fb", native: "\u{1F9D1}\u{1F3FB}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FB}" }, { unified: "1f9d1-1f3fc-200d-1f91d-200d-1f9d1-1f3fc", native: "\u{1F9D1}\u{1F3FC}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FC}" }, { unified: "1f9d1-1f3fd-200d-1f91d-200d-1f9d1-1f3fd", native: "\u{1F9D1}\u{1F3FD}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FD}" }, { unified: "1f9d1-1f3fe-200d-1f91d-200d-1f9d1-1f3fe", native: "\u{1F9D1}\u{1F3FE}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FE}" }, { unified: "1f9d1-1f3ff-200d-1f91d-200d-1f9d1-1f3ff", native: "\u{1F9D1}\u{1F3FF}\u200D\u{1F91D}\u200D\u{1F9D1}\u{1F3FF}" }], version: 12 }, two_women_holding_hands: { id: "two_women_holding_hands", name: "Women Holding Hands", keywords: ["two", "pair", "friendship", "couple", "love", "like", "female", "people", "human"], skins: [{ unified: "1f46d", native: "\u{1F46D}" }, { unified: "1f46d-1f3fb", native: "\u{1F46D}\u{1F3FB}" }, { unified: "1f46d-1f3fc", native: "\u{1F46D}\u{1F3FC}" }, { unified: "1f46d-1f3fd", native: "\u{1F46D}\u{1F3FD}" }, { unified: "1f46d-1f3fe", native: "\u{1F46D}\u{1F3FE}" }, { unified: "1f46d-1f3ff", native: "\u{1F46D}\u{1F3FF}" }], version: 1 }, man_and_woman_holding_hands: { id: "man_and_woman_holding_hands", name: "Man and Woman Holding Hands", keywords: ["couple", "pair", "people", "human", "love", "date", "dating", "like", "affection", "valentines", "marriage"], skins: [{ unified: "1f46b", native: "\u{1F46B}" }, { unified: "1f46b-1f3fb", native: "\u{1F46B}\u{1F3FB}" }, { unified: "1f46b-1f3fc", native: "\u{1F46B}\u{1F3FC}" }, { unified: "1f46b-1f3fd", native: "\u{1F46B}\u{1F3FD}" }, { unified: "1f46b-1f3fe", native: "\u{1F46B}\u{1F3FE}" }, { unified: "1f46b-1f3ff", native: "\u{1F46B}\u{1F3FF}" }], version: 1 }, two_men_holding_hands: { id: "two_men_holding_hands", name: "Men Holding Hands", keywords: ["two", "pair", "couple", "love", "like", "bromance", "friendship", "people", "human"], skins: [{ unified: "1f46c", native: "\u{1F46C}" }, { unified: "1f46c-1f3fb", native: "\u{1F46C}\u{1F3FB}" }, { unified: "1f46c-1f3fc", native: "\u{1F46C}\u{1F3FC}" }, { unified: "1f46c-1f3fd", native: "\u{1F46C}\u{1F3FD}" }, { unified: "1f46c-1f3fe", native: "\u{1F46C}\u{1F3FE}" }, { unified: "1f46c-1f3ff", native: "\u{1F46C}\u{1F3FF}" }], version: 1 }, couplekiss: { id: "couplekiss", name: "Kiss", keywords: ["couplekiss", "pair", "valentines", "love", "like", "dating", "marriage"], skins: [{ unified: "1f48f", native: "\u{1F48F}" }, { unified: "1f48f-1f3fb", native: "\u{1F48F}\u{1F3FB}" }, { unified: "1f48f-1f3fc", native: "\u{1F48F}\u{1F3FC}" }, { unified: "1f48f-1f3fd", native: "\u{1F48F}\u{1F3FD}" }, { unified: "1f48f-1f3fe", native: "\u{1F48F}\u{1F3FE}" }, { unified: "1f48f-1f3ff", native: "\u{1F48F}\u{1F3FF}" }], version: 1 }, "woman-kiss-man": { id: "woman-kiss-man", name: "Kiss: Woman, Man", keywords: ["woman", "kiss-man", "kiss", "love"], skins: [{ unified: "1f469-200d-2764-fe0f-200d-1f48b-200d-1f468", native: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}" }, { unified: "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", native: "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}" }, { unified: "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", native: "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}" }, { unified: "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", native: "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}" }, { unified: "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", native: "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}" }, { unified: "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff", native: "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}" }], version: 2 }, "man-kiss-man": { id: "man-kiss-man", name: "Kiss: Man, Man", keywords: ["kiss-man", "kiss", "pair", "valentines", "love", "like", "dating", "marriage"], skins: [{ unified: "1f468-200d-2764-fe0f-200d-1f48b-200d-1f468", native: "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}" }, { unified: "1f468-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fb", native: "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FB}" }, { unified: "1f468-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fc", native: "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FC}" }, { unified: "1f468-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fd", native: "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FD}" }, { unified: "1f468-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3fe", native: "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FE}" }, { unified: "1f468-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f468-1f3ff", native: "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}\u{1F3FF}" }], version: 2 }, "woman-kiss-woman": { id: "woman-kiss-woman", name: "Kiss: Woman, Woman", keywords: ["kiss-woman", "kiss", "pair", "valentines", "love", "like", "dating", "marriage"], skins: [{ unified: "1f469-200d-2764-fe0f-200d-1f48b-200d-1f469", native: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}" }, { unified: "1f469-1f3fb-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fb", native: "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FB}" }, { unified: "1f469-1f3fc-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fc", native: "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FC}" }, { unified: "1f469-1f3fd-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fd", native: "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FD}" }, { unified: "1f469-1f3fe-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3fe", native: "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FE}" }, { unified: "1f469-1f3ff-200d-2764-fe0f-200d-1f48b-200d-1f469-1f3ff", native: "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}\u{1F3FF}" }], version: 2 }, couple_with_heart: { id: "couple_with_heart", name: "Couple with Heart", keywords: ["pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], skins: [{ unified: "1f491", native: "\u{1F491}" }, { unified: "1f491-1f3fb", native: "\u{1F491}\u{1F3FB}" }, { unified: "1f491-1f3fc", native: "\u{1F491}\u{1F3FC}" }, { unified: "1f491-1f3fd", native: "\u{1F491}\u{1F3FD}" }, { unified: "1f491-1f3fe", native: "\u{1F491}\u{1F3FE}" }, { unified: "1f491-1f3ff", native: "\u{1F491}\u{1F3FF}" }], version: 1 }, "woman-heart-man": { id: "woman-heart-man", name: "Couple with Heart: Woman, Man", keywords: ["woman", "heart-man", "heart", "love"], skins: [{ unified: "1f469-200d-2764-fe0f-200d-1f468", native: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}" }, { unified: "1f469-1f3fb-200d-2764-fe0f-200d-1f468-1f3fb", native: "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}" }, { unified: "1f469-1f3fc-200d-2764-fe0f-200d-1f468-1f3fc", native: "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}" }, { unified: "1f469-1f3fd-200d-2764-fe0f-200d-1f468-1f3fd", native: "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}" }, { unified: "1f469-1f3fe-200d-2764-fe0f-200d-1f468-1f3fe", native: "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}" }, { unified: "1f469-1f3ff-200d-2764-fe0f-200d-1f468-1f3ff", native: "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}" }], version: 2 }, "man-heart-man": { id: "man-heart-man", name: "Couple with Heart: Man, Man", keywords: ["heart-man", "heart", "pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], skins: [{ unified: "1f468-200d-2764-fe0f-200d-1f468", native: "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}" }, { unified: "1f468-1f3fb-200d-2764-fe0f-200d-1f468-1f3fb", native: "\u{1F468}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FB}" }, { unified: "1f468-1f3fc-200d-2764-fe0f-200d-1f468-1f3fc", native: "\u{1F468}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FC}" }, { unified: "1f468-1f3fd-200d-2764-fe0f-200d-1f468-1f3fd", native: "\u{1F468}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FD}" }, { unified: "1f468-1f3fe-200d-2764-fe0f-200d-1f468-1f3fe", native: "\u{1F468}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FE}" }, { unified: "1f468-1f3ff-200d-2764-fe0f-200d-1f468-1f3ff", native: "\u{1F468}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F468}\u{1F3FF}" }], version: 2 }, "woman-heart-woman": { id: "woman-heart-woman", name: "Couple with Heart: Woman, Woman", keywords: ["heart-woman", "heart", "pair", "love", "like", "affection", "human", "dating", "valentines", "marriage"], skins: [{ unified: "1f469-200d-2764-fe0f-200d-1f469", native: "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}" }, { unified: "1f469-1f3fb-200d-2764-fe0f-200d-1f469-1f3fb", native: "\u{1F469}\u{1F3FB}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FB}" }, { unified: "1f469-1f3fc-200d-2764-fe0f-200d-1f469-1f3fc", native: "\u{1F469}\u{1F3FC}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FC}" }, { unified: "1f469-1f3fd-200d-2764-fe0f-200d-1f469-1f3fd", native: "\u{1F469}\u{1F3FD}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FD}" }, { unified: "1f469-1f3fe-200d-2764-fe0f-200d-1f469-1f3fe", native: "\u{1F469}\u{1F3FE}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FE}" }, { unified: "1f469-1f3ff-200d-2764-fe0f-200d-1f469-1f3ff", native: "\u{1F469}\u{1F3FF}\u200D\u2764\uFE0F\u200D\u{1F469}\u{1F3FF}" }], version: 2 }, family: { id: "family", name: "Family", keywords: ["home", "parents", "child", "mom", "dad", "father", "mother", "people", "human"], skins: [{ unified: "1f46a", native: "\u{1F46A}" }], version: 1 }, "man-woman-boy": { id: "man-woman-boy", name: "Family: Man, Woman, Boy", keywords: ["man", "woman-boy", "family", "woman", "love"], skins: [{ unified: "1f468-200d-1f469-200d-1f466", native: "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}" }], version: 2 }, "man-woman-girl": { id: "man-woman-girl", name: "Family: Man, Woman, Girl", keywords: ["man", "woman-girl", "family", "woman", "home", "parents", "people", "human", "child"], skins: [{ unified: "1f468-200d-1f469-200d-1f467", native: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}" }], version: 2 }, "man-woman-girl-boy": { id: "man-woman-girl-boy", name: "Family: Man, Woman, Girl, Boy", keywords: ["man", "woman-girl-boy", "family", "woman", "girl", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f468-200d-1f469-200d-1f467-200d-1f466", native: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}" }], version: 2 }, "man-woman-boy-boy": { id: "man-woman-boy-boy", name: "Family: Man, Woman, Boy, Boy", keywords: ["man", "woman-boy-boy", "family", "woman", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f468-200d-1f469-200d-1f466-200d-1f466", native: "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}" }], version: 2 }, "man-woman-girl-girl": { id: "man-woman-girl-girl", name: "Family: Man, Woman, Girl, Girl", keywords: ["man", "woman-girl-girl", "family", "woman", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f468-200d-1f469-200d-1f467-200d-1f467", native: "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}" }], version: 2 }, "man-man-boy": { id: "man-man-boy", name: "Family: Man, Man, Boy", keywords: ["man", "man-boy", "family", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f468-200d-1f468-200d-1f466", native: "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}" }], version: 2 }, "man-man-girl": { id: "man-man-girl", name: "Family: Man, Man, Girl", keywords: ["man", "man-girl", "family", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f468-200d-1f468-200d-1f467", native: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}" }], version: 2 }, "man-man-girl-boy": { id: "man-man-girl-boy", name: "Family: Man, Man, Girl, Boy", keywords: ["man", "man-girl-boy", "family", "girl", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f468-200d-1f468-200d-1f467-200d-1f466", native: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}" }], version: 2 }, "man-man-boy-boy": { id: "man-man-boy-boy", name: "Family: Man, Man, Boy, Boy", keywords: ["man", "man-boy-boy", "family", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f468-200d-1f468-200d-1f466-200d-1f466", native: "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}" }], version: 2 }, "man-man-girl-girl": { id: "man-man-girl-girl", name: "Family: Man, Man, Girl, Girl", keywords: ["man", "man-girl-girl", "family", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f468-200d-1f468-200d-1f467-200d-1f467", native: "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}" }], version: 2 }, "woman-woman-boy": { id: "woman-woman-boy", name: "Family: Woman, Woman, Boy", keywords: ["woman", "woman-boy", "family", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f469-200d-1f469-200d-1f466", native: "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}" }], version: 2 }, "woman-woman-girl": { id: "woman-woman-girl", name: "Family: Woman, Woman, Girl", keywords: ["woman", "woman-girl", "family", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f469-200d-1f469-200d-1f467", native: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}" }], version: 2 }, "woman-woman-girl-boy": { id: "woman-woman-girl-boy", name: "Family: Woman, Woman, Girl, Boy", keywords: ["woman", "woman-girl-boy", "family", "girl", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f469-200d-1f469-200d-1f467-200d-1f466", native: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}" }], version: 2 }, "woman-woman-boy-boy": { id: "woman-woman-boy-boy", name: "Family: Woman, Woman, Boy, Boy", keywords: ["woman", "woman-boy-boy", "family", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f469-200d-1f469-200d-1f466-200d-1f466", native: "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}" }], version: 2 }, "woman-woman-girl-girl": { id: "woman-woman-girl-girl", name: "Family: Woman, Woman, Girl, Girl", keywords: ["woman", "woman-girl-girl", "family", "home", "parents", "people", "human", "children"], skins: [{ unified: "1f469-200d-1f469-200d-1f467-200d-1f467", native: "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}" }], version: 2 }, "man-boy": { id: "man-boy", name: "Family: Man, Boy", keywords: ["man", "family", "home", "parent", "people", "human", "child"], skins: [{ unified: "1f468-200d-1f466", native: "\u{1F468}\u200D\u{1F466}" }], version: 4 }, "man-boy-boy": { id: "man-boy-boy", name: "Family: Man, Boy, Boy", keywords: ["man", "boy-boy", "family", "home", "parent", "people", "human", "children"], skins: [{ unified: "1f468-200d-1f466-200d-1f466", native: "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}" }], version: 4 }, "man-girl": { id: "man-girl", name: "Family: Man, Girl", keywords: ["man", "family", "home", "parent", "people", "human", "child"], skins: [{ unified: "1f468-200d-1f467", native: "\u{1F468}\u200D\u{1F467}" }], version: 4 }, "man-girl-boy": { id: "man-girl-boy", name: "Family: Man, Girl, Boy", keywords: ["man", "girl-boy", "family", "girl", "home", "parent", "people", "human", "children"], skins: [{ unified: "1f468-200d-1f467-200d-1f466", native: "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}" }], version: 4 }, "man-girl-girl": { id: "man-girl-girl", name: "Family: Man, Girl, Girl", keywords: ["man", "girl-girl", "family", "home", "parent", "people", "human", "children"], skins: [{ unified: "1f468-200d-1f467-200d-1f467", native: "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}" }], version: 4 }, "woman-boy": { id: "woman-boy", name: "Family: Woman, Boy", keywords: ["woman", "family", "home", "parent", "people", "human", "child"], skins: [{ unified: "1f469-200d-1f466", native: "\u{1F469}\u200D\u{1F466}" }], version: 4 }, "woman-boy-boy": { id: "woman-boy-boy", name: "Family: Woman, Boy, Boy", keywords: ["woman", "boy-boy", "family", "home", "parent", "people", "human", "children"], skins: [{ unified: "1f469-200d-1f466-200d-1f466", native: "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}" }], version: 4 }, "woman-girl": { id: "woman-girl", name: "Family: Woman, Girl", keywords: ["woman", "family", "home", "parent", "people", "human", "child"], skins: [{ unified: "1f469-200d-1f467", native: "\u{1F469}\u200D\u{1F467}" }], version: 4 }, "woman-girl-boy": { id: "woman-girl-boy", name: "Family: Woman, Girl, Boy", keywords: ["woman", "girl-boy", "family", "girl", "home", "parent", "people", "human", "children"], skins: [{ unified: "1f469-200d-1f467-200d-1f466", native: "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}" }], version: 4 }, "woman-girl-girl": { id: "woman-girl-girl", name: "Family: Woman, Girl, Girl", keywords: ["woman", "girl-girl", "family", "home", "parent", "people", "human", "children"], skins: [{ unified: "1f469-200d-1f467-200d-1f467", native: "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}" }], version: 4 }, speaking_head_in_silhouette: { id: "speaking_head_in_silhouette", name: "Speaking Head", keywords: ["in", "silhouette", "user", "person", "human", "sing", "say", "talk"], skins: [{ unified: "1f5e3-fe0f", native: "\u{1F5E3}\uFE0F" }], version: 1 }, bust_in_silhouette: { id: "bust_in_silhouette", name: "Bust in Silhouette", keywords: ["user", "person", "human"], skins: [{ unified: "1f464", native: "\u{1F464}" }], version: 1 }, busts_in_silhouette: { id: "busts_in_silhouette", name: "Busts in Silhouette", keywords: ["user", "person", "human", "group", "team"], skins: [{ unified: "1f465", native: "\u{1F465}" }], version: 1 }, people_hugging: { id: "people_hugging", name: "People Hugging", keywords: ["care"], skins: [{ unified: "1fac2", native: "\u{1FAC2}" }], version: 13 }, footprints: { id: "footprints", name: "Footprints", keywords: ["feet", "tracking", "walking", "beach"], skins: [{ unified: "1f463", native: "\u{1F463}" }], version: 1 }, monkey_face: { id: "monkey_face", name: "Monkey Face", emoticons: [":o)"], keywords: ["animal", "nature", "circus"], skins: [{ unified: "1f435", native: "\u{1F435}" }], version: 1 }, monkey: { id: "monkey", name: "Monkey", keywords: ["animal", "nature", "banana", "circus"], skins: [{ unified: "1f412", native: "\u{1F412}" }], version: 1 }, gorilla: { id: "gorilla", name: "Gorilla", keywords: ["animal", "nature", "circus"], skins: [{ unified: "1f98d", native: "\u{1F98D}" }], version: 3 }, orangutan: { id: "orangutan", name: "Orangutan", keywords: ["animal"], skins: [{ unified: "1f9a7", native: "\u{1F9A7}" }], version: 12 }, dog: { id: "dog", name: "Dog Face", keywords: ["animal", "friend", "nature", "woof", "puppy", "pet", "faithful"], skins: [{ unified: "1f436", native: "\u{1F436}" }], version: 1 }, dog2: { id: "dog2", name: "Dog", keywords: ["dog2", "animal", "nature", "friend", "doge", "pet", "faithful"], skins: [{ unified: "1f415", native: "\u{1F415}" }], version: 1 }, guide_dog: { id: "guide_dog", name: "Guide Dog", keywords: ["animal", "blind"], skins: [{ unified: "1f9ae", native: "\u{1F9AE}" }], version: 12 }, service_dog: { id: "service_dog", name: "Service Dog", keywords: ["blind", "animal"], skins: [{ unified: "1f415-200d-1f9ba", native: "\u{1F415}\u200D\u{1F9BA}" }], version: 12 }, poodle: { id: "poodle", name: "Poodle", keywords: ["dog", "animal", "101", "nature", "pet"], skins: [{ unified: "1f429", native: "\u{1F429}" }], version: 1 }, wolf: { id: "wolf", name: "Wolf", keywords: ["animal", "nature", "wild"], skins: [{ unified: "1f43a", native: "\u{1F43A}" }], version: 1 }, fox_face: { id: "fox_face", name: "Fox", keywords: ["face", "animal", "nature"], skins: [{ unified: "1f98a", native: "\u{1F98A}" }], version: 3 }, raccoon: { id: "raccoon", name: "Raccoon", keywords: ["animal", "nature"], skins: [{ unified: "1f99d", native: "\u{1F99D}" }], version: 11 }, cat: { id: "cat", name: "Cat Face", keywords: ["animal", "meow", "nature", "pet", "kitten"], skins: [{ unified: "1f431", native: "\u{1F431}" }], version: 1 }, cat2: { id: "cat2", name: "Cat", keywords: ["cat2", "animal", "meow", "pet", "cats"], skins: [{ unified: "1f408", native: "\u{1F408}" }], version: 1 }, black_cat: { id: "black_cat", name: "Black Cat", keywords: ["superstition", "luck"], skins: [{ unified: "1f408-200d-2b1b", native: "\u{1F408}\u200D\u2B1B" }], version: 13 }, lion_face: { id: "lion_face", name: "Lion", keywords: ["face", "animal", "nature"], skins: [{ unified: "1f981", native: "\u{1F981}" }], version: 1 }, tiger: { id: "tiger", name: "Tiger Face", keywords: ["animal", "cat", "danger", "wild", "nature", "roar"], skins: [{ unified: "1f42f", native: "\u{1F42F}" }], version: 1 }, tiger2: { id: "tiger2", name: "Tiger", keywords: ["tiger2", "animal", "nature", "roar"], skins: [{ unified: "1f405", native: "\u{1F405}" }], version: 1 }, leopard: { id: "leopard", name: "Leopard", keywords: ["animal", "nature"], skins: [{ unified: "1f406", native: "\u{1F406}" }], version: 1 }, horse: { id: "horse", name: "Horse Face", keywords: ["animal", "brown", "nature"], skins: [{ unified: "1f434", native: "\u{1F434}" }], version: 1 }, moose: { id: "moose", name: "Moose", keywords: ["shrek", "canada", "sweden", "sven", "cool"], skins: [{ unified: "1face", native: "\u{1FACE}" }], version: 15 }, donkey: { id: "donkey", name: "Donkey", keywords: ["eeyore", "mule"], skins: [{ unified: "1facf", native: "\u{1FACF}" }], version: 15 }, racehorse: { id: "racehorse", name: "Horse", keywords: ["racehorse", "animal", "gamble", "luck"], skins: [{ unified: "1f40e", native: "\u{1F40E}" }], version: 1 }, unicorn_face: { id: "unicorn_face", name: "Unicorn", keywords: ["face", "animal", "nature", "mystical"], skins: [{ unified: "1f984", native: "\u{1F984}" }], version: 1 }, zebra_face: { id: "zebra_face", name: "Zebra", keywords: ["face", "animal", "nature", "stripes", "safari"], skins: [{ unified: "1f993", native: "\u{1F993}" }], version: 5 }, deer: { id: "deer", name: "Deer", keywords: ["animal", "nature", "horns", "venison"], skins: [{ unified: "1f98c", native: "\u{1F98C}" }], version: 3 }, bison: { id: "bison", name: "Bison", keywords: ["ox"], skins: [{ unified: "1f9ac", native: "\u{1F9AC}" }], version: 13 }, cow: { id: "cow", name: "Cow Face", keywords: ["beef", "ox", "animal", "nature", "moo", "milk"], skins: [{ unified: "1f42e", native: "\u{1F42E}" }], version: 1 }, ox: { id: "ox", name: "Ox", keywords: ["animal", "cow", "beef"], skins: [{ unified: "1f402", native: "\u{1F402}" }], version: 1 }, water_buffalo: { id: "water_buffalo", name: "Water Buffalo", keywords: ["animal", "nature", "ox", "cow"], skins: [{ unified: "1f403", native: "\u{1F403}" }], version: 1 }, cow2: { id: "cow2", name: "Cow", keywords: ["cow2", "beef", "ox", "animal", "nature", "moo", "milk"], skins: [{ unified: "1f404", native: "\u{1F404}" }], version: 1 }, pig: { id: "pig", name: "Pig Face", keywords: ["animal", "oink", "nature"], skins: [{ unified: "1f437", native: "\u{1F437}" }], version: 1 }, pig2: { id: "pig2", name: "Pig", keywords: ["pig2", "animal", "nature"], skins: [{ unified: "1f416", native: "\u{1F416}" }], version: 1 }, boar: { id: "boar", name: "Boar", keywords: ["animal", "nature"], skins: [{ unified: "1f417", native: "\u{1F417}" }], version: 1 }, pig_nose: { id: "pig_nose", name: "Pig Nose", keywords: ["animal", "oink"], skins: [{ unified: "1f43d", native: "\u{1F43D}" }], version: 1 }, ram: { id: "ram", name: "Ram", keywords: ["animal", "sheep", "nature"], skins: [{ unified: "1f40f", native: "\u{1F40F}" }], version: 1 }, sheep: { id: "sheep", name: "Ewe", keywords: ["sheep", "animal", "nature", "wool", "shipit"], skins: [{ unified: "1f411", native: "\u{1F411}" }], version: 1 }, goat: { id: "goat", name: "Goat", keywords: ["animal", "nature"], skins: [{ unified: "1f410", native: "\u{1F410}" }], version: 1 }, dromedary_camel: { id: "dromedary_camel", name: "Camel", keywords: ["dromedary", "animal", "hot", "desert", "hump"], skins: [{ unified: "1f42a", native: "\u{1F42A}" }], version: 1 }, camel: { id: "camel", name: "Bactrian Camel", keywords: ["two", "hump", "animal", "nature", "hot", "desert"], skins: [{ unified: "1f42b", native: "\u{1F42B}" }], version: 1 }, llama: { id: "llama", name: "Llama", keywords: ["animal", "nature", "alpaca"], skins: [{ unified: "1f999", native: "\u{1F999}" }], version: 11 }, giraffe_face: { id: "giraffe_face", name: "Giraffe", keywords: ["face", "animal", "nature", "spots", "safari"], skins: [{ unified: "1f992", native: "\u{1F992}" }], version: 5 }, elephant: { id: "elephant", name: "Elephant", keywords: ["animal", "nature", "nose", "th", "circus"], skins: [{ unified: "1f418", native: "\u{1F418}" }], version: 1 }, mammoth: { id: "mammoth", name: "Mammoth", keywords: ["elephant", "tusks"], skins: [{ unified: "1f9a3", native: "\u{1F9A3}" }], version: 13 }, rhinoceros: { id: "rhinoceros", name: "Rhinoceros", keywords: ["animal", "nature", "horn"], skins: [{ unified: "1f98f", native: "\u{1F98F}" }], version: 3 }, hippopotamus: { id: "hippopotamus", name: "Hippopotamus", keywords: ["animal", "nature"], skins: [{ unified: "1f99b", native: "\u{1F99B}" }], version: 11 }, mouse: { id: "mouse", name: "Mouse Face", keywords: ["animal", "nature", "cheese", "wedge", "rodent"], skins: [{ unified: "1f42d", native: "\u{1F42D}" }], version: 1 }, mouse2: { id: "mouse2", name: "Mouse", keywords: ["mouse2", "animal", "nature", "rodent"], skins: [{ unified: "1f401", native: "\u{1F401}" }], version: 1 }, rat: { id: "rat", name: "Rat", keywords: ["animal", "mouse", "rodent"], skins: [{ unified: "1f400", native: "\u{1F400}" }], version: 1 }, hamster: { id: "hamster", name: "Hamster", keywords: ["animal", "nature"], skins: [{ unified: "1f439", native: "\u{1F439}" }], version: 1 }, rabbit: { id: "rabbit", name: "Rabbit Face", keywords: ["animal", "nature", "pet", "spring", "magic", "bunny"], skins: [{ unified: "1f430", native: "\u{1F430}" }], version: 1 }, rabbit2: { id: "rabbit2", name: "Rabbit", keywords: ["rabbit2", "animal", "nature", "pet", "magic", "spring"], skins: [{ unified: "1f407", native: "\u{1F407}" }], version: 1 }, chipmunk: { id: "chipmunk", name: "Chipmunk", keywords: ["animal", "nature", "rodent", "squirrel"], skins: [{ unified: "1f43f-fe0f", native: "\u{1F43F}\uFE0F" }], version: 1 }, beaver: { id: "beaver", name: "Beaver", keywords: ["animal", "rodent"], skins: [{ unified: "1f9ab", native: "\u{1F9AB}" }], version: 13 }, hedgehog: { id: "hedgehog", name: "Hedgehog", keywords: ["animal", "nature", "spiny"], skins: [{ unified: "1f994", native: "\u{1F994}" }], version: 5 }, bat: { id: "bat", name: "Bat", keywords: ["animal", "nature", "blind", "vampire"], skins: [{ unified: "1f987", native: "\u{1F987}" }], version: 3 }, bear: { id: "bear", name: "Bear", keywords: ["animal", "nature", "wild"], skins: [{ unified: "1f43b", native: "\u{1F43B}" }], version: 1 }, polar_bear: { id: "polar_bear", name: "Polar Bear", keywords: ["animal", "arctic"], skins: [{ unified: "1f43b-200d-2744-fe0f", native: "\u{1F43B}\u200D\u2744\uFE0F" }], version: 13 }, koala: { id: "koala", name: "Koala", keywords: ["animal", "nature"], skins: [{ unified: "1f428", native: "\u{1F428}" }], version: 1 }, panda_face: { id: "panda_face", name: "Panda", keywords: ["face", "animal", "nature"], skins: [{ unified: "1f43c", native: "\u{1F43C}" }], version: 1 }, sloth: { id: "sloth", name: "Sloth", keywords: ["animal"], skins: [{ unified: "1f9a5", native: "\u{1F9A5}" }], version: 12 }, otter: { id: "otter", name: "Otter", keywords: ["animal"], skins: [{ unified: "1f9a6", native: "\u{1F9A6}" }], version: 12 }, skunk: { id: "skunk", name: "Skunk", keywords: ["animal"], skins: [{ unified: "1f9a8", native: "\u{1F9A8}" }], version: 12 }, kangaroo: { id: "kangaroo", name: "Kangaroo", keywords: ["animal", "nature", "australia", "joey", "hop", "marsupial"], skins: [{ unified: "1f998", native: "\u{1F998}" }], version: 11 }, badger: { id: "badger", name: "Badger", keywords: ["animal", "nature", "honey"], skins: [{ unified: "1f9a1", native: "\u{1F9A1}" }], version: 11 }, feet: { id: "feet", name: "Paw Prints", keywords: ["feet", "animal", "tracking", "footprints", "dog", "cat", "pet"], skins: [{ unified: "1f43e", native: "\u{1F43E}" }], version: 1 }, turkey: { id: "turkey", name: "Turkey", keywords: ["animal", "bird"], skins: [{ unified: "1f983", native: "\u{1F983}" }], version: 1 }, chicken: { id: "chicken", name: "Chicken", keywords: ["animal", "cluck", "nature", "bird"], skins: [{ unified: "1f414", native: "\u{1F414}" }], version: 1 }, rooster: { id: "rooster", name: "Rooster", keywords: ["animal", "nature", "chicken"], skins: [{ unified: "1f413", native: "\u{1F413}" }], version: 1 }, hatching_chick: { id: "hatching_chick", name: "Hatching Chick", keywords: ["animal", "chicken", "egg", "born", "baby", "bird"], skins: [{ unified: "1f423", native: "\u{1F423}" }], version: 1 }, baby_chick: { id: "baby_chick", name: "Baby Chick", keywords: ["animal", "chicken", "bird"], skins: [{ unified: "1f424", native: "\u{1F424}" }], version: 1 }, hatched_chick: { id: "hatched_chick", name: "Front-Facing Baby Chick", keywords: ["hatched", "front", "facing", "animal", "chicken", "bird"], skins: [{ unified: "1f425", native: "\u{1F425}" }], version: 1 }, bird: { id: "bird", name: "Bird", keywords: ["animal", "nature", "fly", "tweet", "spring"], skins: [{ unified: "1f426", native: "\u{1F426}" }], version: 1 }, penguin: { id: "penguin", name: "Penguin", keywords: ["animal", "nature"], skins: [{ unified: "1f427", native: "\u{1F427}" }], version: 1 }, dove_of_peace: { id: "dove_of_peace", name: "Dove", keywords: ["of", "peace", "animal", "bird"], skins: [{ unified: "1f54a-fe0f", native: "\u{1F54A}\uFE0F" }], version: 1 }, eagle: { id: "eagle", name: "Eagle", keywords: ["animal", "nature", "bird"], skins: [{ unified: "1f985", native: "\u{1F985}" }], version: 3 }, duck: { id: "duck", name: "Duck", keywords: ["animal", "nature", "bird", "mallard"], skins: [{ unified: "1f986", native: "\u{1F986}" }], version: 3 }, swan: { id: "swan", name: "Swan", keywords: ["animal", "nature", "bird"], skins: [{ unified: "1f9a2", native: "\u{1F9A2}" }], version: 11 }, owl: { id: "owl", name: "Owl", keywords: ["animal", "nature", "bird", "hoot"], skins: [{ unified: "1f989", native: "\u{1F989}" }], version: 3 }, dodo: { id: "dodo", name: "Dodo", keywords: ["animal", "bird"], skins: [{ unified: "1f9a4", native: "\u{1F9A4}" }], version: 13 }, feather: { id: "feather", name: "Feather", keywords: ["bird", "fly"], skins: [{ unified: "1fab6", native: "\u{1FAB6}" }], version: 13 }, flamingo: { id: "flamingo", name: "Flamingo", keywords: ["animal"], skins: [{ unified: "1f9a9", native: "\u{1F9A9}" }], version: 12 }, peacock: { id: "peacock", name: "Peacock", keywords: ["animal", "nature", "peahen", "bird"], skins: [{ unified: "1f99a", native: "\u{1F99A}" }], version: 11 }, parrot: { id: "parrot", name: "Parrot", keywords: ["animal", "nature", "bird", "pirate", "talk"], skins: [{ unified: "1f99c", native: "\u{1F99C}" }], version: 11 }, wing: { id: "wing", name: "Wing", keywords: ["angel", "birds", "flying"], skins: [{ unified: "1fabd", native: "\u{1FABD}" }], version: 15 }, black_bird: { id: "black_bird", name: "Black Bird", keywords: ["crow"], skins: [{ unified: "1f426-200d-2b1b", native: "\u{1F426}\u200D\u2B1B" }], version: 15 }, goose: { id: "goose", name: "Goose", keywords: ["silly", "jemima", "goosebumps"], skins: [{ unified: "1fabf", native: "\u{1FABF}" }], version: 15 }, frog: { id: "frog", name: "Frog", keywords: ["animal", "nature", "croak", "toad"], skins: [{ unified: "1f438", native: "\u{1F438}" }], version: 1 }, crocodile: { id: "crocodile", name: "Crocodile", keywords: ["animal", "nature", "reptile", "lizard", "alligator"], skins: [{ unified: "1f40a", native: "\u{1F40A}" }], version: 1 }, turtle: { id: "turtle", name: "Turtle", keywords: ["animal", "slow", "nature", "tortoise"], skins: [{ unified: "1f422", native: "\u{1F422}" }], version: 1 }, lizard: { id: "lizard", name: "Lizard", keywords: ["animal", "nature", "reptile"], skins: [{ unified: "1f98e", native: "\u{1F98E}" }], version: 3 }, snake: { id: "snake", name: "Snake", keywords: ["animal", "evil", "nature", "hiss", "python"], skins: [{ unified: "1f40d", native: "\u{1F40D}" }], version: 1 }, dragon_face: { id: "dragon_face", name: "Dragon Face", keywords: ["animal", "myth", "nature", "chinese", "green"], skins: [{ unified: "1f432", native: "\u{1F432}" }], version: 1 }, dragon: { id: "dragon", name: "Dragon", keywords: ["animal", "myth", "nature", "chinese", "green"], skins: [{ unified: "1f409", native: "\u{1F409}" }], version: 1 }, sauropod: { id: "sauropod", name: "Sauropod", keywords: ["animal", "nature", "dinosaur", "brachiosaurus", "brontosaurus", "diplodocus", "extinct"], skins: [{ unified: "1f995", native: "\u{1F995}" }], version: 5 }, "t-rex": { id: "t-rex", name: "T-Rex", keywords: ["t", "rex", "animal", "nature", "dinosaur", "tyrannosaurus", "extinct"], skins: [{ unified: "1f996", native: "\u{1F996}" }], version: 5 }, whale: { id: "whale", name: "Spouting Whale", keywords: ["animal", "nature", "sea", "ocean"], skins: [{ unified: "1f433", native: "\u{1F433}" }], version: 1 }, whale2: { id: "whale2", name: "Whale", keywords: ["whale2", "animal", "nature", "sea", "ocean"], skins: [{ unified: "1f40b", native: "\u{1F40B}" }], version: 1 }, dolphin: { id: "dolphin", name: "Dolphin", keywords: ["flipper", "animal", "nature", "fish", "sea", "ocean", "fins", "beach"], skins: [{ unified: "1f42c", native: "\u{1F42C}" }], version: 1 }, seal: { id: "seal", name: "Seal", keywords: ["animal", "creature", "sea"], skins: [{ unified: "1f9ad", native: "\u{1F9AD}" }], version: 13 }, fish: { id: "fish", name: "Fish", keywords: ["animal", "food", "nature"], skins: [{ unified: "1f41f", native: "\u{1F41F}" }], version: 1 }, tropical_fish: { id: "tropical_fish", name: "Tropical Fish", keywords: ["animal", "swim", "ocean", "beach", "nemo"], skins: [{ unified: "1f420", native: "\u{1F420}" }], version: 1 }, blowfish: { id: "blowfish", name: "Blowfish", keywords: ["animal", "nature", "food", "sea", "ocean"], skins: [{ unified: "1f421", native: "\u{1F421}" }], version: 1 }, shark: { id: "shark", name: "Shark", keywords: ["animal", "nature", "fish", "sea", "ocean", "jaws", "fins", "beach"], skins: [{ unified: "1f988", native: "\u{1F988}" }], version: 3 }, octopus: { id: "octopus", name: "Octopus", keywords: ["animal", "creature", "ocean", "sea", "nature", "beach"], skins: [{ unified: "1f419", native: "\u{1F419}" }], version: 1 }, shell: { id: "shell", name: "Spiral Shell", keywords: ["nature", "sea", "beach"], skins: [{ unified: "1f41a", native: "\u{1F41A}" }], version: 1 }, coral: { id: "coral", name: "Coral", keywords: ["ocean", "sea", "reef"], skins: [{ unified: "1fab8", native: "\u{1FAB8}" }], version: 14 }, jellyfish: { id: "jellyfish", name: "Jellyfish", keywords: ["sting", "tentacles"], skins: [{ unified: "1fabc", native: "\u{1FABC}" }], version: 15 }, snail: { id: "snail", name: "Snail", keywords: ["slow", "animal", "shell"], skins: [{ unified: "1f40c", native: "\u{1F40C}" }], version: 1 }, butterfly: { id: "butterfly", name: "Butterfly", keywords: ["animal", "insect", "nature", "caterpillar"], skins: [{ unified: "1f98b", native: "\u{1F98B}" }], version: 3 }, bug: { id: "bug", name: "Bug", keywords: ["animal", "insect", "nature", "worm"], skins: [{ unified: "1f41b", native: "\u{1F41B}" }], version: 1 }, ant: { id: "ant", name: "Ant", keywords: ["animal", "insect", "nature", "bug"], skins: [{ unified: "1f41c", native: "\u{1F41C}" }], version: 1 }, bee: { id: "bee", name: "Honeybee", keywords: ["bee", "animal", "insect", "nature", "bug", "spring", "honey"], skins: [{ unified: "1f41d", native: "\u{1F41D}" }], version: 1 }, beetle: { id: "beetle", name: "Beetle", keywords: ["insect"], skins: [{ unified: "1fab2", native: "\u{1FAB2}" }], version: 13 }, ladybug: { id: "ladybug", name: "Lady Beetle", keywords: ["ladybug", "animal", "insect", "nature"], skins: [{ unified: "1f41e", native: "\u{1F41E}" }], version: 1 }, cricket: { id: "cricket", name: "Cricket", keywords: ["animal", "chirp"], skins: [{ unified: "1f997", native: "\u{1F997}" }], version: 5 }, cockroach: { id: "cockroach", name: "Cockroach", keywords: ["insect", "pests"], skins: [{ unified: "1fab3", native: "\u{1FAB3}" }], version: 13 }, spider: { id: "spider", name: "Spider", keywords: ["animal", "arachnid"], skins: [{ unified: "1f577-fe0f", native: "\u{1F577}\uFE0F" }], version: 1 }, spider_web: { id: "spider_web", name: "Spider Web", keywords: ["animal", "insect", "arachnid", "silk"], skins: [{ unified: "1f578-fe0f", native: "\u{1F578}\uFE0F" }], version: 1 }, scorpion: { id: "scorpion", name: "Scorpion", keywords: ["animal", "arachnid"], skins: [{ unified: "1f982", native: "\u{1F982}" }], version: 1 }, mosquito: { id: "mosquito", name: "Mosquito", keywords: ["animal", "nature", "insect", "malaria"], skins: [{ unified: "1f99f", native: "\u{1F99F}" }], version: 11 }, fly: { id: "fly", name: "Fly", keywords: ["insect"], skins: [{ unified: "1fab0", native: "\u{1FAB0}" }], version: 13 }, worm: { id: "worm", name: "Worm", keywords: ["animal"], skins: [{ unified: "1fab1", native: "\u{1FAB1}" }], version: 13 }, microbe: { id: "microbe", name: "Microbe", keywords: ["amoeba", "bacteria", "germs", "virus", "covid"], skins: [{ unified: "1f9a0", native: "\u{1F9A0}" }], version: 11 }, bouquet: { id: "bouquet", name: "Bouquet", keywords: ["flowers", "nature", "spring"], skins: [{ unified: "1f490", native: "\u{1F490}" }], version: 1 }, cherry_blossom: { id: "cherry_blossom", name: "Cherry Blossom", keywords: ["nature", "plant", "spring", "flower"], skins: [{ unified: "1f338", native: "\u{1F338}" }], version: 1 }, white_flower: { id: "white_flower", name: "White Flower", keywords: ["japanese", "spring"], skins: [{ unified: "1f4ae", native: "\u{1F4AE}" }], version: 1 }, lotus: { id: "lotus", name: "Lotus", keywords: ["flower", "calm", "meditation"], skins: [{ unified: "1fab7", native: "\u{1FAB7}" }], version: 14 }, rosette: { id: "rosette", name: "Rosette", keywords: ["flower", "decoration", "military"], skins: [{ unified: "1f3f5-fe0f", native: "\u{1F3F5}\uFE0F" }], version: 1 }, rose: { id: "rose", name: "Rose", keywords: ["flowers", "valentines", "love", "spring"], skins: [{ unified: "1f339", native: "\u{1F339}" }], version: 1 }, wilted_flower: { id: "wilted_flower", name: "Wilted Flower", keywords: ["plant", "nature", "rose"], skins: [{ unified: "1f940", native: "\u{1F940}" }], version: 3 }, hibiscus: { id: "hibiscus", name: "Hibiscus", keywords: ["plant", "vegetable", "flowers", "beach"], skins: [{ unified: "1f33a", native: "\u{1F33A}" }], version: 1 }, sunflower: { id: "sunflower", name: "Sunflower", keywords: ["nature", "plant", "fall"], skins: [{ unified: "1f33b", native: "\u{1F33B}" }], version: 1 }, blossom: { id: "blossom", name: "Blossom", keywords: ["nature", "flowers", "yellow"], skins: [{ unified: "1f33c", native: "\u{1F33C}" }], version: 1 }, tulip: { id: "tulip", name: "Tulip", keywords: ["flowers", "plant", "nature", "summer", "spring"], skins: [{ unified: "1f337", native: "\u{1F337}" }], version: 1 }, hyacinth: { id: "hyacinth", name: "Hyacinth", keywords: ["flower", "lavender"], skins: [{ unified: "1fabb", native: "\u{1FABB}" }], version: 15 }, seedling: { id: "seedling", name: "Seedling", keywords: ["plant", "nature", "grass", "lawn", "spring"], skins: [{ unified: "1f331", native: "\u{1F331}" }], version: 1 }, potted_plant: { id: "potted_plant", name: "Potted Plant", keywords: ["greenery", "house"], skins: [{ unified: "1fab4", native: "\u{1FAB4}" }], version: 13 }, evergreen_tree: { id: "evergreen_tree", name: "Evergreen Tree", keywords: ["plant", "nature"], skins: [{ unified: "1f332", native: "\u{1F332}" }], version: 1 }, deciduous_tree: { id: "deciduous_tree", name: "Deciduous Tree", keywords: ["plant", "nature"], skins: [{ unified: "1f333", native: "\u{1F333}" }], version: 1 }, palm_tree: { id: "palm_tree", name: "Palm Tree", keywords: ["plant", "vegetable", "nature", "summer", "beach", "mojito", "tropical"], skins: [{ unified: "1f334", native: "\u{1F334}" }], version: 1 }, cactus: { id: "cactus", name: "Cactus", keywords: ["vegetable", "plant", "nature"], skins: [{ unified: "1f335", native: "\u{1F335}" }], version: 1 }, ear_of_rice: { id: "ear_of_rice", name: "Ear of Rice", keywords: ["sheaf", "nature", "plant"], skins: [{ unified: "1f33e", native: "\u{1F33E}" }], version: 1 }, herb: { id: "herb", name: "Herb", keywords: ["vegetable", "plant", "medicine", "weed", "grass", "lawn"], skins: [{ unified: "1f33f", native: "\u{1F33F}" }], version: 1 }, shamrock: { id: "shamrock", name: "Shamrock", keywords: ["vegetable", "plant", "nature", "irish", "clover"], skins: [{ unified: "2618-fe0f", native: "\u2618\uFE0F" }], version: 1 }, four_leaf_clover: { id: "four_leaf_clover", name: "Four Leaf Clover", keywords: ["vegetable", "plant", "nature", "lucky", "irish"], skins: [{ unified: "1f340", native: "\u{1F340}" }], version: 1 }, maple_leaf: { id: "maple_leaf", name: "Maple Leaf", keywords: ["nature", "plant", "vegetable", "ca", "fall"], skins: [{ unified: "1f341", native: "\u{1F341}" }], version: 1 }, fallen_leaf: { id: "fallen_leaf", name: "Fallen Leaf", keywords: ["nature", "plant", "vegetable", "leaves"], skins: [{ unified: "1f342", native: "\u{1F342}" }], version: 1 }, leaves: { id: "leaves", name: "Leaf Fluttering in Wind", keywords: ["leaves", "nature", "plant", "tree", "vegetable", "grass", "lawn", "spring"], skins: [{ unified: "1f343", native: "\u{1F343}" }], version: 1 }, empty_nest: { id: "empty_nest", name: "Empty Nest", keywords: ["bird"], skins: [{ unified: "1fab9", native: "\u{1FAB9}" }], version: 14 }, nest_with_eggs: { id: "nest_with_eggs", name: "Nest with Eggs", keywords: ["bird"], skins: [{ unified: "1faba", native: "\u{1FABA}" }], version: 14 }, mushroom: { id: "mushroom", name: "Mushroom", keywords: ["plant", "vegetable"], skins: [{ unified: "1f344", native: "\u{1F344}" }], version: 1 }, grapes: { id: "grapes", name: "Grapes", keywords: ["fruit", "food", "wine"], skins: [{ unified: "1f347", native: "\u{1F347}" }], version: 1 }, melon: { id: "melon", name: "Melon", keywords: ["fruit", "nature", "food"], skins: [{ unified: "1f348", native: "\u{1F348}" }], version: 1 }, watermelon: { id: "watermelon", name: "Watermelon", keywords: ["fruit", "food", "picnic", "summer"], skins: [{ unified: "1f349", native: "\u{1F349}" }], version: 1 }, tangerine: { id: "tangerine", name: "Tangerine", keywords: ["food", "fruit", "nature", "orange"], skins: [{ unified: "1f34a", native: "\u{1F34A}" }], version: 1 }, lemon: { id: "lemon", name: "Lemon", keywords: ["fruit", "nature"], skins: [{ unified: "1f34b", native: "\u{1F34B}" }], version: 1 }, banana: { id: "banana", name: "Banana", keywords: ["fruit", "food", "monkey"], skins: [{ unified: "1f34c", native: "\u{1F34C}" }], version: 1 }, pineapple: { id: "pineapple", name: "Pineapple", keywords: ["fruit", "nature", "food"], skins: [{ unified: "1f34d", native: "\u{1F34D}" }], version: 1 }, mango: { id: "mango", name: "Mango", keywords: ["fruit", "food", "tropical"], skins: [{ unified: "1f96d", native: "\u{1F96D}" }], version: 11 }, apple: { id: "apple", name: "Red Apple", keywords: ["fruit", "mac", "school"], skins: [{ unified: "1f34e", native: "\u{1F34E}" }], version: 1 }, green_apple: { id: "green_apple", name: "Green Apple", keywords: ["fruit", "nature"], skins: [{ unified: "1f34f", native: "\u{1F34F}" }], version: 1 }, pear: { id: "pear", name: "Pear", keywords: ["fruit", "nature", "food"], skins: [{ unified: "1f350", native: "\u{1F350}" }], version: 1 }, peach: { id: "peach", name: "Peach", keywords: ["fruit", "nature", "food"], skins: [{ unified: "1f351", native: "\u{1F351}" }], version: 1 }, cherries: { id: "cherries", name: "Cherries", keywords: ["food", "fruit"], skins: [{ unified: "1f352", native: "\u{1F352}" }], version: 1 }, strawberry: { id: "strawberry", name: "Strawberry", keywords: ["fruit", "food", "nature"], skins: [{ unified: "1f353", native: "\u{1F353}" }], version: 1 }, blueberries: { id: "blueberries", name: "Blueberries", keywords: ["fruit"], skins: [{ unified: "1fad0", native: "\u{1FAD0}" }], version: 13 }, kiwifruit: { id: "kiwifruit", name: "Kiwifruit", keywords: ["kiwi", "fruit", "food"], skins: [{ unified: "1f95d", native: "\u{1F95D}" }], version: 3 }, tomato: { id: "tomato", name: "Tomato", keywords: ["fruit", "vegetable", "nature", "food"], skins: [{ unified: "1f345", native: "\u{1F345}" }], version: 1 }, olive: { id: "olive", name: "Olive", keywords: ["fruit"], skins: [{ unified: "1fad2", native: "\u{1FAD2}" }], version: 13 }, coconut: { id: "coconut", name: "Coconut", keywords: ["fruit", "nature", "food", "palm"], skins: [{ unified: "1f965", native: "\u{1F965}" }], version: 5 }, avocado: { id: "avocado", name: "Avocado", keywords: ["fruit", "food"], skins: [{ unified: "1f951", native: "\u{1F951}" }], version: 3 }, eggplant: { id: "eggplant", name: "Eggplant", keywords: ["vegetable", "nature", "food", "aubergine"], skins: [{ unified: "1f346", native: "\u{1F346}" }], version: 1 }, potato: { id: "potato", name: "Potato", keywords: ["food", "tuber", "vegatable", "starch"], skins: [{ unified: "1f954", native: "\u{1F954}" }], version: 3 }, carrot: { id: "carrot", name: "Carrot", keywords: ["vegetable", "food", "orange"], skins: [{ unified: "1f955", native: "\u{1F955}" }], version: 3 }, corn: { id: "corn", name: "Ear of Corn", keywords: ["food", "vegetable", "plant"], skins: [{ unified: "1f33d", native: "\u{1F33D}" }], version: 1 }, hot_pepper: { id: "hot_pepper", name: "Hot Pepper", keywords: ["food", "spicy", "chilli", "chili"], skins: [{ unified: "1f336-fe0f", native: "\u{1F336}\uFE0F" }], version: 1 }, bell_pepper: { id: "bell_pepper", name: "Bell Pepper", keywords: ["fruit", "plant"], skins: [{ unified: "1fad1", native: "\u{1FAD1}" }], version: 13 }, cucumber: { id: "cucumber", name: "Cucumber", keywords: ["fruit", "food", "pickle"], skins: [{ unified: "1f952", native: "\u{1F952}" }], version: 3 }, leafy_green: { id: "leafy_green", name: "Leafy Green", keywords: ["food", "vegetable", "plant", "bok", "choy", "cabbage", "kale", "lettuce"], skins: [{ unified: "1f96c", native: "\u{1F96C}" }], version: 11 }, broccoli: { id: "broccoli", name: "Broccoli", keywords: ["fruit", "food", "vegetable"], skins: [{ unified: "1f966", native: "\u{1F966}" }], version: 5 }, garlic: { id: "garlic", name: "Garlic", keywords: ["food", "spice", "cook"], skins: [{ unified: "1f9c4", native: "\u{1F9C4}" }], version: 12 }, onion: { id: "onion", name: "Onion", keywords: ["cook", "food", "spice"], skins: [{ unified: "1f9c5", native: "\u{1F9C5}" }], version: 12 }, peanuts: { id: "peanuts", name: "Peanuts", keywords: ["food", "nut"], skins: [{ unified: "1f95c", native: "\u{1F95C}" }], version: 3 }, beans: { id: "beans", name: "Beans", keywords: ["food"], skins: [{ unified: "1fad8", native: "\u{1FAD8}" }], version: 14 }, chestnut: { id: "chestnut", name: "Chestnut", keywords: ["food", "squirrel"], skins: [{ unified: "1f330", native: "\u{1F330}" }], version: 1 }, ginger_root: { id: "ginger_root", name: "Ginger Root", keywords: ["spice", "yellow", "cooking", "gingerbread"], skins: [{ unified: "1fada", native: "\u{1FADA}" }], version: 15 }, pea_pod: { id: "pea_pod", name: "Pea Pod", keywords: ["cozy", "green"], skins: [{ unified: "1fadb", native: "\u{1FADB}" }], version: 15 }, bread: { id: "bread", name: "Bread", keywords: ["food", "wheat", "breakfast", "toast"], skins: [{ unified: "1f35e", native: "\u{1F35E}" }], version: 1 }, croissant: { id: "croissant", name: "Croissant", keywords: ["food", "bread", "french"], skins: [{ unified: "1f950", native: "\u{1F950}" }], version: 3 }, baguette_bread: { id: "baguette_bread", name: "Baguette Bread", keywords: ["food", "french", "france", "bakery"], skins: [{ unified: "1f956", native: "\u{1F956}" }], version: 3 }, flatbread: { id: "flatbread", name: "Flatbread", keywords: ["flour", "food", "bakery"], skins: [{ unified: "1fad3", native: "\u{1FAD3}" }], version: 13 }, pretzel: { id: "pretzel", name: "Pretzel", keywords: ["food", "bread", "twisted", "germany", "bakery"], skins: [{ unified: "1f968", native: "\u{1F968}" }], version: 5 }, bagel: { id: "bagel", name: "Bagel", keywords: ["food", "bread", "bakery", "schmear", "jewish"], skins: [{ unified: "1f96f", native: "\u{1F96F}" }], version: 11 }, pancakes: { id: "pancakes", name: "Pancakes", keywords: ["food", "breakfast", "flapjacks", "hotcakes", "brunch"], skins: [{ unified: "1f95e", native: "\u{1F95E}" }], version: 3 }, waffle: { id: "waffle", name: "Waffle", keywords: ["food", "breakfast", "brunch"], skins: [{ unified: "1f9c7", native: "\u{1F9C7}" }], version: 12 }, cheese_wedge: { id: "cheese_wedge", name: "Cheese Wedge", keywords: ["food", "chadder", "swiss"], skins: [{ unified: "1f9c0", native: "\u{1F9C0}" }], version: 1 }, meat_on_bone: { id: "meat_on_bone", name: "Meat on Bone", keywords: ["good", "food", "drumstick"], skins: [{ unified: "1f356", native: "\u{1F356}" }], version: 1 }, poultry_leg: { id: "poultry_leg", name: "Poultry Leg", keywords: ["food", "meat", "drumstick", "bird", "chicken", "turkey"], skins: [{ unified: "1f357", native: "\u{1F357}" }], version: 1 }, cut_of_meat: { id: "cut_of_meat", name: "Cut of Meat", keywords: ["food", "cow", "chop", "lambchop", "porkchop"], skins: [{ unified: "1f969", native: "\u{1F969}" }], version: 5 }, bacon: { id: "bacon", name: "Bacon", keywords: ["food", "breakfast", "pork", "pig", "meat", "brunch"], skins: [{ unified: "1f953", native: "\u{1F953}" }], version: 3 }, hamburger: { id: "hamburger", name: "Hamburger", keywords: ["meat", "fast", "food", "beef", "cheeseburger", "mcdonalds", "burger", "king"], skins: [{ unified: "1f354", native: "\u{1F354}" }], version: 1 }, fries: { id: "fries", name: "French Fries", keywords: ["chips", "snack", "fast", "food", "potato"], skins: [{ unified: "1f35f", native: "\u{1F35F}" }], version: 1 }, pizza: { id: "pizza", name: "Pizza", keywords: ["food", "party", "italy"], skins: [{ unified: "1f355", native: "\u{1F355}" }], version: 1 }, hotdog: { id: "hotdog", name: "Hot Dog", keywords: ["hotdog", "food", "frankfurter", "america"], skins: [{ unified: "1f32d", native: "\u{1F32D}" }], version: 1 }, sandwich: { id: "sandwich", name: "Sandwich", keywords: ["food", "lunch", "bread", "toast", "bakery"], skins: [{ unified: "1f96a", native: "\u{1F96A}" }], version: 5 }, taco: { id: "taco", name: "Taco", keywords: ["food", "mexican"], skins: [{ unified: "1f32e", native: "\u{1F32E}" }], version: 1 }, burrito: { id: "burrito", name: "Burrito", keywords: ["food", "mexican"], skins: [{ unified: "1f32f", native: "\u{1F32F}" }], version: 1 }, tamale: { id: "tamale", name: "Tamale", keywords: ["food", "masa"], skins: [{ unified: "1fad4", native: "\u{1FAD4}" }], version: 13 }, stuffed_flatbread: { id: "stuffed_flatbread", name: "Stuffed Flatbread", keywords: ["food", "gyro", "mediterranean"], skins: [{ unified: "1f959", native: "\u{1F959}" }], version: 3 }, falafel: { id: "falafel", name: "Falafel", keywords: ["food", "mediterranean"], skins: [{ unified: "1f9c6", native: "\u{1F9C6}" }], version: 12 }, egg: { id: "egg", name: "Egg", keywords: ["food", "chicken", "breakfast"], skins: [{ unified: "1f95a", native: "\u{1F95A}" }], version: 3 }, fried_egg: { id: "fried_egg", name: "Cooking", keywords: ["fried", "egg", "food", "breakfast", "kitchen", "skillet"], skins: [{ unified: "1f373", native: "\u{1F373}" }], version: 1 }, shallow_pan_of_food: { id: "shallow_pan_of_food", name: "Shallow Pan of Food", keywords: ["cooking", "casserole", "paella", "skillet"], skins: [{ unified: "1f958", native: "\u{1F958}" }], version: 3 }, stew: { id: "stew", name: "Pot of Food", keywords: ["stew", "meat", "soup", "hot"], skins: [{ unified: "1f372", native: "\u{1F372}" }], version: 1 }, fondue: { id: "fondue", name: "Fondue", keywords: ["cheese", "pot", "food"], skins: [{ unified: "1fad5", native: "\u{1FAD5}" }], version: 13 }, bowl_with_spoon: { id: "bowl_with_spoon", name: "Bowl with Spoon", keywords: ["food", "breakfast", "cereal", "oatmeal", "porridge"], skins: [{ unified: "1f963", native: "\u{1F963}" }], version: 5 }, green_salad: { id: "green_salad", name: "Green Salad", keywords: ["food", "healthy", "lettuce", "vegetable"], skins: [{ unified: "1f957", native: "\u{1F957}" }], version: 3 }, popcorn: { id: "popcorn", name: "Popcorn", keywords: ["food", "movie", "theater", "films", "snack", "drama"], skins: [{ unified: "1f37f", native: "\u{1F37F}" }], version: 1 }, butter: { id: "butter", name: "Butter", keywords: ["food", "cook"], skins: [{ unified: "1f9c8", native: "\u{1F9C8}" }], version: 12 }, salt: { id: "salt", name: "Salt", keywords: ["condiment", "shaker"], skins: [{ unified: "1f9c2", native: "\u{1F9C2}" }], version: 11 }, canned_food: { id: "canned_food", name: "Canned Food", keywords: ["soup", "tomatoes"], skins: [{ unified: "1f96b", native: "\u{1F96B}" }], version: 5 }, bento: { id: "bento", name: "Bento Box", keywords: ["food", "japanese", "lunch"], skins: [{ unified: "1f371", native: "\u{1F371}" }], version: 1 }, rice_cracker: { id: "rice_cracker", name: "Rice Cracker", keywords: ["food", "japanese", "snack"], skins: [{ unified: "1f358", native: "\u{1F358}" }], version: 1 }, rice_ball: { id: "rice_ball", name: "Rice Ball", keywords: ["food", "japanese"], skins: [{ unified: "1f359", native: "\u{1F359}" }], version: 1 }, rice: { id: "rice", name: "Cooked Rice", keywords: ["food", "asian"], skins: [{ unified: "1f35a", native: "\u{1F35A}" }], version: 1 }, curry: { id: "curry", name: "Curry Rice", keywords: ["food", "spicy", "hot", "indian"], skins: [{ unified: "1f35b", native: "\u{1F35B}" }], version: 1 }, ramen: { id: "ramen", name: "Steaming Bowl", keywords: ["ramen", "food", "japanese", "noodle", "chopsticks"], skins: [{ unified: "1f35c", native: "\u{1F35C}" }], version: 1 }, spaghetti: { id: "spaghetti", name: "Spaghetti", keywords: ["food", "italian", "pasta", "noodle"], skins: [{ unified: "1f35d", native: "\u{1F35D}" }], version: 1 }, sweet_potato: { id: "sweet_potato", name: "Roasted Sweet Potato", keywords: ["food", "nature", "plant"], skins: [{ unified: "1f360", native: "\u{1F360}" }], version: 1 }, oden: { id: "oden", name: "Oden", keywords: ["food", "japanese"], skins: [{ unified: "1f362", native: "\u{1F362}" }], version: 1 }, sushi: { id: "sushi", name: "Sushi", keywords: ["food", "fish", "japanese", "rice"], skins: [{ unified: "1f363", native: "\u{1F363}" }], version: 1 }, fried_shrimp: { id: "fried_shrimp", name: "Fried Shrimp", keywords: ["food", "animal", "appetizer", "summer"], skins: [{ unified: "1f364", native: "\u{1F364}" }], version: 1 }, fish_cake: { id: "fish_cake", name: "Fish Cake with Swirl", keywords: ["food", "japan", "sea", "beach", "narutomaki", "pink", "kamaboko", "surimi", "ramen"], skins: [{ unified: "1f365", native: "\u{1F365}" }], version: 1 }, moon_cake: { id: "moon_cake", name: "Moon Cake", keywords: ["food", "autumn", "dessert"], skins: [{ unified: "1f96e", native: "\u{1F96E}" }], version: 11 }, dango: { id: "dango", name: "Dango", keywords: ["food", "dessert", "sweet", "japanese", "barbecue", "meat"], skins: [{ unified: "1f361", native: "\u{1F361}" }], version: 1 }, dumpling: { id: "dumpling", name: "Dumpling", keywords: ["food", "empanada", "pierogi", "potsticker", "gyoza"], skins: [{ unified: "1f95f", native: "\u{1F95F}" }], version: 5 }, fortune_cookie: { id: "fortune_cookie", name: "Fortune Cookie", keywords: ["food", "prophecy", "dessert"], skins: [{ unified: "1f960", native: "\u{1F960}" }], version: 5 }, takeout_box: { id: "takeout_box", name: "Takeout Box", keywords: ["food", "leftovers"], skins: [{ unified: "1f961", native: "\u{1F961}" }], version: 5 }, crab: { id: "crab", name: "Crab", keywords: ["animal", "crustacean"], skins: [{ unified: "1f980", native: "\u{1F980}" }], version: 1 }, lobster: { id: "lobster", name: "Lobster", keywords: ["animal", "nature", "bisque", "claws", "seafood"], skins: [{ unified: "1f99e", native: "\u{1F99E}" }], version: 11 }, shrimp: { id: "shrimp", name: "Shrimp", keywords: ["animal", "ocean", "nature", "seafood"], skins: [{ unified: "1f990", native: "\u{1F990}" }], version: 3 }, squid: { id: "squid", name: "Squid", keywords: ["animal", "nature", "ocean", "sea"], skins: [{ unified: "1f991", native: "\u{1F991}" }], version: 3 }, oyster: { id: "oyster", name: "Oyster", keywords: ["food"], skins: [{ unified: "1f9aa", native: "\u{1F9AA}" }], version: 12 }, icecream: { id: "icecream", name: "Soft Ice Cream", keywords: ["icecream", "food", "hot", "dessert", "summer"], skins: [{ unified: "1f366", native: "\u{1F366}" }], version: 1 }, shaved_ice: { id: "shaved_ice", name: "Shaved Ice", keywords: ["hot", "dessert", "summer"], skins: [{ unified: "1f367", native: "\u{1F367}" }], version: 1 }, ice_cream: { id: "ice_cream", name: "Ice Cream", keywords: ["food", "hot", "dessert"], skins: [{ unified: "1f368", native: "\u{1F368}" }], version: 1 }, doughnut: { id: "doughnut", name: "Doughnut", keywords: ["food", "dessert", "snack", "sweet", "donut"], skins: [{ unified: "1f369", native: "\u{1F369}" }], version: 1 }, cookie: { id: "cookie", name: "Cookie", keywords: ["food", "snack", "oreo", "chocolate", "sweet", "dessert"], skins: [{ unified: "1f36a", native: "\u{1F36A}" }], version: 1 }, birthday: { id: "birthday", name: "Birthday Cake", keywords: ["food", "dessert"], skins: [{ unified: "1f382", native: "\u{1F382}" }], version: 1 }, cake: { id: "cake", name: "Shortcake", keywords: ["cake", "food", "dessert"], skins: [{ unified: "1f370", native: "\u{1F370}" }], version: 1 }, cupcake: { id: "cupcake", name: "Cupcake", keywords: ["food", "dessert", "bakery", "sweet"], skins: [{ unified: "1f9c1", native: "\u{1F9C1}" }], version: 11 }, pie: { id: "pie", name: "Pie", keywords: ["food", "dessert", "pastry"], skins: [{ unified: "1f967", native: "\u{1F967}" }], version: 5 }, chocolate_bar: { id: "chocolate_bar", name: "Chocolate Bar", keywords: ["food", "snack", "dessert", "sweet"], skins: [{ unified: "1f36b", native: "\u{1F36B}" }], version: 1 }, candy: { id: "candy", name: "Candy", keywords: ["snack", "dessert", "sweet", "lolly"], skins: [{ unified: "1f36c", native: "\u{1F36C}" }], version: 1 }, lollipop: { id: "lollipop", name: "Lollipop", keywords: ["food", "snack", "candy", "sweet"], skins: [{ unified: "1f36d", native: "\u{1F36D}" }], version: 1 }, custard: { id: "custard", name: "Custard", keywords: ["dessert", "food"], skins: [{ unified: "1f36e", native: "\u{1F36E}" }], version: 1 }, honey_pot: { id: "honey_pot", name: "Honey Pot", keywords: ["bees", "sweet", "kitchen"], skins: [{ unified: "1f36f", native: "\u{1F36F}" }], version: 1 }, baby_bottle: { id: "baby_bottle", name: "Baby Bottle", keywords: ["food", "container", "milk"], skins: [{ unified: "1f37c", native: "\u{1F37C}" }], version: 1 }, glass_of_milk: { id: "glass_of_milk", name: "Glass of Milk", keywords: ["beverage", "drink", "cow"], skins: [{ unified: "1f95b", native: "\u{1F95B}" }], version: 3 }, coffee: { id: "coffee", name: "Hot Beverage", keywords: ["coffee", "caffeine", "latte", "espresso", "mug"], skins: [{ unified: "2615", native: "\u2615" }], version: 1 }, teapot: { id: "teapot", name: "Teapot", keywords: ["drink", "hot"], skins: [{ unified: "1fad6", native: "\u{1FAD6}" }], version: 13 }, tea: { id: "tea", name: "Teacup Without Handle", keywords: ["tea", "drink", "bowl", "breakfast", "green", "british"], skins: [{ unified: "1f375", native: "\u{1F375}" }], version: 1 }, sake: { id: "sake", name: "Sake", keywords: ["wine", "drink", "drunk", "beverage", "japanese", "alcohol", "booze"], skins: [{ unified: "1f376", native: "\u{1F376}" }], version: 1 }, champagne: { id: "champagne", name: "Bottle with Popping Cork", keywords: ["champagne", "drink", "wine", "celebration"], skins: [{ unified: "1f37e", native: "\u{1F37E}" }], version: 1 }, wine_glass: { id: "wine_glass", name: "Wine Glass", keywords: ["drink", "beverage", "drunk", "alcohol", "booze"], skins: [{ unified: "1f377", native: "\u{1F377}" }], version: 1 }, cocktail: { id: "cocktail", name: "Cocktail Glass", keywords: ["drink", "drunk", "alcohol", "beverage", "booze", "mojito"], skins: [{ unified: "1f378", native: "\u{1F378}" }], version: 1 }, tropical_drink: { id: "tropical_drink", name: "Tropical Drink", keywords: ["beverage", "cocktail", "summer", "beach", "alcohol", "booze", "mojito"], skins: [{ unified: "1f379", native: "\u{1F379}" }], version: 1 }, beer: { id: "beer", name: "Beer Mug", keywords: ["relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"], skins: [{ unified: "1f37a", native: "\u{1F37A}" }], version: 1 }, beers: { id: "beers", name: "Clinking Beer Mugs", keywords: ["beers", "relax", "beverage", "drink", "drunk", "party", "pub", "summer", "alcohol", "booze"], skins: [{ unified: "1f37b", native: "\u{1F37B}" }], version: 1 }, clinking_glasses: { id: "clinking_glasses", name: "Clinking Glasses", keywords: ["beverage", "drink", "party", "alcohol", "celebrate", "cheers", "wine", "champagne", "toast"], skins: [{ unified: "1f942", native: "\u{1F942}" }], version: 3 }, tumbler_glass: { id: "tumbler_glass", name: "Tumbler Glass", keywords: ["drink", "beverage", "drunk", "alcohol", "liquor", "booze", "bourbon", "scotch", "whisky", "shot"], skins: [{ unified: "1f943", native: "\u{1F943}" }], version: 3 }, pouring_liquid: { id: "pouring_liquid", name: "Pouring Liquid", keywords: ["cup", "water"], skins: [{ unified: "1fad7", native: "\u{1FAD7}" }], version: 14 }, cup_with_straw: { id: "cup_with_straw", name: "Cup with Straw", keywords: ["drink", "soda"], skins: [{ unified: "1f964", native: "\u{1F964}" }], version: 5 }, bubble_tea: { id: "bubble_tea", name: "Bubble Tea", keywords: ["taiwan", "boba", "milk", "straw"], skins: [{ unified: "1f9cb", native: "\u{1F9CB}" }], version: 13 }, beverage_box: { id: "beverage_box", name: "Beverage Box", keywords: ["drink"], skins: [{ unified: "1f9c3", native: "\u{1F9C3}" }], version: 12 }, mate_drink: { id: "mate_drink", name: "Mate", keywords: ["drink", "tea", "beverage"], skins: [{ unified: "1f9c9", native: "\u{1F9C9}" }], version: 12 }, ice_cube: { id: "ice_cube", name: "Ice", keywords: ["cube", "water", "cold"], skins: [{ unified: "1f9ca", native: "\u{1F9CA}" }], version: 12 }, chopsticks: { id: "chopsticks", name: "Chopsticks", keywords: ["food"], skins: [{ unified: "1f962", native: "\u{1F962}" }], version: 5 }, knife_fork_plate: { id: "knife_fork_plate", name: "Fork and Knife with Plate", keywords: ["food", "eat", "meal", "lunch", "dinner", "restaurant"], skins: [{ unified: "1f37d-fe0f", native: "\u{1F37D}\uFE0F" }], version: 1 }, fork_and_knife: { id: "fork_and_knife", name: "Fork and Knife", keywords: ["cutlery", "kitchen"], skins: [{ unified: "1f374", native: "\u{1F374}" }], version: 1 }, spoon: { id: "spoon", name: "Spoon", keywords: ["cutlery", "kitchen", "tableware"], skins: [{ unified: "1f944", native: "\u{1F944}" }], version: 3 }, hocho: { id: "hocho", name: "Hocho", keywords: ["knife", "kitchen", "blade", "cutlery", "weapon"], skins: [{ unified: "1f52a", native: "\u{1F52A}" }], version: 1 }, jar: { id: "jar", name: "Jar", keywords: ["container", "sauce"], skins: [{ unified: "1fad9", native: "\u{1FAD9}" }], version: 14 }, amphora: { id: "amphora", name: "Amphora", keywords: ["vase", "jar"], skins: [{ unified: "1f3fa", native: "\u{1F3FA}" }], version: 1 }, earth_africa: { id: "earth_africa", name: "Earth Globe Europe-Africa", keywords: ["africa", "showing", "europe", "world", "international"], skins: [{ unified: "1f30d", native: "\u{1F30D}" }], version: 1 }, earth_americas: { id: "earth_americas", name: "Earth Globe Americas", keywords: ["showing", "world", "USA", "international"], skins: [{ unified: "1f30e", native: "\u{1F30E}" }], version: 1 }, earth_asia: { id: "earth_asia", name: "Earth Globe Asia-Australia", keywords: ["asia", "showing", "australia", "world", "east", "international"], skins: [{ unified: "1f30f", native: "\u{1F30F}" }], version: 1 }, globe_with_meridians: { id: "globe_with_meridians", name: "Globe with Meridians", keywords: ["earth", "international", "world", "internet", "interweb", "i18n"], skins: [{ unified: "1f310", native: "\u{1F310}" }], version: 1 }, world_map: { id: "world_map", name: "World Map", keywords: ["location", "direction"], skins: [{ unified: "1f5fa-fe0f", native: "\u{1F5FA}\uFE0F" }], version: 1 }, japan: { id: "japan", name: "Map of Japan", keywords: ["nation", "country", "japanese", "asia"], skins: [{ unified: "1f5fe", native: "\u{1F5FE}" }], version: 1 }, compass: { id: "compass", name: "Compass", keywords: ["magnetic", "navigation", "orienteering"], skins: [{ unified: "1f9ed", native: "\u{1F9ED}" }], version: 11 }, snow_capped_mountain: { id: "snow_capped_mountain", name: "Snow-Capped Mountain", keywords: ["snow", "capped", "photo", "nature", "environment", "winter", "cold"], skins: [{ unified: "1f3d4-fe0f", native: "\u{1F3D4}\uFE0F" }], version: 1 }, mountain: { id: "mountain", name: "Mountain", keywords: ["photo", "nature", "environment"], skins: [{ unified: "26f0-fe0f", native: "\u26F0\uFE0F" }], version: 1 }, volcano: { id: "volcano", name: "Volcano", keywords: ["photo", "nature", "disaster"], skins: [{ unified: "1f30b", native: "\u{1F30B}" }], version: 1 }, mount_fuji: { id: "mount_fuji", name: "Mount Fuji", keywords: ["photo", "mountain", "nature", "japanese"], skins: [{ unified: "1f5fb", native: "\u{1F5FB}" }], version: 1 }, camping: { id: "camping", name: "Camping", keywords: ["photo", "outdoors", "tent"], skins: [{ unified: "1f3d5-fe0f", native: "\u{1F3D5}\uFE0F" }], version: 1 }, beach_with_umbrella: { id: "beach_with_umbrella", name: "Beach with Umbrella", keywords: ["weather", "summer", "sunny", "sand", "mojito"], skins: [{ unified: "1f3d6-fe0f", native: "\u{1F3D6}\uFE0F" }], version: 1 }, desert: { id: "desert", name: "Desert", keywords: ["photo", "warm", "saharah"], skins: [{ unified: "1f3dc-fe0f", native: "\u{1F3DC}\uFE0F" }], version: 1 }, desert_island: { id: "desert_island", name: "Desert Island", keywords: ["photo", "tropical", "mojito"], skins: [{ unified: "1f3dd-fe0f", native: "\u{1F3DD}\uFE0F" }], version: 1 }, national_park: { id: "national_park", name: "National Park", keywords: ["photo", "environment", "nature"], skins: [{ unified: "1f3de-fe0f", native: "\u{1F3DE}\uFE0F" }], version: 1 }, stadium: { id: "stadium", name: "Stadium", keywords: ["photo", "place", "sports", "concert", "venue"], skins: [{ unified: "1f3df-fe0f", native: "\u{1F3DF}\uFE0F" }], version: 1 }, classical_building: { id: "classical_building", name: "Classical Building", keywords: ["art", "culture", "history"], skins: [{ unified: "1f3db-fe0f", native: "\u{1F3DB}\uFE0F" }], version: 1 }, building_construction: { id: "building_construction", name: "Building Construction", keywords: ["wip", "working", "progress"], skins: [{ unified: "1f3d7-fe0f", native: "\u{1F3D7}\uFE0F" }], version: 1 }, bricks: { id: "bricks", name: "Brick", keywords: ["bricks"], skins: [{ unified: "1f9f1", native: "\u{1F9F1}" }], version: 11 }, rock: { id: "rock", name: "Rock", keywords: ["stone"], skins: [{ unified: "1faa8", native: "\u{1FAA8}" }], version: 13 }, wood: { id: "wood", name: "Wood", keywords: ["nature", "timber", "trunk"], skins: [{ unified: "1fab5", native: "\u{1FAB5}" }], version: 13 }, hut: { id: "hut", name: "Hut", keywords: ["house", "structure"], skins: [{ unified: "1f6d6", native: "\u{1F6D6}" }], version: 13 }, house_buildings: { id: "house_buildings", name: "Houses", keywords: ["house", "buildings", "photo"], skins: [{ unified: "1f3d8-fe0f", native: "\u{1F3D8}\uFE0F" }], version: 1 }, derelict_house_building: { id: "derelict_house_building", name: "Derelict House", keywords: ["building", "abandon", "evict", "broken"], skins: [{ unified: "1f3da-fe0f", native: "\u{1F3DA}\uFE0F" }], version: 1 }, house: { id: "house", name: "House", keywords: ["building", "home"], skins: [{ unified: "1f3e0", native: "\u{1F3E0}" }], version: 1 }, house_with_garden: { id: "house_with_garden", name: "House with Garden", keywords: ["home", "plant", "nature"], skins: [{ unified: "1f3e1", native: "\u{1F3E1}" }], version: 1 }, office: { id: "office", name: "Office Building", keywords: ["bureau", "work"], skins: [{ unified: "1f3e2", native: "\u{1F3E2}" }], version: 1 }, post_office: { id: "post_office", name: "Japanese Post Office", keywords: ["building", "envelope", "communication"], skins: [{ unified: "1f3e3", native: "\u{1F3E3}" }], version: 1 }, european_post_office: { id: "european_post_office", name: "Post Office", keywords: ["european", "building", "email"], skins: [{ unified: "1f3e4", native: "\u{1F3E4}" }], version: 1 }, hospital: { id: "hospital", name: "Hospital", keywords: ["building", "health", "surgery", "doctor"], skins: [{ unified: "1f3e5", native: "\u{1F3E5}" }], version: 1 }, bank: { id: "bank", name: "Bank", keywords: ["building", "money", "sales", "cash", "business", "enterprise"], skins: [{ unified: "1f3e6", native: "\u{1F3E6}" }], version: 1 }, hotel: { id: "hotel", name: "Hotel", keywords: ["building", "accomodation", "checkin"], skins: [{ unified: "1f3e8", native: "\u{1F3E8}" }], version: 1 }, love_hotel: { id: "love_hotel", name: "Love Hotel", keywords: ["like", "affection", "dating"], skins: [{ unified: "1f3e9", native: "\u{1F3E9}" }], version: 1 }, convenience_store: { id: "convenience_store", name: "Convenience Store", keywords: ["building", "shopping", "groceries"], skins: [{ unified: "1f3ea", native: "\u{1F3EA}" }], version: 1 }, school: { id: "school", name: "School", keywords: ["building", "student", "education", "learn", "teach"], skins: [{ unified: "1f3eb", native: "\u{1F3EB}" }], version: 1 }, department_store: { id: "department_store", name: "Department Store", keywords: ["building", "shopping", "mall"], skins: [{ unified: "1f3ec", native: "\u{1F3EC}" }], version: 1 }, factory: { id: "factory", name: "Factory", keywords: ["building", "industry", "pollution", "smoke"], skins: [{ unified: "1f3ed", native: "\u{1F3ED}" }], version: 1 }, japanese_castle: { id: "japanese_castle", name: "Japanese Castle", keywords: ["photo", "building"], skins: [{ unified: "1f3ef", native: "\u{1F3EF}" }], version: 1 }, european_castle: { id: "european_castle", name: "Castle", keywords: ["european", "building", "royalty", "history"], skins: [{ unified: "1f3f0", native: "\u{1F3F0}" }], version: 1 }, wedding: { id: "wedding", name: "Wedding", keywords: ["love", "like", "affection", "couple", "marriage", "bride", "groom"], skins: [{ unified: "1f492", native: "\u{1F492}" }], version: 1 }, tokyo_tower: { id: "tokyo_tower", name: "Tokyo Tower", keywords: ["photo", "japanese"], skins: [{ unified: "1f5fc", native: "\u{1F5FC}" }], version: 1 }, statue_of_liberty: { id: "statue_of_liberty", name: "Statue of Liberty", keywords: ["american", "newyork"], skins: [{ unified: "1f5fd", native: "\u{1F5FD}" }], version: 1 }, church: { id: "church", name: "Church", keywords: ["building", "religion", "christ"], skins: [{ unified: "26ea", native: "\u26EA" }], version: 1 }, mosque: { id: "mosque", name: "Mosque", keywords: ["islam", "worship", "minaret"], skins: [{ unified: "1f54c", native: "\u{1F54C}" }], version: 1 }, hindu_temple: { id: "hindu_temple", name: "Hindu Temple", keywords: ["religion"], skins: [{ unified: "1f6d5", native: "\u{1F6D5}" }], version: 12 }, synagogue: { id: "synagogue", name: "Synagogue", keywords: ["judaism", "worship", "temple", "jewish"], skins: [{ unified: "1f54d", native: "\u{1F54D}" }], version: 1 }, shinto_shrine: { id: "shinto_shrine", name: "Shinto Shrine", keywords: ["temple", "japan", "kyoto"], skins: [{ unified: "26e9-fe0f", native: "\u26E9\uFE0F" }], version: 1 }, kaaba: { id: "kaaba", name: "Kaaba", keywords: ["mecca", "mosque", "islam"], skins: [{ unified: "1f54b", native: "\u{1F54B}" }], version: 1 }, fountain: { id: "fountain", name: "Fountain", keywords: ["photo", "summer", "water", "fresh"], skins: [{ unified: "26f2", native: "\u26F2" }], version: 1 }, tent: { id: "tent", name: "Tent", keywords: ["photo", "camping", "outdoors"], skins: [{ unified: "26fa", native: "\u26FA" }], version: 1 }, foggy: { id: "foggy", name: "Foggy", keywords: ["photo", "mountain"], skins: [{ unified: "1f301", native: "\u{1F301}" }], version: 1 }, night_with_stars: { id: "night_with_stars", name: "Night with Stars", keywords: ["evening", "city", "downtown"], skins: [{ unified: "1f303", native: "\u{1F303}" }], version: 1 }, cityscape: { id: "cityscape", name: "Cityscape", keywords: ["photo", "night", "life", "urban"], skins: [{ unified: "1f3d9-fe0f", native: "\u{1F3D9}\uFE0F" }], version: 1 }, sunrise_over_mountains: { id: "sunrise_over_mountains", name: "Sunrise over Mountains", keywords: ["view", "vacation", "photo"], skins: [{ unified: "1f304", native: "\u{1F304}" }], version: 1 }, sunrise: { id: "sunrise", name: "Sunrise", keywords: ["morning", "view", "vacation", "photo"], skins: [{ unified: "1f305", native: "\u{1F305}" }], version: 1 }, city_sunset: { id: "city_sunset", name: "Cityscape at Dusk", keywords: ["city", "sunset", "photo", "evening", "sky", "buildings"], skins: [{ unified: "1f306", native: "\u{1F306}" }], version: 1 }, city_sunrise: { id: "city_sunrise", name: "Sunset", keywords: ["city", "sunrise", "photo", "good", "morning", "dawn"], skins: [{ unified: "1f307", native: "\u{1F307}" }], version: 1 }, bridge_at_night: { id: "bridge_at_night", name: "Bridge at Night", keywords: ["photo", "sanfrancisco"], skins: [{ unified: "1f309", native: "\u{1F309}" }], version: 1 }, hotsprings: { id: "hotsprings", name: "Hot Springs", keywords: ["hotsprings", "bath", "warm", "relax"], skins: [{ unified: "2668-fe0f", native: "\u2668\uFE0F" }], version: 1 }, carousel_horse: { id: "carousel_horse", name: "Carousel Horse", keywords: ["photo", "carnival"], skins: [{ unified: "1f3a0", native: "\u{1F3A0}" }], version: 1 }, playground_slide: { id: "playground_slide", name: "Playground Slide", keywords: ["fun", "park"], skins: [{ unified: "1f6dd", native: "\u{1F6DD}" }], version: 14 }, ferris_wheel: { id: "ferris_wheel", name: "Ferris Wheel", keywords: ["photo", "carnival", "londoneye"], skins: [{ unified: "1f3a1", native: "\u{1F3A1}" }], version: 1 }, roller_coaster: { id: "roller_coaster", name: "Roller Coaster", keywords: ["carnival", "playground", "photo", "fun"], skins: [{ unified: "1f3a2", native: "\u{1F3A2}" }], version: 1 }, barber: { id: "barber", name: "Barber Pole", keywords: ["hair", "salon", "style"], skins: [{ unified: "1f488", native: "\u{1F488}" }], version: 1 }, circus_tent: { id: "circus_tent", name: "Circus Tent", keywords: ["festival", "carnival", "party"], skins: [{ unified: "1f3aa", native: "\u{1F3AA}" }], version: 1 }, steam_locomotive: { id: "steam_locomotive", name: "Locomotive", keywords: ["steam", "transportation", "vehicle", "train"], skins: [{ unified: "1f682", native: "\u{1F682}" }], version: 1 }, railway_car: { id: "railway_car", name: "Railway Car", keywords: ["transportation", "vehicle"], skins: [{ unified: "1f683", native: "\u{1F683}" }], version: 1 }, bullettrain_side: { id: "bullettrain_side", name: "High-Speed Train", keywords: ["bullettrain", "side", "high", "speed", "transportation", "vehicle"], skins: [{ unified: "1f684", native: "\u{1F684}" }], version: 1 }, bullettrain_front: { id: "bullettrain_front", name: "Bullet Train", keywords: ["bullettrain", "front", "transportation", "vehicle", "speed", "fast", "public", "travel"], skins: [{ unified: "1f685", native: "\u{1F685}" }], version: 1 }, train2: { id: "train2", name: "Train", keywords: ["train2", "transportation", "vehicle"], skins: [{ unified: "1f686", native: "\u{1F686}" }], version: 1 }, metro: { id: "metro", name: "Metro", keywords: ["transportation", "blue", "square", "mrt", "underground", "tube"], skins: [{ unified: "1f687", native: "\u{1F687}" }], version: 1 }, light_rail: { id: "light_rail", name: "Light Rail", keywords: ["transportation", "vehicle"], skins: [{ unified: "1f688", native: "\u{1F688}" }], version: 1 }, station: { id: "station", name: "Station", keywords: ["transportation", "vehicle", "public"], skins: [{ unified: "1f689", native: "\u{1F689}" }], version: 1 }, tram: { id: "tram", name: "Tram", keywords: ["transportation", "vehicle"], skins: [{ unified: "1f68a", native: "\u{1F68A}" }], version: 1 }, monorail: { id: "monorail", name: "Monorail", keywords: ["transportation", "vehicle"], skins: [{ unified: "1f69d", native: "\u{1F69D}" }], version: 1 }, mountain_railway: { id: "mountain_railway", name: "Mountain Railway", keywords: ["transportation", "vehicle"], skins: [{ unified: "1f69e", native: "\u{1F69E}" }], version: 1 }, train: { id: "train", name: "Tram Car", keywords: ["train", "transportation", "vehicle", "carriage", "public", "travel"], skins: [{ unified: "1f68b", native: "\u{1F68B}" }], version: 1 }, bus: { id: "bus", name: "Bus", keywords: ["car", "vehicle", "transportation"], skins: [{ unified: "1f68c", native: "\u{1F68C}" }], version: 1 }, oncoming_bus: { id: "oncoming_bus", name: "Oncoming Bus", keywords: ["vehicle", "transportation"], skins: [{ unified: "1f68d", native: "\u{1F68D}" }], version: 1 }, trolleybus: { id: "trolleybus", name: "Trolleybus", keywords: ["bart", "transportation", "vehicle"], skins: [{ unified: "1f68e", native: "\u{1F68E}" }], version: 1 }, minibus: { id: "minibus", name: "Minibus", keywords: ["vehicle", "car", "transportation"], skins: [{ unified: "1f690", native: "\u{1F690}" }], version: 1 }, ambulance: { id: "ambulance", name: "Ambulance", keywords: ["health", "911", "hospital"], skins: [{ unified: "1f691", native: "\u{1F691}" }], version: 1 }, fire_engine: { id: "fire_engine", name: "Fire Engine", keywords: ["transportation", "cars", "vehicle"], skins: [{ unified: "1f692", native: "\u{1F692}" }], version: 1 }, police_car: { id: "police_car", name: "Police Car", keywords: ["vehicle", "cars", "transportation", "law", "legal", "enforcement"], skins: [{ unified: "1f693", native: "\u{1F693}" }], version: 1 }, oncoming_police_car: { id: "oncoming_police_car", name: "Oncoming Police Car", keywords: ["vehicle", "law", "legal", "enforcement", "911"], skins: [{ unified: "1f694", native: "\u{1F694}" }], version: 1 }, taxi: { id: "taxi", name: "Taxi", keywords: ["uber", "vehicle", "cars", "transportation"], skins: [{ unified: "1f695", native: "\u{1F695}" }], version: 1 }, oncoming_taxi: { id: "oncoming_taxi", name: "Oncoming Taxi", keywords: ["vehicle", "cars", "uber"], skins: [{ unified: "1f696", native: "\u{1F696}" }], version: 1 }, car: { id: "car", name: "Automobile", keywords: ["car", "red", "transportation", "vehicle"], skins: [{ unified: "1f697", native: "\u{1F697}" }], version: 1 }, oncoming_automobile: { id: "oncoming_automobile", name: "Oncoming Automobile", keywords: ["car", "vehicle", "transportation"], skins: [{ unified: "1f698", native: "\u{1F698}" }], version: 1 }, blue_car: { id: "blue_car", name: "Recreational Vehicle", keywords: ["blue", "car", "sport", "utility", "transportation"], skins: [{ unified: "1f699", native: "\u{1F699}" }], version: 1 }, pickup_truck: { id: "pickup_truck", name: "Pickup Truck", keywords: ["car", "transportation"], skins: [{ unified: "1f6fb", native: "\u{1F6FB}" }], version: 13 }, truck: { id: "truck", name: "Delivery Truck", keywords: ["cars", "transportation"], skins: [{ unified: "1f69a", native: "\u{1F69A}" }], version: 1 }, articulated_lorry: { id: "articulated_lorry", name: "Articulated Lorry", keywords: ["vehicle", "cars", "transportation", "express"], skins: [{ unified: "1f69b", native: "\u{1F69B}" }], version: 1 }, tractor: { id: "tractor", name: "Tractor", keywords: ["vehicle", "car", "farming", "agriculture"], skins: [{ unified: "1f69c", native: "\u{1F69C}" }], version: 1 }, racing_car: { id: "racing_car", name: "Racing Car", keywords: ["sports", "race", "fast", "formula", "f1"], skins: [{ unified: "1f3ce-fe0f", native: "\u{1F3CE}\uFE0F" }], version: 1 }, racing_motorcycle: { id: "racing_motorcycle", name: "Motorcycle", keywords: ["racing", "race", "sports", "fast"], skins: [{ unified: "1f3cd-fe0f", native: "\u{1F3CD}\uFE0F" }], version: 1 }, motor_scooter: { id: "motor_scooter", name: "Motor Scooter", keywords: ["vehicle", "vespa", "sasha"], skins: [{ unified: "1f6f5", native: "\u{1F6F5}" }], version: 3 }, manual_wheelchair: { id: "manual_wheelchair", name: "Manual Wheelchair", keywords: ["accessibility"], skins: [{ unified: "1f9bd", native: "\u{1F9BD}" }], version: 12 }, motorized_wheelchair: { id: "motorized_wheelchair", name: "Motorized Wheelchair", keywords: ["accessibility"], skins: [{ unified: "1f9bc", native: "\u{1F9BC}" }], version: 12 }, auto_rickshaw: { id: "auto_rickshaw", name: "Auto Rickshaw", keywords: ["move", "transportation"], skins: [{ unified: "1f6fa", native: "\u{1F6FA}" }], version: 12 }, bike: { id: "bike", name: "Bicycle", keywords: ["bike", "sports", "exercise", "hipster"], skins: [{ unified: "1f6b2", native: "\u{1F6B2}" }], version: 1 }, scooter: { id: "scooter", name: "Scooter", keywords: ["kick", "vehicle", "razor"], skins: [{ unified: "1f6f4", native: "\u{1F6F4}" }], version: 3 }, skateboard: { id: "skateboard", name: "Skateboard", keywords: ["board"], skins: [{ unified: "1f6f9", native: "\u{1F6F9}" }], version: 11 }, roller_skate: { id: "roller_skate", name: "Roller Skate", keywords: ["footwear", "sports"], skins: [{ unified: "1f6fc", native: "\u{1F6FC}" }], version: 13 }, busstop: { id: "busstop", name: "Bus Stop", keywords: ["busstop", "transportation", "wait"], skins: [{ unified: "1f68f", native: "\u{1F68F}" }], version: 1 }, motorway: { id: "motorway", name: "Motorway", keywords: ["road", "cupertino", "interstate", "highway"], skins: [{ unified: "1f6e3-fe0f", native: "\u{1F6E3}\uFE0F" }], version: 1 }, railway_track: { id: "railway_track", name: "Railway Track", keywords: ["train", "transportation"], skins: [{ unified: "1f6e4-fe0f", native: "\u{1F6E4}\uFE0F" }], version: 1 }, oil_drum: { id: "oil_drum", name: "Oil Drum", keywords: ["barrell"], skins: [{ unified: "1f6e2-fe0f", native: "\u{1F6E2}\uFE0F" }], version: 1 }, fuelpump: { id: "fuelpump", name: "Fuel Pump", keywords: ["fuelpump", "gas", "station", "petroleum"], skins: [{ unified: "26fd", native: "\u26FD" }], version: 1 }, wheel: { id: "wheel", name: "Wheel", keywords: ["car", "transport"], skins: [{ unified: "1f6de", native: "\u{1F6DE}" }], version: 14 }, rotating_light: { id: "rotating_light", name: "Police Car Light", keywords: ["rotating", "ambulance", "911", "emergency", "alert", "error", "pinged", "law", "legal"], skins: [{ unified: "1f6a8", native: "\u{1F6A8}" }], version: 1 }, traffic_light: { id: "traffic_light", name: "Horizontal Traffic Light", keywords: ["transportation", "signal"], skins: [{ unified: "1f6a5", native: "\u{1F6A5}" }], version: 1 }, vertical_traffic_light: { id: "vertical_traffic_light", name: "Vertical Traffic Light", keywords: ["transportation", "driving"], skins: [{ unified: "1f6a6", native: "\u{1F6A6}" }], version: 1 }, octagonal_sign: { id: "octagonal_sign", name: "Stop Sign", keywords: ["octagonal"], skins: [{ unified: "1f6d1", native: "\u{1F6D1}" }], version: 3 }, construction: { id: "construction", name: "Construction", keywords: ["wip", "progress", "caution", "warning"], skins: [{ unified: "1f6a7", native: "\u{1F6A7}" }], version: 1 }, anchor: { id: "anchor", name: "Anchor", keywords: ["ship", "ferry", "sea", "boat"], skins: [{ unified: "2693", native: "\u2693" }], version: 1 }, ring_buoy: { id: "ring_buoy", name: "Ring Buoy", keywords: ["life", "saver", "preserver"], skins: [{ unified: "1f6df", native: "\u{1F6DF}" }], version: 14 }, boat: { id: "boat", name: "Sailboat", keywords: ["boat", "ship", "summer", "transportation", "water", "sailing"], skins: [{ unified: "26f5", native: "\u26F5" }], version: 1 }, canoe: { id: "canoe", name: "Canoe", keywords: ["boat", "paddle", "water", "ship"], skins: [{ unified: "1f6f6", native: "\u{1F6F6}" }], version: 3 }, speedboat: { id: "speedboat", name: "Speedboat", keywords: ["ship", "transportation", "vehicle", "summer"], skins: [{ unified: "1f6a4", native: "\u{1F6A4}" }], version: 1 }, passenger_ship: { id: "passenger_ship", name: "Passenger Ship", keywords: ["yacht", "cruise", "ferry"], skins: [{ unified: "1f6f3-fe0f", native: "\u{1F6F3}\uFE0F" }], version: 1 }, ferry: { id: "ferry", name: "Ferry", keywords: ["boat", "ship", "yacht"], skins: [{ unified: "26f4-fe0f", native: "\u26F4\uFE0F" }], version: 1 }, motor_boat: { id: "motor_boat", name: "Motor Boat", keywords: ["ship"], skins: [{ unified: "1f6e5-fe0f", native: "\u{1F6E5}\uFE0F" }], version: 1 }, ship: { id: "ship", name: "Ship", keywords: ["transportation", "titanic", "deploy"], skins: [{ unified: "1f6a2", native: "\u{1F6A2}" }], version: 1 }, airplane: { id: "airplane", name: "Airplane", keywords: ["vehicle", "transportation", "flight", "fly"], skins: [{ unified: "2708-fe0f", native: "\u2708\uFE0F" }], version: 1 }, small_airplane: { id: "small_airplane", name: "Small Airplane", keywords: ["flight", "transportation", "fly", "vehicle"], skins: [{ unified: "1f6e9-fe0f", native: "\u{1F6E9}\uFE0F" }], version: 1 }, airplane_departure: { id: "airplane_departure", name: "Airplane Departure", keywords: ["airport", "flight", "landing"], skins: [{ unified: "1f6eb", native: "\u{1F6EB}" }], version: 1 }, airplane_arriving: { id: "airplane_arriving", name: "Airplane Arrival", keywords: ["arriving", "airport", "flight", "boarding"], skins: [{ unified: "1f6ec", native: "\u{1F6EC}" }], version: 1 }, parachute: { id: "parachute", name: "Parachute", keywords: ["fly", "glide"], skins: [{ unified: "1fa82", native: "\u{1FA82}" }], version: 12 }, seat: { id: "seat", name: "Seat", keywords: ["sit", "airplane", "transport", "bus", "flight", "fly"], skins: [{ unified: "1f4ba", native: "\u{1F4BA}" }], version: 1 }, helicopter: { id: "helicopter", name: "Helicopter", keywords: ["transportation", "vehicle", "fly"], skins: [{ unified: "1f681", native: "\u{1F681}" }], version: 1 }, suspension_railway: { id: "suspension_railway", name: "Suspension Railway", keywords: ["vehicle", "transportation"], skins: [{ unified: "1f69f", native: "\u{1F69F}" }], version: 1 }, mountain_cableway: { id: "mountain_cableway", name: "Mountain Cableway", keywords: ["transportation", "vehicle", "ski"], skins: [{ unified: "1f6a0", native: "\u{1F6A0}" }], version: 1 }, aerial_tramway: { id: "aerial_tramway", name: "Aerial Tramway", keywords: ["transportation", "vehicle", "ski"], skins: [{ unified: "1f6a1", native: "\u{1F6A1}" }], version: 1 }, satellite: { id: "satellite", name: "Satellite", keywords: ["communication", "gps", "orbit", "spaceflight", "NASA", "ISS"], skins: [{ unified: "1f6f0-fe0f", native: "\u{1F6F0}\uFE0F" }], version: 1 }, rocket: { id: "rocket", name: "Rocket", keywords: ["launch", "ship", "staffmode", "NASA", "outer", "space", "fly"], skins: [{ unified: "1f680", native: "\u{1F680}" }], version: 1 }, flying_saucer: { id: "flying_saucer", name: "Flying Saucer", keywords: ["transportation", "vehicle", "ufo"], skins: [{ unified: "1f6f8", native: "\u{1F6F8}" }], version: 5 }, bellhop_bell: { id: "bellhop_bell", name: "Bellhop Bell", keywords: ["service"], skins: [{ unified: "1f6ce-fe0f", native: "\u{1F6CE}\uFE0F" }], version: 1 }, luggage: { id: "luggage", name: "Luggage", keywords: ["packing", "travel"], skins: [{ unified: "1f9f3", native: "\u{1F9F3}" }], version: 11 }, hourglass: { id: "hourglass", name: "Hourglass", keywords: ["done", "time", "clock", "oldschool", "limit", "exam", "quiz", "test"], skins: [{ unified: "231b", native: "\u231B" }], version: 1 }, hourglass_flowing_sand: { id: "hourglass_flowing_sand", name: "Hourglass Not Done", keywords: ["flowing", "sand", "oldschool", "time", "countdown"], skins: [{ unified: "23f3", native: "\u23F3" }], version: 1 }, watch: { id: "watch", name: "Watch", keywords: ["time", "accessories"], skins: [{ unified: "231a", native: "\u231A" }], version: 1 }, alarm_clock: { id: "alarm_clock", name: "Alarm Clock", keywords: ["time", "wake"], skins: [{ unified: "23f0", native: "\u23F0" }], version: 1 }, stopwatch: { id: "stopwatch", name: "Stopwatch", keywords: ["time", "deadline"], skins: [{ unified: "23f1-fe0f", native: "\u23F1\uFE0F" }], version: 1 }, timer_clock: { id: "timer_clock", name: "Timer Clock", keywords: ["alarm"], skins: [{ unified: "23f2-fe0f", native: "\u23F2\uFE0F" }], version: 1 }, mantelpiece_clock: { id: "mantelpiece_clock", name: "Mantelpiece Clock", keywords: ["time"], skins: [{ unified: "1f570-fe0f", native: "\u{1F570}\uFE0F" }], version: 1 }, clock12: { id: "clock12", name: "Twelve O\u2019clock", keywords: ["clock12", "o", "clock", "12", "00:00", "0000", "12:00", "1200", "time", "noon", "midnight", "midday", "late", "early", "schedule"], skins: [{ unified: "1f55b", native: "\u{1F55B}" }], version: 1 }, clock1230: { id: "clock1230", name: "Twelve-Thirty", keywords: ["clock1230", "twelve", "thirty", "00:30", "0030", "12:30", "1230", "time", "late", "early", "schedule"], skins: [{ unified: "1f567", native: "\u{1F567}" }], version: 1 }, clock1: { id: "clock1", name: "One O\u2019clock", keywords: ["clock1", "o", "clock", "1", "1:00", "100", "13:00", "1300", "time", "late", "early", "schedule"], skins: [{ unified: "1f550", native: "\u{1F550}" }], version: 1 }, clock130: { id: "clock130", name: "One-Thirty", keywords: ["clock130", "one", "thirty", "1:30", "130", "13:30", "1330", "time", "late", "early", "schedule"], skins: [{ unified: "1f55c", native: "\u{1F55C}" }], version: 1 }, clock2: { id: "clock2", name: "Two O\u2019clock", keywords: ["clock2", "o", "clock", "2", "2:00", "200", "14:00", "1400", "time", "late", "early", "schedule"], skins: [{ unified: "1f551", native: "\u{1F551}" }], version: 1 }, clock230: { id: "clock230", name: "Two-Thirty", keywords: ["clock230", "two", "thirty", "2:30", "230", "14:30", "1430", "time", "late", "early", "schedule"], skins: [{ unified: "1f55d", native: "\u{1F55D}" }], version: 1 }, clock3: { id: "clock3", name: "Three O\u2019clock", keywords: ["clock3", "o", "clock", "3", "3:00", "300", "15:00", "1500", "time", "late", "early", "schedule"], skins: [{ unified: "1f552", native: "\u{1F552}" }], version: 1 }, clock330: { id: "clock330", name: "Three-Thirty", keywords: ["clock330", "three", "thirty", "3:30", "330", "15:30", "1530", "time", "late", "early", "schedule"], skins: [{ unified: "1f55e", native: "\u{1F55E}" }], version: 1 }, clock4: { id: "clock4", name: "Four O\u2019clock", keywords: ["clock4", "o", "clock", "4", "4:00", "400", "16:00", "1600", "time", "late", "early", "schedule"], skins: [{ unified: "1f553", native: "\u{1F553}" }], version: 1 }, clock430: { id: "clock430", name: "Four-Thirty", keywords: ["clock430", "four", "thirty", "4:30", "430", "16:30", "1630", "time", "late", "early", "schedule"], skins: [{ unified: "1f55f", native: "\u{1F55F}" }], version: 1 }, clock5: { id: "clock5", name: "Five O\u2019clock", keywords: ["clock5", "o", "clock", "5", "5:00", "500", "17:00", "1700", "time", "late", "early", "schedule"], skins: [{ unified: "1f554", native: "\u{1F554}" }], version: 1 }, clock530: { id: "clock530", name: "Five-Thirty", keywords: ["clock530", "five", "thirty", "5:30", "530", "17:30", "1730", "time", "late", "early", "schedule"], skins: [{ unified: "1f560", native: "\u{1F560}" }], version: 1 }, clock6: { id: "clock6", name: "Six O\u2019clock", keywords: ["clock6", "o", "clock", "6", "6:00", "600", "18:00", "1800", "time", "late", "early", "schedule", "dawn", "dusk"], skins: [{ unified: "1f555", native: "\u{1F555}" }], version: 1 }, clock630: { id: "clock630", name: "Six-Thirty", keywords: ["clock630", "six", "thirty", "6:30", "630", "18:30", "1830", "time", "late", "early", "schedule"], skins: [{ unified: "1f561", native: "\u{1F561}" }], version: 1 }, clock7: { id: "clock7", name: "Seven O\u2019clock", keywords: ["clock7", "o", "clock", "7", "7:00", "700", "19:00", "1900", "time", "late", "early", "schedule"], skins: [{ unified: "1f556", native: "\u{1F556}" }], version: 1 }, clock730: { id: "clock730", name: "Seven-Thirty", keywords: ["clock730", "seven", "thirty", "7:30", "730", "19:30", "1930", "time", "late", "early", "schedule"], skins: [{ unified: "1f562", native: "\u{1F562}" }], version: 1 }, clock8: { id: "clock8", name: "Eight O\u2019clock", keywords: ["clock8", "o", "clock", "8", "8:00", "800", "20:00", "2000", "time", "late", "early", "schedule"], skins: [{ unified: "1f557", native: "\u{1F557}" }], version: 1 }, clock830: { id: "clock830", name: "Eight-Thirty", keywords: ["clock830", "eight", "thirty", "8:30", "830", "20:30", "2030", "time", "late", "early", "schedule"], skins: [{ unified: "1f563", native: "\u{1F563}" }], version: 1 }, clock9: { id: "clock9", name: "Nine O\u2019clock", keywords: ["clock9", "o", "clock", "9", "9:00", "900", "21:00", "2100", "time", "late", "early", "schedule"], skins: [{ unified: "1f558", native: "\u{1F558}" }], version: 1 }, clock930: { id: "clock930", name: "Nine-Thirty", keywords: ["clock930", "nine", "thirty", "9:30", "930", "21:30", "2130", "time", "late", "early", "schedule"], skins: [{ unified: "1f564", native: "\u{1F564}" }], version: 1 }, clock10: { id: "clock10", name: "Ten O\u2019clock", keywords: ["clock10", "o", "clock", "10", "10:00", "1000", "22:00", "2200", "time", "late", "early", "schedule"], skins: [{ unified: "1f559", native: "\u{1F559}" }], version: 1 }, clock1030: { id: "clock1030", name: "Ten-Thirty", keywords: ["clock1030", "ten", "thirty", "10:30", "1030", "22:30", "2230", "time", "late", "early", "schedule"], skins: [{ unified: "1f565", native: "\u{1F565}" }], version: 1 }, clock11: { id: "clock11", name: "Eleven O\u2019clock", keywords: ["clock11", "o", "clock", "11", "11:00", "1100", "23:00", "2300", "time", "late", "early", "schedule"], skins: [{ unified: "1f55a", native: "\u{1F55A}" }], version: 1 }, clock1130: { id: "clock1130", name: "Eleven-Thirty", keywords: ["clock1130", "eleven", "thirty", "11:30", "1130", "23:30", "2330", "time", "late", "early", "schedule"], skins: [{ unified: "1f566", native: "\u{1F566}" }], version: 1 }, new_moon: { id: "new_moon", name: "New Moon", keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], skins: [{ unified: "1f311", native: "\u{1F311}" }], version: 1 }, waxing_crescent_moon: { id: "waxing_crescent_moon", name: "Waxing Crescent Moon", keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], skins: [{ unified: "1f312", native: "\u{1F312}" }], version: 1 }, first_quarter_moon: { id: "first_quarter_moon", name: "First Quarter Moon", keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], skins: [{ unified: "1f313", native: "\u{1F313}" }], version: 1 }, moon: { id: "moon", name: "Waxing Gibbous Moon", keywords: ["nature", "night", "sky", "gray", "twilight", "planet", "space", "evening", "sleep"], skins: [{ unified: "1f314", native: "\u{1F314}" }], version: 1 }, full_moon: { id: "full_moon", name: "Full Moon", keywords: ["nature", "yellow", "twilight", "planet", "space", "night", "evening", "sleep"], skins: [{ unified: "1f315", native: "\u{1F315}" }], version: 1 }, waning_gibbous_moon: { id: "waning_gibbous_moon", name: "Waning Gibbous Moon", keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep", "waxing"], skins: [{ unified: "1f316", native: "\u{1F316}" }], version: 1 }, last_quarter_moon: { id: "last_quarter_moon", name: "Last Quarter Moon", keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], skins: [{ unified: "1f317", native: "\u{1F317}" }], version: 1 }, waning_crescent_moon: { id: "waning_crescent_moon", name: "Waning Crescent Moon", keywords: ["nature", "twilight", "planet", "space", "night", "evening", "sleep"], skins: [{ unified: "1f318", native: "\u{1F318}" }], version: 1 }, crescent_moon: { id: "crescent_moon", name: "Crescent Moon", keywords: ["night", "sleep", "sky", "evening", "magic"], skins: [{ unified: "1f319", native: "\u{1F319}" }], version: 1 }, new_moon_with_face: { id: "new_moon_with_face", name: "New Moon Face", keywords: ["with", "nature", "twilight", "planet", "space", "night", "evening", "sleep"], skins: [{ unified: "1f31a", native: "\u{1F31A}" }], version: 1 }, first_quarter_moon_with_face: { id: "first_quarter_moon_with_face", name: "First Quarter Moon Face", keywords: ["with", "nature", "twilight", "planet", "space", "night", "evening", "sleep"], skins: [{ unified: "1f31b", native: "\u{1F31B}" }], version: 1 }, last_quarter_moon_with_face: { id: "last_quarter_moon_with_face", name: "Last Quarter Moon Face", keywords: ["with", "nature", "twilight", "planet", "space", "night", "evening", "sleep"], skins: [{ unified: "1f31c", native: "\u{1F31C}" }], version: 1 }, thermometer: { id: "thermometer", name: "Thermometer", keywords: ["weather", "temperature", "hot", "cold"], skins: [{ unified: "1f321-fe0f", native: "\u{1F321}\uFE0F" }], version: 1 }, sunny: { id: "sunny", name: "Sun", keywords: ["sunny", "weather", "nature", "brightness", "summer", "beach", "spring"], skins: [{ unified: "2600-fe0f", native: "\u2600\uFE0F" }], version: 1 }, full_moon_with_face: { id: "full_moon_with_face", name: "Full Moon Face", keywords: ["with", "nature", "twilight", "planet", "space", "night", "evening", "sleep"], skins: [{ unified: "1f31d", native: "\u{1F31D}" }], version: 1 }, sun_with_face: { id: "sun_with_face", name: "Sun with Face", keywords: ["nature", "morning", "sky"], skins: [{ unified: "1f31e", native: "\u{1F31E}" }], version: 1 }, ringed_planet: { id: "ringed_planet", name: "Ringed Planet", keywords: ["outerspace"], skins: [{ unified: "1fa90", native: "\u{1FA90}" }], version: 12 }, star: { id: "star", name: "Star", keywords: ["night", "yellow"], skins: [{ unified: "2b50", native: "\u2B50" }], version: 1 }, star2: { id: "star2", name: "Glowing Star", keywords: ["star2", "night", "sparkle", "awesome", "good", "magic"], skins: [{ unified: "1f31f", native: "\u{1F31F}" }], version: 1 }, stars: { id: "stars", name: "Shooting Star", keywords: ["stars", "night", "photo"], skins: [{ unified: "1f320", native: "\u{1F320}" }], version: 1 }, milky_way: { id: "milky_way", name: "Milky Way", keywords: ["photo", "space", "stars"], skins: [{ unified: "1f30c", native: "\u{1F30C}" }], version: 1 }, cloud: { id: "cloud", name: "Cloud", keywords: ["weather", "sky"], skins: [{ unified: "2601-fe0f", native: "\u2601\uFE0F" }], version: 1 }, partly_sunny: { id: "partly_sunny", name: "Sun Behind Cloud", keywords: ["partly", "sunny", "weather", "nature", "cloudy", "morning", "fall", "spring"], skins: [{ unified: "26c5", native: "\u26C5" }], version: 1 }, thunder_cloud_and_rain: { id: "thunder_cloud_and_rain", name: "Cloud with Lightning and Rain", keywords: ["thunder", "weather"], skins: [{ unified: "26c8-fe0f", native: "\u26C8\uFE0F" }], version: 1 }, mostly_sunny: { id: "mostly_sunny", name: "Sun Behind Small Cloud", keywords: ["mostly", "sunny", "weather"], skins: [{ unified: "1f324-fe0f", native: "\u{1F324}\uFE0F" }], version: 1 }, barely_sunny: { id: "barely_sunny", name: "Sun Behind Large Cloud", keywords: ["barely", "sunny", "weather"], skins: [{ unified: "1f325-fe0f", native: "\u{1F325}\uFE0F" }], version: 1 }, partly_sunny_rain: { id: "partly_sunny_rain", name: "Sun Behind Rain Cloud", keywords: ["partly", "sunny", "weather"], skins: [{ unified: "1f326-fe0f", native: "\u{1F326}\uFE0F" }], version: 1 }, rain_cloud: { id: "rain_cloud", name: "Cloud with Rain", keywords: ["weather"], skins: [{ unified: "1f327-fe0f", native: "\u{1F327}\uFE0F" }], version: 1 }, snow_cloud: { id: "snow_cloud", name: "Cloud with Snow", keywords: ["weather"], skins: [{ unified: "1f328-fe0f", native: "\u{1F328}\uFE0F" }], version: 1 }, lightning: { id: "lightning", name: "Cloud with Lightning", keywords: ["weather", "thunder"], skins: [{ unified: "1f329-fe0f", native: "\u{1F329}\uFE0F" }], version: 1 }, tornado: { id: "tornado", name: "Tornado", keywords: ["cloud", "weather", "cyclone", "twister"], skins: [{ unified: "1f32a-fe0f", native: "\u{1F32A}\uFE0F" }], version: 1 }, fog: { id: "fog", name: "Fog", keywords: ["weather"], skins: [{ unified: "1f32b-fe0f", native: "\u{1F32B}\uFE0F" }], version: 1 }, wind_blowing_face: { id: "wind_blowing_face", name: "Wind Face", keywords: ["blowing", "gust", "air"], skins: [{ unified: "1f32c-fe0f", native: "\u{1F32C}\uFE0F" }], version: 1 }, cyclone: { id: "cyclone", name: "Cyclone", keywords: ["weather", "swirl", "blue", "cloud", "vortex", "spiral", "whirlpool", "spin", "tornado", "hurricane", "typhoon"], skins: [{ unified: "1f300", native: "\u{1F300}" }], version: 1 }, rainbow: { id: "rainbow", name: "Rainbow", keywords: ["nature", "happy", "unicorn", "face", "photo", "sky", "spring"], skins: [{ unified: "1f308", native: "\u{1F308}" }], version: 1 }, closed_umbrella: { id: "closed_umbrella", name: "Closed Umbrella", keywords: ["weather", "rain", "drizzle"], skins: [{ unified: "1f302", native: "\u{1F302}" }], version: 1 }, umbrella: { id: "umbrella", name: "Umbrella", keywords: ["weather", "spring"], skins: [{ unified: "2602-fe0f", native: "\u2602\uFE0F" }], version: 1 }, umbrella_with_rain_drops: { id: "umbrella_with_rain_drops", name: "Umbrella with Rain Drops", keywords: ["rainy", "weather", "spring"], skins: [{ unified: "2614", native: "\u2614" }], version: 1 }, umbrella_on_ground: { id: "umbrella_on_ground", name: "Umbrella on Ground", keywords: ["weather", "summer"], skins: [{ unified: "26f1-fe0f", native: "\u26F1\uFE0F" }], version: 1 }, zap: { id: "zap", name: "High Voltage", keywords: ["zap", "thunder", "weather", "lightning", "bolt", "fast"], skins: [{ unified: "26a1", native: "\u26A1" }], version: 1 }, snowflake: { id: "snowflake", name: "Snowflake", keywords: ["winter", "season", "cold", "weather", "christmas", "xmas"], skins: [{ unified: "2744-fe0f", native: "\u2744\uFE0F" }], version: 1 }, snowman: { id: "snowman", name: "Snowman", keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen"], skins: [{ unified: "2603-fe0f", native: "\u2603\uFE0F" }], version: 1 }, snowman_without_snow: { id: "snowman_without_snow", name: "Snowman Without Snow", keywords: ["winter", "season", "cold", "weather", "christmas", "xmas", "frozen"], skins: [{ unified: "26c4", native: "\u26C4" }], version: 1 }, comet: { id: "comet", name: "Comet", keywords: ["space"], skins: [{ unified: "2604-fe0f", native: "\u2604\uFE0F" }], version: 1 }, fire: { id: "fire", name: "Fire", keywords: ["hot", "cook", "flame"], skins: [{ unified: "1f525", native: "\u{1F525}" }], version: 1 }, droplet: { id: "droplet", name: "Droplet", keywords: ["water", "drip", "faucet", "spring"], skins: [{ unified: "1f4a7", native: "\u{1F4A7}" }], version: 1 }, ocean: { id: "ocean", name: "Water Wave", keywords: ["ocean", "sea", "nature", "tsunami", "disaster"], skins: [{ unified: "1f30a", native: "\u{1F30A}" }], version: 1 }, jack_o_lantern: { id: "jack_o_lantern", name: "Jack-O-Lantern", keywords: ["jack", "o", "lantern", "halloween", "light", "pumpkin", "creepy", "fall"], skins: [{ unified: "1f383", native: "\u{1F383}" }], version: 1 }, christmas_tree: { id: "christmas_tree", name: "Christmas Tree", keywords: ["festival", "vacation", "december", "xmas", "celebration"], skins: [{ unified: "1f384", native: "\u{1F384}" }], version: 1 }, fireworks: { id: "fireworks", name: "Fireworks", keywords: ["photo", "festival", "carnival", "congratulations"], skins: [{ unified: "1f386", native: "\u{1F386}" }], version: 1 }, sparkler: { id: "sparkler", name: "Sparkler", keywords: ["stars", "night", "shine"], skins: [{ unified: "1f387", native: "\u{1F387}" }], version: 1 }, firecracker: { id: "firecracker", name: "Firecracker", keywords: ["dynamite", "boom", "explode", "explosion", "explosive"], skins: [{ unified: "1f9e8", native: "\u{1F9E8}" }], version: 11 }, sparkles: { id: "sparkles", name: "Sparkles", keywords: ["stars", "shine", "shiny", "cool", "awesome", "good", "magic"], skins: [{ unified: "2728", native: "\u2728" }], version: 1 }, balloon: { id: "balloon", name: "Balloon", keywords: ["party", "celebration", "birthday", "circus"], skins: [{ unified: "1f388", native: "\u{1F388}" }], version: 1 }, tada: { id: "tada", name: "Party Popper", keywords: ["tada", "congratulations", "birthday", "magic", "circus", "celebration"], skins: [{ unified: "1f389", native: "\u{1F389}" }], version: 1 }, confetti_ball: { id: "confetti_ball", name: "Confetti Ball", keywords: ["festival", "party", "birthday", "circus"], skins: [{ unified: "1f38a", native: "\u{1F38A}" }], version: 1 }, tanabata_tree: { id: "tanabata_tree", name: "Tanabata Tree", keywords: ["plant", "nature", "branch", "summer", "bamboo", "wish", "star", "festival", "tanzaku"], skins: [{ unified: "1f38b", native: "\u{1F38B}" }], version: 1 }, bamboo: { id: "bamboo", name: "Pine Decoration", keywords: ["bamboo", "japanese", "plant", "nature", "vegetable", "panda", "new", "years"], skins: [{ unified: "1f38d", native: "\u{1F38D}" }], version: 1 }, dolls: { id: "dolls", name: "Japanese Dolls", keywords: ["toy", "kimono"], skins: [{ unified: "1f38e", native: "\u{1F38E}" }], version: 1 }, flags: { id: "flags", name: "Carp Streamer", keywords: ["flags", "fish", "japanese", "koinobori", "banner"], skins: [{ unified: "1f38f", native: "\u{1F38F}" }], version: 1 }, wind_chime: { id: "wind_chime", name: "Wind Chime", keywords: ["nature", "ding", "spring", "bell"], skins: [{ unified: "1f390", native: "\u{1F390}" }], version: 1 }, rice_scene: { id: "rice_scene", name: "Moon Viewing Ceremony", keywords: ["rice", "scene", "photo", "japan", "asia", "tsukimi"], skins: [{ unified: "1f391", native: "\u{1F391}" }], version: 1 }, red_envelope: { id: "red_envelope", name: "Red Envelope", keywords: ["gift"], skins: [{ unified: "1f9e7", native: "\u{1F9E7}" }], version: 11 }, ribbon: { id: "ribbon", name: "Ribbon", keywords: ["decoration", "pink", "girl", "bowtie"], skins: [{ unified: "1f380", native: "\u{1F380}" }], version: 1 }, gift: { id: "gift", name: "Wrapped Gift", keywords: ["present", "birthday", "christmas", "xmas"], skins: [{ unified: "1f381", native: "\u{1F381}" }], version: 1 }, reminder_ribbon: { id: "reminder_ribbon", name: "Reminder Ribbon", keywords: ["sports", "cause", "support", "awareness"], skins: [{ unified: "1f397-fe0f", native: "\u{1F397}\uFE0F" }], version: 1 }, admission_tickets: { id: "admission_tickets", name: "Admission Tickets", keywords: ["sports", "concert", "entrance"], skins: [{ unified: "1f39f-fe0f", native: "\u{1F39F}\uFE0F" }], version: 1 }, ticket: { id: "ticket", name: "Ticket", keywords: ["event", "concert", "pass"], skins: [{ unified: "1f3ab", native: "\u{1F3AB}" }], version: 1 }, medal: { id: "medal", name: "Military Medal", keywords: ["award", "winning", "army"], skins: [{ unified: "1f396-fe0f", native: "\u{1F396}\uFE0F" }], version: 1 }, trophy: { id: "trophy", name: "Trophy", keywords: ["win", "award", "contest", "place", "ftw", "ceremony"], skins: [{ unified: "1f3c6", native: "\u{1F3C6}" }], version: 1 }, sports_medal: { id: "sports_medal", name: "Sports Medal", keywords: ["award", "winning"], skins: [{ unified: "1f3c5", native: "\u{1F3C5}" }], version: 1 }, first_place_medal: { id: "first_place_medal", name: "1st Place Medal", keywords: ["first", "award", "winning"], skins: [{ unified: "1f947", native: "\u{1F947}" }], version: 3 }, second_place_medal: { id: "second_place_medal", name: "2nd Place Medal", keywords: ["second", "award"], skins: [{ unified: "1f948", native: "\u{1F948}" }], version: 3 }, third_place_medal: { id: "third_place_medal", name: "3rd Place Medal", keywords: ["third", "award"], skins: [{ unified: "1f949", native: "\u{1F949}" }], version: 3 }, soccer: { id: "soccer", name: "Soccer Ball", keywords: ["sports", "football"], skins: [{ unified: "26bd", native: "\u26BD" }], version: 1 }, baseball: { id: "baseball", name: "Baseball", keywords: ["sports", "balls"], skins: [{ unified: "26be", native: "\u26BE" }], version: 1 }, softball: { id: "softball", name: "Softball", keywords: ["sports", "balls"], skins: [{ unified: "1f94e", native: "\u{1F94E}" }], version: 11 }, basketball: { id: "basketball", name: "Basketball", keywords: ["sports", "balls", "NBA"], skins: [{ unified: "1f3c0", native: "\u{1F3C0}" }], version: 1 }, volleyball: { id: "volleyball", name: "Volleyball", keywords: ["sports", "balls"], skins: [{ unified: "1f3d0", native: "\u{1F3D0}" }], version: 1 }, football: { id: "football", name: "American Football", keywords: ["sports", "balls", "NFL"], skins: [{ unified: "1f3c8", native: "\u{1F3C8}" }], version: 1 }, rugby_football: { id: "rugby_football", name: "Rugby Football", keywords: ["sports", "team"], skins: [{ unified: "1f3c9", native: "\u{1F3C9}" }], version: 1 }, tennis: { id: "tennis", name: "Tennis", keywords: ["sports", "balls", "green"], skins: [{ unified: "1f3be", native: "\u{1F3BE}" }], version: 1 }, flying_disc: { id: "flying_disc", name: "Flying Disc", keywords: ["sports", "frisbee", "ultimate"], skins: [{ unified: "1f94f", native: "\u{1F94F}" }], version: 11 }, bowling: { id: "bowling", name: "Bowling", keywords: ["sports", "fun", "play"], skins: [{ unified: "1f3b3", native: "\u{1F3B3}" }], version: 1 }, cricket_bat_and_ball: { id: "cricket_bat_and_ball", name: "Cricket Game", keywords: ["bat", "and", "ball", "sports"], skins: [{ unified: "1f3cf", native: "\u{1F3CF}" }], version: 1 }, field_hockey_stick_and_ball: { id: "field_hockey_stick_and_ball", name: "Field Hockey", keywords: ["stick", "and", "ball", "sports"], skins: [{ unified: "1f3d1", native: "\u{1F3D1}" }], version: 1 }, ice_hockey_stick_and_puck: { id: "ice_hockey_stick_and_puck", name: "Ice Hockey", keywords: ["stick", "and", "puck", "sports"], skins: [{ unified: "1f3d2", native: "\u{1F3D2}" }], version: 1 }, lacrosse: { id: "lacrosse", name: "Lacrosse", keywords: ["sports", "ball", "stick"], skins: [{ unified: "1f94d", native: "\u{1F94D}" }], version: 11 }, table_tennis_paddle_and_ball: { id: "table_tennis_paddle_and_ball", name: "Ping Pong", keywords: ["table", "tennis", "paddle", "and", "ball", "sports", "pingpong"], skins: [{ unified: "1f3d3", native: "\u{1F3D3}" }], version: 1 }, badminton_racquet_and_shuttlecock: { id: "badminton_racquet_and_shuttlecock", name: "Badminton", keywords: ["racquet", "and", "shuttlecock", "sports"], skins: [{ unified: "1f3f8", native: "\u{1F3F8}" }], version: 1 }, boxing_glove: { id: "boxing_glove", name: "Boxing Glove", keywords: ["sports", "fighting"], skins: [{ unified: "1f94a", native: "\u{1F94A}" }], version: 3 }, martial_arts_uniform: { id: "martial_arts_uniform", name: "Martial Arts Uniform", keywords: ["judo", "karate", "taekwondo"], skins: [{ unified: "1f94b", native: "\u{1F94B}" }], version: 3 }, goal_net: { id: "goal_net", name: "Goal Net", keywords: ["sports"], skins: [{ unified: "1f945", native: "\u{1F945}" }], version: 3 }, golf: { id: "golf", name: "Flag in Hole", keywords: ["golf", "sports", "business", "summer"], skins: [{ unified: "26f3", native: "\u26F3" }], version: 1 }, ice_skate: { id: "ice_skate", name: "Ice Skate", keywords: ["sports"], skins: [{ unified: "26f8-fe0f", native: "\u26F8\uFE0F" }], version: 1 }, fishing_pole_and_fish: { id: "fishing_pole_and_fish", name: "Fishing Pole", keywords: ["and", "fish", "food", "hobby", "summer"], skins: [{ unified: "1f3a3", native: "\u{1F3A3}" }], version: 1 }, diving_mask: { id: "diving_mask", name: "Diving Mask", keywords: ["sport", "ocean"], skins: [{ unified: "1f93f", native: "\u{1F93F}" }], version: 12 }, running_shirt_with_sash: { id: "running_shirt_with_sash", name: "Running Shirt", keywords: ["with", "sash", "play", "pageant"], skins: [{ unified: "1f3bd", native: "\u{1F3BD}" }], version: 1 }, ski: { id: "ski", name: "Skis", keywords: ["ski", "sports", "winter", "cold", "snow"], skins: [{ unified: "1f3bf", native: "\u{1F3BF}" }], version: 1 }, sled: { id: "sled", name: "Sled", keywords: ["sleigh", "luge", "toboggan"], skins: [{ unified: "1f6f7", native: "\u{1F6F7}" }], version: 5 }, curling_stone: { id: "curling_stone", name: "Curling Stone", keywords: ["sports"], skins: [{ unified: "1f94c", native: "\u{1F94C}" }], version: 5 }, dart: { id: "dart", name: "Bullseye", keywords: ["dart", "direct", "hit", "game", "play", "bar", "target"], skins: [{ unified: "1f3af", native: "\u{1F3AF}" }], version: 1 }, "yo-yo": { id: "yo-yo", name: "Yo-Yo", keywords: ["yo", "toy"], skins: [{ unified: "1fa80", native: "\u{1FA80}" }], version: 12 }, kite: { id: "kite", name: "Kite", keywords: ["wind", "fly"], skins: [{ unified: "1fa81", native: "\u{1FA81}" }], version: 12 }, gun: { id: "gun", name: "Pistol", keywords: ["gun", "violence", "weapon", "revolver"], skins: [{ unified: "1f52b", native: "\u{1F52B}" }], version: 1 }, "8ball": { id: "8ball", name: "Billiards", keywords: ["8ball", "pool", "8", "ball", "hobby", "game", "luck", "magic"], skins: [{ unified: "1f3b1", native: "\u{1F3B1}" }], version: 1 }, crystal_ball: { id: "crystal_ball", name: "Crystal Ball", keywords: ["disco", "party", "magic", "circus", "fortune", "teller"], skins: [{ unified: "1f52e", native: "\u{1F52E}" }], version: 1 }, magic_wand: { id: "magic_wand", name: "Magic Wand", keywords: ["supernature", "power"], skins: [{ unified: "1fa84", native: "\u{1FA84}" }], version: 13 }, video_game: { id: "video_game", name: "Video Game", keywords: ["play", "console", "PS4", "controller"], skins: [{ unified: "1f3ae", native: "\u{1F3AE}" }], version: 1 }, joystick: { id: "joystick", name: "Joystick", keywords: ["game", "play"], skins: [{ unified: "1f579-fe0f", native: "\u{1F579}\uFE0F" }], version: 1 }, slot_machine: { id: "slot_machine", name: "Slot Machine", keywords: ["bet", "gamble", "vegas", "fruit", "luck", "casino"], skins: [{ unified: "1f3b0", native: "\u{1F3B0}" }], version: 1 }, game_die: { id: "game_die", name: "Game Die", keywords: ["dice", "random", "tabletop", "play", "luck"], skins: [{ unified: "1f3b2", native: "\u{1F3B2}" }], version: 1 }, jigsaw: { id: "jigsaw", name: "Puzzle Piece", keywords: ["jigsaw", "interlocking"], skins: [{ unified: "1f9e9", native: "\u{1F9E9}" }], version: 11 }, teddy_bear: { id: "teddy_bear", name: "Teddy Bear", keywords: ["plush", "stuffed"], skins: [{ unified: "1f9f8", native: "\u{1F9F8}" }], version: 11 }, pinata: { id: "pinata", name: "Pinata", keywords: ["mexico", "candy", "celebration"], skins: [{ unified: "1fa85", native: "\u{1FA85}" }], version: 13 }, mirror_ball: { id: "mirror_ball", name: "Mirror Ball", keywords: ["disco", "dance", "party"], skins: [{ unified: "1faa9", native: "\u{1FAA9}" }], version: 14 }, nesting_dolls: { id: "nesting_dolls", name: "Nesting Dolls", keywords: ["matryoshka", "toy"], skins: [{ unified: "1fa86", native: "\u{1FA86}" }], version: 13 }, spades: { id: "spades", name: "Spade Suit", keywords: ["spades", "poker", "cards", "suits", "magic"], skins: [{ unified: "2660-fe0f", native: "\u2660\uFE0F" }], version: 1 }, hearts: { id: "hearts", name: "Heart Suit", keywords: ["hearts", "poker", "cards", "magic", "suits"], skins: [{ unified: "2665-fe0f", native: "\u2665\uFE0F" }], version: 1 }, diamonds: { id: "diamonds", name: "Diamond Suit", keywords: ["diamonds", "poker", "cards", "magic", "suits"], skins: [{ unified: "2666-fe0f", native: "\u2666\uFE0F" }], version: 1 }, clubs: { id: "clubs", name: "Club Suit", keywords: ["clubs", "poker", "cards", "magic", "suits"], skins: [{ unified: "2663-fe0f", native: "\u2663\uFE0F" }], version: 1 }, chess_pawn: { id: "chess_pawn", name: "Chess Pawn", keywords: ["expendable"], skins: [{ unified: "265f-fe0f", native: "\u265F\uFE0F" }], version: 11 }, black_joker: { id: "black_joker", name: "Joker", keywords: ["black", "poker", "cards", "game", "play", "magic"], skins: [{ unified: "1f0cf", native: "\u{1F0CF}" }], version: 1 }, mahjong: { id: "mahjong", name: "Mahjong Red Dragon", keywords: ["game", "play", "chinese", "kanji"], skins: [{ unified: "1f004", native: "\u{1F004}" }], version: 1 }, flower_playing_cards: { id: "flower_playing_cards", name: "Flower Playing Cards", keywords: ["game", "sunset", "red"], skins: [{ unified: "1f3b4", native: "\u{1F3B4}" }], version: 1 }, performing_arts: { id: "performing_arts", name: "Performing Arts", keywords: ["acting", "theater", "drama"], skins: [{ unified: "1f3ad", native: "\u{1F3AD}" }], version: 1 }, frame_with_picture: { id: "frame_with_picture", name: "Framed Picture", keywords: ["frame", "with", "photography"], skins: [{ unified: "1f5bc-fe0f", native: "\u{1F5BC}\uFE0F" }], version: 1 }, art: { id: "art", name: "Artist Palette", keywords: ["art", "design", "paint", "draw", "colors"], skins: [{ unified: "1f3a8", native: "\u{1F3A8}" }], version: 1 }, thread: { id: "thread", name: "Thread", keywords: ["needle", "sewing", "spool", "string"], skins: [{ unified: "1f9f5", native: "\u{1F9F5}" }], version: 11 }, sewing_needle: { id: "sewing_needle", name: "Sewing Needle", keywords: ["stitches"], skins: [{ unified: "1faa1", native: "\u{1FAA1}" }], version: 13 }, yarn: { id: "yarn", name: "Yarn", keywords: ["ball", "crochet", "knit"], skins: [{ unified: "1f9f6", native: "\u{1F9F6}" }], version: 11 }, knot: { id: "knot", name: "Knot", keywords: ["rope", "scout"], skins: [{ unified: "1faa2", native: "\u{1FAA2}" }], version: 13 }, eyeglasses: { id: "eyeglasses", name: "Glasses", keywords: ["eyeglasses", "fashion", "accessories", "eyesight", "nerdy", "dork", "geek"], skins: [{ unified: "1f453", native: "\u{1F453}" }], version: 1 }, dark_sunglasses: { id: "dark_sunglasses", name: "Sunglasses", keywords: ["dark", "face", "cool", "accessories"], skins: [{ unified: "1f576-fe0f", native: "\u{1F576}\uFE0F" }], version: 1 }, goggles: { id: "goggles", name: "Goggles", keywords: ["eyes", "protection", "safety"], skins: [{ unified: "1f97d", native: "\u{1F97D}" }], version: 11 }, lab_coat: { id: "lab_coat", name: "Lab Coat", keywords: ["doctor", "experiment", "scientist", "chemist"], skins: [{ unified: "1f97c", native: "\u{1F97C}" }], version: 11 }, safety_vest: { id: "safety_vest", name: "Safety Vest", keywords: ["protection"], skins: [{ unified: "1f9ba", native: "\u{1F9BA}" }], version: 12 }, necktie: { id: "necktie", name: "Necktie", keywords: ["shirt", "suitup", "formal", "fashion", "cloth", "business"], skins: [{ unified: "1f454", native: "\u{1F454}" }], version: 1 }, shirt: { id: "shirt", name: "T-Shirt", keywords: ["shirt", "tshirt", "t", "fashion", "cloth", "casual", "tee"], skins: [{ unified: "1f455", native: "\u{1F455}" }], version: 1 }, jeans: { id: "jeans", name: "Jeans", keywords: ["fashion", "shopping"], skins: [{ unified: "1f456", native: "\u{1F456}" }], version: 1 }, scarf: { id: "scarf", name: "Scarf", keywords: ["neck", "winter", "clothes"], skins: [{ unified: "1f9e3", native: "\u{1F9E3}" }], version: 5 }, gloves: { id: "gloves", name: "Gloves", keywords: ["hands", "winter", "clothes"], skins: [{ unified: "1f9e4", native: "\u{1F9E4}" }], version: 5 }, coat: { id: "coat", name: "Coat", keywords: ["jacket"], skins: [{ unified: "1f9e5", native: "\u{1F9E5}" }], version: 5 }, socks: { id: "socks", name: "Socks", keywords: ["stockings", "clothes"], skins: [{ unified: "1f9e6", native: "\u{1F9E6}" }], version: 5 }, dress: { id: "dress", name: "Dress", keywords: ["clothes", "fashion", "shopping"], skins: [{ unified: "1f457", native: "\u{1F457}" }], version: 1 }, kimono: { id: "kimono", name: "Kimono", keywords: ["dress", "fashion", "women", "female", "japanese"], skins: [{ unified: "1f458", native: "\u{1F458}" }], version: 1 }, sari: { id: "sari", name: "Sari", keywords: ["dress"], skins: [{ unified: "1f97b", native: "\u{1F97B}" }], version: 12 }, "one-piece_swimsuit": { id: "one-piece_swimsuit", name: "One-Piece Swimsuit", keywords: ["one", "piece", "fashion"], skins: [{ unified: "1fa71", native: "\u{1FA71}" }], version: 12 }, briefs: { id: "briefs", name: "Briefs", keywords: ["clothing"], skins: [{ unified: "1fa72", native: "\u{1FA72}" }], version: 12 }, shorts: { id: "shorts", name: "Shorts", keywords: ["clothing"], skins: [{ unified: "1fa73", native: "\u{1FA73}" }], version: 12 }, bikini: { id: "bikini", name: "Bikini", keywords: ["swimming", "female", "woman", "girl", "fashion", "beach", "summer"], skins: [{ unified: "1f459", native: "\u{1F459}" }], version: 1 }, womans_clothes: { id: "womans_clothes", name: "Womans Clothes", keywords: ["woman", "s", "fashion", "shopping", "bags", "female"], skins: [{ unified: "1f45a", native: "\u{1F45A}" }], version: 1 }, folding_hand_fan: { id: "folding_hand_fan", name: "Folding Hand Fan", keywords: ["flamenco", "hot"], skins: [{ unified: "1faad", native: "\u{1FAAD}" }], version: 15 }, purse: { id: "purse", name: "Purse", keywords: ["fashion", "accessories", "money", "sales", "shopping"], skins: [{ unified: "1f45b", native: "\u{1F45B}" }], version: 1 }, handbag: { id: "handbag", name: "Handbag", keywords: ["fashion", "accessory", "accessories", "shopping"], skins: [{ unified: "1f45c", native: "\u{1F45C}" }], version: 1 }, pouch: { id: "pouch", name: "Pouch", keywords: ["clutch", "bag", "accessories", "shopping"], skins: [{ unified: "1f45d", native: "\u{1F45D}" }], version: 1 }, shopping_bags: { id: "shopping_bags", name: "Shopping Bags", keywords: ["mall", "buy", "purchase"], skins: [{ unified: "1f6cd-fe0f", native: "\u{1F6CD}\uFE0F" }], version: 1 }, school_satchel: { id: "school_satchel", name: "Backpack", keywords: ["school", "satchel", "student", "education", "bag"], skins: [{ unified: "1f392", native: "\u{1F392}" }], version: 1 }, thong_sandal: { id: "thong_sandal", name: "Thong Sandal", keywords: ["footwear", "summer"], skins: [{ unified: "1fa74", native: "\u{1FA74}" }], version: 13 }, mans_shoe: { id: "mans_shoe", name: "Mans Shoe", keywords: ["man", "s", "fashion", "male"], skins: [{ unified: "1f45e", native: "\u{1F45E}" }], version: 1 }, athletic_shoe: { id: "athletic_shoe", name: "Running Shoe", keywords: ["athletic", "shoes", "sports", "sneakers"], skins: [{ unified: "1f45f", native: "\u{1F45F}" }], version: 1 }, hiking_boot: { id: "hiking_boot", name: "Hiking Boot", keywords: ["backpacking", "camping"], skins: [{ unified: "1f97e", native: "\u{1F97E}" }], version: 11 }, womans_flat_shoe: { id: "womans_flat_shoe", name: "Flat Shoe", keywords: ["womans", "ballet", "slip", "on", "slipper"], skins: [{ unified: "1f97f", native: "\u{1F97F}" }], version: 11 }, high_heel: { id: "high_heel", name: "High-Heeled Shoe", keywords: ["high", "heel", "heeled", "fashion", "shoes", "female", "pumps", "stiletto"], skins: [{ unified: "1f460", native: "\u{1F460}" }], version: 1 }, sandal: { id: "sandal", name: "Womans Sandal", keywords: ["woman", "s", "shoes", "fashion", "flip", "flops"], skins: [{ unified: "1f461", native: "\u{1F461}" }], version: 1 }, ballet_shoes: { id: "ballet_shoes", name: "Ballet Shoes", keywords: ["dance"], skins: [{ unified: "1fa70", native: "\u{1FA70}" }], version: 12 }, boot: { id: "boot", name: "Womans Boots", keywords: ["boot", "woman", "s", "shoes", "fashion"], skins: [{ unified: "1f462", native: "\u{1F462}" }], version: 1 }, hair_pick: { id: "hair_pick", name: "Hair Pick", keywords: ["afro", "comb"], skins: [{ unified: "1faae", native: "\u{1FAAE}" }], version: 15 }, crown: { id: "crown", name: "Crown", keywords: ["king", "kod", "leader", "royalty", "lord"], skins: [{ unified: "1f451", native: "\u{1F451}" }], version: 1 }, womans_hat: { id: "womans_hat", name: "Womans Hat", keywords: ["woman", "s", "fashion", "accessories", "female", "lady", "spring"], skins: [{ unified: "1f452", native: "\u{1F452}" }], version: 1 }, tophat: { id: "tophat", name: "Top Hat", keywords: ["tophat", "magic", "gentleman", "classy", "circus"], skins: [{ unified: "1f3a9", native: "\u{1F3A9}" }], version: 1 }, mortar_board: { id: "mortar_board", name: "Graduation Cap", keywords: ["mortar", "board", "school", "college", "degree", "university", "hat", "legal", "learn", "education"], skins: [{ unified: "1f393", native: "\u{1F393}" }], version: 1 }, billed_cap: { id: "billed_cap", name: "Billed Cap", keywords: ["baseball"], skins: [{ unified: "1f9e2", native: "\u{1F9E2}" }], version: 5 }, military_helmet: { id: "military_helmet", name: "Military Helmet", keywords: ["army", "protection"], skins: [{ unified: "1fa96", native: "\u{1FA96}" }], version: 13 }, helmet_with_white_cross: { id: "helmet_with_white_cross", name: "Rescue Worker\u2019s Helmet", keywords: ["with", "white", "cross", "worker", "s", "construction", "build"], skins: [{ unified: "26d1-fe0f", native: "\u26D1\uFE0F" }], version: 1 }, prayer_beads: { id: "prayer_beads", name: "Prayer Beads", keywords: ["dhikr", "religious"], skins: [{ unified: "1f4ff", native: "\u{1F4FF}" }], version: 1 }, lipstick: { id: "lipstick", name: "Lipstick", keywords: ["female", "girl", "fashion", "woman"], skins: [{ unified: "1f484", native: "\u{1F484}" }], version: 1 }, ring: { id: "ring", name: "Ring", keywords: ["wedding", "propose", "marriage", "valentines", "diamond", "fashion", "jewelry", "gem", "engagement"], skins: [{ unified: "1f48d", native: "\u{1F48D}" }], version: 1 }, gem: { id: "gem", name: "Gem Stone", keywords: ["blue", "ruby", "diamond", "jewelry"], skins: [{ unified: "1f48e", native: "\u{1F48E}" }], version: 1 }, mute: { id: "mute", name: "Muted Speaker", keywords: ["mute", "sound", "volume", "silence", "quiet"], skins: [{ unified: "1f507", native: "\u{1F507}" }], version: 1 }, speaker: { id: "speaker", name: "Speaker", keywords: ["low", "volume", "sound", "silence", "broadcast"], skins: [{ unified: "1f508", native: "\u{1F508}" }], version: 1 }, sound: { id: "sound", name: "Speaker Medium Volume", keywords: ["sound", "broadcast"], skins: [{ unified: "1f509", native: "\u{1F509}" }], version: 1 }, loud_sound: { id: "loud_sound", name: "Speaker High Volume", keywords: ["loud", "sound", "noise", "noisy", "broadcast"], skins: [{ unified: "1f50a", native: "\u{1F50A}" }], version: 1 }, loudspeaker: { id: "loudspeaker", name: "Loudspeaker", keywords: ["volume", "sound"], skins: [{ unified: "1f4e2", native: "\u{1F4E2}" }], version: 1 }, mega: { id: "mega", name: "Megaphone", keywords: ["mega", "sound", "speaker", "volume"], skins: [{ unified: "1f4e3", native: "\u{1F4E3}" }], version: 1 }, postal_horn: { id: "postal_horn", name: "Postal Horn", keywords: ["instrument", "music"], skins: [{ unified: "1f4ef", native: "\u{1F4EF}" }], version: 1 }, bell: { id: "bell", name: "Bell", keywords: ["sound", "notification", "christmas", "xmas", "chime"], skins: [{ unified: "1f514", native: "\u{1F514}" }], version: 1 }, no_bell: { id: "no_bell", name: "Bell with Slash", keywords: ["no", "sound", "volume", "mute", "quiet", "silent"], skins: [{ unified: "1f515", native: "\u{1F515}" }], version: 1 }, musical_score: { id: "musical_score", name: "Musical Score", keywords: ["treble", "clef", "compose"], skins: [{ unified: "1f3bc", native: "\u{1F3BC}" }], version: 1 }, musical_note: { id: "musical_note", name: "Musical Note", keywords: ["score", "tone", "sound"], skins: [{ unified: "1f3b5", native: "\u{1F3B5}" }], version: 1 }, notes: { id: "notes", name: "Musical Notes", keywords: ["music", "score"], skins: [{ unified: "1f3b6", native: "\u{1F3B6}" }], version: 1 }, studio_microphone: { id: "studio_microphone", name: "Studio Microphone", keywords: ["sing", "recording", "artist", "talkshow"], skins: [{ unified: "1f399-fe0f", native: "\u{1F399}\uFE0F" }], version: 1 }, level_slider: { id: "level_slider", name: "Level Slider", keywords: ["scale"], skins: [{ unified: "1f39a-fe0f", native: "\u{1F39A}\uFE0F" }], version: 1 }, control_knobs: { id: "control_knobs", name: "Control Knobs", keywords: ["dial"], skins: [{ unified: "1f39b-fe0f", native: "\u{1F39B}\uFE0F" }], version: 1 }, microphone: { id: "microphone", name: "Microphone", keywords: ["sound", "music", "PA", "sing", "talkshow"], skins: [{ unified: "1f3a4", native: "\u{1F3A4}" }], version: 1 }, headphones: { id: "headphones", name: "Headphone", keywords: ["headphones", "music", "score", "gadgets"], skins: [{ unified: "1f3a7", native: "\u{1F3A7}" }], version: 1 }, radio: { id: "radio", name: "Radio", keywords: ["communication", "music", "podcast", "program"], skins: [{ unified: "1f4fb", native: "\u{1F4FB}" }], version: 1 }, saxophone: { id: "saxophone", name: "Saxophone", keywords: ["music", "instrument", "jazz", "blues"], skins: [{ unified: "1f3b7", native: "\u{1F3B7}" }], version: 1 }, accordion: { id: "accordion", name: "Accordion", keywords: ["music"], skins: [{ unified: "1fa97", native: "\u{1FA97}" }], version: 13 }, guitar: { id: "guitar", name: "Guitar", keywords: ["music", "instrument"], skins: [{ unified: "1f3b8", native: "\u{1F3B8}" }], version: 1 }, musical_keyboard: { id: "musical_keyboard", name: "Musical Keyboard", keywords: ["piano", "instrument", "compose"], skins: [{ unified: "1f3b9", native: "\u{1F3B9}" }], version: 1 }, trumpet: { id: "trumpet", name: "Trumpet", keywords: ["music", "brass"], skins: [{ unified: "1f3ba", native: "\u{1F3BA}" }], version: 1 }, violin: { id: "violin", name: "Violin", keywords: ["music", "instrument", "orchestra", "symphony"], skins: [{ unified: "1f3bb", native: "\u{1F3BB}" }], version: 1 }, banjo: { id: "banjo", name: "Banjo", keywords: ["music", "instructment"], skins: [{ unified: "1fa95", native: "\u{1FA95}" }], version: 12 }, drum_with_drumsticks: { id: "drum_with_drumsticks", name: "Drum", keywords: ["with", "drumsticks", "music", "instrument", "snare"], skins: [{ unified: "1f941", native: "\u{1F941}" }], version: 3 }, long_drum: { id: "long_drum", name: "Long Drum", keywords: ["music"], skins: [{ unified: "1fa98", native: "\u{1FA98}" }], version: 13 }, maracas: { id: "maracas", name: "Maracas", keywords: ["music", "instrument", "percussion"], skins: [{ unified: "1fa87", native: "\u{1FA87}" }], version: 15 }, flute: { id: "flute", name: "Flute", keywords: ["bamboo", "music", "instrument", "pied", "piper"], skins: [{ unified: "1fa88", native: "\u{1FA88}" }], version: 15 }, iphone: { id: "iphone", name: "Mobile Phone", keywords: ["iphone", "technology", "apple", "gadgets", "dial"], skins: [{ unified: "1f4f1", native: "\u{1F4F1}" }], version: 1 }, calling: { id: "calling", name: "Mobile Phone with Arrow", keywords: ["calling", "iphone", "incoming"], skins: [{ unified: "1f4f2", native: "\u{1F4F2}" }], version: 1 }, phone: { id: "phone", name: "Telephone", keywords: ["phone", "technology", "communication", "dial"], skins: [{ unified: "260e-fe0f", native: "\u260E\uFE0F" }], version: 1 }, telephone_receiver: { id: "telephone_receiver", name: "Telephone Receiver", keywords: ["technology", "communication", "dial"], skins: [{ unified: "1f4de", native: "\u{1F4DE}" }], version: 1 }, pager: { id: "pager", name: "Pager", keywords: ["bbcall", "oldschool", "90s"], skins: [{ unified: "1f4df", native: "\u{1F4DF}" }], version: 1 }, fax: { id: "fax", name: "Fax Machine", keywords: ["communication", "technology"], skins: [{ unified: "1f4e0", native: "\u{1F4E0}" }], version: 1 }, battery: { id: "battery", name: "Battery", keywords: ["power", "energy", "sustain"], skins: [{ unified: "1f50b", native: "\u{1F50B}" }], version: 1 }, low_battery: { id: "low_battery", name: "Low Battery", keywords: ["drained", "dead"], skins: [{ unified: "1faab", native: "\u{1FAAB}" }], version: 14 }, electric_plug: { id: "electric_plug", name: "Electric Plug", keywords: ["charger", "power"], skins: [{ unified: "1f50c", native: "\u{1F50C}" }], version: 1 }, computer: { id: "computer", name: "Laptop", keywords: ["computer", "technology", "screen", "display", "monitor"], skins: [{ unified: "1f4bb", native: "\u{1F4BB}" }], version: 1 }, desktop_computer: { id: "desktop_computer", name: "Desktop Computer", keywords: ["technology", "computing", "screen"], skins: [{ unified: "1f5a5-fe0f", native: "\u{1F5A5}\uFE0F" }], version: 1 }, printer: { id: "printer", name: "Printer", keywords: ["paper", "ink"], skins: [{ unified: "1f5a8-fe0f", native: "\u{1F5A8}\uFE0F" }], version: 1 }, keyboard: { id: "keyboard", name: "Keyboard", keywords: ["technology", "computer", "type", "input", "text"], skins: [{ unified: "2328-fe0f", native: "\u2328\uFE0F" }], version: 1 }, three_button_mouse: { id: "three_button_mouse", name: "Computer Mouse", keywords: ["three", "button", "click"], skins: [{ unified: "1f5b1-fe0f", native: "\u{1F5B1}\uFE0F" }], version: 1 }, trackball: { id: "trackball", name: "Trackball", keywords: ["technology", "trackpad"], skins: [{ unified: "1f5b2-fe0f", native: "\u{1F5B2}\uFE0F" }], version: 1 }, minidisc: { id: "minidisc", name: "Minidisc", keywords: ["computer", "disk", "technology", "record", "data", "90s"], skins: [{ unified: "1f4bd", native: "\u{1F4BD}" }], version: 1 }, floppy_disk: { id: "floppy_disk", name: "Floppy Disk", keywords: ["oldschool", "technology", "save", "90s", "80s"], skins: [{ unified: "1f4be", native: "\u{1F4BE}" }], version: 1 }, cd: { id: "cd", name: "Optical Disc", keywords: ["cd", "disk", "technology", "dvd", "90s"], skins: [{ unified: "1f4bf", native: "\u{1F4BF}" }], version: 1 }, dvd: { id: "dvd", name: "Dvd", keywords: ["cd", "disk", "disc"], skins: [{ unified: "1f4c0", native: "\u{1F4C0}" }], version: 1 }, abacus: { id: "abacus", name: "Abacus", keywords: ["calculation"], skins: [{ unified: "1f9ee", native: "\u{1F9EE}" }], version: 11 }, movie_camera: { id: "movie_camera", name: "Movie Camera", keywords: ["film", "record"], skins: [{ unified: "1f3a5", native: "\u{1F3A5}" }], version: 1 }, film_frames: { id: "film_frames", name: "Film Frames", keywords: ["movie"], skins: [{ unified: "1f39e-fe0f", native: "\u{1F39E}\uFE0F" }], version: 1 }, film_projector: { id: "film_projector", name: "Film Projector", keywords: ["video", "tape", "record", "movie"], skins: [{ unified: "1f4fd-fe0f", native: "\u{1F4FD}\uFE0F" }], version: 1 }, clapper: { id: "clapper", name: "Clapper Board", keywords: ["movie", "film", "record"], skins: [{ unified: "1f3ac", native: "\u{1F3AC}" }], version: 1 }, tv: { id: "tv", name: "Television", keywords: ["tv", "technology", "program", "oldschool", "show"], skins: [{ unified: "1f4fa", native: "\u{1F4FA}" }], version: 1 }, camera: { id: "camera", name: "Camera", keywords: ["gadgets", "photography"], skins: [{ unified: "1f4f7", native: "\u{1F4F7}" }], version: 1 }, camera_with_flash: { id: "camera_with_flash", name: "Camera with Flash", keywords: ["photography", "gadgets"], skins: [{ unified: "1f4f8", native: "\u{1F4F8}" }], version: 1 }, video_camera: { id: "video_camera", name: "Video Camera", keywords: ["film", "record"], skins: [{ unified: "1f4f9", native: "\u{1F4F9}" }], version: 1 }, vhs: { id: "vhs", name: "Videocassette", keywords: ["vhs", "record", "video", "oldschool", "90s", "80s"], skins: [{ unified: "1f4fc", native: "\u{1F4FC}" }], version: 1 }, mag: { id: "mag", name: "Magnifying Glass Tilted Left", keywords: ["mag", "search", "zoom", "find", "detective"], skins: [{ unified: "1f50d", native: "\u{1F50D}" }], version: 1 }, mag_right: { id: "mag_right", name: "Magnifying Glass Tilted Right", keywords: ["mag", "search", "zoom", "find", "detective"], skins: [{ unified: "1f50e", native: "\u{1F50E}" }], version: 1 }, candle: { id: "candle", name: "Candle", keywords: ["fire", "wax"], skins: [{ unified: "1f56f-fe0f", native: "\u{1F56F}\uFE0F" }], version: 1 }, bulb: { id: "bulb", name: "Light Bulb", keywords: ["electricity", "idea"], skins: [{ unified: "1f4a1", native: "\u{1F4A1}" }], version: 1 }, flashlight: { id: "flashlight", name: "Flashlight", keywords: ["dark", "camping", "sight", "night"], skins: [{ unified: "1f526", native: "\u{1F526}" }], version: 1 }, izakaya_lantern: { id: "izakaya_lantern", name: "Izakaya Lantern", keywords: ["red", "paper", "light", "halloween", "spooky"], skins: [{ unified: "1f3ee", native: "\u{1F3EE}" }], version: 1 }, diya_lamp: { id: "diya_lamp", name: "Diya Lamp", keywords: ["lighting"], skins: [{ unified: "1fa94", native: "\u{1FA94}" }], version: 12 }, notebook_with_decorative_cover: { id: "notebook_with_decorative_cover", name: "Notebook with Decorative Cover", keywords: ["classroom", "notes", "record", "paper", "study"], skins: [{ unified: "1f4d4", native: "\u{1F4D4}" }], version: 1 }, closed_book: { id: "closed_book", name: "Closed Book", keywords: ["read", "library", "knowledge", "textbook", "learn"], skins: [{ unified: "1f4d5", native: "\u{1F4D5}" }], version: 1 }, book: { id: "book", name: "Open Book", keywords: ["read", "library", "knowledge", "literature", "learn", "study"], skins: [{ unified: "1f4d6", native: "\u{1F4D6}" }], version: 1 }, green_book: { id: "green_book", name: "Green Book", keywords: ["read", "library", "knowledge", "study"], skins: [{ unified: "1f4d7", native: "\u{1F4D7}" }], version: 1 }, blue_book: { id: "blue_book", name: "Blue Book", keywords: ["read", "library", "knowledge", "learn", "study"], skins: [{ unified: "1f4d8", native: "\u{1F4D8}" }], version: 1 }, orange_book: { id: "orange_book", name: "Orange Book", keywords: ["read", "library", "knowledge", "textbook", "study"], skins: [{ unified: "1f4d9", native: "\u{1F4D9}" }], version: 1 }, books: { id: "books", name: "Books", keywords: ["literature", "library", "study"], skins: [{ unified: "1f4da", native: "\u{1F4DA}" }], version: 1 }, notebook: { id: "notebook", name: "Notebook", keywords: ["stationery", "record", "notes", "paper", "study"], skins: [{ unified: "1f4d3", native: "\u{1F4D3}" }], version: 1 }, ledger: { id: "ledger", name: "Ledger", keywords: ["notes", "paper"], skins: [{ unified: "1f4d2", native: "\u{1F4D2}" }], version: 1 }, page_with_curl: { id: "page_with_curl", name: "Page with Curl", keywords: ["documents", "office", "paper"], skins: [{ unified: "1f4c3", native: "\u{1F4C3}" }], version: 1 }, scroll: { id: "scroll", name: "Scroll", keywords: ["documents", "ancient", "history", "paper"], skins: [{ unified: "1f4dc", native: "\u{1F4DC}" }], version: 1 }, page_facing_up: { id: "page_facing_up", name: "Page Facing Up", keywords: ["documents", "office", "paper", "information"], skins: [{ unified: "1f4c4", native: "\u{1F4C4}" }], version: 1 }, newspaper: { id: "newspaper", name: "Newspaper", keywords: ["press", "headline"], skins: [{ unified: "1f4f0", native: "\u{1F4F0}" }], version: 1 }, rolled_up_newspaper: { id: "rolled_up_newspaper", name: "Rolled-Up Newspaper", keywords: ["rolled", "up", "press", "headline"], skins: [{ unified: "1f5de-fe0f", native: "\u{1F5DE}\uFE0F" }], version: 1 }, bookmark_tabs: { id: "bookmark_tabs", name: "Bookmark Tabs", keywords: ["favorite", "save", "order", "tidy"], skins: [{ unified: "1f4d1", native: "\u{1F4D1}" }], version: 1 }, bookmark: { id: "bookmark", name: "Bookmark", keywords: ["favorite", "label", "save"], skins: [{ unified: "1f516", native: "\u{1F516}" }], version: 1 }, label: { id: "label", name: "Label", keywords: ["sale", "tag"], skins: [{ unified: "1f3f7-fe0f", native: "\u{1F3F7}\uFE0F" }], version: 1 }, moneybag: { id: "moneybag", name: "Money Bag", keywords: ["moneybag", "dollar", "payment", "coins", "sale"], skins: [{ unified: "1f4b0", native: "\u{1F4B0}" }], version: 1 }, coin: { id: "coin", name: "Coin", keywords: ["money", "currency"], skins: [{ unified: "1fa99", native: "\u{1FA99}" }], version: 13 }, yen: { id: "yen", name: "Yen Banknote", keywords: ["money", "sales", "japanese", "dollar", "currency"], skins: [{ unified: "1f4b4", native: "\u{1F4B4}" }], version: 1 }, dollar: { id: "dollar", name: "Dollar Banknote", keywords: ["money", "sales", "bill", "currency"], skins: [{ unified: "1f4b5", native: "\u{1F4B5}" }], version: 1 }, euro: { id: "euro", name: "Euro Banknote", keywords: ["money", "sales", "dollar", "currency"], skins: [{ unified: "1f4b6", native: "\u{1F4B6}" }], version: 1 }, pound: { id: "pound", name: "Pound Banknote", keywords: ["british", "sterling", "money", "sales", "bills", "uk", "england", "currency"], skins: [{ unified: "1f4b7", native: "\u{1F4B7}" }], version: 1 }, money_with_wings: { id: "money_with_wings", name: "Money with Wings", keywords: ["dollar", "bills", "payment", "sale"], skins: [{ unified: "1f4b8", native: "\u{1F4B8}" }], version: 1 }, credit_card: { id: "credit_card", name: "Credit Card", keywords: ["money", "sales", "dollar", "bill", "payment", "shopping"], skins: [{ unified: "1f4b3", native: "\u{1F4B3}" }], version: 1 }, receipt: { id: "receipt", name: "Receipt", keywords: ["accounting", "expenses"], skins: [{ unified: "1f9fe", native: "\u{1F9FE}" }], version: 11 }, chart: { id: "chart", name: "Chart Increasing with Yen", keywords: ["green", "square", "graph", "presentation", "stats"], skins: [{ unified: "1f4b9", native: "\u{1F4B9}" }], version: 1 }, email: { id: "email", name: "Envelope", keywords: ["email", "letter", "postal", "inbox", "communication"], skins: [{ unified: "2709-fe0f", native: "\u2709\uFE0F" }], version: 1 }, "e-mail": { id: "e-mail", name: "E-Mail", keywords: ["e", "mail", "communication", "inbox"], skins: [{ unified: "1f4e7", native: "\u{1F4E7}" }], version: 1 }, incoming_envelope: { id: "incoming_envelope", name: "Incoming Envelope", keywords: ["email", "inbox"], skins: [{ unified: "1f4e8", native: "\u{1F4E8}" }], version: 1 }, envelope_with_arrow: { id: "envelope_with_arrow", name: "Envelope with Arrow", keywords: ["email", "communication"], skins: [{ unified: "1f4e9", native: "\u{1F4E9}" }], version: 1 }, outbox_tray: { id: "outbox_tray", name: "Outbox Tray", keywords: ["inbox", "email"], skins: [{ unified: "1f4e4", native: "\u{1F4E4}" }], version: 1 }, inbox_tray: { id: "inbox_tray", name: "Inbox Tray", keywords: ["email", "documents"], skins: [{ unified: "1f4e5", native: "\u{1F4E5}" }], version: 1 }, package: { id: "package", name: "Package", keywords: ["mail", "gift", "cardboard", "box", "moving"], skins: [{ unified: "1f4e6", native: "\u{1F4E6}" }], version: 1 }, mailbox: { id: "mailbox", name: "Closed Mailbox with Raised Flag", keywords: ["email", "inbox", "communication"], skins: [{ unified: "1f4eb", native: "\u{1F4EB}" }], version: 1 }, mailbox_closed: { id: "mailbox_closed", name: "Closed Mailbox with Lowered Flag", keywords: ["email", "communication", "inbox"], skins: [{ unified: "1f4ea", native: "\u{1F4EA}" }], version: 1 }, mailbox_with_mail: { id: "mailbox_with_mail", name: "Open Mailbox with Raised Flag", keywords: ["mail", "email", "inbox", "communication"], skins: [{ unified: "1f4ec", native: "\u{1F4EC}" }], version: 1 }, mailbox_with_no_mail: { id: "mailbox_with_no_mail", name: "Open Mailbox with Lowered Flag", keywords: ["no", "mail", "email", "inbox"], skins: [{ unified: "1f4ed", native: "\u{1F4ED}" }], version: 1 }, postbox: { id: "postbox", name: "Postbox", keywords: ["email", "letter", "envelope"], skins: [{ unified: "1f4ee", native: "\u{1F4EE}" }], version: 1 }, ballot_box_with_ballot: { id: "ballot_box_with_ballot", name: "Ballot Box with Ballot", keywords: ["election", "vote"], skins: [{ unified: "1f5f3-fe0f", native: "\u{1F5F3}\uFE0F" }], version: 1 }, pencil2: { id: "pencil2", name: "Pencil", keywords: ["pencil2", "stationery", "write", "paper", "writing", "school", "study"], skins: [{ unified: "270f-fe0f", native: "\u270F\uFE0F" }], version: 1 }, black_nib: { id: "black_nib", name: "Black Nib", keywords: ["pen", "stationery", "writing", "write"], skins: [{ unified: "2712-fe0f", native: "\u2712\uFE0F" }], version: 1 }, lower_left_fountain_pen: { id: "lower_left_fountain_pen", name: "Fountain Pen", keywords: ["lower", "left", "stationery", "writing", "write"], skins: [{ unified: "1f58b-fe0f", native: "\u{1F58B}\uFE0F" }], version: 1 }, lower_left_ballpoint_pen: { id: "lower_left_ballpoint_pen", name: "Pen", keywords: ["lower", "left", "ballpoint", "stationery", "writing", "write"], skins: [{ unified: "1f58a-fe0f", native: "\u{1F58A}\uFE0F" }], version: 1 }, lower_left_paintbrush: { id: "lower_left_paintbrush", name: "Paintbrush", keywords: ["lower", "left", "drawing", "creativity", "art"], skins: [{ unified: "1f58c-fe0f", native: "\u{1F58C}\uFE0F" }], version: 1 }, lower_left_crayon: { id: "lower_left_crayon", name: "Crayon", keywords: ["lower", "left", "drawing", "creativity"], skins: [{ unified: "1f58d-fe0f", native: "\u{1F58D}\uFE0F" }], version: 1 }, memo: { id: "memo", name: "Memo", keywords: ["pencil", "write", "documents", "stationery", "paper", "writing", "legal", "exam", "quiz", "test", "study", "compose"], skins: [{ unified: "1f4dd", native: "\u{1F4DD}" }], version: 1 }, briefcase: { id: "briefcase", name: "Briefcase", keywords: ["business", "documents", "work", "law", "legal", "job", "career"], skins: [{ unified: "1f4bc", native: "\u{1F4BC}" }], version: 1 }, file_folder: { id: "file_folder", name: "File Folder", keywords: ["documents", "business", "office"], skins: [{ unified: "1f4c1", native: "\u{1F4C1}" }], version: 1 }, open_file_folder: { id: "open_file_folder", name: "Open File Folder", keywords: ["documents", "load"], skins: [{ unified: "1f4c2", native: "\u{1F4C2}" }], version: 1 }, card_index_dividers: { id: "card_index_dividers", name: "Card Index Dividers", keywords: ["organizing", "business", "stationery"], skins: [{ unified: "1f5c2-fe0f", native: "\u{1F5C2}\uFE0F" }], version: 1 }, date: { id: "date", name: "Calendar", keywords: ["date", "schedule"], skins: [{ unified: "1f4c5", native: "\u{1F4C5}" }], version: 1 }, calendar: { id: "calendar", name: "Tear-off Calendar", keywords: ["tear", "off", "schedule", "date", "planning"], skins: [{ unified: "1f4c6", native: "\u{1F4C6}" }], version: 1 }, spiral_note_pad: { id: "spiral_note_pad", name: "Spiral Notepad", keywords: ["note", "pad", "memo", "stationery"], skins: [{ unified: "1f5d2-fe0f", native: "\u{1F5D2}\uFE0F" }], version: 1 }, spiral_calendar_pad: { id: "spiral_calendar_pad", name: "Spiral Calendar", keywords: ["pad", "date", "schedule", "planning"], skins: [{ unified: "1f5d3-fe0f", native: "\u{1F5D3}\uFE0F" }], version: 1 }, card_index: { id: "card_index", name: "Card Index", keywords: ["business", "stationery"], skins: [{ unified: "1f4c7", native: "\u{1F4C7}" }], version: 1 }, chart_with_upwards_trend: { id: "chart_with_upwards_trend", name: "Chart Increasing", keywords: ["with", "upwards", "trend", "graph", "presentation", "stats", "recovery", "business", "economics", "money", "sales", "good", "success"], skins: [{ unified: "1f4c8", native: "\u{1F4C8}" }], version: 1 }, chart_with_downwards_trend: { id: "chart_with_downwards_trend", name: "Chart Decreasing", keywords: ["with", "downwards", "trend", "graph", "presentation", "stats", "recession", "business", "economics", "money", "sales", "bad", "failure"], skins: [{ unified: "1f4c9", native: "\u{1F4C9}" }], version: 1 }, bar_chart: { id: "bar_chart", name: "Bar Chart", keywords: ["graph", "presentation", "stats"], skins: [{ unified: "1f4ca", native: "\u{1F4CA}" }], version: 1 }, clipboard: { id: "clipboard", name: "Clipboard", keywords: ["stationery", "documents"], skins: [{ unified: "1f4cb", native: "\u{1F4CB}" }], version: 1 }, pushpin: { id: "pushpin", name: "Pushpin", keywords: ["stationery", "mark", "here"], skins: [{ unified: "1f4cc", native: "\u{1F4CC}" }], version: 1 }, round_pushpin: { id: "round_pushpin", name: "Round Pushpin", keywords: ["stationery", "location", "map", "here"], skins: [{ unified: "1f4cd", native: "\u{1F4CD}" }], version: 1 }, paperclip: { id: "paperclip", name: "Paperclip", keywords: ["documents", "stationery"], skins: [{ unified: "1f4ce", native: "\u{1F4CE}" }], version: 1 }, linked_paperclips: { id: "linked_paperclips", name: "Linked Paperclips", keywords: ["documents", "stationery"], skins: [{ unified: "1f587-fe0f", native: "\u{1F587}\uFE0F" }], version: 1 }, straight_ruler: { id: "straight_ruler", name: "Straight Ruler", keywords: ["stationery", "calculate", "length", "math", "school", "drawing", "architect", "sketch"], skins: [{ unified: "1f4cf", native: "\u{1F4CF}" }], version: 1 }, triangular_ruler: { id: "triangular_ruler", name: "Triangular Ruler", keywords: ["stationery", "math", "architect", "sketch"], skins: [{ unified: "1f4d0", native: "\u{1F4D0}" }], version: 1 }, scissors: { id: "scissors", name: "Scissors", keywords: ["stationery", "cut"], skins: [{ unified: "2702-fe0f", native: "\u2702\uFE0F" }], version: 1 }, card_file_box: { id: "card_file_box", name: "Card File Box", keywords: ["business", "stationery"], skins: [{ unified: "1f5c3-fe0f", native: "\u{1F5C3}\uFE0F" }], version: 1 }, file_cabinet: { id: "file_cabinet", name: "File Cabinet", keywords: ["filing", "organizing"], skins: [{ unified: "1f5c4-fe0f", native: "\u{1F5C4}\uFE0F" }], version: 1 }, wastebasket: { id: "wastebasket", name: "Wastebasket", keywords: ["bin", "trash", "rubbish", "garbage", "toss"], skins: [{ unified: "1f5d1-fe0f", native: "\u{1F5D1}\uFE0F" }], version: 1 }, lock: { id: "lock", name: "Lock", keywords: ["locked", "security", "password", "padlock"], skins: [{ unified: "1f512", native: "\u{1F512}" }], version: 1 }, unlock: { id: "unlock", name: "Unlocked", keywords: ["unlock", "privacy", "security"], skins: [{ unified: "1f513", native: "\u{1F513}" }], version: 1 }, lock_with_ink_pen: { id: "lock_with_ink_pen", name: "Locked with Pen", keywords: ["lock", "ink", "security", "secret"], skins: [{ unified: "1f50f", native: "\u{1F50F}" }], version: 1 }, closed_lock_with_key: { id: "closed_lock_with_key", name: "Locked with Key", keywords: ["closed", "lock", "security", "privacy"], skins: [{ unified: "1f510", native: "\u{1F510}" }], version: 1 }, key: { id: "key", name: "Key", keywords: ["lock", "door", "password"], skins: [{ unified: "1f511", native: "\u{1F511}" }], version: 1 }, old_key: { id: "old_key", name: "Old Key", keywords: ["lock", "door", "password"], skins: [{ unified: "1f5dd-fe0f", native: "\u{1F5DD}\uFE0F" }], version: 1 }, hammer: { id: "hammer", name: "Hammer", keywords: ["tools", "build", "create"], skins: [{ unified: "1f528", native: "\u{1F528}" }], version: 1 }, axe: { id: "axe", name: "Axe", keywords: ["tool", "chop", "cut"], skins: [{ unified: "1fa93", native: "\u{1FA93}" }], version: 12 }, pick: { id: "pick", name: "Pick", keywords: ["tools", "dig"], skins: [{ unified: "26cf-fe0f", native: "\u26CF\uFE0F" }], version: 1 }, hammer_and_pick: { id: "hammer_and_pick", name: "Hammer and Pick", keywords: ["tools", "build", "create"], skins: [{ unified: "2692-fe0f", native: "\u2692\uFE0F" }], version: 1 }, hammer_and_wrench: { id: "hammer_and_wrench", name: "Hammer and Wrench", keywords: ["tools", "build", "create"], skins: [{ unified: "1f6e0-fe0f", native: "\u{1F6E0}\uFE0F" }], version: 1 }, dagger_knife: { id: "dagger_knife", name: "Dagger", keywords: ["knife", "weapon"], skins: [{ unified: "1f5e1-fe0f", native: "\u{1F5E1}\uFE0F" }], version: 1 }, crossed_swords: { id: "crossed_swords", name: "Crossed Swords", keywords: ["weapon"], skins: [{ unified: "2694-fe0f", native: "\u2694\uFE0F" }], version: 1 }, bomb: { id: "bomb", name: "Bomb", keywords: ["boom", "explode", "explosion", "terrorism"], skins: [{ unified: "1f4a3", native: "\u{1F4A3}" }], version: 1 }, boomerang: { id: "boomerang", name: "Boomerang", keywords: ["weapon"], skins: [{ unified: "1fa83", native: "\u{1FA83}" }], version: 13 }, bow_and_arrow: { id: "bow_and_arrow", name: "Bow and Arrow", keywords: ["sports"], skins: [{ unified: "1f3f9", native: "\u{1F3F9}" }], version: 1 }, shield: { id: "shield", name: "Shield", keywords: ["protection", "security"], skins: [{ unified: "1f6e1-fe0f", native: "\u{1F6E1}\uFE0F" }], version: 1 }, carpentry_saw: { id: "carpentry_saw", name: "Carpentry Saw", keywords: ["cut", "chop"], skins: [{ unified: "1fa9a", native: "\u{1FA9A}" }], version: 13 }, wrench: { id: "wrench", name: "Wrench", keywords: ["tools", "diy", "ikea", "fix", "maintainer"], skins: [{ unified: "1f527", native: "\u{1F527}" }], version: 1 }, screwdriver: { id: "screwdriver", name: "Screwdriver", keywords: ["tools"], skins: [{ unified: "1fa9b", native: "\u{1FA9B}" }], version: 13 }, nut_and_bolt: { id: "nut_and_bolt", name: "Nut and Bolt", keywords: ["handy", "tools", "fix"], skins: [{ unified: "1f529", native: "\u{1F529}" }], version: 1 }, gear: { id: "gear", name: "Gear", keywords: ["cog"], skins: [{ unified: "2699-fe0f", native: "\u2699\uFE0F" }], version: 1 }, compression: { id: "compression", name: "Clamp", keywords: ["compression", "tool"], skins: [{ unified: "1f5dc-fe0f", native: "\u{1F5DC}\uFE0F" }], version: 1 }, scales: { id: "scales", name: "Balance Scale", keywords: ["scales", "law", "fairness", "weight"], skins: [{ unified: "2696-fe0f", native: "\u2696\uFE0F" }], version: 1 }, probing_cane: { id: "probing_cane", name: "White Cane", keywords: ["probing", "accessibility"], skins: [{ unified: "1f9af", native: "\u{1F9AF}" }], version: 12 }, link: { id: "link", name: "Link", keywords: ["rings", "url"], skins: [{ unified: "1f517", native: "\u{1F517}" }], version: 1 }, chains: { id: "chains", name: "Chains", keywords: ["lock", "arrest"], skins: [{ unified: "26d3-fe0f", native: "\u26D3\uFE0F" }], version: 1 }, hook: { id: "hook", name: "Hook", keywords: ["tools"], skins: [{ unified: "1fa9d", native: "\u{1FA9D}" }], version: 13 }, toolbox: { id: "toolbox", name: "Toolbox", keywords: ["tools", "diy", "fix", "maintainer", "mechanic"], skins: [{ unified: "1f9f0", native: "\u{1F9F0}" }], version: 11 }, magnet: { id: "magnet", name: "Magnet", keywords: ["attraction", "magnetic"], skins: [{ unified: "1f9f2", native: "\u{1F9F2}" }], version: 11 }, ladder: { id: "ladder", name: "Ladder", keywords: ["tools"], skins: [{ unified: "1fa9c", native: "\u{1FA9C}" }], version: 13 }, alembic: { id: "alembic", name: "Alembic", keywords: ["distilling", "science", "experiment", "chemistry"], skins: [{ unified: "2697-fe0f", native: "\u2697\uFE0F" }], version: 1 }, test_tube: { id: "test_tube", name: "Test Tube", keywords: ["chemistry", "experiment", "lab", "science"], skins: [{ unified: "1f9ea", native: "\u{1F9EA}" }], version: 11 }, petri_dish: { id: "petri_dish", name: "Petri Dish", keywords: ["bacteria", "biology", "culture", "lab"], skins: [{ unified: "1f9eb", native: "\u{1F9EB}" }], version: 11 }, dna: { id: "dna", name: "Dna", keywords: ["biologist", "genetics", "life"], skins: [{ unified: "1f9ec", native: "\u{1F9EC}" }], version: 11 }, microscope: { id: "microscope", name: "Microscope", keywords: ["laboratory", "experiment", "zoomin", "science", "study"], skins: [{ unified: "1f52c", native: "\u{1F52C}" }], version: 1 }, telescope: { id: "telescope", name: "Telescope", keywords: ["stars", "space", "zoom", "science", "astronomy"], skins: [{ unified: "1f52d", native: "\u{1F52D}" }], version: 1 }, satellite_antenna: { id: "satellite_antenna", name: "Satellite Antenna", keywords: ["communication", "future", "radio", "space"], skins: [{ unified: "1f4e1", native: "\u{1F4E1}" }], version: 1 }, syringe: { id: "syringe", name: "Syringe", keywords: ["health", "hospital", "drugs", "blood", "medicine", "needle", "doctor", "nurse"], skins: [{ unified: "1f489", native: "\u{1F489}" }], version: 1 }, drop_of_blood: { id: "drop_of_blood", name: "Drop of Blood", keywords: ["period", "hurt", "harm", "wound"], skins: [{ unified: "1fa78", native: "\u{1FA78}" }], version: 12 }, pill: { id: "pill", name: "Pill", keywords: ["health", "medicine", "doctor", "pharmacy", "drug"], skins: [{ unified: "1f48a", native: "\u{1F48A}" }], version: 1 }, adhesive_bandage: { id: "adhesive_bandage", name: "Adhesive Bandage", keywords: ["heal"], skins: [{ unified: "1fa79", native: "\u{1FA79}" }], version: 12 }, crutch: { id: "crutch", name: "Crutch", keywords: ["accessibility", "assist"], skins: [{ unified: "1fa7c", native: "\u{1FA7C}" }], version: 14 }, stethoscope: { id: "stethoscope", name: "Stethoscope", keywords: ["health"], skins: [{ unified: "1fa7a", native: "\u{1FA7A}" }], version: 12 }, "x-ray": { id: "x-ray", name: "X-Ray", keywords: ["x", "ray", "skeleton", "medicine"], skins: [{ unified: "1fa7b", native: "\u{1FA7B}" }], version: 14 }, door: { id: "door", name: "Door", keywords: ["house", "entry", "exit"], skins: [{ unified: "1f6aa", native: "\u{1F6AA}" }], version: 1 }, elevator: { id: "elevator", name: "Elevator", keywords: ["lift"], skins: [{ unified: "1f6d7", native: "\u{1F6D7}" }], version: 13 }, mirror: { id: "mirror", name: "Mirror", keywords: ["reflection"], skins: [{ unified: "1fa9e", native: "\u{1FA9E}" }], version: 13 }, window: { id: "window", name: "Window", keywords: ["scenery"], skins: [{ unified: "1fa9f", native: "\u{1FA9F}" }], version: 13 }, bed: { id: "bed", name: "Bed", keywords: ["sleep", "rest"], skins: [{ unified: "1f6cf-fe0f", native: "\u{1F6CF}\uFE0F" }], version: 1 }, couch_and_lamp: { id: "couch_and_lamp", name: "Couch and Lamp", keywords: ["read", "chill"], skins: [{ unified: "1f6cb-fe0f", native: "\u{1F6CB}\uFE0F" }], version: 1 }, chair: { id: "chair", name: "Chair", keywords: ["sit", "furniture"], skins: [{ unified: "1fa91", native: "\u{1FA91}" }], version: 12 }, toilet: { id: "toilet", name: "Toilet", keywords: ["restroom", "wc", "washroom", "bathroom", "potty"], skins: [{ unified: "1f6bd", native: "\u{1F6BD}" }], version: 1 }, plunger: { id: "plunger", name: "Plunger", keywords: ["toilet"], skins: [{ unified: "1faa0", native: "\u{1FAA0}" }], version: 13 }, shower: { id: "shower", name: "Shower", keywords: ["clean", "water", "bathroom"], skins: [{ unified: "1f6bf", native: "\u{1F6BF}" }], version: 1 }, bathtub: { id: "bathtub", name: "Bathtub", keywords: ["clean", "shower", "bathroom"], skins: [{ unified: "1f6c1", native: "\u{1F6C1}" }], version: 1 }, mouse_trap: { id: "mouse_trap", name: "Mouse Trap", keywords: ["cheese"], skins: [{ unified: "1faa4", native: "\u{1FAA4}" }], version: 13 }, razor: { id: "razor", name: "Razor", keywords: ["cut"], skins: [{ unified: "1fa92", native: "\u{1FA92}" }], version: 12 }, lotion_bottle: { id: "lotion_bottle", name: "Lotion Bottle", keywords: ["moisturizer", "sunscreen"], skins: [{ unified: "1f9f4", native: "\u{1F9F4}" }], version: 11 }, safety_pin: { id: "safety_pin", name: "Safety Pin", keywords: ["diaper"], skins: [{ unified: "1f9f7", native: "\u{1F9F7}" }], version: 11 }, broom: { id: "broom", name: "Broom", keywords: ["cleaning", "sweeping", "witch"], skins: [{ unified: "1f9f9", native: "\u{1F9F9}" }], version: 11 }, basket: { id: "basket", name: "Basket", keywords: ["laundry"], skins: [{ unified: "1f9fa", native: "\u{1F9FA}" }], version: 11 }, roll_of_paper: { id: "roll_of_paper", name: "Roll of Paper", keywords: [], skins: [{ unified: "1f9fb", native: "\u{1F9FB}" }], version: 11 }, bucket: { id: "bucket", name: "Bucket", keywords: ["water", "container"], skins: [{ unified: "1faa3", native: "\u{1FAA3}" }], version: 13 }, soap: { id: "soap", name: "Soap", keywords: ["bar", "bathing", "cleaning", "lather"], skins: [{ unified: "1f9fc", native: "\u{1F9FC}" }], version: 11 }, bubbles: { id: "bubbles", name: "Bubbles", keywords: ["soap", "fun", "carbonation", "sparkling"], skins: [{ unified: "1fae7", native: "\u{1FAE7}" }], version: 14 }, toothbrush: { id: "toothbrush", name: "Toothbrush", keywords: ["hygiene", "dental"], skins: [{ unified: "1faa5", native: "\u{1FAA5}" }], version: 13 }, sponge: { id: "sponge", name: "Sponge", keywords: ["absorbing", "cleaning", "porous"], skins: [{ unified: "1f9fd", native: "\u{1F9FD}" }], version: 11 }, fire_extinguisher: { id: "fire_extinguisher", name: "Fire Extinguisher", keywords: ["quench"], skins: [{ unified: "1f9ef", native: "\u{1F9EF}" }], version: 11 }, shopping_trolley: { id: "shopping_trolley", name: "Shopping Cart", keywords: ["trolley"], skins: [{ unified: "1f6d2", native: "\u{1F6D2}" }], version: 3 }, smoking: { id: "smoking", name: "Cigarette", keywords: ["smoking", "kills", "tobacco", "joint", "smoke"], skins: [{ unified: "1f6ac", native: "\u{1F6AC}" }], version: 1 }, coffin: { id: "coffin", name: "Coffin", keywords: ["vampire", "dead", "die", "death", "rip", "graveyard", "cemetery", "casket", "funeral", "box"], skins: [{ unified: "26b0-fe0f", native: "\u26B0\uFE0F" }], version: 1 }, headstone: { id: "headstone", name: "Headstone", keywords: ["death", "rip", "grave"], skins: [{ unified: "1faa6", native: "\u{1FAA6}" }], version: 13 }, funeral_urn: { id: "funeral_urn", name: "Funeral Urn", keywords: ["dead", "die", "death", "rip", "ashes"], skins: [{ unified: "26b1-fe0f", native: "\u26B1\uFE0F" }], version: 1 }, nazar_amulet: { id: "nazar_amulet", name: "Nazar Amulet", keywords: ["bead", "charm"], skins: [{ unified: "1f9ff", native: "\u{1F9FF}" }], version: 11 }, hamsa: { id: "hamsa", name: "Hamsa", keywords: ["religion", "protection"], skins: [{ unified: "1faac", native: "\u{1FAAC}" }], version: 14 }, moyai: { id: "moyai", name: "Moai", keywords: ["moyai", "rock", "easter", "island"], skins: [{ unified: "1f5ff", native: "\u{1F5FF}" }], version: 1 }, placard: { id: "placard", name: "Placard", keywords: ["announcement"], skins: [{ unified: "1faa7", native: "\u{1FAA7}" }], version: 13 }, identification_card: { id: "identification_card", name: "Identification Card", keywords: ["document"], skins: [{ unified: "1faaa", native: "\u{1FAAA}" }], version: 14 }, atm: { id: "atm", name: "Atm Sign", keywords: ["money", "sales", "cash", "blue", "square", "payment", "bank"], skins: [{ unified: "1f3e7", native: "\u{1F3E7}" }], version: 1 }, put_litter_in_its_place: { id: "put_litter_in_its_place", name: "Litter in Bin Sign", keywords: ["put", "its", "place", "blue", "square", "human", "info"], skins: [{ unified: "1f6ae", native: "\u{1F6AE}" }], version: 1 }, potable_water: { id: "potable_water", name: "Potable Water", keywords: ["blue", "square", "liquid", "restroom", "cleaning", "faucet"], skins: [{ unified: "1f6b0", native: "\u{1F6B0}" }], version: 1 }, wheelchair: { id: "wheelchair", name: "Wheelchair Symbol", keywords: ["blue", "square", "disabled", "accessibility"], skins: [{ unified: "267f", native: "\u267F" }], version: 1 }, mens: { id: "mens", name: "Men\u2019s Room", keywords: ["mens", "men", "s", "toilet", "restroom", "wc", "blue", "square", "gender", "male"], skins: [{ unified: "1f6b9", native: "\u{1F6B9}" }], version: 1 }, womens: { id: "womens", name: "Women\u2019s Room", keywords: ["womens", "women", "s", "purple", "square", "woman", "female", "toilet", "loo", "restroom", "gender"], skins: [{ unified: "1f6ba", native: "\u{1F6BA}" }], version: 1 }, restroom: { id: "restroom", name: "Restroom", keywords: ["blue", "square", "toilet", "refresh", "wc", "gender"], skins: [{ unified: "1f6bb", native: "\u{1F6BB}" }], version: 1 }, baby_symbol: { id: "baby_symbol", name: "Baby Symbol", keywords: ["orange", "square", "child"], skins: [{ unified: "1f6bc", native: "\u{1F6BC}" }], version: 1 }, wc: { id: "wc", name: "Water Closet", keywords: ["wc", "toilet", "restroom", "blue", "square"], skins: [{ unified: "1f6be", native: "\u{1F6BE}" }], version: 1 }, passport_control: { id: "passport_control", name: "Passport Control", keywords: ["custom", "blue", "square"], skins: [{ unified: "1f6c2", native: "\u{1F6C2}" }], version: 1 }, customs: { id: "customs", name: "Customs", keywords: ["passport", "border", "blue", "square"], skins: [{ unified: "1f6c3", native: "\u{1F6C3}" }], version: 1 }, baggage_claim: { id: "baggage_claim", name: "Baggage Claim", keywords: ["blue", "square", "airport", "transport"], skins: [{ unified: "1f6c4", native: "\u{1F6C4}" }], version: 1 }, left_luggage: { id: "left_luggage", name: "Left Luggage", keywords: ["blue", "square", "travel"], skins: [{ unified: "1f6c5", native: "\u{1F6C5}" }], version: 1 }, warning: { id: "warning", name: "Warning", keywords: ["exclamation", "wip", "alert", "error", "problem", "issue"], skins: [{ unified: "26a0-fe0f", native: "\u26A0\uFE0F" }], version: 1 }, children_crossing: { id: "children_crossing", name: "Children Crossing", keywords: ["school", "warning", "danger", "sign", "driving", "yellow", "diamond"], skins: [{ unified: "1f6b8", native: "\u{1F6B8}" }], version: 1 }, no_entry: { id: "no_entry", name: "No Entry", keywords: ["limit", "security", "privacy", "bad", "denied", "stop", "circle"], skins: [{ unified: "26d4", native: "\u26D4" }], version: 1 }, no_entry_sign: { id: "no_entry_sign", name: "Prohibited", keywords: ["no", "entry", "sign", "forbid", "stop", "limit", "denied", "disallow", "circle"], skins: [{ unified: "1f6ab", native: "\u{1F6AB}" }], version: 1 }, no_bicycles: { id: "no_bicycles", name: "No Bicycles", keywords: ["cyclist", "prohibited", "circle"], skins: [{ unified: "1f6b3", native: "\u{1F6B3}" }], version: 1 }, no_smoking: { id: "no_smoking", name: "No Smoking", keywords: ["cigarette", "blue", "square", "smell", "smoke"], skins: [{ unified: "1f6ad", native: "\u{1F6AD}" }], version: 1 }, do_not_litter: { id: "do_not_litter", name: "No Littering", keywords: ["do", "not", "litter", "trash", "bin", "garbage", "circle"], skins: [{ unified: "1f6af", native: "\u{1F6AF}" }], version: 1 }, "non-potable_water": { id: "non-potable_water", name: "Non-Potable Water", keywords: ["non", "potable", "drink", "faucet", "tap", "circle"], skins: [{ unified: "1f6b1", native: "\u{1F6B1}" }], version: 1 }, no_pedestrians: { id: "no_pedestrians", name: "No Pedestrians", keywords: ["rules", "crossing", "walking", "circle"], skins: [{ unified: "1f6b7", native: "\u{1F6B7}" }], version: 1 }, no_mobile_phones: { id: "no_mobile_phones", name: "No Mobile Phones", keywords: ["iphone", "mute", "circle"], skins: [{ unified: "1f4f5", native: "\u{1F4F5}" }], version: 1 }, underage: { id: "underage", name: "No One Under Eighteen", keywords: ["underage", "18", "drink", "pub", "night", "minor", "circle"], skins: [{ unified: "1f51e", native: "\u{1F51E}" }], version: 1 }, radioactive_sign: { id: "radioactive_sign", name: "Radioactive", keywords: ["sign", "nuclear", "danger"], skins: [{ unified: "2622-fe0f", native: "\u2622\uFE0F" }], version: 1 }, biohazard_sign: { id: "biohazard_sign", name: "Biohazard", keywords: ["sign", "danger"], skins: [{ unified: "2623-fe0f", native: "\u2623\uFE0F" }], version: 1 }, arrow_up: { id: "arrow_up", name: "Up Arrow", keywords: ["blue", "square", "continue", "top", "direction"], skins: [{ unified: "2b06-fe0f", native: "\u2B06\uFE0F" }], version: 1 }, arrow_upper_right: { id: "arrow_upper_right", name: "Up-Right Arrow", keywords: ["upper", "right", "up", "blue", "square", "point", "direction", "diagonal", "northeast"], skins: [{ unified: "2197-fe0f", native: "\u2197\uFE0F" }], version: 1 }, arrow_right: { id: "arrow_right", name: "Right Arrow", keywords: ["blue", "square", "next"], skins: [{ unified: "27a1-fe0f", native: "\u27A1\uFE0F" }], version: 1 }, arrow_lower_right: { id: "arrow_lower_right", name: "South East Arrow", keywords: ["lower", "right", "down", "blue", "square", "direction", "diagonal", "southeast"], skins: [{ unified: "2198-fe0f", native: "\u2198\uFE0F" }], version: 1 }, arrow_down: { id: "arrow_down", name: "Down Arrow", keywords: ["blue", "square", "direction", "bottom"], skins: [{ unified: "2b07-fe0f", native: "\u2B07\uFE0F" }], version: 1 }, arrow_lower_left: { id: "arrow_lower_left", name: "Down-Left Arrow", keywords: ["lower", "left", "down", "blue", "square", "direction", "diagonal", "southwest"], skins: [{ unified: "2199-fe0f", native: "\u2199\uFE0F" }], version: 1 }, arrow_left: { id: "arrow_left", name: "Left Arrow", keywords: ["blue", "square", "previous", "back"], skins: [{ unified: "2b05-fe0f", native: "\u2B05\uFE0F" }], version: 1 }, arrow_upper_left: { id: "arrow_upper_left", name: "Up-Left Arrow", keywords: ["upper", "left", "up", "blue", "square", "point", "direction", "diagonal", "northwest"], skins: [{ unified: "2196-fe0f", native: "\u2196\uFE0F" }], version: 1 }, arrow_up_down: { id: "arrow_up_down", name: "Up Down Arrow", keywords: ["blue", "square", "direction", "way", "vertical"], skins: [{ unified: "2195-fe0f", native: "\u2195\uFE0F" }], version: 1 }, left_right_arrow: { id: "left_right_arrow", name: "Left Right Arrow", keywords: ["shape", "direction", "horizontal", "sideways"], skins: [{ unified: "2194-fe0f", native: "\u2194\uFE0F" }], version: 1 }, leftwards_arrow_with_hook: { id: "leftwards_arrow_with_hook", name: "Right Arrow Curving Left", keywords: ["leftwards", "with", "hook", "back", "return", "blue", "square", "undo", "enter"], skins: [{ unified: "21a9-fe0f", native: "\u21A9\uFE0F" }], version: 1 }, arrow_right_hook: { id: "arrow_right_hook", name: "Left Arrow Curving Right", keywords: ["hook", "blue", "square", "return", "rotate", "direction"], skins: [{ unified: "21aa-fe0f", native: "\u21AA\uFE0F" }], version: 1 }, arrow_heading_up: { id: "arrow_heading_up", name: "Right Arrow Curving Up", keywords: ["heading", "blue", "square", "direction", "top"], skins: [{ unified: "2934-fe0f", native: "\u2934\uFE0F" }], version: 1 }, arrow_heading_down: { id: "arrow_heading_down", name: "Right Arrow Curving Down", keywords: ["heading", "blue", "square", "direction", "bottom"], skins: [{ unified: "2935-fe0f", native: "\u2935\uFE0F" }], version: 1 }, arrows_clockwise: { id: "arrows_clockwise", name: "Clockwise Vertical Arrows", keywords: ["sync", "cycle", "round", "repeat"], skins: [{ unified: "1f503", native: "\u{1F503}" }], version: 1 }, arrows_counterclockwise: { id: "arrows_counterclockwise", name: "Counterclockwise Arrows Button", keywords: ["blue", "square", "sync", "cycle"], skins: [{ unified: "1f504", native: "\u{1F504}" }], version: 1 }, back: { id: "back", name: "Back Arrow", keywords: ["words", "return"], skins: [{ unified: "1f519", native: "\u{1F519}" }], version: 1 }, end: { id: "end", name: "End Arrow", keywords: ["words"], skins: [{ unified: "1f51a", native: "\u{1F51A}" }], version: 1 }, on: { id: "on", name: "On! Arrow", keywords: ["on", "words"], skins: [{ unified: "1f51b", native: "\u{1F51B}" }], version: 1 }, soon: { id: "soon", name: "Soon Arrow", keywords: ["words"], skins: [{ unified: "1f51c", native: "\u{1F51C}" }], version: 1 }, top: { id: "top", name: "Top Arrow", keywords: ["words", "blue", "square"], skins: [{ unified: "1f51d", native: "\u{1F51D}" }], version: 1 }, place_of_worship: { id: "place_of_worship", name: "Place of Worship", keywords: ["religion", "church", "temple", "prayer"], skins: [{ unified: "1f6d0", native: "\u{1F6D0}" }], version: 1 }, atom_symbol: { id: "atom_symbol", name: "Atom Symbol", keywords: ["science", "physics", "chemistry"], skins: [{ unified: "269b-fe0f", native: "\u269B\uFE0F" }], version: 1 }, om_symbol: { id: "om_symbol", name: "Om", keywords: ["symbol", "hinduism", "buddhism", "sikhism", "jainism"], skins: [{ unified: "1f549-fe0f", native: "\u{1F549}\uFE0F" }], version: 1 }, star_of_david: { id: "star_of_david", name: "Star of David", keywords: ["judaism"], skins: [{ unified: "2721-fe0f", native: "\u2721\uFE0F" }], version: 1 }, wheel_of_dharma: { id: "wheel_of_dharma", name: "Wheel of Dharma", keywords: ["hinduism", "buddhism", "sikhism", "jainism"], skins: [{ unified: "2638-fe0f", native: "\u2638\uFE0F" }], version: 1 }, yin_yang: { id: "yin_yang", name: "Yin Yang", keywords: ["balance"], skins: [{ unified: "262f-fe0f", native: "\u262F\uFE0F" }], version: 1 }, latin_cross: { id: "latin_cross", name: "Latin Cross", keywords: ["christianity"], skins: [{ unified: "271d-fe0f", native: "\u271D\uFE0F" }], version: 1 }, orthodox_cross: { id: "orthodox_cross", name: "Orthodox Cross", keywords: ["suppedaneum", "religion"], skins: [{ unified: "2626-fe0f", native: "\u2626\uFE0F" }], version: 1 }, star_and_crescent: { id: "star_and_crescent", name: "Star and Crescent", keywords: ["islam"], skins: [{ unified: "262a-fe0f", native: "\u262A\uFE0F" }], version: 1 }, peace_symbol: { id: "peace_symbol", name: "Peace Symbol", keywords: ["hippie"], skins: [{ unified: "262e-fe0f", native: "\u262E\uFE0F" }], version: 1 }, menorah_with_nine_branches: { id: "menorah_with_nine_branches", name: "Menorah", keywords: ["with", "nine", "branches", "hanukkah", "candles", "jewish"], skins: [{ unified: "1f54e", native: "\u{1F54E}" }], version: 1 }, six_pointed_star: { id: "six_pointed_star", name: "Dotted Six-Pointed Star", keywords: ["six", "pointed", "purple", "square", "religion", "jewish", "hexagram"], skins: [{ unified: "1f52f", native: "\u{1F52F}" }], version: 1 }, khanda: { id: "khanda", name: "Khanda", keywords: ["Sikhism", "religion"], skins: [{ unified: "1faaf", native: "\u{1FAAF}" }], version: 15 }, aries: { id: "aries", name: "Aries", keywords: ["sign", "purple", "square", "zodiac", "astrology"], skins: [{ unified: "2648", native: "\u2648" }], version: 1 }, taurus: { id: "taurus", name: "Taurus", keywords: ["purple", "square", "sign", "zodiac", "astrology"], skins: [{ unified: "2649", native: "\u2649" }], version: 1 }, gemini: { id: "gemini", name: "Gemini", keywords: ["sign", "zodiac", "purple", "square", "astrology"], skins: [{ unified: "264a", native: "\u264A" }], version: 1 }, cancer: { id: "cancer", name: "Cancer", keywords: ["sign", "zodiac", "purple", "square", "astrology"], skins: [{ unified: "264b", native: "\u264B" }], version: 1 }, leo: { id: "leo", name: "Leo", keywords: ["sign", "purple", "square", "zodiac", "astrology"], skins: [{ unified: "264c", native: "\u264C" }], version: 1 }, virgo: { id: "virgo", name: "Virgo", keywords: ["sign", "zodiac", "purple", "square", "astrology"], skins: [{ unified: "264d", native: "\u264D" }], version: 1 }, libra: { id: "libra", name: "Libra", keywords: ["sign", "purple", "square", "zodiac", "astrology"], skins: [{ unified: "264e", native: "\u264E" }], version: 1 }, scorpius: { id: "scorpius", name: "Scorpio", keywords: ["scorpius", "sign", "zodiac", "purple", "square", "astrology"], skins: [{ unified: "264f", native: "\u264F" }], version: 1 }, sagittarius: { id: "sagittarius", name: "Sagittarius", keywords: ["sign", "zodiac", "purple", "square", "astrology"], skins: [{ unified: "2650", native: "\u2650" }], version: 1 }, capricorn: { id: "capricorn", name: "Capricorn", keywords: ["sign", "zodiac", "purple", "square", "astrology"], skins: [{ unified: "2651", native: "\u2651" }], version: 1 }, aquarius: { id: "aquarius", name: "Aquarius", keywords: ["sign", "purple", "square", "zodiac", "astrology"], skins: [{ unified: "2652", native: "\u2652" }], version: 1 }, pisces: { id: "pisces", name: "Pisces", keywords: ["purple", "square", "sign", "zodiac", "astrology"], skins: [{ unified: "2653", native: "\u2653" }], version: 1 }, ophiuchus: { id: "ophiuchus", name: "Ophiuchus", keywords: ["sign", "purple", "square", "constellation", "astrology"], skins: [{ unified: "26ce", native: "\u26CE" }], version: 1 }, twisted_rightwards_arrows: { id: "twisted_rightwards_arrows", name: "Shuffle Tracks Button", keywords: ["twisted", "rightwards", "arrows", "blue", "square", "music", "random"], skins: [{ unified: "1f500", native: "\u{1F500}" }], version: 1 }, repeat: { id: "repeat", name: "Repeat Button", keywords: ["loop", "record"], skins: [{ unified: "1f501", native: "\u{1F501}" }], version: 1 }, repeat_one: { id: "repeat_one", name: "Repeat Single Button", keywords: ["one", "blue", "square", "loop"], skins: [{ unified: "1f502", native: "\u{1F502}" }], version: 1 }, arrow_forward: { id: "arrow_forward", name: "Play Button", keywords: ["arrow", "forward", "blue", "square", "right", "direction"], skins: [{ unified: "25b6-fe0f", native: "\u25B6\uFE0F" }], version: 1 }, fast_forward: { id: "fast_forward", name: "Fast-Forward Button", keywords: ["fast", "forward", "blue", "square", "play", "speed", "continue"], skins: [{ unified: "23e9", native: "\u23E9" }], version: 1 }, black_right_pointing_double_triangle_with_vertical_bar: { id: "black_right_pointing_double_triangle_with_vertical_bar", name: "Next Track Button", keywords: ["black", "right", "pointing", "double", "triangle", "with", "vertical", "bar", "forward", "blue", "square"], skins: [{ unified: "23ed-fe0f", native: "\u23ED\uFE0F" }], version: 1 }, black_right_pointing_triangle_with_double_vertical_bar: { id: "black_right_pointing_triangle_with_double_vertical_bar", name: "Play or Pause Button", keywords: ["black", "right", "pointing", "triangle", "with", "double", "vertical", "bar", "blue", "square"], skins: [{ unified: "23ef-fe0f", native: "\u23EF\uFE0F" }], version: 1 }, arrow_backward: { id: "arrow_backward", name: "Reverse Button", keywords: ["arrow", "backward", "blue", "square", "left", "direction"], skins: [{ unified: "25c0-fe0f", native: "\u25C0\uFE0F" }], version: 1 }, rewind: { id: "rewind", name: "Fast Reverse Button", keywords: ["rewind", "play", "blue", "square"], skins: [{ unified: "23ea", native: "\u23EA" }], version: 1 }, black_left_pointing_double_triangle_with_vertical_bar: { id: "black_left_pointing_double_triangle_with_vertical_bar", name: "Last Track Button", keywords: ["black", "left", "pointing", "double", "triangle", "with", "vertical", "bar", "backward"], skins: [{ unified: "23ee-fe0f", native: "\u23EE\uFE0F" }], version: 1 }, arrow_up_small: { id: "arrow_up_small", name: "Upwards Button", keywords: ["arrow", "up", "small", "blue", "square", "triangle", "direction", "point", "forward", "top"], skins: [{ unified: "1f53c", native: "\u{1F53C}" }], version: 1 }, arrow_double_up: { id: "arrow_double_up", name: "Fast Up Button", keywords: ["arrow", "double", "blue", "square", "direction", "top"], skins: [{ unified: "23eb", native: "\u23EB" }], version: 1 }, arrow_down_small: { id: "arrow_down_small", name: "Downwards Button", keywords: ["arrow", "down", "small", "blue", "square", "direction", "bottom"], skins: [{ unified: "1f53d", native: "\u{1F53D}" }], version: 1 }, arrow_double_down: { id: "arrow_double_down", name: "Fast Down Button", keywords: ["arrow", "double", "blue", "square", "direction", "bottom"], skins: [{ unified: "23ec", native: "\u23EC" }], version: 1 }, double_vertical_bar: { id: "double_vertical_bar", name: "Pause Button", keywords: ["double", "vertical", "bar", "blue", "square"], skins: [{ unified: "23f8-fe0f", native: "\u23F8\uFE0F" }], version: 1 }, black_square_for_stop: { id: "black_square_for_stop", name: "Stop Button", keywords: ["black", "square", "for", "blue"], skins: [{ unified: "23f9-fe0f", native: "\u23F9\uFE0F" }], version: 1 }, black_circle_for_record: { id: "black_circle_for_record", name: "Record Button", keywords: ["black", "circle", "for", "blue", "square"], skins: [{ unified: "23fa-fe0f", native: "\u23FA\uFE0F" }], version: 1 }, eject: { id: "eject", name: "Eject Button", keywords: ["blue", "square"], skins: [{ unified: "23cf-fe0f", native: "\u23CF\uFE0F" }], version: 1 }, cinema: { id: "cinema", name: "Cinema", keywords: ["blue", "square", "record", "film", "movie", "curtain", "stage", "theater"], skins: [{ unified: "1f3a6", native: "\u{1F3A6}" }], version: 1 }, low_brightness: { id: "low_brightness", name: "Dim Button", keywords: ["low", "brightness", "sun", "afternoon", "warm", "summer"], skins: [{ unified: "1f505", native: "\u{1F505}" }], version: 1 }, high_brightness: { id: "high_brightness", name: "Bright Button", keywords: ["high", "brightness", "sun", "light"], skins: [{ unified: "1f506", native: "\u{1F506}" }], version: 1 }, signal_strength: { id: "signal_strength", name: "Antenna Bars", keywords: ["signal", "strength", "blue", "square", "reception", "phone", "internet", "connection", "wifi", "bluetooth"], skins: [{ unified: "1f4f6", native: "\u{1F4F6}" }], version: 1 }, wireless: { id: "wireless", name: "Wireless", keywords: ["wifi", "internet", "contactless", "signal"], skins: [{ unified: "1f6dc", native: "\u{1F6DC}" }], version: 15 }, vibration_mode: { id: "vibration_mode", name: "Vibration Mode", keywords: ["orange", "square", "phone"], skins: [{ unified: "1f4f3", native: "\u{1F4F3}" }], version: 1 }, mobile_phone_off: { id: "mobile_phone_off", name: "Mobile Phone off", keywords: ["mute", "orange", "square", "silence", "quiet"], skins: [{ unified: "1f4f4", native: "\u{1F4F4}" }], version: 1 }, female_sign: { id: "female_sign", name: "Female Sign", keywords: ["woman", "women", "lady", "girl"], skins: [{ unified: "2640-fe0f", native: "\u2640\uFE0F" }], version: 4 }, male_sign: { id: "male_sign", name: "Male Sign", keywords: ["man", "boy", "men"], skins: [{ unified: "2642-fe0f", native: "\u2642\uFE0F" }], version: 4 }, transgender_symbol: { id: "transgender_symbol", name: "Transgender Symbol", keywords: ["lgbtq"], skins: [{ unified: "26a7-fe0f", native: "\u26A7\uFE0F" }], version: 13 }, heavy_multiplication_x: { id: "heavy_multiplication_x", name: "Multiply", keywords: ["heavy", "multiplication", "x", "sign", "math", "calculation"], skins: [{ unified: "2716-fe0f", native: "\u2716\uFE0F" }], version: 1 }, heavy_plus_sign: { id: "heavy_plus_sign", name: "Plus", keywords: ["heavy", "sign", "math", "calculation", "addition", "more", "increase"], skins: [{ unified: "2795", native: "\u2795" }], version: 1 }, heavy_minus_sign: { id: "heavy_minus_sign", name: "Minus", keywords: ["heavy", "sign", "math", "calculation", "subtract", "less"], skins: [{ unified: "2796", native: "\u2796" }], version: 1 }, heavy_division_sign: { id: "heavy_division_sign", name: "Divide", keywords: ["heavy", "division", "sign", "math", "calculation"], skins: [{ unified: "2797", native: "\u2797" }], version: 1 }, heavy_equals_sign: { id: "heavy_equals_sign", name: "Heavy Equals Sign", keywords: ["math"], skins: [{ unified: "1f7f0", native: "\u{1F7F0}" }], version: 14 }, infinity: { id: "infinity", name: "Infinity", keywords: ["forever"], skins: [{ unified: "267e-fe0f", native: "\u267E\uFE0F" }], version: 11 }, bangbang: { id: "bangbang", name: "Double Exclamation Mark", keywords: ["bangbang", "surprise"], skins: [{ unified: "203c-fe0f", native: "\u203C\uFE0F" }], version: 1 }, interrobang: { id: "interrobang", name: "Exclamation Question Mark", keywords: ["interrobang", "wat", "punctuation", "surprise"], skins: [{ unified: "2049-fe0f", native: "\u2049\uFE0F" }], version: 1 }, question: { id: "question", name: "Red Question Mark", keywords: ["doubt", "confused"], skins: [{ unified: "2753", native: "\u2753" }], version: 1 }, grey_question: { id: "grey_question", name: "White Question Mark", keywords: ["grey", "doubts", "gray", "huh", "confused"], skins: [{ unified: "2754", native: "\u2754" }], version: 1 }, grey_exclamation: { id: "grey_exclamation", name: "White Exclamation Mark", keywords: ["grey", "surprise", "punctuation", "gray", "wow", "warning"], skins: [{ unified: "2755", native: "\u2755" }], version: 1 }, exclamation: { id: "exclamation", name: "Red Exclamation Mark", keywords: ["heavy", "danger", "surprise", "punctuation", "wow", "warning"], skins: [{ unified: "2757", native: "\u2757" }], version: 1 }, wavy_dash: { id: "wavy_dash", name: "Wavy Dash", keywords: ["draw", "line", "moustache", "mustache", "squiggle", "scribble"], skins: [{ unified: "3030-fe0f", native: "\u3030\uFE0F" }], version: 1 }, currency_exchange: { id: "currency_exchange", name: "Currency Exchange", keywords: ["money", "sales", "dollar", "travel"], skins: [{ unified: "1f4b1", native: "\u{1F4B1}" }], version: 1 }, heavy_dollar_sign: { id: "heavy_dollar_sign", name: "Heavy Dollar Sign", keywords: ["money", "sales", "payment", "currency", "buck"], skins: [{ unified: "1f4b2", native: "\u{1F4B2}" }], version: 1 }, medical_symbol: { id: "medical_symbol", name: "Medical Symbol", keywords: ["staff", "of", "aesculapius", "health", "hospital"], skins: [{ unified: "2695-fe0f", native: "\u2695\uFE0F" }], version: 4 }, recycle: { id: "recycle", name: "Recycling Symbol", keywords: ["recycle", "arrow", "environment", "garbage", "trash"], skins: [{ unified: "267b-fe0f", native: "\u267B\uFE0F" }], version: 1 }, fleur_de_lis: { id: "fleur_de_lis", name: "Fleur-De-Lis", keywords: ["fleur", "de", "lis", "decorative", "scout"], skins: [{ unified: "269c-fe0f", native: "\u269C\uFE0F" }], version: 1 }, trident: { id: "trident", name: "Trident Emblem", keywords: ["weapon", "spear"], skins: [{ unified: "1f531", native: "\u{1F531}" }], version: 1 }, name_badge: { id: "name_badge", name: "Name Badge", keywords: ["fire", "forbid"], skins: [{ unified: "1f4db", native: "\u{1F4DB}" }], version: 1 }, beginner: { id: "beginner", name: "Japanese Symbol for Beginner", keywords: ["badge", "shield"], skins: [{ unified: "1f530", native: "\u{1F530}" }], version: 1 }, o: { id: "o", name: "Hollow Red Circle", keywords: ["o", "round"], skins: [{ unified: "2b55", native: "\u2B55" }], version: 1 }, white_check_mark: { id: "white_check_mark", name: "Check Mark Button", keywords: ["white", "green", "square", "ok", "agree", "vote", "election", "answer", "tick"], skins: [{ unified: "2705", native: "\u2705" }], version: 1 }, ballot_box_with_check: { id: "ballot_box_with_check", name: "Check Box with Check", keywords: ["ballot", "ok", "agree", "confirm", "black", "square", "vote", "election", "yes", "tick"], skins: [{ unified: "2611-fe0f", native: "\u2611\uFE0F" }], version: 1 }, heavy_check_mark: { id: "heavy_check_mark", name: "Check Mark", keywords: ["heavy", "ok", "nike", "answer", "yes", "tick"], skins: [{ unified: "2714-fe0f", native: "\u2714\uFE0F" }], version: 1 }, x: { id: "x", name: "Cross Mark", keywords: ["x", "no", "delete", "remove", "cancel", "red"], skins: [{ unified: "274c", native: "\u274C" }], version: 1 }, negative_squared_cross_mark: { id: "negative_squared_cross_mark", name: "Cross Mark Button", keywords: ["negative", "squared", "x", "green", "square", "no", "deny"], skins: [{ unified: "274e", native: "\u274E" }], version: 1 }, curly_loop: { id: "curly_loop", name: "Curly Loop", keywords: ["scribble", "draw", "shape", "squiggle"], skins: [{ unified: "27b0", native: "\u27B0" }], version: 1 }, loop: { id: "loop", name: "Double Curly Loop", keywords: ["tape", "cassette"], skins: [{ unified: "27bf", native: "\u27BF" }], version: 1 }, part_alternation_mark: { id: "part_alternation_mark", name: "Part Alternation Mark", keywords: ["graph", "presentation", "stats", "business", "economics", "bad"], skins: [{ unified: "303d-fe0f", native: "\u303D\uFE0F" }], version: 1 }, eight_spoked_asterisk: { id: "eight_spoked_asterisk", name: "Eight Spoked Asterisk", keywords: ["star", "sparkle", "green", "square"], skins: [{ unified: "2733-fe0f", native: "\u2733\uFE0F" }], version: 1 }, eight_pointed_black_star: { id: "eight_pointed_black_star", name: "Eight-Pointed Star", keywords: ["eight", "pointed", "black", "orange", "square", "shape", "polygon"], skins: [{ unified: "2734-fe0f", native: "\u2734\uFE0F" }], version: 1 }, sparkle: { id: "sparkle", name: "Sparkle", keywords: ["stars", "green", "square", "awesome", "good", "fireworks"], skins: [{ unified: "2747-fe0f", native: "\u2747\uFE0F" }], version: 1 }, copyright: { id: "copyright", name: "Copyright", keywords: ["ip", "license", "circle", "law", "legal"], skins: [{ unified: "00a9-fe0f", native: "\xA9\uFE0F" }], version: 1 }, registered: { id: "registered", name: "Registered", keywords: ["alphabet", "circle"], skins: [{ unified: "00ae-fe0f", native: "\xAE\uFE0F" }], version: 1 }, tm: { id: "tm", name: "Trade Mark", keywords: ["tm", "trademark", "brand", "law", "legal"], skins: [{ unified: "2122-fe0f", native: "\u2122\uFE0F" }], version: 1 }, hash: { id: "hash", name: "Hash Key", keywords: ["keycap", "", "symbol", "blue", "square", "twitter"], skins: [{ unified: "0023-fe0f-20e3", native: "#\uFE0F\u20E3" }], version: 1 }, keycap_star: { id: "keycap_star", name: "Keycap: *", keywords: ["keycap", "star", ""], skins: [{ unified: "002a-fe0f-20e3", native: "*\uFE0F\u20E3" }], version: 2 }, zero: { id: "zero", name: "Keycap 0", keywords: ["zero", "numbers", "blue", "square", "null"], skins: [{ unified: "0030-fe0f-20e3", native: "0\uFE0F\u20E3" }], version: 1 }, one: { id: "one", name: "Keycap 1", keywords: ["one", "blue", "square", "numbers"], skins: [{ unified: "0031-fe0f-20e3", native: "1\uFE0F\u20E3" }], version: 1 }, two: { id: "two", name: "Keycap 2", keywords: ["two", "numbers", "prime", "blue", "square"], skins: [{ unified: "0032-fe0f-20e3", native: "2\uFE0F\u20E3" }], version: 1 }, three: { id: "three", name: "Keycap 3", keywords: ["three", "numbers", "prime", "blue", "square"], skins: [{ unified: "0033-fe0f-20e3", native: "3\uFE0F\u20E3" }], version: 1 }, four: { id: "four", name: "Keycap 4", keywords: ["four", "numbers", "blue", "square"], skins: [{ unified: "0034-fe0f-20e3", native: "4\uFE0F\u20E3" }], version: 1 }, five: { id: "five", name: "Keycap 5", keywords: ["five", "numbers", "blue", "square", "prime"], skins: [{ unified: "0035-fe0f-20e3", native: "5\uFE0F\u20E3" }], version: 1 }, six: { id: "six", name: "Keycap 6", keywords: ["six", "numbers", "blue", "square"], skins: [{ unified: "0036-fe0f-20e3", native: "6\uFE0F\u20E3" }], version: 1 }, seven: { id: "seven", name: "Keycap 7", keywords: ["seven", "numbers", "blue", "square", "prime"], skins: [{ unified: "0037-fe0f-20e3", native: "7\uFE0F\u20E3" }], version: 1 }, eight: { id: "eight", name: "Keycap 8", keywords: ["eight", "blue", "square", "numbers"], skins: [{ unified: "0038-fe0f-20e3", native: "8\uFE0F\u20E3" }], version: 1 }, nine: { id: "nine", name: "Keycap 9", keywords: ["nine", "blue", "square", "numbers"], skins: [{ unified: "0039-fe0f-20e3", native: "9\uFE0F\u20E3" }], version: 1 }, keycap_ten: { id: "keycap_ten", name: "Keycap 10", keywords: ["ten", "numbers", "blue", "square"], skins: [{ unified: "1f51f", native: "\u{1F51F}" }], version: 1 }, capital_abcd: { id: "capital_abcd", name: "Input Latin Uppercase", keywords: ["capital", "abcd", "alphabet", "words", "blue", "square"], skins: [{ unified: "1f520", native: "\u{1F520}" }], version: 1 }, abcd: { id: "abcd", name: "Input Latin Lowercase", keywords: ["abcd", "blue", "square", "alphabet"], skins: [{ unified: "1f521", native: "\u{1F521}" }], version: 1 }, symbols: { id: "symbols", name: "Input Symbols", keywords: ["blue", "square", "music", "note", "ampersand", "percent", "glyphs", "characters"], skins: [{ unified: "1f523", native: "\u{1F523}" }], version: 1 }, abc: { id: "abc", name: "Input Latin Letters", keywords: ["abc", "blue", "square", "alphabet"], skins: [{ unified: "1f524", native: "\u{1F524}" }], version: 1 }, a: { id: "a", name: "A Button (blood Type)", keywords: ["red", "square", "alphabet", "letter"], skins: [{ unified: "1f170-fe0f", native: "\u{1F170}\uFE0F" }], version: 1 }, ab: { id: "ab", name: "Negative Squared Ab", keywords: ["button", "red", "square", "alphabet"], skins: [{ unified: "1f18e", native: "\u{1F18E}" }], version: 1 }, b: { id: "b", name: "B Button (blood Type)", keywords: ["red", "square", "alphabet", "letter"], skins: [{ unified: "1f171-fe0f", native: "\u{1F171}\uFE0F" }], version: 1 }, cl: { id: "cl", name: "Cl Button", keywords: ["alphabet", "words", "red", "square"], skins: [{ unified: "1f191", native: "\u{1F191}" }], version: 1 }, cool: { id: "cool", name: "Cool Button", keywords: ["words", "blue", "square"], skins: [{ unified: "1f192", native: "\u{1F192}" }], version: 1 }, free: { id: "free", name: "Free Button", keywords: ["blue", "square", "words"], skins: [{ unified: "1f193", native: "\u{1F193}" }], version: 1 }, information_source: { id: "information_source", name: "Information", keywords: ["source", "blue", "square", "alphabet", "letter"], skins: [{ unified: "2139-fe0f", native: "\u2139\uFE0F" }], version: 1 }, id: { id: "id", name: "Id Button", keywords: ["purple", "square", "words"], skins: [{ unified: "1f194", native: "\u{1F194}" }], version: 1 }, m: { id: "m", name: "Circled M", keywords: ["alphabet", "blue", "circle", "letter"], skins: [{ unified: "24c2-fe0f", native: "\u24C2\uFE0F" }], version: 1 }, new: { id: "new", name: "New Button", keywords: ["blue", "square", "words", "start"], skins: [{ unified: "1f195", native: "\u{1F195}" }], version: 1 }, ng: { id: "ng", name: "Ng Button", keywords: ["blue", "square", "words", "shape", "icon"], skins: [{ unified: "1f196", native: "\u{1F196}" }], version: 1 }, o2: { id: "o2", name: "O Button (blood Type)", keywords: ["o2", "alphabet", "red", "square", "letter"], skins: [{ unified: "1f17e-fe0f", native: "\u{1F17E}\uFE0F" }], version: 1 }, ok: { id: "ok", name: "Ok Button", keywords: ["good", "agree", "yes", "blue", "square"], skins: [{ unified: "1f197", native: "\u{1F197}" }], version: 1 }, parking: { id: "parking", name: "P Button", keywords: ["parking", "cars", "blue", "square", "alphabet", "letter"], skins: [{ unified: "1f17f-fe0f", native: "\u{1F17F}\uFE0F" }], version: 1 }, sos: { id: "sos", name: "Sos Button", keywords: ["help", "red", "square", "words", "emergency", "911"], skins: [{ unified: "1f198", native: "\u{1F198}" }], version: 1 }, up: { id: "up", name: "Up! Button", keywords: ["up", "blue", "square", "above", "high"], skins: [{ unified: "1f199", native: "\u{1F199}" }], version: 1 }, vs: { id: "vs", name: "Vs Button", keywords: ["words", "orange", "square"], skins: [{ unified: "1f19a", native: "\u{1F19A}" }], version: 1 }, koko: { id: "koko", name: "Squared Katakana Koko", keywords: ["japanese", "here", "button", "blue", "square", "destination"], skins: [{ unified: "1f201", native: "\u{1F201}" }], version: 1 }, sa: { id: "sa", name: "Squared Katakana Sa", keywords: ["japanese", "service", "charge", "button", "blue", "square"], skins: [{ unified: "1f202-fe0f", native: "\u{1F202}\uFE0F" }], version: 1 }, u6708: { id: "u6708", name: "Japanese \u201Cmonthly Amount\u201D Button", keywords: ["u6708", "monthly", "amount", "chinese", "month", "moon", "orange", "square", "kanji"], skins: [{ unified: "1f237-fe0f", native: "\u{1F237}\uFE0F" }], version: 1 }, u6709: { id: "u6709", name: "Squared Cjk Unified Ideograph-6709", keywords: ["u6709", "japanese", "not", "free", "of", "charge", "button", "orange", "square", "chinese", "have", "kanji"], skins: [{ unified: "1f236", native: "\u{1F236}" }], version: 1 }, u6307: { id: "u6307", name: "Japanese \u201Creserved\u201D Button", keywords: ["u6307", "reserved", "chinese", "point", "green", "square", "kanji"], skins: [{ unified: "1f22f", native: "\u{1F22F}" }], version: 1 }, ideograph_advantage: { id: "ideograph_advantage", name: "Japanese \u201Cbargain\u201D Button", keywords: ["ideograph", "advantage", "bargain", "chinese", "kanji", "obtain", "get", "circle"], skins: [{ unified: "1f250", native: "\u{1F250}" }], version: 1 }, u5272: { id: "u5272", name: "Japanese \u201Cdiscount\u201D Button", keywords: ["u5272", "discount", "cut", "divide", "chinese", "kanji", "pink", "square"], skins: [{ unified: "1f239", native: "\u{1F239}" }], version: 1 }, u7121: { id: "u7121", name: "Japanese \u201Cfree of Charge\u201D Button", keywords: ["u7121", "free", "charge", "nothing", "chinese", "kanji", "orange", "square"], skins: [{ unified: "1f21a", native: "\u{1F21A}" }], version: 1 }, u7981: { id: "u7981", name: "Japanese \u201Cprohibited\u201D Button", keywords: ["u7981", "prohibited", "kanji", "chinese", "forbidden", "limit", "restricted", "red", "square"], skins: [{ unified: "1f232", native: "\u{1F232}" }], version: 1 }, accept: { id: "accept", name: "Circled Ideograph Accept", keywords: ["japanese", "acceptable", "button", "ok", "good", "chinese", "kanji", "agree", "yes", "orange", "circle"], skins: [{ unified: "1f251", native: "\u{1F251}" }], version: 1 }, u7533: { id: "u7533", name: "Japanese \u201Capplication\u201D Button", keywords: ["u7533", "application", "chinese", "kanji", "orange", "square"], skins: [{ unified: "1f238", native: "\u{1F238}" }], version: 1 }, u5408: { id: "u5408", name: "Japanese \u201Cpassing Grade\u201D Button", keywords: ["u5408", "passing", "grade", "chinese", "join", "kanji", "red", "square"], skins: [{ unified: "1f234", native: "\u{1F234}" }], version: 1 }, u7a7a: { id: "u7a7a", name: "Japanese \u201Cvacancy\u201D Button", keywords: ["u7a7a", "vacancy", "kanji", "chinese", "empty", "sky", "blue", "square"], skins: [{ unified: "1f233", native: "\u{1F233}" }], version: 1 }, congratulations: { id: "congratulations", name: "Circled Ideograph Congratulation", keywords: ["congratulations", "japanese", "button", "chinese", "kanji", "red", "circle"], skins: [{ unified: "3297-fe0f", native: "\u3297\uFE0F" }], version: 1 }, secret: { id: "secret", name: "Circled Ideograph Secret", keywords: ["japanese", "button", "privacy", "chinese", "sshh", "kanji", "red", "circle"], skins: [{ unified: "3299-fe0f", native: "\u3299\uFE0F" }], version: 1 }, u55b6: { id: "u55b6", name: "Squared Cjk Unified Ideograph-55b6", keywords: ["u55b6", "japanese", "open", "for", "business", "button", "opening", "hours", "orange", "square"], skins: [{ unified: "1f23a", native: "\u{1F23A}" }], version: 1 }, u6e80: { id: "u6e80", name: "Japanese \u201Cno Vacancy\u201D Button", keywords: ["u6e80", "no", "vacancy", "full", "chinese", "red", "square", "kanji"], skins: [{ unified: "1f235", native: "\u{1F235}" }], version: 1 }, red_circle: { id: "red_circle", name: "Red Circle", keywords: ["shape", "error", "danger"], skins: [{ unified: "1f534", native: "\u{1F534}" }], version: 1 }, large_orange_circle: { id: "large_orange_circle", name: "Orange Circle", keywords: ["large", "round"], skins: [{ unified: "1f7e0", native: "\u{1F7E0}" }], version: 12 }, large_yellow_circle: { id: "large_yellow_circle", name: "Yellow Circle", keywords: ["large", "round"], skins: [{ unified: "1f7e1", native: "\u{1F7E1}" }], version: 12 }, large_green_circle: { id: "large_green_circle", name: "Green Circle", keywords: ["large", "round"], skins: [{ unified: "1f7e2", native: "\u{1F7E2}" }], version: 12 }, large_blue_circle: { id: "large_blue_circle", name: "Blue Circle", keywords: ["large", "shape", "icon", "button"], skins: [{ unified: "1f535", native: "\u{1F535}" }], version: 1 }, large_purple_circle: { id: "large_purple_circle", name: "Purple Circle", keywords: ["large", "round"], skins: [{ unified: "1f7e3", native: "\u{1F7E3}" }], version: 12 }, large_brown_circle: { id: "large_brown_circle", name: "Brown Circle", keywords: ["large", "round"], skins: [{ unified: "1f7e4", native: "\u{1F7E4}" }], version: 12 }, black_circle: { id: "black_circle", name: "Black Circle", keywords: ["shape", "button", "round"], skins: [{ unified: "26ab", native: "\u26AB" }], version: 1 }, white_circle: { id: "white_circle", name: "White Circle", keywords: ["shape", "round"], skins: [{ unified: "26aa", native: "\u26AA" }], version: 1 }, large_red_square: { id: "large_red_square", name: "Red Square", keywords: ["large"], skins: [{ unified: "1f7e5", native: "\u{1F7E5}" }], version: 12 }, large_orange_square: { id: "large_orange_square", name: "Orange Square", keywords: ["large"], skins: [{ unified: "1f7e7", native: "\u{1F7E7}" }], version: 12 }, large_yellow_square: { id: "large_yellow_square", name: "Yellow Square", keywords: ["large"], skins: [{ unified: "1f7e8", native: "\u{1F7E8}" }], version: 12 }, large_green_square: { id: "large_green_square", name: "Green Square", keywords: ["large"], skins: [{ unified: "1f7e9", native: "\u{1F7E9}" }], version: 12 }, large_blue_square: { id: "large_blue_square", name: "Blue Square", keywords: ["large"], skins: [{ unified: "1f7e6", native: "\u{1F7E6}" }], version: 12 }, large_purple_square: { id: "large_purple_square", name: "Purple Square", keywords: ["large"], skins: [{ unified: "1f7ea", native: "\u{1F7EA}" }], version: 12 }, large_brown_square: { id: "large_brown_square", name: "Brown Square", keywords: ["large"], skins: [{ unified: "1f7eb", native: "\u{1F7EB}" }], version: 12 }, black_large_square: { id: "black_large_square", name: "Black Large Square", keywords: ["shape", "icon", "button"], skins: [{ unified: "2b1b", native: "\u2B1B" }], version: 1 }, white_large_square: { id: "white_large_square", name: "White Large Square", keywords: ["shape", "icon", "stone", "button"], skins: [{ unified: "2b1c", native: "\u2B1C" }], version: 1 }, black_medium_square: { id: "black_medium_square", name: "Black Medium Square", keywords: ["shape", "button", "icon"], skins: [{ unified: "25fc-fe0f", native: "\u25FC\uFE0F" }], version: 1 }, white_medium_square: { id: "white_medium_square", name: "White Medium Square", keywords: ["shape", "stone", "icon"], skins: [{ unified: "25fb-fe0f", native: "\u25FB\uFE0F" }], version: 1 }, black_medium_small_square: { id: "black_medium_small_square", name: "Black Medium Small Square", keywords: ["icon", "shape", "button"], skins: [{ unified: "25fe", native: "\u25FE" }], version: 1 }, white_medium_small_square: { id: "white_medium_small_square", name: "White Medium Small Square", keywords: ["shape", "stone", "icon", "button"], skins: [{ unified: "25fd", native: "\u25FD" }], version: 1 }, black_small_square: { id: "black_small_square", name: "Black Small Square", keywords: ["shape", "icon"], skins: [{ unified: "25aa-fe0f", native: "\u25AA\uFE0F" }], version: 1 }, white_small_square: { id: "white_small_square", name: "White Small Square", keywords: ["shape", "icon"], skins: [{ unified: "25ab-fe0f", native: "\u25AB\uFE0F" }], version: 1 }, large_orange_diamond: { id: "large_orange_diamond", name: "Large Orange Diamond", keywords: ["shape", "jewel", "gem"], skins: [{ unified: "1f536", native: "\u{1F536}" }], version: 1 }, large_blue_diamond: { id: "large_blue_diamond", name: "Large Blue Diamond", keywords: ["shape", "jewel", "gem"], skins: [{ unified: "1f537", native: "\u{1F537}" }], version: 1 }, small_orange_diamond: { id: "small_orange_diamond", name: "Small Orange Diamond", keywords: ["shape", "jewel", "gem"], skins: [{ unified: "1f538", native: "\u{1F538}" }], version: 1 }, small_blue_diamond: { id: "small_blue_diamond", name: "Small Blue Diamond", keywords: ["shape", "jewel", "gem"], skins: [{ unified: "1f539", native: "\u{1F539}" }], version: 1 }, small_red_triangle: { id: "small_red_triangle", name: "Red Triangle Pointed Up", keywords: ["small", "shape", "direction", "top"], skins: [{ unified: "1f53a", native: "\u{1F53A}" }], version: 1 }, small_red_triangle_down: { id: "small_red_triangle_down", name: "Red Triangle Pointed Down", keywords: ["small", "shape", "direction", "bottom"], skins: [{ unified: "1f53b", native: "\u{1F53B}" }], version: 1 }, diamond_shape_with_a_dot_inside: { id: "diamond_shape_with_a_dot_inside", name: "Diamond with a Dot", keywords: ["shape", "inside", "jewel", "blue", "gem", "crystal", "fancy"], skins: [{ unified: "1f4a0", native: "\u{1F4A0}" }], version: 1 }, radio_button: { id: "radio_button", name: "Radio Button", keywords: ["input", "old", "music", "circle"], skins: [{ unified: "1f518", native: "\u{1F518}" }], version: 1 }, white_square_button: { id: "white_square_button", name: "White Square Button", keywords: ["shape", "input"], skins: [{ unified: "1f533", native: "\u{1F533}" }], version: 1 }, black_square_button: { id: "black_square_button", name: "Black Square Button", keywords: ["shape", "input", "frame"], skins: [{ unified: "1f532", native: "\u{1F532}" }], version: 1 }, checkered_flag: { id: "checkered_flag", name: "Chequered Flag", keywords: ["checkered", "contest", "finishline", "race", "gokart"], skins: [{ unified: "1f3c1", native: "\u{1F3C1}" }], version: 1 }, triangular_flag_on_post: { id: "triangular_flag_on_post", name: "Triangular Flag", keywords: ["on", "post", "mark", "milestone", "place"], skins: [{ unified: "1f6a9", native: "\u{1F6A9}" }], version: 1 }, crossed_flags: { id: "crossed_flags", name: "Crossed Flags", keywords: ["japanese", "nation", "country", "border"], skins: [{ unified: "1f38c", native: "\u{1F38C}" }], version: 1 }, waving_black_flag: { id: "waving_black_flag", name: "Black Flag", keywords: ["waving", "pirate"], skins: [{ unified: "1f3f4", native: "\u{1F3F4}" }], version: 1 }, waving_white_flag: { id: "waving_white_flag", name: "White Flag", keywords: ["waving", "losing", "loser", "lost", "surrender", "give", "up", "fail"], skins: [{ unified: "1f3f3-fe0f", native: "\u{1F3F3}\uFE0F" }], version: 1 }, "rainbow-flag": { id: "rainbow-flag", name: "Rainbow Flag", keywords: ["pride", "gay", "lgbt", "glbt", "queer", "homosexual", "lesbian", "bisexual", "transgender"], skins: [{ unified: "1f3f3-fe0f-200d-1f308", native: "\u{1F3F3}\uFE0F\u200D\u{1F308}" }], version: 4 }, transgender_flag: { id: "transgender_flag", name: "Transgender Flag", keywords: ["lgbtq"], skins: [{ unified: "1f3f3-fe0f-200d-26a7-fe0f", native: "\u{1F3F3}\uFE0F\u200D\u26A7\uFE0F" }], version: 13 }, pirate_flag: { id: "pirate_flag", name: "Pirate Flag", keywords: ["skull", "crossbones", "banner"], skins: [{ unified: "1f3f4-200d-2620-fe0f", native: "\u{1F3F4}\u200D\u2620\uFE0F" }], version: 11 }, "flag-ac": { id: "flag-ac", name: "Ascension Island Flag", keywords: ["ac"], skins: [{ unified: "1f1e6-1f1e8", native: "\u{1F1E6}\u{1F1E8}" }], version: 2 }, "flag-ad": { id: "flag-ad", name: "Andorra Flag", keywords: ["ad", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1e9", native: "\u{1F1E6}\u{1F1E9}" }], version: 2 }, "flag-ae": { id: "flag-ae", name: "United Arab Emirates Flag", keywords: ["ae", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1ea", native: "\u{1F1E6}\u{1F1EA}" }], version: 2 }, "flag-af": { id: "flag-af", name: "Afghanistan Flag", keywords: ["af", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1eb", native: "\u{1F1E6}\u{1F1EB}" }], version: 2 }, "flag-ag": { id: "flag-ag", name: "Antigua & Barbuda Flag", keywords: ["ag", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1ec", native: "\u{1F1E6}\u{1F1EC}" }], version: 2 }, "flag-ai": { id: "flag-ai", name: "Anguilla Flag", keywords: ["ai", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1ee", native: "\u{1F1E6}\u{1F1EE}" }], version: 2 }, "flag-al": { id: "flag-al", name: "Albania Flag", keywords: ["al", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1f1", native: "\u{1F1E6}\u{1F1F1}" }], version: 2 }, "flag-am": { id: "flag-am", name: "Armenia Flag", keywords: ["am", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1f2", native: "\u{1F1E6}\u{1F1F2}" }], version: 2 }, "flag-ao": { id: "flag-ao", name: "Angola Flag", keywords: ["ao", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1f4", native: "\u{1F1E6}\u{1F1F4}" }], version: 2 }, "flag-aq": { id: "flag-aq", name: "Antarctica Flag", keywords: ["aq", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1f6", native: "\u{1F1E6}\u{1F1F6}" }], version: 2 }, "flag-ar": { id: "flag-ar", name: "Argentina Flag", keywords: ["ar", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1f7", native: "\u{1F1E6}\u{1F1F7}" }], version: 2 }, "flag-as": { id: "flag-as", name: "American Samoa Flag", keywords: ["as", "ws", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1f8", native: "\u{1F1E6}\u{1F1F8}" }], version: 2 }, "flag-at": { id: "flag-at", name: "Austria Flag", keywords: ["at", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1f9", native: "\u{1F1E6}\u{1F1F9}" }], version: 2 }, "flag-au": { id: "flag-au", name: "Australia Flag", keywords: ["au", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1fa", native: "\u{1F1E6}\u{1F1FA}" }], version: 2 }, "flag-aw": { id: "flag-aw", name: "Aruba Flag", keywords: ["aw", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1fc", native: "\u{1F1E6}\u{1F1FC}" }], version: 2 }, "flag-ax": { id: "flag-ax", name: "\xC5land Islands Flag", keywords: ["ax", "aland", "Aland", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1fd", native: "\u{1F1E6}\u{1F1FD}" }], version: 2 }, "flag-az": { id: "flag-az", name: "Azerbaijan Flag", keywords: ["az", "nation", "country", "banner"], skins: [{ unified: "1f1e6-1f1ff", native: "\u{1F1E6}\u{1F1FF}" }], version: 2 }, "flag-ba": { id: "flag-ba", name: "Bosnia & Herzegovina Flag", keywords: ["ba", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1e6", native: "\u{1F1E7}\u{1F1E6}" }], version: 2 }, "flag-bb": { id: "flag-bb", name: "Barbados Flag", keywords: ["bb", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1e7", native: "\u{1F1E7}\u{1F1E7}" }], version: 2 }, "flag-bd": { id: "flag-bd", name: "Bangladesh Flag", keywords: ["bd", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1e9", native: "\u{1F1E7}\u{1F1E9}" }], version: 2 }, "flag-be": { id: "flag-be", name: "Belgium Flag", keywords: ["be", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1ea", native: "\u{1F1E7}\u{1F1EA}" }], version: 2 }, "flag-bf": { id: "flag-bf", name: "Burkina Faso Flag", keywords: ["bf", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1eb", native: "\u{1F1E7}\u{1F1EB}" }], version: 2 }, "flag-bg": { id: "flag-bg", name: "Bulgaria Flag", keywords: ["bg", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1ec", native: "\u{1F1E7}\u{1F1EC}" }], version: 2 }, "flag-bh": { id: "flag-bh", name: "Bahrain Flag", keywords: ["bh", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1ed", native: "\u{1F1E7}\u{1F1ED}" }], version: 2 }, "flag-bi": { id: "flag-bi", name: "Burundi Flag", keywords: ["bi", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1ee", native: "\u{1F1E7}\u{1F1EE}" }], version: 2 }, "flag-bj": { id: "flag-bj", name: "Benin Flag", keywords: ["bj", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1ef", native: "\u{1F1E7}\u{1F1EF}" }], version: 2 }, "flag-bl": { id: "flag-bl", name: "St. Barth\xE9lemy Flag", keywords: ["bl", "st", "barthelemy", "saint", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1f1", native: "\u{1F1E7}\u{1F1F1}" }], version: 2 }, "flag-bm": { id: "flag-bm", name: "Bermuda Flag", keywords: ["bm", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1f2", native: "\u{1F1E7}\u{1F1F2}" }], version: 2 }, "flag-bn": { id: "flag-bn", name: "Brunei Flag", keywords: ["bn", "darussalam", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1f3", native: "\u{1F1E7}\u{1F1F3}" }], version: 2 }, "flag-bo": { id: "flag-bo", name: "Bolivia Flag", keywords: ["bo", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1f4", native: "\u{1F1E7}\u{1F1F4}" }], version: 2 }, "flag-bq": { id: "flag-bq", name: "Caribbean Netherlands Flag", keywords: ["bq", "bonaire", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1f6", native: "\u{1F1E7}\u{1F1F6}" }], version: 2 }, "flag-br": { id: "flag-br", name: "Brazil Flag", keywords: ["br", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1f7", native: "\u{1F1E7}\u{1F1F7}" }], version: 2 }, "flag-bs": { id: "flag-bs", name: "Bahamas Flag", keywords: ["bs", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1f8", native: "\u{1F1E7}\u{1F1F8}" }], version: 2 }, "flag-bt": { id: "flag-bt", name: "Bhutan Flag", keywords: ["bt", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1f9", native: "\u{1F1E7}\u{1F1F9}" }], version: 2 }, "flag-bv": { id: "flag-bv", name: "Bouvet Island Flag", keywords: ["bv", "norway"], skins: [{ unified: "1f1e7-1f1fb", native: "\u{1F1E7}\u{1F1FB}" }], version: 2 }, "flag-bw": { id: "flag-bw", name: "Botswana Flag", keywords: ["bw", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1fc", native: "\u{1F1E7}\u{1F1FC}" }], version: 2 }, "flag-by": { id: "flag-by", name: "Belarus Flag", keywords: ["by", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1fe", native: "\u{1F1E7}\u{1F1FE}" }], version: 2 }, "flag-bz": { id: "flag-bz", name: "Belize Flag", keywords: ["bz", "nation", "country", "banner"], skins: [{ unified: "1f1e7-1f1ff", native: "\u{1F1E7}\u{1F1FF}" }], version: 2 }, "flag-ca": { id: "flag-ca", name: "Canada Flag", keywords: ["ca", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1e6", native: "\u{1F1E8}\u{1F1E6}" }], version: 2 }, "flag-cc": { id: "flag-cc", name: "Cocos (keeling) Islands Flag", keywords: ["cc", "keeling", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1e8", native: "\u{1F1E8}\u{1F1E8}" }], version: 2 }, "flag-cd": { id: "flag-cd", name: "Congo - Kinshasa Flag", keywords: ["cd", "democratic", "republic", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1e9", native: "\u{1F1E8}\u{1F1E9}" }], version: 2 }, "flag-cf": { id: "flag-cf", name: "Central African Republic Flag", keywords: ["cf", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1eb", native: "\u{1F1E8}\u{1F1EB}" }], version: 2 }, "flag-cg": { id: "flag-cg", name: "Congo - Brazzaville Flag", keywords: ["cg", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1ec", native: "\u{1F1E8}\u{1F1EC}" }], version: 2 }, "flag-ch": { id: "flag-ch", name: "Switzerland Flag", keywords: ["ch", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1ed", native: "\u{1F1E8}\u{1F1ED}" }], version: 2 }, "flag-ci": { id: "flag-ci", name: "C\xF4te D\u2019ivoire Flag", keywords: ["ci", "cote", "d", "ivoire", "ivory", "coast", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1ee", native: "\u{1F1E8}\u{1F1EE}" }], version: 2 }, "flag-ck": { id: "flag-ck", name: "Cook Islands Flag", keywords: ["ck", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1f0", native: "\u{1F1E8}\u{1F1F0}" }], version: 2 }, "flag-cl": { id: "flag-cl", name: "Chile Flag", keywords: ["cl", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1f1", native: "\u{1F1E8}\u{1F1F1}" }], version: 2 }, "flag-cm": { id: "flag-cm", name: "Cameroon Flag", keywords: ["cm", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1f2", native: "\u{1F1E8}\u{1F1F2}" }], version: 2 }, cn: { id: "cn", name: "China Flag", keywords: ["cn", "chinese", "prc", "country", "nation", "banner"], skins: [{ unified: "1f1e8-1f1f3", native: "\u{1F1E8}\u{1F1F3}" }], version: 1 }, "flag-co": { id: "flag-co", name: "Colombia Flag", keywords: ["co", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1f4", native: "\u{1F1E8}\u{1F1F4}" }], version: 2 }, "flag-cp": { id: "flag-cp", name: "Clipperton Island Flag", keywords: ["cp"], skins: [{ unified: "1f1e8-1f1f5", native: "\u{1F1E8}\u{1F1F5}" }], version: 2 }, "flag-cr": { id: "flag-cr", name: "Costa Rica Flag", keywords: ["cr", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1f7", native: "\u{1F1E8}\u{1F1F7}" }], version: 2 }, "flag-cu": { id: "flag-cu", name: "Cuba Flag", keywords: ["cu", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1fa", native: "\u{1F1E8}\u{1F1FA}" }], version: 2 }, "flag-cv": { id: "flag-cv", name: "Cape Verde Flag", keywords: ["cv", "cabo", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1fb", native: "\u{1F1E8}\u{1F1FB}" }], version: 2 }, "flag-cw": { id: "flag-cw", name: "Cura\xE7ao Flag", keywords: ["cw", "curacao", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1fc", native: "\u{1F1E8}\u{1F1FC}" }], version: 2 }, "flag-cx": { id: "flag-cx", name: "Christmas Island Flag", keywords: ["cx", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1fd", native: "\u{1F1E8}\u{1F1FD}" }], version: 2 }, "flag-cy": { id: "flag-cy", name: "Cyprus Flag", keywords: ["cy", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1fe", native: "\u{1F1E8}\u{1F1FE}" }], version: 2 }, "flag-cz": { id: "flag-cz", name: "Czechia Flag", keywords: ["cz", "nation", "country", "banner"], skins: [{ unified: "1f1e8-1f1ff", native: "\u{1F1E8}\u{1F1FF}" }], version: 2 }, de: { id: "de", name: "Germany Flag", keywords: ["de", "german", "nation", "country", "banner"], skins: [{ unified: "1f1e9-1f1ea", native: "\u{1F1E9}\u{1F1EA}" }], version: 1 }, "flag-dg": { id: "flag-dg", name: "Diego Garcia Flag", keywords: ["dg"], skins: [{ unified: "1f1e9-1f1ec", native: "\u{1F1E9}\u{1F1EC}" }], version: 2 }, "flag-dj": { id: "flag-dj", name: "Djibouti Flag", keywords: ["dj", "nation", "country", "banner"], skins: [{ unified: "1f1e9-1f1ef", native: "\u{1F1E9}\u{1F1EF}" }], version: 2 }, "flag-dk": { id: "flag-dk", name: "Denmark Flag", keywords: ["dk", "nation", "country", "banner"], skins: [{ unified: "1f1e9-1f1f0", native: "\u{1F1E9}\u{1F1F0}" }], version: 2 }, "flag-dm": { id: "flag-dm", name: "Dominica Flag", keywords: ["dm", "nation", "country", "banner"], skins: [{ unified: "1f1e9-1f1f2", native: "\u{1F1E9}\u{1F1F2}" }], version: 2 }, "flag-do": { id: "flag-do", name: "Dominican Republic Flag", keywords: ["do", "nation", "country", "banner"], skins: [{ unified: "1f1e9-1f1f4", native: "\u{1F1E9}\u{1F1F4}" }], version: 2 }, "flag-dz": { id: "flag-dz", name: "Algeria Flag", keywords: ["dz", "nation", "country", "banner"], skins: [{ unified: "1f1e9-1f1ff", native: "\u{1F1E9}\u{1F1FF}" }], version: 2 }, "flag-ea": { id: "flag-ea", name: "Ceuta & Melilla Flag", keywords: ["ea"], skins: [{ unified: "1f1ea-1f1e6", native: "\u{1F1EA}\u{1F1E6}" }], version: 2 }, "flag-ec": { id: "flag-ec", name: "Ecuador Flag", keywords: ["ec", "nation", "country", "banner"], skins: [{ unified: "1f1ea-1f1e8", native: "\u{1F1EA}\u{1F1E8}" }], version: 2 }, "flag-ee": { id: "flag-ee", name: "Estonia Flag", keywords: ["ee", "nation", "country", "banner"], skins: [{ unified: "1f1ea-1f1ea", native: "\u{1F1EA}\u{1F1EA}" }], version: 2 }, "flag-eg": { id: "flag-eg", name: "Egypt Flag", keywords: ["eg", "nation", "country", "banner"], skins: [{ unified: "1f1ea-1f1ec", native: "\u{1F1EA}\u{1F1EC}" }], version: 2 }, "flag-eh": { id: "flag-eh", name: "Western Sahara Flag", keywords: ["eh", "nation", "country", "banner"], skins: [{ unified: "1f1ea-1f1ed", native: "\u{1F1EA}\u{1F1ED}" }], version: 2 }, "flag-er": { id: "flag-er", name: "Eritrea Flag", keywords: ["er", "nation", "country", "banner"], skins: [{ unified: "1f1ea-1f1f7", native: "\u{1F1EA}\u{1F1F7}" }], version: 2 }, es: { id: "es", name: "Spain Flag", keywords: ["es", "nation", "country", "banner"], skins: [{ unified: "1f1ea-1f1f8", native: "\u{1F1EA}\u{1F1F8}" }], version: 1 }, "flag-et": { id: "flag-et", name: "Ethiopia Flag", keywords: ["et", "nation", "country", "banner"], skins: [{ unified: "1f1ea-1f1f9", native: "\u{1F1EA}\u{1F1F9}" }], version: 2 }, "flag-eu": { id: "flag-eu", name: "European Union Flag", keywords: ["eu", "banner"], skins: [{ unified: "1f1ea-1f1fa", native: "\u{1F1EA}\u{1F1FA}" }], version: 2 }, "flag-fi": { id: "flag-fi", name: "Finland Flag", keywords: ["fi", "nation", "country", "banner"], skins: [{ unified: "1f1eb-1f1ee", native: "\u{1F1EB}\u{1F1EE}" }], version: 2 }, "flag-fj": { id: "flag-fj", name: "Fiji Flag", keywords: ["fj", "nation", "country", "banner"], skins: [{ unified: "1f1eb-1f1ef", native: "\u{1F1EB}\u{1F1EF}" }], version: 2 }, "flag-fk": { id: "flag-fk", name: "Falkland Islands Flag", keywords: ["fk", "malvinas", "nation", "country", "banner"], skins: [{ unified: "1f1eb-1f1f0", native: "\u{1F1EB}\u{1F1F0}" }], version: 2 }, "flag-fm": { id: "flag-fm", name: "Micronesia Flag", keywords: ["fm", "federated", "states", "nation", "country", "banner"], skins: [{ unified: "1f1eb-1f1f2", native: "\u{1F1EB}\u{1F1F2}" }], version: 2 }, "flag-fo": { id: "flag-fo", name: "Faroe Islands Flag", keywords: ["fo", "nation", "country", "banner"], skins: [{ unified: "1f1eb-1f1f4", native: "\u{1F1EB}\u{1F1F4}" }], version: 2 }, fr: { id: "fr", name: "France Flag", keywords: ["fr", "banner", "nation", "french", "country"], skins: [{ unified: "1f1eb-1f1f7", native: "\u{1F1EB}\u{1F1F7}" }], version: 1 }, "flag-ga": { id: "flag-ga", name: "Gabon Flag", keywords: ["ga", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1e6", native: "\u{1F1EC}\u{1F1E6}" }], version: 2 }, gb: { id: "gb", name: "United Kingdom Flag", keywords: ["gb", "uk", "great", "britain", "northern", "ireland", "nation", "country", "banner", "british", "UK", "english", "england", "union", "jack"], skins: [{ unified: "1f1ec-1f1e7", native: "\u{1F1EC}\u{1F1E7}" }], version: 1 }, "flag-gd": { id: "flag-gd", name: "Grenada Flag", keywords: ["gd", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1e9", native: "\u{1F1EC}\u{1F1E9}" }], version: 2 }, "flag-ge": { id: "flag-ge", name: "Georgia Flag", keywords: ["ge", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1ea", native: "\u{1F1EC}\u{1F1EA}" }], version: 2 }, "flag-gf": { id: "flag-gf", name: "French Guiana Flag", keywords: ["gf", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1eb", native: "\u{1F1EC}\u{1F1EB}" }], version: 2 }, "flag-gg": { id: "flag-gg", name: "Guernsey Flag", keywords: ["gg", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1ec", native: "\u{1F1EC}\u{1F1EC}" }], version: 2 }, "flag-gh": { id: "flag-gh", name: "Ghana Flag", keywords: ["gh", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1ed", native: "\u{1F1EC}\u{1F1ED}" }], version: 2 }, "flag-gi": { id: "flag-gi", name: "Gibraltar Flag", keywords: ["gi", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1ee", native: "\u{1F1EC}\u{1F1EE}" }], version: 2 }, "flag-gl": { id: "flag-gl", name: "Greenland Flag", keywords: ["gl", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1f1", native: "\u{1F1EC}\u{1F1F1}" }], version: 2 }, "flag-gm": { id: "flag-gm", name: "Gambia Flag", keywords: ["gm", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1f2", native: "\u{1F1EC}\u{1F1F2}" }], version: 2 }, "flag-gn": { id: "flag-gn", name: "Guinea Flag", keywords: ["gn", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1f3", native: "\u{1F1EC}\u{1F1F3}" }], version: 2 }, "flag-gp": { id: "flag-gp", name: "Guadeloupe Flag", keywords: ["gp", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1f5", native: "\u{1F1EC}\u{1F1F5}" }], version: 2 }, "flag-gq": { id: "flag-gq", name: "Equatorial Guinea Flag", keywords: ["gq", "gn", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1f6", native: "\u{1F1EC}\u{1F1F6}" }], version: 2 }, "flag-gr": { id: "flag-gr", name: "Greece Flag", keywords: ["gr", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1f7", native: "\u{1F1EC}\u{1F1F7}" }], version: 2 }, "flag-gs": { id: "flag-gs", name: "South Georgia & South Sandwich Islands Flag", keywords: ["gs", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1f8", native: "\u{1F1EC}\u{1F1F8}" }], version: 2 }, "flag-gt": { id: "flag-gt", name: "Guatemala Flag", keywords: ["gt", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1f9", native: "\u{1F1EC}\u{1F1F9}" }], version: 2 }, "flag-gu": { id: "flag-gu", name: "Guam Flag", keywords: ["gu", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1fa", native: "\u{1F1EC}\u{1F1FA}" }], version: 2 }, "flag-gw": { id: "flag-gw", name: "Guinea-Bissau Flag", keywords: ["gw", "guinea", "bissau", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1fc", native: "\u{1F1EC}\u{1F1FC}" }], version: 2 }, "flag-gy": { id: "flag-gy", name: "Guyana Flag", keywords: ["gy", "nation", "country", "banner"], skins: [{ unified: "1f1ec-1f1fe", native: "\u{1F1EC}\u{1F1FE}" }], version: 2 }, "flag-hk": { id: "flag-hk", name: "Hong Kong Sar China Flag", keywords: ["hk", "nation", "country", "banner"], skins: [{ unified: "1f1ed-1f1f0", native: "\u{1F1ED}\u{1F1F0}" }], version: 2 }, "flag-hm": { id: "flag-hm", name: "Heard & Mcdonald Islands Flag", keywords: ["hm"], skins: [{ unified: "1f1ed-1f1f2", native: "\u{1F1ED}\u{1F1F2}" }], version: 2 }, "flag-hn": { id: "flag-hn", name: "Honduras Flag", keywords: ["hn", "nation", "country", "banner"], skins: [{ unified: "1f1ed-1f1f3", native: "\u{1F1ED}\u{1F1F3}" }], version: 2 }, "flag-hr": { id: "flag-hr", name: "Croatia Flag", keywords: ["hr", "nation", "country", "banner"], skins: [{ unified: "1f1ed-1f1f7", native: "\u{1F1ED}\u{1F1F7}" }], version: 2 }, "flag-ht": { id: "flag-ht", name: "Haiti Flag", keywords: ["ht", "nation", "country", "banner"], skins: [{ unified: "1f1ed-1f1f9", native: "\u{1F1ED}\u{1F1F9}" }], version: 2 }, "flag-hu": { id: "flag-hu", name: "Hungary Flag", keywords: ["hu", "nation", "country", "banner"], skins: [{ unified: "1f1ed-1f1fa", native: "\u{1F1ED}\u{1F1FA}" }], version: 2 }, "flag-ic": { id: "flag-ic", name: "Canary Islands Flag", keywords: ["ic", "nation", "country", "banner"], skins: [{ unified: "1f1ee-1f1e8", native: "\u{1F1EE}\u{1F1E8}" }], version: 2 }, "flag-id": { id: "flag-id", name: "Indonesia Flag", keywords: ["id", "nation", "country", "banner"], skins: [{ unified: "1f1ee-1f1e9", native: "\u{1F1EE}\u{1F1E9}" }], version: 2 }, "flag-ie": { id: "flag-ie", name: "Ireland Flag", keywords: ["ie", "nation", "country", "banner"], skins: [{ unified: "1f1ee-1f1ea", native: "\u{1F1EE}\u{1F1EA}" }], version: 2 }, "flag-il": { id: "flag-il", name: "Israel Flag", keywords: ["il", "nation", "country", "banner"], skins: [{ unified: "1f1ee-1f1f1", native: "\u{1F1EE}\u{1F1F1}" }], version: 2 }, "flag-im": { id: "flag-im", name: "Isle of Man Flag", keywords: ["im", "nation", "country", "banner"], skins: [{ unified: "1f1ee-1f1f2", native: "\u{1F1EE}\u{1F1F2}" }], version: 2 }, "flag-in": { id: "flag-in", name: "India Flag", keywords: ["in", "nation", "country", "banner"], skins: [{ unified: "1f1ee-1f1f3", native: "\u{1F1EE}\u{1F1F3}" }], version: 2 }, "flag-io": { id: "flag-io", name: "British Indian Ocean Territory Flag", keywords: ["io", "nation", "country", "banner"], skins: [{ unified: "1f1ee-1f1f4", native: "\u{1F1EE}\u{1F1F4}" }], version: 2 }, "flag-iq": { id: "flag-iq", name: "Iraq Flag", keywords: ["iq", "nation", "country", "banner"], skins: [{ unified: "1f1ee-1f1f6", native: "\u{1F1EE}\u{1F1F6}" }], version: 2 }, "flag-ir": { id: "flag-ir", name: "Iran Flag", keywords: ["ir", "islamic", "republic", "nation", "country", "banner"], skins: [{ unified: "1f1ee-1f1f7", native: "\u{1F1EE}\u{1F1F7}" }], version: 2 }, "flag-is": { id: "flag-is", name: "Iceland Flag", keywords: ["is", "nation", "country", "banner"], skins: [{ unified: "1f1ee-1f1f8", native: "\u{1F1EE}\u{1F1F8}" }], version: 2 }, it: { id: "it", name: "Italy Flag", keywords: ["it", "nation", "country", "banner"], skins: [{ unified: "1f1ee-1f1f9", native: "\u{1F1EE}\u{1F1F9}" }], version: 1 }, "flag-je": { id: "flag-je", name: "Jersey Flag", keywords: ["je", "nation", "country", "banner"], skins: [{ unified: "1f1ef-1f1ea", native: "\u{1F1EF}\u{1F1EA}" }], version: 2 }, "flag-jm": { id: "flag-jm", name: "Jamaica Flag", keywords: ["jm", "nation", "country", "banner"], skins: [{ unified: "1f1ef-1f1f2", native: "\u{1F1EF}\u{1F1F2}" }], version: 2 }, "flag-jo": { id: "flag-jo", name: "Jordan Flag", keywords: ["jo", "nation", "country", "banner"], skins: [{ unified: "1f1ef-1f1f4", native: "\u{1F1EF}\u{1F1F4}" }], version: 2 }, jp: { id: "jp", name: "Japan Flag", keywords: ["jp", "japanese", "nation", "country", "banner", "ja"], skins: [{ unified: "1f1ef-1f1f5", native: "\u{1F1EF}\u{1F1F5}" }], version: 1 }, "flag-ke": { id: "flag-ke", name: "Kenya Flag", keywords: ["ke", "nation", "country", "banner"], skins: [{ unified: "1f1f0-1f1ea", native: "\u{1F1F0}\u{1F1EA}" }], version: 2 }, "flag-kg": { id: "flag-kg", name: "Kyrgyzstan Flag", keywords: ["kg", "nation", "country", "banner"], skins: [{ unified: "1f1f0-1f1ec", native: "\u{1F1F0}\u{1F1EC}" }], version: 2 }, "flag-kh": { id: "flag-kh", name: "Cambodia Flag", keywords: ["kh", "nation", "country", "banner"], skins: [{ unified: "1f1f0-1f1ed", native: "\u{1F1F0}\u{1F1ED}" }], version: 2 }, "flag-ki": { id: "flag-ki", name: "Kiribati Flag", keywords: ["ki", "nation", "country", "banner"], skins: [{ unified: "1f1f0-1f1ee", native: "\u{1F1F0}\u{1F1EE}" }], version: 2 }, "flag-km": { id: "flag-km", name: "Comoros Flag", keywords: ["km", "nation", "country", "banner"], skins: [{ unified: "1f1f0-1f1f2", native: "\u{1F1F0}\u{1F1F2}" }], version: 2 }, "flag-kn": { id: "flag-kn", name: "St. Kitts & Nevis Flag", keywords: ["kn", "st", "saint", "nation", "country", "banner"], skins: [{ unified: "1f1f0-1f1f3", native: "\u{1F1F0}\u{1F1F3}" }], version: 2 }, "flag-kp": { id: "flag-kp", name: "North Korea Flag", keywords: ["kp", "nation", "country", "banner"], skins: [{ unified: "1f1f0-1f1f5", native: "\u{1F1F0}\u{1F1F5}" }], version: 2 }, kr: { id: "kr", name: "South Korea Flag", keywords: ["kr", "nation", "country", "banner"], skins: [{ unified: "1f1f0-1f1f7", native: "\u{1F1F0}\u{1F1F7}" }], version: 1 }, "flag-kw": { id: "flag-kw", name: "Kuwait Flag", keywords: ["kw", "nation", "country", "banner"], skins: [{ unified: "1f1f0-1f1fc", native: "\u{1F1F0}\u{1F1FC}" }], version: 2 }, "flag-ky": { id: "flag-ky", name: "Cayman Islands Flag", keywords: ["ky", "nation", "country", "banner"], skins: [{ unified: "1f1f0-1f1fe", native: "\u{1F1F0}\u{1F1FE}" }], version: 2 }, "flag-kz": { id: "flag-kz", name: "Kazakhstan Flag", keywords: ["kz", "nation", "country", "banner"], skins: [{ unified: "1f1f0-1f1ff", native: "\u{1F1F0}\u{1F1FF}" }], version: 2 }, "flag-la": { id: "flag-la", name: "Laos Flag", keywords: ["la", "lao", "democratic", "republic", "nation", "country", "banner"], skins: [{ unified: "1f1f1-1f1e6", native: "\u{1F1F1}\u{1F1E6}" }], version: 2 }, "flag-lb": { id: "flag-lb", name: "Lebanon Flag", keywords: ["lb", "nation", "country", "banner"], skins: [{ unified: "1f1f1-1f1e7", native: "\u{1F1F1}\u{1F1E7}" }], version: 2 }, "flag-lc": { id: "flag-lc", name: "St. Lucia Flag", keywords: ["lc", "st", "saint", "nation", "country", "banner"], skins: [{ unified: "1f1f1-1f1e8", native: "\u{1F1F1}\u{1F1E8}" }], version: 2 }, "flag-li": { id: "flag-li", name: "Liechtenstein Flag", keywords: ["li", "nation", "country", "banner"], skins: [{ unified: "1f1f1-1f1ee", native: "\u{1F1F1}\u{1F1EE}" }], version: 2 }, "flag-lk": { id: "flag-lk", name: "Sri Lanka Flag", keywords: ["lk", "nation", "country", "banner"], skins: [{ unified: "1f1f1-1f1f0", native: "\u{1F1F1}\u{1F1F0}" }], version: 2 }, "flag-lr": { id: "flag-lr", name: "Liberia Flag", keywords: ["lr", "nation", "country", "banner"], skins: [{ unified: "1f1f1-1f1f7", native: "\u{1F1F1}\u{1F1F7}" }], version: 2 }, "flag-ls": { id: "flag-ls", name: "Lesotho Flag", keywords: ["ls", "nation", "country", "banner"], skins: [{ unified: "1f1f1-1f1f8", native: "\u{1F1F1}\u{1F1F8}" }], version: 2 }, "flag-lt": { id: "flag-lt", name: "Lithuania Flag", keywords: ["lt", "nation", "country", "banner"], skins: [{ unified: "1f1f1-1f1f9", native: "\u{1F1F1}\u{1F1F9}" }], version: 2 }, "flag-lu": { id: "flag-lu", name: "Luxembourg Flag", keywords: ["lu", "nation", "country", "banner"], skins: [{ unified: "1f1f1-1f1fa", native: "\u{1F1F1}\u{1F1FA}" }], version: 2 }, "flag-lv": { id: "flag-lv", name: "Latvia Flag", keywords: ["lv", "nation", "country", "banner"], skins: [{ unified: "1f1f1-1f1fb", native: "\u{1F1F1}\u{1F1FB}" }], version: 2 }, "flag-ly": { id: "flag-ly", name: "Libya Flag", keywords: ["ly", "nation", "country", "banner"], skins: [{ unified: "1f1f1-1f1fe", native: "\u{1F1F1}\u{1F1FE}" }], version: 2 }, "flag-ma": { id: "flag-ma", name: "Morocco Flag", keywords: ["ma", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1e6", native: "\u{1F1F2}\u{1F1E6}" }], version: 2 }, "flag-mc": { id: "flag-mc", name: "Monaco Flag", keywords: ["mc", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1e8", native: "\u{1F1F2}\u{1F1E8}" }], version: 2 }, "flag-md": { id: "flag-md", name: "Moldova Flag", keywords: ["md", "republic", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1e9", native: "\u{1F1F2}\u{1F1E9}" }], version: 2 }, "flag-me": { id: "flag-me", name: "Montenegro Flag", keywords: ["me", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1ea", native: "\u{1F1F2}\u{1F1EA}" }], version: 2 }, "flag-mf": { id: "flag-mf", name: "St. Martin Flag", keywords: ["mf", "st"], skins: [{ unified: "1f1f2-1f1eb", native: "\u{1F1F2}\u{1F1EB}" }], version: 2 }, "flag-mg": { id: "flag-mg", name: "Madagascar Flag", keywords: ["mg", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1ec", native: "\u{1F1F2}\u{1F1EC}" }], version: 2 }, "flag-mh": { id: "flag-mh", name: "Marshall Islands Flag", keywords: ["mh", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1ed", native: "\u{1F1F2}\u{1F1ED}" }], version: 2 }, "flag-mk": { id: "flag-mk", name: "North Macedonia Flag", keywords: ["mk", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1f0", native: "\u{1F1F2}\u{1F1F0}" }], version: 2 }, "flag-ml": { id: "flag-ml", name: "Mali Flag", keywords: ["ml", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1f1", native: "\u{1F1F2}\u{1F1F1}" }], version: 2 }, "flag-mm": { id: "flag-mm", name: "Myanmar (burma) Flag", keywords: ["mm", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1f2", native: "\u{1F1F2}\u{1F1F2}" }], version: 2 }, "flag-mn": { id: "flag-mn", name: "Mongolia Flag", keywords: ["mn", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1f3", native: "\u{1F1F2}\u{1F1F3}" }], version: 2 }, "flag-mo": { id: "flag-mo", name: "Macao Sar China Flag", keywords: ["mo", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1f4", native: "\u{1F1F2}\u{1F1F4}" }], version: 2 }, "flag-mp": { id: "flag-mp", name: "Northern Mariana Islands Flag", keywords: ["mp", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1f5", native: "\u{1F1F2}\u{1F1F5}" }], version: 2 }, "flag-mq": { id: "flag-mq", name: "Martinique Flag", keywords: ["mq", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1f6", native: "\u{1F1F2}\u{1F1F6}" }], version: 2 }, "flag-mr": { id: "flag-mr", name: "Mauritania Flag", keywords: ["mr", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1f7", native: "\u{1F1F2}\u{1F1F7}" }], version: 2 }, "flag-ms": { id: "flag-ms", name: "Montserrat Flag", keywords: ["ms", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1f8", native: "\u{1F1F2}\u{1F1F8}" }], version: 2 }, "flag-mt": { id: "flag-mt", name: "Malta Flag", keywords: ["mt", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1f9", native: "\u{1F1F2}\u{1F1F9}" }], version: 2 }, "flag-mu": { id: "flag-mu", name: "Mauritius Flag", keywords: ["mu", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1fa", native: "\u{1F1F2}\u{1F1FA}" }], version: 2 }, "flag-mv": { id: "flag-mv", name: "Maldives Flag", keywords: ["mv", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1fb", native: "\u{1F1F2}\u{1F1FB}" }], version: 2 }, "flag-mw": { id: "flag-mw", name: "Malawi Flag", keywords: ["mw", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1fc", native: "\u{1F1F2}\u{1F1FC}" }], version: 2 }, "flag-mx": { id: "flag-mx", name: "Mexico Flag", keywords: ["mx", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1fd", native: "\u{1F1F2}\u{1F1FD}" }], version: 2 }, "flag-my": { id: "flag-my", name: "Malaysia Flag", keywords: ["my", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1fe", native: "\u{1F1F2}\u{1F1FE}" }], version: 2 }, "flag-mz": { id: "flag-mz", name: "Mozambique Flag", keywords: ["mz", "nation", "country", "banner"], skins: [{ unified: "1f1f2-1f1ff", native: "\u{1F1F2}\u{1F1FF}" }], version: 2 }, "flag-na": { id: "flag-na", name: "Namibia Flag", keywords: ["na", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1e6", native: "\u{1F1F3}\u{1F1E6}" }], version: 2 }, "flag-nc": { id: "flag-nc", name: "New Caledonia Flag", keywords: ["nc", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1e8", native: "\u{1F1F3}\u{1F1E8}" }], version: 2 }, "flag-ne": { id: "flag-ne", name: "Niger Flag", keywords: ["ne", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1ea", native: "\u{1F1F3}\u{1F1EA}" }], version: 2 }, "flag-nf": { id: "flag-nf", name: "Norfolk Island Flag", keywords: ["nf", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1eb", native: "\u{1F1F3}\u{1F1EB}" }], version: 2 }, "flag-ng": { id: "flag-ng", name: "Nigeria Flag", keywords: ["ng", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1ec", native: "\u{1F1F3}\u{1F1EC}" }], version: 2 }, "flag-ni": { id: "flag-ni", name: "Nicaragua Flag", keywords: ["ni", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1ee", native: "\u{1F1F3}\u{1F1EE}" }], version: 2 }, "flag-nl": { id: "flag-nl", name: "Netherlands Flag", keywords: ["nl", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1f1", native: "\u{1F1F3}\u{1F1F1}" }], version: 2 }, "flag-no": { id: "flag-no", name: "Norway Flag", keywords: ["no", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1f4", native: "\u{1F1F3}\u{1F1F4}" }], version: 2 }, "flag-np": { id: "flag-np", name: "Nepal Flag", keywords: ["np", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1f5", native: "\u{1F1F3}\u{1F1F5}" }], version: 2 }, "flag-nr": { id: "flag-nr", name: "Nauru Flag", keywords: ["nr", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1f7", native: "\u{1F1F3}\u{1F1F7}" }], version: 2 }, "flag-nu": { id: "flag-nu", name: "Niue Flag", keywords: ["nu", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1fa", native: "\u{1F1F3}\u{1F1FA}" }], version: 2 }, "flag-nz": { id: "flag-nz", name: "New Zealand Flag", keywords: ["nz", "nation", "country", "banner"], skins: [{ unified: "1f1f3-1f1ff", native: "\u{1F1F3}\u{1F1FF}" }], version: 2 }, "flag-om": { id: "flag-om", name: "Oman Flag", keywords: ["om", "symbol", "nation", "country", "banner"], skins: [{ unified: "1f1f4-1f1f2", native: "\u{1F1F4}\u{1F1F2}" }], version: 2 }, "flag-pa": { id: "flag-pa", name: "Panama Flag", keywords: ["pa", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1e6", native: "\u{1F1F5}\u{1F1E6}" }], version: 2 }, "flag-pe": { id: "flag-pe", name: "Peru Flag", keywords: ["pe", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1ea", native: "\u{1F1F5}\u{1F1EA}" }], version: 2 }, "flag-pf": { id: "flag-pf", name: "French Polynesia Flag", keywords: ["pf", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1eb", native: "\u{1F1F5}\u{1F1EB}" }], version: 2 }, "flag-pg": { id: "flag-pg", name: "Papua New Guinea Flag", keywords: ["pg", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1ec", native: "\u{1F1F5}\u{1F1EC}" }], version: 2 }, "flag-ph": { id: "flag-ph", name: "Philippines Flag", keywords: ["ph", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1ed", native: "\u{1F1F5}\u{1F1ED}" }], version: 2 }, "flag-pk": { id: "flag-pk", name: "Pakistan Flag", keywords: ["pk", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1f0", native: "\u{1F1F5}\u{1F1F0}" }], version: 2 }, "flag-pl": { id: "flag-pl", name: "Poland Flag", keywords: ["pl", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1f1", native: "\u{1F1F5}\u{1F1F1}" }], version: 2 }, "flag-pm": { id: "flag-pm", name: "St. Pierre & Miquelon Flag", keywords: ["pm", "st", "saint", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1f2", native: "\u{1F1F5}\u{1F1F2}" }], version: 2 }, "flag-pn": { id: "flag-pn", name: "Pitcairn Islands Flag", keywords: ["pn", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1f3", native: "\u{1F1F5}\u{1F1F3}" }], version: 2 }, "flag-pr": { id: "flag-pr", name: "Puerto Rico Flag", keywords: ["pr", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1f7", native: "\u{1F1F5}\u{1F1F7}" }], version: 2 }, "flag-ps": { id: "flag-ps", name: "Palestinian Territories Flag", keywords: ["ps", "palestine", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1f8", native: "\u{1F1F5}\u{1F1F8}" }], version: 2 }, "flag-pt": { id: "flag-pt", name: "Portugal Flag", keywords: ["pt", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1f9", native: "\u{1F1F5}\u{1F1F9}" }], version: 2 }, "flag-pw": { id: "flag-pw", name: "Palau Flag", keywords: ["pw", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1fc", native: "\u{1F1F5}\u{1F1FC}" }], version: 2 }, "flag-py": { id: "flag-py", name: "Paraguay Flag", keywords: ["py", "nation", "country", "banner"], skins: [{ unified: "1f1f5-1f1fe", native: "\u{1F1F5}\u{1F1FE}" }], version: 2 }, "flag-qa": { id: "flag-qa", name: "Qatar Flag", keywords: ["qa", "nation", "country", "banner"], skins: [{ unified: "1f1f6-1f1e6", native: "\u{1F1F6}\u{1F1E6}" }], version: 2 }, "flag-re": { id: "flag-re", name: "R\xE9union Flag", keywords: ["re", "reunion", "nation", "country", "banner"], skins: [{ unified: "1f1f7-1f1ea", native: "\u{1F1F7}\u{1F1EA}" }], version: 2 }, "flag-ro": { id: "flag-ro", name: "Romania Flag", keywords: ["ro", "nation", "country", "banner"], skins: [{ unified: "1f1f7-1f1f4", native: "\u{1F1F7}\u{1F1F4}" }], version: 2 }, "flag-rs": { id: "flag-rs", name: "Serbia Flag", keywords: ["rs", "nation", "country", "banner"], skins: [{ unified: "1f1f7-1f1f8", native: "\u{1F1F7}\u{1F1F8}" }], version: 2 }, ru: { id: "ru", name: "Russia Flag", keywords: ["ru", "russian", "federation", "nation", "country", "banner"], skins: [{ unified: "1f1f7-1f1fa", native: "\u{1F1F7}\u{1F1FA}" }], version: 1 }, "flag-rw": { id: "flag-rw", name: "Rwanda Flag", keywords: ["rw", "nation", "country", "banner"], skins: [{ unified: "1f1f7-1f1fc", native: "\u{1F1F7}\u{1F1FC}" }], version: 2 }, "flag-sa": { id: "flag-sa", name: "Saudi Arabia Flag", keywords: ["sa", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1e6", native: "\u{1F1F8}\u{1F1E6}" }], version: 2 }, "flag-sb": { id: "flag-sb", name: "Solomon Islands Flag", keywords: ["sb", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1e7", native: "\u{1F1F8}\u{1F1E7}" }], version: 2 }, "flag-sc": { id: "flag-sc", name: "Seychelles Flag", keywords: ["sc", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1e8", native: "\u{1F1F8}\u{1F1E8}" }], version: 2 }, "flag-sd": { id: "flag-sd", name: "Sudan Flag", keywords: ["sd", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1e9", native: "\u{1F1F8}\u{1F1E9}" }], version: 2 }, "flag-se": { id: "flag-se", name: "Sweden Flag", keywords: ["se", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1ea", native: "\u{1F1F8}\u{1F1EA}" }], version: 2 }, "flag-sg": { id: "flag-sg", name: "Singapore Flag", keywords: ["sg", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1ec", native: "\u{1F1F8}\u{1F1EC}" }], version: 2 }, "flag-sh": { id: "flag-sh", name: "St. Helena Flag", keywords: ["sh", "st", "saint", "ascension", "tristan", "cunha", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1ed", native: "\u{1F1F8}\u{1F1ED}" }], version: 2 }, "flag-si": { id: "flag-si", name: "Slovenia Flag", keywords: ["si", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1ee", native: "\u{1F1F8}\u{1F1EE}" }], version: 2 }, "flag-sj": { id: "flag-sj", name: "Svalbard & Jan Mayen Flag", keywords: ["sj"], skins: [{ unified: "1f1f8-1f1ef", native: "\u{1F1F8}\u{1F1EF}" }], version: 2 }, "flag-sk": { id: "flag-sk", name: "Slovakia Flag", keywords: ["sk", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1f0", native: "\u{1F1F8}\u{1F1F0}" }], version: 2 }, "flag-sl": { id: "flag-sl", name: "Sierra Leone Flag", keywords: ["sl", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1f1", native: "\u{1F1F8}\u{1F1F1}" }], version: 2 }, "flag-sm": { id: "flag-sm", name: "San Marino Flag", keywords: ["sm", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1f2", native: "\u{1F1F8}\u{1F1F2}" }], version: 2 }, "flag-sn": { id: "flag-sn", name: "Senegal Flag", keywords: ["sn", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1f3", native: "\u{1F1F8}\u{1F1F3}" }], version: 2 }, "flag-so": { id: "flag-so", name: "Somalia Flag", keywords: ["so", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1f4", native: "\u{1F1F8}\u{1F1F4}" }], version: 2 }, "flag-sr": { id: "flag-sr", name: "Suriname Flag", keywords: ["sr", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1f7", native: "\u{1F1F8}\u{1F1F7}" }], version: 2 }, "flag-ss": { id: "flag-ss", name: "South Sudan Flag", keywords: ["ss", "sd", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1f8", native: "\u{1F1F8}\u{1F1F8}" }], version: 2 }, "flag-st": { id: "flag-st", name: "S\xE3o Tom\xE9 & Pr\xEDncipe Flag", keywords: ["st", "sao", "tome", "principe", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1f9", native: "\u{1F1F8}\u{1F1F9}" }], version: 2 }, "flag-sv": { id: "flag-sv", name: "El Salvador Flag", keywords: ["sv", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1fb", native: "\u{1F1F8}\u{1F1FB}" }], version: 2 }, "flag-sx": { id: "flag-sx", name: "Sint Maarten Flag", keywords: ["sx", "dutch", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1fd", native: "\u{1F1F8}\u{1F1FD}" }], version: 2 }, "flag-sy": { id: "flag-sy", name: "Syria Flag", keywords: ["sy", "syrian", "arab", "republic", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1fe", native: "\u{1F1F8}\u{1F1FE}" }], version: 2 }, "flag-sz": { id: "flag-sz", name: "Eswatini Flag", keywords: ["sz", "nation", "country", "banner"], skins: [{ unified: "1f1f8-1f1ff", native: "\u{1F1F8}\u{1F1FF}" }], version: 2 }, "flag-ta": { id: "flag-ta", name: "Tristan Da Cunha Flag", keywords: ["ta"], skins: [{ unified: "1f1f9-1f1e6", native: "\u{1F1F9}\u{1F1E6}" }], version: 2 }, "flag-tc": { id: "flag-tc", name: "Turks & Caicos Islands Flag", keywords: ["tc", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1e8", native: "\u{1F1F9}\u{1F1E8}" }], version: 2 }, "flag-td": { id: "flag-td", name: "Chad Flag", keywords: ["td", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1e9", native: "\u{1F1F9}\u{1F1E9}" }], version: 2 }, "flag-tf": { id: "flag-tf", name: "French Southern Territories Flag", keywords: ["tf", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1eb", native: "\u{1F1F9}\u{1F1EB}" }], version: 2 }, "flag-tg": { id: "flag-tg", name: "Togo Flag", keywords: ["tg", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1ec", native: "\u{1F1F9}\u{1F1EC}" }], version: 2 }, "flag-th": { id: "flag-th", name: "Thailand Flag", keywords: ["th", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1ed", native: "\u{1F1F9}\u{1F1ED}" }], version: 2 }, "flag-tj": { id: "flag-tj", name: "Tajikistan Flag", keywords: ["tj", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1ef", native: "\u{1F1F9}\u{1F1EF}" }], version: 2 }, "flag-tk": { id: "flag-tk", name: "Tokelau Flag", keywords: ["tk", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1f0", native: "\u{1F1F9}\u{1F1F0}" }], version: 2 }, "flag-tl": { id: "flag-tl", name: "Timor-Leste Flag", keywords: ["tl", "timor", "leste", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1f1", native: "\u{1F1F9}\u{1F1F1}" }], version: 2 }, "flag-tm": { id: "flag-tm", name: "Turkmenistan Flag", keywords: ["tm", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1f2", native: "\u{1F1F9}\u{1F1F2}" }], version: 2 }, "flag-tn": { id: "flag-tn", name: "Tunisia Flag", keywords: ["tn", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1f3", native: "\u{1F1F9}\u{1F1F3}" }], version: 2 }, "flag-to": { id: "flag-to", name: "Tonga Flag", keywords: ["to", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1f4", native: "\u{1F1F9}\u{1F1F4}" }], version: 2 }, "flag-tr": { id: "flag-tr", name: "Turkey Flag", keywords: ["tr", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1f7", native: "\u{1F1F9}\u{1F1F7}" }], version: 2 }, "flag-tt": { id: "flag-tt", name: "Trinidad & Tobago Flag", keywords: ["tt", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1f9", native: "\u{1F1F9}\u{1F1F9}" }], version: 2 }, "flag-tv": { id: "flag-tv", name: "Tuvalu Flag", keywords: ["tv", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1fb", native: "\u{1F1F9}\u{1F1FB}" }], version: 2 }, "flag-tw": { id: "flag-tw", name: "Taiwan Flag", keywords: ["tw", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1fc", native: "\u{1F1F9}\u{1F1FC}" }], version: 2 }, "flag-tz": { id: "flag-tz", name: "Tanzania Flag", keywords: ["tz", "united", "republic", "nation", "country", "banner"], skins: [{ unified: "1f1f9-1f1ff", native: "\u{1F1F9}\u{1F1FF}" }], version: 2 }, "flag-ua": { id: "flag-ua", name: "Ukraine Flag", keywords: ["ua", "nation", "country", "banner"], skins: [{ unified: "1f1fa-1f1e6", native: "\u{1F1FA}\u{1F1E6}" }], version: 2 }, "flag-ug": { id: "flag-ug", name: "Uganda Flag", keywords: ["ug", "nation", "country", "banner"], skins: [{ unified: "1f1fa-1f1ec", native: "\u{1F1FA}\u{1F1EC}" }], version: 2 }, "flag-um": { id: "flag-um", name: "U.s. Outlying Islands Flag", keywords: ["um", "u", "s"], skins: [{ unified: "1f1fa-1f1f2", native: "\u{1F1FA}\u{1F1F2}" }], version: 2 }, "flag-un": { id: "flag-un", name: "United Nations Flag", keywords: ["un", "banner"], skins: [{ unified: "1f1fa-1f1f3", native: "\u{1F1FA}\u{1F1F3}" }], version: 4 }, us: { id: "us", name: "United States Flag", keywords: ["us", "america", "nation", "country", "banner"], skins: [{ unified: "1f1fa-1f1f8", native: "\u{1F1FA}\u{1F1F8}" }], version: 1 }, "flag-uy": { id: "flag-uy", name: "Uruguay Flag", keywords: ["uy", "nation", "country", "banner"], skins: [{ unified: "1f1fa-1f1fe", native: "\u{1F1FA}\u{1F1FE}" }], version: 2 }, "flag-uz": { id: "flag-uz", name: "Uzbekistan Flag", keywords: ["uz", "nation", "country", "banner"], skins: [{ unified: "1f1fa-1f1ff", native: "\u{1F1FA}\u{1F1FF}" }], version: 2 }, "flag-va": { id: "flag-va", name: "Vatican City Flag", keywords: ["va", "nation", "country", "banner"], skins: [{ unified: "1f1fb-1f1e6", native: "\u{1F1FB}\u{1F1E6}" }], version: 2 }, "flag-vc": { id: "flag-vc", name: "St. Vincent & Grenadines Flag", keywords: ["vc", "st", "saint", "nation", "country", "banner"], skins: [{ unified: "1f1fb-1f1e8", native: "\u{1F1FB}\u{1F1E8}" }], version: 2 }, "flag-ve": { id: "flag-ve", name: "Venezuela Flag", keywords: ["ve", "bolivarian", "republic", "nation", "country", "banner"], skins: [{ unified: "1f1fb-1f1ea", native: "\u{1F1FB}\u{1F1EA}" }], version: 2 }, "flag-vg": { id: "flag-vg", name: "British Virgin Islands Flag", keywords: ["vg", "bvi", "nation", "country", "banner"], skins: [{ unified: "1f1fb-1f1ec", native: "\u{1F1FB}\u{1F1EC}" }], version: 2 }, "flag-vi": { id: "flag-vi", name: "U.s. Virgin Islands Flag", keywords: ["vi", "u", "s", "us", "nation", "country", "banner"], skins: [{ unified: "1f1fb-1f1ee", native: "\u{1F1FB}\u{1F1EE}" }], version: 2 }, "flag-vn": { id: "flag-vn", name: "Vietnam Flag", keywords: ["vn", "viet", "nam", "nation", "country", "banner"], skins: [{ unified: "1f1fb-1f1f3", native: "\u{1F1FB}\u{1F1F3}" }], version: 2 }, "flag-vu": { id: "flag-vu", name: "Vanuatu Flag", keywords: ["vu", "nation", "country", "banner"], skins: [{ unified: "1f1fb-1f1fa", native: "\u{1F1FB}\u{1F1FA}" }], version: 2 }, "flag-wf": { id: "flag-wf", name: "Wallis & Futuna Flag", keywords: ["wf", "nation", "country", "banner"], skins: [{ unified: "1f1fc-1f1eb", native: "\u{1F1FC}\u{1F1EB}" }], version: 2 }, "flag-ws": { id: "flag-ws", name: "Samoa Flag", keywords: ["ws", "nation", "country", "banner"], skins: [{ unified: "1f1fc-1f1f8", native: "\u{1F1FC}\u{1F1F8}" }], version: 2 }, "flag-xk": { id: "flag-xk", name: "Kosovo Flag", keywords: ["xk", "nation", "country", "banner"], skins: [{ unified: "1f1fd-1f1f0", native: "\u{1F1FD}\u{1F1F0}" }], version: 2 }, "flag-ye": { id: "flag-ye", name: "Yemen Flag", keywords: ["ye", "nation", "country", "banner"], skins: [{ unified: "1f1fe-1f1ea", native: "\u{1F1FE}\u{1F1EA}" }], version: 2 }, "flag-yt": { id: "flag-yt", name: "Mayotte Flag", keywords: ["yt", "nation", "country", "banner"], skins: [{ unified: "1f1fe-1f1f9", native: "\u{1F1FE}\u{1F1F9}" }], version: 2 }, "flag-za": { id: "flag-za", name: "South Africa Flag", keywords: ["za", "nation", "country", "banner"], skins: [{ unified: "1f1ff-1f1e6", native: "\u{1F1FF}\u{1F1E6}" }], version: 2 }, "flag-zm": { id: "flag-zm", name: "Zambia Flag", keywords: ["zm", "nation", "country", "banner"], skins: [{ unified: "1f1ff-1f1f2", native: "\u{1F1FF}\u{1F1F2}" }], version: 2 }, "flag-zw": { id: "flag-zw", name: "Zimbabwe Flag", keywords: ["zw", "nation", "country", "banner"], skins: [{ unified: "1f1ff-1f1fc", native: "\u{1F1FF}\u{1F1FC}" }], version: 2 }, "flag-england": { id: "flag-england", name: "England Flag", keywords: ["english"], skins: [{ unified: "1f3f4-e0067-e0062-e0065-e006e-e0067-e007f", native: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}" }], version: 5 }, "flag-scotland": { id: "flag-scotland", name: "Scotland Flag", keywords: ["scottish"], skins: [{ unified: "1f3f4-e0067-e0062-e0073-e0063-e0074-e007f", native: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}" }], version: 5 }, "flag-wales": { id: "flag-wales", name: "Wales Flag", keywords: ["welsh"], skins: [{ unified: "1f3f4-e0067-e0062-e0077-e006c-e0073-e007f", native: "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}" }], version: 5 } }, aliases: { satisfied: "laughing", grinning_face_with_star_eyes: "star-struck", grinning_face_with_one_large_and_one_small_eye: "zany_face", smiling_face_with_smiling_eyes_and_hand_covering_mouth: "face_with_hand_over_mouth", face_with_finger_covering_closed_lips: "shushing_face", face_with_one_eyebrow_raised: "face_with_raised_eyebrow", face_with_open_mouth_vomiting: "face_vomiting", shocked_face_with_exploding_head: "exploding_head", serious_face_with_symbols_covering_mouth: "face_with_symbols_on_mouth", poop: "hankey", shit: "hankey", collision: "boom", raised_hand: "hand", hand_with_index_and_middle_fingers_crossed: "crossed_fingers", sign_of_the_horns: "the_horns", reversed_hand_with_middle_finger_extended: "middle_finger", thumbsup: "+1", thumbsdown: "-1", punch: "facepunch", mother_christmas: "mrs_claus", running: "runner", "man-with-bunny-ears-partying": "men-with-bunny-ears-partying", "woman-with-bunny-ears-partying": "women-with-bunny-ears-partying", women_holding_hands: "two_women_holding_hands", woman_and_man_holding_hands: "man_and_woman_holding_hands", couple: "man_and_woman_holding_hands", men_holding_hands: "two_men_holding_hands", paw_prints: "feet", flipper: "dolphin", honeybee: "bee", lady_beetle: "ladybug", cooking: "fried_egg", knife: "hocho", red_car: "car", sailboat: "boat", waxing_gibbous_moon: "moon", sun_small_cloud: "mostly_sunny", sun_behind_cloud: "barely_sunny", sun_behind_rain_cloud: "partly_sunny_rain", lightning_cloud: "lightning", tornado_cloud: "tornado", tshirt: "shirt", shoe: "mans_shoe", telephone: "phone", lantern: "izakaya_lantern", open_book: "book", envelope: "email", pencil: "memo", heavy_exclamation_mark: "exclamation", staff_of_aesculapius: "medical_symbol", "flag-cn": "cn", "flag-de": "de", "flag-es": "es", "flag-fr": "fr", uk: "gb", "flag-gb": "gb", "flag-it": "it", "flag-jp": "jp", "flag-kr": "kr", "flag-ru": "ru", "flag-us": "us" }, sheet: { cols: 61, rows: 61 } };
    }
  });

  // node_modules/orderedmap/dist/index.js
  function OrderedMap(content5) {
    this.content = content5;
  }
  OrderedMap.prototype = {
    constructor: OrderedMap,
    find: function(key2) {
      for (var i = 0; i < this.content.length; i += 2)
        if (this.content[i] === key2) return i;
      return -1;
    },
    // :: (string)  ?any
    // Retrieve the value stored under `key`, or return undefined when
    // no such key exists.
    get: function(key2) {
      var found2 = this.find(key2);
      return found2 == -1 ? void 0 : this.content[found2 + 1];
    },
    // :: (string, any, ?string)  OrderedMap
    // Create a new map by replacing the value of `key` with a new
    // value, or adding a binding to the end of the map. If `newKey` is
    // given, the key of the binding will be replaced with that key.
    update: function(key2, value, newKey) {
      var self2 = newKey && newKey != key2 ? this.remove(newKey) : this;
      var found2 = self2.find(key2), content5 = self2.content.slice();
      if (found2 == -1) {
        content5.push(newKey || key2, value);
      } else {
        content5[found2 + 1] = value;
        if (newKey) content5[found2] = newKey;
      }
      return new OrderedMap(content5);
    },
    // :: (string)  OrderedMap
    // Return a map with the given key removed, if it existed.
    remove: function(key2) {
      var found2 = this.find(key2);
      if (found2 == -1) return this;
      var content5 = this.content.slice();
      content5.splice(found2, 2);
      return new OrderedMap(content5);
    },
    // :: (string, any)  OrderedMap
    // Add a new key to the start of the map.
    addToStart: function(key2, value) {
      return new OrderedMap([key2, value].concat(this.remove(key2).content));
    },
    // :: (string, any)  OrderedMap
    // Add a new key to the end of the map.
    addToEnd: function(key2, value) {
      var content5 = this.remove(key2).content.slice();
      content5.push(key2, value);
      return new OrderedMap(content5);
    },
    // :: (string, string, any)  OrderedMap
    // Add a key after the given key. If `place` is not found, the new
    // key is added to the end.
    addBefore: function(place, key2, value) {
      var without = this.remove(key2), content5 = without.content.slice();
      var found2 = without.find(place);
      content5.splice(found2 == -1 ? content5.length : found2, 0, key2, value);
      return new OrderedMap(content5);
    },
    // :: ((key: string, value: any))
    // Call the given function for each key/value pair in the map, in
    // order.
    forEach: function(f) {
      for (var i = 0; i < this.content.length; i += 2)
        f(this.content[i], this.content[i + 1]);
    },
    // :: (union<Object, OrderedMap>)  OrderedMap
    // Create a new map by prepending the keys in this map that don't
    // appear in `map` before the keys in `map`.
    prepend: function(map9) {
      map9 = OrderedMap.from(map9);
      if (!map9.size) return this;
      return new OrderedMap(map9.content.concat(this.subtract(map9).content));
    },
    // :: (union<Object, OrderedMap>)  OrderedMap
    // Create a new map by appending the keys in this map that don't
    // appear in `map` after the keys in `map`.
    append: function(map9) {
      map9 = OrderedMap.from(map9);
      if (!map9.size) return this;
      return new OrderedMap(this.subtract(map9).content.concat(map9.content));
    },
    // :: (union<Object, OrderedMap>)  OrderedMap
    // Create a map containing all the keys in this map that don't
    // appear in `map`.
    subtract: function(map9) {
      var result = this;
      map9 = OrderedMap.from(map9);
      for (var i = 0; i < map9.content.length; i += 2)
        result = result.remove(map9.content[i]);
      return result;
    },
    // :: ()  Object
    // Turn ordered map into a plain object.
    toObject: function() {
      var result = {};
      this.forEach(function(key2, value) {
        result[key2] = value;
      });
      return result;
    },
    // :: number
    // The amount of keys in this map.
    get size() {
      return this.content.length >> 1;
    }
  };
  OrderedMap.from = function(value) {
    if (value instanceof OrderedMap) return value;
    var content5 = [];
    if (value) for (var prop in value) content5.push(prop, value[prop]);
    return new OrderedMap(content5);
  };
  var dist_default = OrderedMap;

  // node_modules/prosemirror-model/dist/index.js
  function findDiffStart(a2, b, pos) {
    for (let i = 0; ; i++) {
      if (i == a2.childCount || i == b.childCount)
        return a2.childCount == b.childCount ? null : pos;
      let childA = a2.child(i), childB = b.child(i);
      if (childA == childB) {
        pos += childA.nodeSize;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return pos;
      if (childA.isText && childA.text != childB.text) {
        for (let j2 = 0; childA.text[j2] == childB.text[j2]; j2++)
          pos++;
        return pos;
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffStart(childA.content, childB.content, pos + 1);
        if (inner != null)
          return inner;
      }
      pos += childA.nodeSize;
    }
  }
  function findDiffEnd(a2, b, posA, posB) {
    for (let iA = a2.childCount, iB = b.childCount; ; ) {
      if (iA == 0 || iB == 0)
        return iA == iB ? null : { a: posA, b: posB };
      let childA = a2.child(--iA), childB = b.child(--iB), size2 = childA.nodeSize;
      if (childA == childB) {
        posA -= size2;
        posB -= size2;
        continue;
      }
      if (!childA.sameMarkup(childB))
        return { a: posA, b: posB };
      if (childA.isText && childA.text != childB.text) {
        let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
          same++;
          posA--;
          posB--;
        }
        return { a: posA, b: posB };
      }
      if (childA.content.size || childB.content.size) {
        let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
        if (inner)
          return inner;
      }
      posA -= size2;
      posB -= size2;
    }
  }
  var Fragment = class _Fragment {
    /**
    @internal
    */
    constructor(content5, size2) {
      this.content = content5;
      this.size = size2 || 0;
      if (size2 == null)
        for (let i = 0; i < content5.length; i++)
          this.size += content5[i].nodeSize;
    }
    /**
    Invoke a callback for all descendant nodes between the given two
    positions (relative to start of this fragment). Doesn't descend
    into a node when the callback returns `false`.
    */
    nodesBetween(from4, to2, f, nodeStart = 0, parent) {
      for (let i = 0, pos = 0; pos < to2; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from4 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
          let start = pos + 1;
          child.nodesBetween(Math.max(0, from4 - start), Math.min(child.content.size, to2 - start), f, nodeStart + start);
        }
        pos = end;
      }
    }
    /**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */
    descendants(f) {
      this.nodesBetween(0, this.size, f);
    }
    /**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */
    textBetween(from4, to2, blockSeparator, leafText) {
      let text10 = "", first3 = true;
      this.nodesBetween(from4, to2, (node2, pos) => {
        let nodeText = node2.isText ? node2.text.slice(Math.max(from4, pos) - pos, to2 - pos) : !node2.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node2) : leafText : node2.type.spec.leafText ? node2.type.spec.leafText(node2) : "";
        if (node2.isBlock && (node2.isLeaf && nodeText || node2.isTextblock) && blockSeparator) {
          if (first3)
            first3 = false;
          else
            text10 += blockSeparator;
        }
        text10 += nodeText;
      }, 0);
      return text10;
    }
    /**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */
    append(other) {
      if (!other.size)
        return this;
      if (!this.size)
        return other;
      let last2 = this.lastChild, first3 = other.firstChild, content5 = this.content.slice(), i = 0;
      if (last2.isText && last2.sameMarkup(first3)) {
        content5[content5.length - 1] = last2.withText(last2.text + first3.text);
        i = 1;
      }
      for (; i < other.content.length; i++)
        content5.push(other.content[i]);
      return new _Fragment(content5, this.size + other.size);
    }
    /**
    Cut out the sub-fragment between the two given positions.
    */
    cut(from4, to2 = this.size) {
      if (from4 == 0 && to2 == this.size)
        return this;
      let result = [], size2 = 0;
      if (to2 > from4)
        for (let i = 0, pos = 0; pos < to2; i++) {
          let child = this.content[i], end = pos + child.nodeSize;
          if (end > from4) {
            if (pos < from4 || end > to2) {
              if (child.isText)
                child = child.cut(Math.max(0, from4 - pos), Math.min(child.text.length, to2 - pos));
              else
                child = child.cut(Math.max(0, from4 - pos - 1), Math.min(child.content.size, to2 - pos - 1));
            }
            result.push(child);
            size2 += child.nodeSize;
          }
          pos = end;
        }
      return new _Fragment(result, size2);
    }
    /**
    @internal
    */
    cutByIndex(from4, to2) {
      if (from4 == to2)
        return _Fragment.empty;
      if (from4 == 0 && to2 == this.content.length)
        return this;
      return new _Fragment(this.content.slice(from4, to2));
    }
    /**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */
    replaceChild(index3, node2) {
      let current = this.content[index3];
      if (current == node2)
        return this;
      let copy4 = this.content.slice();
      let size2 = this.size + node2.nodeSize - current.nodeSize;
      copy4[index3] = node2;
      return new _Fragment(copy4, size2);
    }
    /**
    Create a new fragment by prepending the given node to this
    fragment.
    */
    addToStart(node2) {
      return new _Fragment([node2].concat(this.content), this.size + node2.nodeSize);
    }
    /**
    Create a new fragment by appending the given node to this
    fragment.
    */
    addToEnd(node2) {
      return new _Fragment(this.content.concat(node2), this.size + node2.nodeSize);
    }
    /**
    Compare this fragment to another one.
    */
    eq(other) {
      if (this.content.length != other.content.length)
        return false;
      for (let i = 0; i < this.content.length; i++)
        if (!this.content[i].eq(other.content[i]))
          return false;
      return true;
    }
    /**
    The first child of the fragment, or `null` if it is empty.
    */
    get firstChild() {
      return this.content.length ? this.content[0] : null;
    }
    /**
    The last child of the fragment, or `null` if it is empty.
    */
    get lastChild() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    /**
    The number of child nodes in this fragment.
    */
    get childCount() {
      return this.content.length;
    }
    /**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */
    child(index3) {
      let found2 = this.content[index3];
      if (!found2)
        throw new RangeError("Index " + index3 + " out of range for " + this);
      return found2;
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index3) {
      return this.content[index3] || null;
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      for (let i = 0, p5 = 0; i < this.content.length; i++) {
        let child = this.content[i];
        f(child, p5, i);
        p5 += child.nodeSize;
      }
    }
    /**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */
    findDiffStart(other, pos = 0) {
      return findDiffStart(this, other, pos);
    }
    /**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */
    findDiffEnd(other, pos = this.size, otherPos = other.size) {
      return findDiffEnd(this, other, pos, otherPos);
    }
    /**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. @internal
    */
    findIndex(pos, round2 = -1) {
      if (pos == 0)
        return retIndex(0, pos);
      if (pos == this.size)
        return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0)
        throw new RangeError(`Position ${pos} outside of fragment (${this})`);
      for (let i = 0, curPos = 0; ; i++) {
        let cur = this.child(i), end = curPos + cur.nodeSize;
        if (end >= pos) {
          if (end == pos || round2 > 0)
            return retIndex(i + 1, end);
          return retIndex(i, curPos);
        }
        curPos = end;
      }
    }
    /**
    Return a debugging string that describes this fragment.
    */
    toString() {
      return "<" + this.toStringInner() + ">";
    }
    /**
    @internal
    */
    toStringInner() {
      return this.content.join(", ");
    }
    /**
    Create a JSON-serializeable representation of this fragment.
    */
    toJSON() {
      return this.content.length ? this.content.map((n) => n.toJSON()) : null;
    }
    /**
    Deserialize a fragment from its JSON representation.
    */
    static fromJSON(schema, value) {
      if (!value)
        return _Fragment.empty;
      if (!Array.isArray(value))
        throw new RangeError("Invalid input for Fragment.fromJSON");
      return new _Fragment(value.map(schema.nodeFromJSON));
    }
    /**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */
    static fromArray(array) {
      if (!array.length)
        return _Fragment.empty;
      let joined, size2 = 0;
      for (let i = 0; i < array.length; i++) {
        let node2 = array[i];
        size2 += node2.nodeSize;
        if (i && node2.isText && array[i - 1].sameMarkup(node2)) {
          if (!joined)
            joined = array.slice(0, i);
          joined[joined.length - 1] = node2.withText(joined[joined.length - 1].text + node2.text);
        } else if (joined) {
          joined.push(node2);
        }
      }
      return new _Fragment(joined || array, size2);
    }
    /**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */
    static from(nodes) {
      if (!nodes)
        return _Fragment.empty;
      if (nodes instanceof _Fragment)
        return nodes;
      if (Array.isArray(nodes))
        return this.fromArray(nodes);
      if (nodes.attrs)
        return new _Fragment([nodes], nodes.nodeSize);
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  };
  Fragment.empty = new Fragment([], 0);
  var found = { index: 0, offset: 0 };
  function retIndex(index3, offset) {
    found.index = index3;
    found.offset = offset;
    return found;
  }
  function compareDeep(a2, b) {
    if (a2 === b)
      return true;
    if (!(a2 && typeof a2 == "object") || !(b && typeof b == "object"))
      return false;
    let array = Array.isArray(a2);
    if (Array.isArray(b) != array)
      return false;
    if (array) {
      if (a2.length != b.length)
        return false;
      for (let i = 0; i < a2.length; i++)
        if (!compareDeep(a2[i], b[i]))
          return false;
    } else {
      for (let p5 in a2)
        if (!(p5 in b) || !compareDeep(a2[p5], b[p5]))
          return false;
      for (let p5 in b)
        if (!(p5 in a2))
          return false;
    }
    return true;
  }
  var Mark = class _Mark {
    /**
    @internal
    */
    constructor(type, attrs) {
      this.type = type;
      this.attrs = attrs;
    }
    /**
    Given a set of marks, create a new set which contains this one as
    well, in the right position. If this mark is already in the set,
    the set itself is returned. If any marks that are set to be
    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
    those are replaced by this one.
    */
    addToSet(set2) {
      let copy4, placed = false;
      for (let i = 0; i < set2.length; i++) {
        let other = set2[i];
        if (this.eq(other))
          return set2;
        if (this.type.excludes(other.type)) {
          if (!copy4)
            copy4 = set2.slice(0, i);
        } else if (other.type.excludes(this.type)) {
          return set2;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy4)
              copy4 = set2.slice(0, i);
            copy4.push(this);
            placed = true;
          }
          if (copy4)
            copy4.push(other);
        }
      }
      if (!copy4)
        copy4 = set2.slice();
      if (!placed)
        copy4.push(this);
      return copy4;
    }
    /**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */
    removeFromSet(set2) {
      for (let i = 0; i < set2.length; i++)
        if (this.eq(set2[i]))
          return set2.slice(0, i).concat(set2.slice(i + 1));
      return set2;
    }
    /**
    Test whether this mark is in the given set of marks.
    */
    isInSet(set2) {
      for (let i = 0; i < set2.length; i++)
        if (this.eq(set2[i]))
          return true;
      return false;
    }
    /**
    Test whether this mark has the same type and attributes as
    another mark.
    */
    eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    }
    /**
    Convert this mark to a JSON-serializeable representation.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _2 in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    }
    /**
    Deserialize a mark from JSON.
    */
    static fromJSON(schema, json) {
      if (!json)
        throw new RangeError("Invalid input for Mark.fromJSON");
      let type = schema.marks[json.type];
      if (!type)
        throw new RangeError(`There is no mark type ${json.type} in this schema`);
      let mark2 = type.create(json.attrs);
      type.checkAttrs(mark2.attrs);
      return mark2;
    }
    /**
    Test whether two sets of marks are identical.
    */
    static sameSet(a2, b) {
      if (a2 == b)
        return true;
      if (a2.length != b.length)
        return false;
      for (let i = 0; i < a2.length; i++)
        if (!a2[i].eq(b[i]))
          return false;
      return true;
    }
    /**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */
    static setFrom(marks) {
      if (!marks || Array.isArray(marks) && marks.length == 0)
        return _Mark.none;
      if (marks instanceof _Mark)
        return [marks];
      let copy4 = marks.slice();
      copy4.sort((a2, b) => a2.type.rank - b.type.rank);
      return copy4;
    }
  };
  Mark.none = [];
  var ReplaceError = class extends Error {
  };
  var Slice = class _Slice {
    /**
    Create a slice. When specifying a non-zero open depth, you must
    make sure that there are nodes of at least that depth at the
    appropriate side of the fragmenti.e. if the fragment is an
    empty paragraph node, `openStart` and `openEnd` can't be greater
    than 1.
    
    It is not necessary for the content of open nodes to conform to
    the schema's content constraints, though it should be a valid
    start/end/middle for such a node, depending on which sides are
    open.
    */
    constructor(content5, openStart, openEnd) {
      this.content = content5;
      this.openStart = openStart;
      this.openEnd = openEnd;
    }
    /**
    The size this slice would add when inserted into a document.
    */
    get size() {
      return this.content.size - this.openStart - this.openEnd;
    }
    /**
    @internal
    */
    insertAt(pos, fragment2) {
      let content5 = insertInto(this.content, pos + this.openStart, fragment2);
      return content5 && new _Slice(content5, this.openStart, this.openEnd);
    }
    /**
    @internal
    */
    removeBetween(from4, to2) {
      return new _Slice(removeRange(this.content, from4 + this.openStart, to2 + this.openStart), this.openStart, this.openEnd);
    }
    /**
    Tests whether this slice is equal to another slice.
    */
    eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    }
    /**
    @internal
    */
    toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    /**
    Convert a slice to a JSON-serializable representation.
    */
    toJSON() {
      if (!this.content.size)
        return null;
      let json = { content: this.content.toJSON() };
      if (this.openStart > 0)
        json.openStart = this.openStart;
      if (this.openEnd > 0)
        json.openEnd = this.openEnd;
      return json;
    }
    /**
    Deserialize a slice from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json)
        return _Slice.empty;
      let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number")
        throw new RangeError("Invalid input for Slice.fromJSON");
      return new _Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    }
    /**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */
    static maxOpen(fragment2, openIsolating = true) {
      let openStart = 0, openEnd = 0;
      for (let n = fragment2.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
        openStart++;
      for (let n = fragment2.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
        openEnd++;
      return new _Slice(fragment2, openStart, openEnd);
    }
  };
  Slice.empty = new Slice(Fragment.empty, 0, 0);
  function removeRange(content5, from4, to2) {
    let { index: index3, offset } = content5.findIndex(from4), child = content5.maybeChild(index3);
    let { index: indexTo, offset: offsetTo } = content5.findIndex(to2);
    if (offset == from4 || child.isText) {
      if (offsetTo != to2 && !content5.child(indexTo).isText)
        throw new RangeError("Removing non-flat range");
      return content5.cut(0, from4).append(content5.cut(to2));
    }
    if (index3 != indexTo)
      throw new RangeError("Removing non-flat range");
    return content5.replaceChild(index3, child.copy(removeRange(child.content, from4 - offset - 1, to2 - offset - 1)));
  }
  function insertInto(content5, dist, insert, parent) {
    let { index: index3, offset } = content5.findIndex(dist), child = content5.maybeChild(index3);
    if (offset == dist || child.isText) {
      if (parent && !parent.canReplace(index3, index3, insert))
        return null;
      return content5.cut(0, dist).append(insert).append(content5.cut(dist));
    }
    let inner = insertInto(child.content, dist - offset - 1, insert);
    return inner && content5.replaceChild(index3, child.copy(inner));
  }
  function replace3($from, $to, slice2) {
    if (slice2.openStart > $from.depth)
      throw new ReplaceError("Inserted content deeper than insertion position");
    if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
      throw new ReplaceError("Inconsistent open depths");
    return replaceOuter($from, $to, slice2, 0);
  }
  function replaceOuter($from, $to, slice2, depth) {
    let index3 = $from.index(depth), node2 = $from.node(depth);
    if (index3 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
      let inner = replaceOuter($from, $to, slice2, depth + 1);
      return node2.copy(node2.content.replaceChild(index3, inner));
    } else if (!slice2.content.size) {
      return close(node2, replaceTwoWay($from, $to, depth));
    } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
      let parent = $from.parent, content5 = parent.content;
      return close(parent, content5.cut(0, $from.parentOffset).append(slice2.content).append(content5.cut($to.parentOffset)));
    } else {
      let { start, end } = prepareSliceForReplace(slice2, $from);
      return close(node2, replaceThreeWay($from, start, end, $to, depth));
    }
  }
  function checkJoin(main, sub) {
    if (!sub.type.compatibleContent(main.type))
      throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
  }
  function joinable($before, $after, depth) {
    let node2 = $before.node(depth);
    checkJoin(node2, $after.node(depth));
    return node2;
  }
  function addNode(child, target) {
    let last2 = target.length - 1;
    if (last2 >= 0 && child.isText && child.sameMarkup(target[last2]))
      target[last2] = child.withText(target[last2].text + child.text);
    else
      target.push(child);
  }
  function addRange($start, $end, depth, target) {
    let node2 = ($end || $start).node(depth);
    let startIndex = 0, endIndex = $end ? $end.index(depth) : node2.childCount;
    if ($start) {
      startIndex = $start.index(depth);
      if ($start.depth > depth) {
        startIndex++;
      } else if ($start.textOffset) {
        addNode($start.nodeAfter, target);
        startIndex++;
      }
    }
    for (let i = startIndex; i < endIndex; i++)
      addNode(node2.child(i), target);
    if ($end && $end.depth == depth && $end.textOffset)
      addNode($end.nodeBefore, target);
  }
  function close(node2, content5) {
    node2.type.checkContent(content5);
    return node2.copy(content5);
  }
  function replaceThreeWay($from, $start, $end, $to, depth) {
    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);
    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
    let content5 = [];
    addRange(null, $from, depth, content5);
    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
      checkJoin(openStart, openEnd);
      addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content5);
    } else {
      if (openStart)
        addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content5);
      addRange($start, $end, depth, content5);
      if (openEnd)
        addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content5);
    }
    addRange($to, null, depth, content5);
    return new Fragment(content5);
  }
  function replaceTwoWay($from, $to, depth) {
    let content5 = [];
    addRange(null, $from, depth, content5);
    if ($from.depth > depth) {
      let type = joinable($from, $to, depth + 1);
      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content5);
    }
    addRange($to, null, depth, content5);
    return new Fragment(content5);
  }
  function prepareSliceForReplace(slice2, $along) {
    let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
    let node2 = parent.copy(slice2.content);
    for (let i = extra - 1; i >= 0; i--)
      node2 = $along.node(i).copy(Fragment.from(node2));
    return {
      start: node2.resolveNoCache(slice2.openStart + extra),
      end: node2.resolveNoCache(node2.content.size - slice2.openEnd - extra)
    };
  }
  var ResolvedPos = class _ResolvedPos {
    /**
    @internal
    */
    constructor(pos, path2, parentOffset) {
      this.pos = pos;
      this.path = path2;
      this.parentOffset = parentOffset;
      this.depth = path2.length / 3 - 1;
    }
    /**
    @internal
    */
    resolveDepth(val) {
      if (val == null)
        return this.depth;
      if (val < 0)
        return this.depth + val;
      return val;
    }
    /**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parenttext nodes are flat in this model, and have no content.
    */
    get parent() {
      return this.node(this.depth);
    }
    /**
    The root node in which the position was resolved.
    */
    get doc() {
      return this.node(0);
    }
    /**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */
    node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    }
    /**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */
    index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    }
    /**
    The index pointing after this position into the ancestor at the
    given level.
    */
    indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    }
    /**
    The (absolute) position at the start of the node at the given
    level.
    */
    start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
    /**
    The (absolute) position at the end of the node at the given
    level.
    */
    end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    }
    /**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */
    before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
    /**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */
    after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth)
        throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
    /**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */
    get textOffset() {
      return this.pos - this.path[this.path.length - 1];
    }
    /**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */
    get nodeAfter() {
      let parent = this.parent, index3 = this.index(this.depth);
      if (index3 == parent.childCount)
        return null;
      let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index3);
      return dOff ? parent.child(index3).cut(dOff) : child;
    }
    /**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */
    get nodeBefore() {
      let index3 = this.index(this.depth);
      let dOff = this.pos - this.path[this.path.length - 1];
      if (dOff)
        return this.parent.child(index3).cut(0, dOff);
      return index3 == 0 ? null : this.parent.child(index3 - 1);
    }
    /**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */
    posAtIndex(index3, depth) {
      depth = this.resolveDepth(depth);
      let node2 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (let i = 0; i < index3; i++)
        pos += node2.child(i).nodeSize;
      return pos;
    }
    /**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */
    marks() {
      let parent = this.parent, index3 = this.index();
      if (parent.content.size == 0)
        return Mark.none;
      if (this.textOffset)
        return parent.child(index3).marks;
      let main = parent.maybeChild(index3 - 1), other = parent.maybeChild(index3);
      if (!main) {
        let tmp = main;
        main = other;
        other = tmp;
      }
      let marks = main.marks;
      for (var i = 0; i < marks.length; i++)
        if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
          marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */
    marksAcross($end) {
      let after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline)
        return null;
      let marks = after.marks, next2 = $end.parent.maybeChild($end.index());
      for (var i = 0; i < marks.length; i++)
        if (marks[i].type.spec.inclusive === false && (!next2 || !marks[i].isInSet(next2.marks)))
          marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */
    sharedDepth(pos) {
      for (let depth = this.depth; depth > 0; depth--)
        if (this.start(depth) <= pos && this.end(depth) >= pos)
          return depth;
      return 0;
    }
    /**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */
    blockRange(other = this, pred) {
      if (other.pos < this.pos)
        return other.blockRange(this);
      for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
          return new NodeRange(this, other, d);
      return null;
    }
    /**
    Query whether the given position shares the same parent node.
    */
    sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
    /**
    Return the greater of this and the given position.
    */
    max(other) {
      return other.pos > this.pos ? other : this;
    }
    /**
    Return the smaller of this and the given position.
    */
    min(other) {
      return other.pos < this.pos ? other : this;
    }
    /**
    @internal
    */
    toString() {
      let str = "";
      for (let i = 1; i <= this.depth; i++)
        str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      return str + ":" + this.parentOffset;
    }
    /**
    @internal
    */
    static resolve(doc4, pos) {
      if (!(pos >= 0 && pos <= doc4.content.size))
        throw new RangeError("Position " + pos + " out of range");
      let path2 = [];
      let start = 0, parentOffset = pos;
      for (let node2 = doc4; ; ) {
        let { index: index3, offset } = node2.content.findIndex(parentOffset);
        let rem = parentOffset - offset;
        path2.push(node2, index3, start + offset);
        if (!rem)
          break;
        node2 = node2.child(index3);
        if (node2.isText)
          break;
        parentOffset = rem - 1;
        start += offset + 1;
      }
      return new _ResolvedPos(pos, path2, parentOffset);
    }
    /**
    @internal
    */
    static resolveCached(doc4, pos) {
      let cache = resolveCache.get(doc4);
      if (cache) {
        for (let i = 0; i < cache.elts.length; i++) {
          let elt = cache.elts[i];
          if (elt.pos == pos)
            return elt;
        }
      } else {
        resolveCache.set(doc4, cache = new ResolveCache());
      }
      let result = cache.elts[cache.i] = _ResolvedPos.resolve(doc4, pos);
      cache.i = (cache.i + 1) % resolveCacheSize;
      return result;
    }
  };
  var ResolveCache = class {
    constructor() {
      this.elts = [];
      this.i = 0;
    }
  };
  var resolveCacheSize = 12, resolveCache = /* @__PURE__ */ new WeakMap();
  var NodeRange = class {
    /**
    Construct a node range. `$from` and `$to` should point into the
    same node until at least the given `depth`, since a node range
    denotes an adjacent set of nodes in a single parent node.
    */
    constructor($from, $to, depth) {
      this.$from = $from;
      this.$to = $to;
      this.depth = depth;
    }
    /**
    The position at the start of the range.
    */
    get start() {
      return this.$from.before(this.depth + 1);
    }
    /**
    The position at the end of the range.
    */
    get end() {
      return this.$to.after(this.depth + 1);
    }
    /**
    The parent node that the range points into.
    */
    get parent() {
      return this.$from.node(this.depth);
    }
    /**
    The start index of the range in the parent node.
    */
    get startIndex() {
      return this.$from.index(this.depth);
    }
    /**
    The end index of the range in the parent node.
    */
    get endIndex() {
      return this.$to.indexAfter(this.depth);
    }
  };
  var emptyAttrs = /* @__PURE__ */ Object.create(null);
  var Node2 = class _Node {
    /**
    @internal
    */
    constructor(type, attrs, content5, marks = Mark.none) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.content = content5 || Fragment.empty;
    }
    /**
    The array of this node's child nodes.
    */
    get children() {
      return this.content.content;
    }
    /**
    The size of this node, as defined by the integer-based [indexing
    scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
    amount of characters. For other leaf nodes, it is one. For
    non-leaf nodes, it is the size of the content plus two (the
    start and end token).
    */
    get nodeSize() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    /**
    The number of children that the node has.
    */
    get childCount() {
      return this.content.childCount;
    }
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
    child(index3) {
      return this.content.child(index3);
    }
    /**
    Get the child node at the given index, if it exists.
    */
    maybeChild(index3) {
      return this.content.maybeChild(index3);
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
    forEach(f) {
      this.content.forEach(f);
    }
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    position relative to the original node (method receiver),
    its parent node, and its child index. When the callback returns
    false for a given node, that node's children will not be
    recursed over. The last parameter can be used to specify a
    starting position to count from.
    */
    nodesBetween(from4, to2, f, startPos = 0) {
      this.content.nodesBetween(from4, to2, f, startPos, this);
    }
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
    descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    }
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
    get textContent() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */
    textBetween(from4, to2, blockSeparator, leafText) {
      return this.content.textBetween(from4, to2, blockSeparator, leafText);
    }
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
    get firstChild() {
      return this.content.firstChild;
    }
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
    get lastChild() {
      return this.content.lastChild;
    }
    /**
    Test whether two nodes represent the same piece of document.
    */
    eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    }
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
    sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    }
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
    hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
    }
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
    copy(content5 = null) {
      if (content5 == this.content)
        return this;
      return new _Node(this.type, this.attrs, content5, this.marks);
    }
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
    mark(marks) {
      return marks == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks);
    }
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
    cut(from4, to2 = this.content.size) {
      if (from4 == 0 && to2 == this.content.size)
        return this;
      return this.copy(this.content.cut(from4, to2));
    }
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
    slice(from4, to2 = this.content.size, includeParents = false) {
      if (from4 == to2)
        return Slice.empty;
      let $from = this.resolve(from4), $to = this.resolve(to2);
      let depth = includeParents ? 0 : $from.sharedDepth(to2);
      let start = $from.start(depth), node2 = $from.node(depth);
      let content5 = node2.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content5, $from.depth - depth, $to.depth - depth);
    }
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
    replace(from4, to2, slice2) {
      return replace3(this.resolve(from4), this.resolve(to2), slice2);
    }
    /**
    Find the node directly after the given position.
    */
    nodeAt(pos) {
      for (let node2 = this; ; ) {
        let { index: index3, offset } = node2.content.findIndex(pos);
        node2 = node2.maybeChild(index3);
        if (!node2)
          return null;
        if (offset == pos || node2.isText)
          return node2;
        pos -= offset + 1;
      }
    }
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childAfter(pos) {
      let { index: index3, offset } = this.content.findIndex(pos);
      return { node: this.content.maybeChild(index3), index: index3, offset };
    }
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
    childBefore(pos) {
      if (pos == 0)
        return { node: null, index: 0, offset: 0 };
      let { index: index3, offset } = this.content.findIndex(pos);
      if (offset < pos)
        return { node: this.content.child(index3), index: index3, offset };
      let node2 = this.content.child(index3 - 1);
      return { node: node2, index: index3 - 1, offset: offset - node2.nodeSize };
    }
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
    resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    }
    /**
    @internal
    */
    resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    }
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
    rangeHasMark(from4, to2, type) {
      let found2 = false;
      if (to2 > from4)
        this.nodesBetween(from4, to2, (node2) => {
          if (type.isInSet(node2.marks))
            found2 = true;
          return !found2;
        });
      return found2;
    }
    /**
    True when this is a block (non-inline node)
    */
    get isBlock() {
      return this.type.isBlock;
    }
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
    get isTextblock() {
      return this.type.isTextblock;
    }
    /**
    True when this node allows inline content.
    */
    get inlineContent() {
      return this.type.inlineContent;
    }
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
    get isInline() {
      return this.type.isInline;
    }
    /**
    True when this is a text node.
    */
    get isText() {
      return this.type.isText;
    }
    /**
    True when this is a leaf node.
    */
    get isLeaf() {
      return this.type.isLeaf;
    }
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
    get isAtom() {
      return this.type.isAtom;
    }
    /**
    Return a string representation of this node for debugging
    purposes.
    */
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      let name = this.type.name;
      if (this.content.size)
        name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    }
    /**
    Get the content match in this node at the given index.
    */
    contentMatchAt(index3) {
      let match = this.type.contentMatch.matchFragment(this.content, 0, index3);
      if (!match)
        throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    }
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
    canReplace(from4, to2, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
      let one6 = this.contentMatchAt(from4).matchFragment(replacement, start, end);
      let two = one6 && one6.matchFragment(this.content, to2);
      if (!two || !two.validEnd)
        return false;
      for (let i = start; i < end; i++)
        if (!this.type.allowsMarks(replacement.child(i).marks))
          return false;
      return true;
    }
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
    canReplaceWith(from4, to2, type, marks) {
      if (marks && !this.type.allowsMarks(marks))
        return false;
      let start = this.contentMatchAt(from4).matchType(type);
      let end = start && start.matchFragment(this.content, to2);
      return end ? end.validEnd : false;
    }
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
    canAppend(other) {
      if (other.content.size)
        return this.canReplace(this.childCount, this.childCount, other.content);
      else
        return this.type.compatibleContent(other.type);
    }
    /**
    Check whether this node and its descendants conform to the
    schema, and raise an exception when they do not.
    */
    check() {
      this.type.checkContent(this.content);
      this.type.checkAttrs(this.attrs);
      let copy4 = Mark.none;
      for (let i = 0; i < this.marks.length; i++) {
        let mark2 = this.marks[i];
        mark2.type.checkAttrs(mark2.attrs);
        copy4 = mark2.addToSet(copy4);
      }
      if (!Mark.sameSet(copy4, this.marks))
        throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
      this.content.forEach((node2) => node2.check());
    }
    /**
    Return a JSON-serializeable representation of this node.
    */
    toJSON() {
      let obj = { type: this.type.name };
      for (let _2 in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size)
        obj.content = this.content.toJSON();
      if (this.marks.length)
        obj.marks = this.marks.map((n) => n.toJSON());
      return obj;
    }
    /**
    Deserialize a node from its JSON representation.
    */
    static fromJSON(schema, json) {
      if (!json)
        throw new RangeError("Invalid input for Node.fromJSON");
      let marks = void 0;
      if (json.marks) {
        if (!Array.isArray(json.marks))
          throw new RangeError("Invalid mark data for Node.fromJSON");
        marks = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string")
          throw new RangeError("Invalid text node in JSON");
        return schema.text(json.text, marks);
      }
      let content5 = Fragment.fromJSON(schema, json.content);
      let node2 = schema.nodeType(json.type).create(json.attrs, content5, marks);
      node2.type.checkAttrs(node2.attrs);
      return node2;
    }
  };
  Node2.prototype.text = void 0;
  var TextNode = class _TextNode extends Node2 {
    /**
    @internal
    */
    constructor(type, attrs, content5, marks) {
      super(type, attrs, null, marks);
      if (!content5)
        throw new RangeError("Empty text nodes are not allowed");
      this.text = content5;
    }
    toString() {
      if (this.type.spec.toDebugString)
        return this.type.spec.toDebugString(this);
      return wrapMarks(this.marks, JSON.stringify(this.text));
    }
    get textContent() {
      return this.text;
    }
    textBetween(from4, to2) {
      return this.text.slice(from4, to2);
    }
    get nodeSize() {
      return this.text.length;
    }
    mark(marks) {
      return marks == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks);
    }
    withText(text10) {
      if (text10 == this.text)
        return this;
      return new _TextNode(this.type, this.attrs, text10, this.marks);
    }
    cut(from4 = 0, to2 = this.text.length) {
      if (from4 == 0 && to2 == this.text.length)
        return this;
      return this.withText(this.text.slice(from4, to2));
    }
    eq(other) {
      return this.sameMarkup(other) && this.text == other.text;
    }
    toJSON() {
      let base4 = super.toJSON();
      base4.text = this.text;
      return base4;
    }
  };
  function wrapMarks(marks, str) {
    for (let i = marks.length - 1; i >= 0; i--)
      str = marks[i].type.name + "(" + str + ")";
    return str;
  }
  var ContentMatch = class _ContentMatch {
    /**
    @internal
    */
    constructor(validEnd) {
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    }
    /**
    @internal
    */
    static parse(string3, nodeTypes) {
      let stream = new TokenStream(string3, nodeTypes);
      if (stream.next == null)
        return _ContentMatch.empty;
      let expr = parseExpr(stream);
      if (stream.next)
        stream.err("Unexpected trailing text");
      let match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    }
    /**
    Match a node type, returning a match after that node if
    successful.
    */
    matchType(type) {
      for (let i = 0; i < this.next.length; i++)
        if (this.next[i].type == type)
          return this.next[i].next;
      return null;
    }
    /**
    Try to match a fragment. Returns the resulting match when
    successful.
    */
    matchFragment(frag, start = 0, end = frag.childCount) {
      let cur = this;
      for (let i = start; cur && i < end; i++)
        cur = cur.matchType(frag.child(i).type);
      return cur;
    }
    /**
    @internal
    */
    get inlineContent() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    /**
    Get the first matching node type at this match position that can
    be generated.
    */
    get defaultType() {
      for (let i = 0; i < this.next.length; i++) {
        let { type } = this.next[i];
        if (!(type.isText || type.hasRequiredAttrs()))
          return type;
      }
      return null;
    }
    /**
    @internal
    */
    compatible(other) {
      for (let i = 0; i < this.next.length; i++)
        for (let j2 = 0; j2 < other.next.length; j2++)
          if (this.next[i].type == other.next[j2].type)
            return true;
      return false;
    }
    /**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */
    fillBefore(after, toEnd = false, startIndex = 0) {
      let seen = [this];
      function search3(match, types) {
        let finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd))
          return Fragment.from(types.map((tp) => tp.createAndFill()));
        for (let i = 0; i < match.next.length; i++) {
          let { type, next: next2 } = match.next[i];
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next2) == -1) {
            seen.push(next2);
            let found2 = search3(next2, types.concat(type));
            if (found2)
              return found2;
          }
        }
        return null;
      }
      return search3(this, []);
    }
    /**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */
    findWrapping(target) {
      for (let i = 0; i < this.wrapCache.length; i += 2)
        if (this.wrapCache[i] == target)
          return this.wrapCache[i + 1];
      let computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    }
    /**
    @internal
    */
    computeWrapping(target) {
      let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
      while (active.length) {
        let current = active.shift(), match = current.match;
        if (match.matchType(target)) {
          let result = [];
          for (let obj = current; obj.type; obj = obj.via)
            result.push(obj.type);
          return result.reverse();
        }
        for (let i = 0; i < match.next.length; i++) {
          let { type, next: next2 } = match.next[i];
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next2.validEnd)) {
            active.push({ match: type.contentMatch, type, via: current });
            seen[type.name] = true;
          }
        }
      }
      return null;
    }
    /**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */
    get edgeCount() {
      return this.next.length;
    }
    /**
    Get the _n_th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */
    edge(n) {
      if (n >= this.next.length)
        throw new RangeError(`There's no ${n}th edge in this content match`);
      return this.next[n];
    }
    /**
    @internal
    */
    toString() {
      let seen = [];
      function scan(m) {
        seen.push(m);
        for (let i = 0; i < m.next.length; i++)
          if (seen.indexOf(m.next[i].next) == -1)
            scan(m.next[i].next);
      }
      scan(this);
      return seen.map((m, i) => {
        let out = i + (m.validEnd ? "*" : " ") + " ";
        for (let i2 = 0; i2 < m.next.length; i2++)
          out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
        return out;
      }).join("\n");
    }
  };
  ContentMatch.empty = new ContentMatch(true);
  var TokenStream = class {
    constructor(string3, nodeTypes) {
      this.string = string3;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string3.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "")
        this.tokens.pop();
      if (this.tokens[0] == "")
        this.tokens.shift();
    }
    get next() {
      return this.tokens[this.pos];
    }
    eat(tok) {
      return this.next == tok && (this.pos++ || true);
    }
    err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    }
  };
  function parseExpr(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSeq(stream));
    } while (stream.eat("|"));
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  }
  function parseExprSeq(stream) {
    let exprs = [];
    do {
      exprs.push(parseExprSubscript(stream));
    } while (stream.next && stream.next != ")" && stream.next != "|");
    return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
  }
  function parseExprSubscript(stream) {
    let expr = parseExprAtom(stream);
    for (; ; ) {
      if (stream.eat("+"))
        expr = { type: "plus", expr };
      else if (stream.eat("*"))
        expr = { type: "star", expr };
      else if (stream.eat("?"))
        expr = { type: "opt", expr };
      else if (stream.eat("{"))
        expr = parseExprRange(stream, expr);
      else
        break;
    }
    return expr;
  }
  function parseNum(stream) {
    if (/\D/.test(stream.next))
      stream.err("Expected number, got '" + stream.next + "'");
    let result = Number(stream.next);
    stream.pos++;
    return result;
  }
  function parseExprRange(stream, expr) {
    let min2 = parseNum(stream), max2 = min2;
    if (stream.eat(",")) {
      if (stream.next != "}")
        max2 = parseNum(stream);
      else
        max2 = -1;
    }
    if (!stream.eat("}"))
      stream.err("Unclosed braced range");
    return { type: "range", min: min2, max: max2, expr };
  }
  function resolveName(stream, name) {
    let types = stream.nodeTypes, type = types[name];
    if (type)
      return [type];
    let result = [];
    for (let typeName in types) {
      let type2 = types[typeName];
      if (type2.isInGroup(name))
        result.push(type2);
    }
    if (result.length == 0)
      stream.err("No node type or group '" + name + "' found");
    return result;
  }
  function parseExprAtom(stream) {
    if (stream.eat("(")) {
      let expr = parseExpr(stream);
      if (!stream.eat(")"))
        stream.err("Missing closing paren");
      return expr;
    } else if (!/\W/.test(stream.next)) {
      let exprs = resolveName(stream, stream.next).map((type) => {
        if (stream.inline == null)
          stream.inline = type.isInline;
        else if (stream.inline != type.isInline)
          stream.err("Mixing inline and block content");
        return { type: "name", value: type };
      });
      stream.pos++;
      return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
    } else {
      stream.err("Unexpected token '" + stream.next + "'");
    }
  }
  function nfa(expr) {
    let nfa2 = [[]];
    connect(compile2(expr, 0), node2());
    return nfa2;
    function node2() {
      return nfa2.push([]) - 1;
    }
    function edge(from4, to2, term) {
      let edge2 = { term, to: to2 };
      nfa2[from4].push(edge2);
      return edge2;
    }
    function connect(edges, to2) {
      edges.forEach((edge2) => edge2.to = to2);
    }
    function compile2(expr2, from4) {
      if (expr2.type == "choice") {
        return expr2.exprs.reduce((out, expr3) => out.concat(compile2(expr3, from4)), []);
      } else if (expr2.type == "seq") {
        for (let i = 0; ; i++) {
          let next2 = compile2(expr2.exprs[i], from4);
          if (i == expr2.exprs.length - 1)
            return next2;
          connect(next2, from4 = node2());
        }
      } else if (expr2.type == "star") {
        let loop = node2();
        edge(from4, loop);
        connect(compile2(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "plus") {
        let loop = node2();
        connect(compile2(expr2.expr, from4), loop);
        connect(compile2(expr2.expr, loop), loop);
        return [edge(loop)];
      } else if (expr2.type == "opt") {
        return [edge(from4)].concat(compile2(expr2.expr, from4));
      } else if (expr2.type == "range") {
        let cur = from4;
        for (let i = 0; i < expr2.min; i++) {
          let next2 = node2();
          connect(compile2(expr2.expr, cur), next2);
          cur = next2;
        }
        if (expr2.max == -1) {
          connect(compile2(expr2.expr, cur), cur);
        } else {
          for (let i = expr2.min; i < expr2.max; i++) {
            let next2 = node2();
            edge(cur, next2);
            connect(compile2(expr2.expr, cur), next2);
            cur = next2;
          }
        }
        return [edge(cur)];
      } else if (expr2.type == "name") {
        return [edge(from4, void 0, expr2.value)];
      } else {
        throw new Error("Unknown expr type");
      }
    }
  }
  function cmp(a2, b) {
    return b - a2;
  }
  function nullFrom(nfa2, node2) {
    let result = [];
    scan(node2);
    return result.sort(cmp);
    function scan(node3) {
      let edges = nfa2[node3];
      if (edges.length == 1 && !edges[0].term)
        return scan(edges[0].to);
      result.push(node3);
      for (let i = 0; i < edges.length; i++) {
        let { term, to: to2 } = edges[i];
        if (!term && result.indexOf(to2) == -1)
          scan(to2);
      }
    }
  }
  function dfa(nfa2) {
    let labeled = /* @__PURE__ */ Object.create(null);
    return explore(nullFrom(nfa2, 0));
    function explore(states) {
      let out = [];
      states.forEach((node2) => {
        nfa2[node2].forEach(({ term, to: to2 }) => {
          if (!term)
            return;
          let set2;
          for (let i = 0; i < out.length; i++)
            if (out[i][0] == term)
              set2 = out[i][1];
          nullFrom(nfa2, to2).forEach((node3) => {
            if (!set2)
              out.push([term, set2 = []]);
            if (set2.indexOf(node3) == -1)
              set2.push(node3);
          });
        });
      });
      let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
      for (let i = 0; i < out.length; i++) {
        let states2 = out[i][1].sort(cmp);
        state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
      }
      return state;
    }
  }
  function checkForDeadEnds(match, stream) {
    for (let i = 0, work = [match]; i < work.length; i++) {
      let state = work[i], dead = !state.validEnd, nodes = [];
      for (let j2 = 0; j2 < state.next.length; j2++) {
        let { type, next: next2 } = state.next[j2];
        nodes.push(type.name);
        if (dead && !(type.isText || type.hasRequiredAttrs()))
          dead = false;
        if (work.indexOf(next2) == -1)
          work.push(next2);
      }
      if (dead)
        stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function defaultAttrs(attrs) {
    let defaults3 = /* @__PURE__ */ Object.create(null);
    for (let attrName in attrs) {
      let attr = attrs[attrName];
      if (!attr.hasDefault)
        return null;
      defaults3[attrName] = attr.default;
    }
    return defaults3;
  }
  function computeAttrs(attrs, value) {
    let built = /* @__PURE__ */ Object.create(null);
    for (let name in attrs) {
      let given = value && value[name];
      if (given === void 0) {
        let attr = attrs[name];
        if (attr.hasDefault)
          given = attr.default;
        else
          throw new RangeError("No value supplied for attribute " + name);
      }
      built[name] = given;
    }
    return built;
  }
  function checkAttrs(attrs, values, type, name) {
    for (let name2 in values)
      if (!(name2 in attrs))
        throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
    for (let name2 in attrs) {
      let attr = attrs[name2];
      if (attr.validate)
        attr.validate(values[name2]);
    }
  }
  function initAttrs(typeName, attrs) {
    let result = /* @__PURE__ */ Object.create(null);
    if (attrs)
      for (let name in attrs)
        result[name] = new Attribute(typeName, name, attrs[name]);
    return result;
  }
  var NodeType = class _NodeType {
    /**
    @internal
    */
    constructor(name, schema, spec) {
      this.name = name;
      this.schema = schema;
      this.spec = spec;
      this.markSet = null;
      this.groups = spec.group ? spec.group.split(" ") : [];
      this.attrs = initAttrs(name, spec.attrs);
      this.defaultAttrs = defaultAttrs(this.attrs);
      this.contentMatch = null;
      this.inlineContent = null;
      this.isBlock = !(spec.inline || name == "text");
      this.isText = name == "text";
    }
    /**
    True if this is an inline type.
    */
    get isInline() {
      return !this.isBlock;
    }
    /**
    True if this is a textblock type, a block that contains inline
    content.
    */
    get isTextblock() {
      return this.isBlock && this.inlineContent;
    }
    /**
    True for node types that allow no content.
    */
    get isLeaf() {
      return this.contentMatch == ContentMatch.empty;
    }
    /**
    True when this node is an atom, i.e. when it does not have
    directly editable content.
    */
    get isAtom() {
      return this.isLeaf || !!this.spec.atom;
    }
    /**
    Return true when this node type is part of the given
    [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
    */
    isInGroup(group2) {
      return this.groups.indexOf(group2) > -1;
    }
    /**
    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
    */
    get whitespace() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
    /**
    Tells you whether this node type has any required attributes.
    */
    hasRequiredAttrs() {
      for (let n in this.attrs)
        if (this.attrs[n].isRequired)
          return true;
      return false;
    }
    /**
    Indicates whether this node allows some of the same content as
    the given node type.
    */
    compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    }
    /**
    @internal
    */
    computeAttrs(attrs) {
      if (!attrs && this.defaultAttrs)
        return this.defaultAttrs;
      else
        return computeAttrs(this.attrs, attrs);
    }
    /**
    Create a `Node` of this type. The given attributes are
    checked and defaulted (you can pass `null` to use the type's
    defaults entirely, if no required attributes exist). `content`
    may be a `Fragment`, a node, an array of nodes, or
    `null`. Similarly `marks` may be `null` to default to the empty
    set of marks.
    */
    create(attrs = null, content5, marks) {
      if (this.isText)
        throw new Error("NodeType.create can't construct text nodes");
      return new Node2(this, this.computeAttrs(attrs), Fragment.from(content5), Mark.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
    against the node type's content restrictions, and throw an error
    if it doesn't match.
    */
    createChecked(attrs = null, content5, marks) {
      content5 = Fragment.from(content5);
      this.checkContent(content5);
      return new Node2(this, this.computeAttrs(attrs), content5, Mark.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
    necessary to add nodes to the start or end of the given fragment
    to make it fit the node. If no fitting wrapping can be found,
    return null. Note that, due to the fact that required nodes can
    always be created, this will always succeed if you pass null or
    `Fragment.empty` as content.
    */
    createAndFill(attrs = null, content5, marks) {
      attrs = this.computeAttrs(attrs);
      content5 = Fragment.from(content5);
      if (content5.size) {
        let before = this.contentMatch.fillBefore(content5);
        if (!before)
          return null;
        content5 = before.append(content5);
      }
      let matched = this.contentMatch.matchFragment(content5);
      let after = matched && matched.fillBefore(Fragment.empty, true);
      if (!after)
        return null;
      return new Node2(this, attrs, content5.append(after), Mark.setFrom(marks));
    }
    /**
    Returns true if the given fragment is valid content for this node
    type.
    */
    validContent(content5) {
      let result = this.contentMatch.matchFragment(content5);
      if (!result || !result.validEnd)
        return false;
      for (let i = 0; i < content5.childCount; i++)
        if (!this.allowsMarks(content5.child(i).marks))
          return false;
      return true;
    }
    /**
    Throws a RangeError if the given fragment is not valid content for this
    node type.
    @internal
    */
    checkContent(content5) {
      if (!this.validContent(content5))
        throw new RangeError(`Invalid content for node ${this.name}: ${content5.toString().slice(0, 50)}`);
    }
    /**
    @internal
    */
    checkAttrs(attrs) {
      checkAttrs(this.attrs, attrs, "node", this.name);
    }
    /**
    Check whether the given mark type is allowed in this node.
    */
    allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    }
    /**
    Test whether the given set of marks are allowed in this node.
    */
    allowsMarks(marks) {
      if (this.markSet == null)
        return true;
      for (let i = 0; i < marks.length; i++)
        if (!this.allowsMarkType(marks[i].type))
          return false;
      return true;
    }
    /**
    Removes the marks that are not allowed in this node from the given set.
    */
    allowedMarks(marks) {
      if (this.markSet == null)
        return marks;
      let copy4;
      for (let i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          if (!copy4)
            copy4 = marks.slice(0, i);
        } else if (copy4) {
          copy4.push(marks[i]);
        }
      }
      return !copy4 ? marks : copy4.length ? copy4 : Mark.none;
    }
    /**
    @internal
    */
    static compile(nodes, schema) {
      let result = /* @__PURE__ */ Object.create(null);
      nodes.forEach((name, spec) => result[name] = new _NodeType(name, schema, spec));
      let topType = schema.spec.topNode || "doc";
      if (!result[topType])
        throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      if (!result.text)
        throw new RangeError("Every schema needs a 'text' type");
      for (let _2 in result.text.attrs)
        throw new RangeError("The text node type should not have attributes");
      return result;
    }
  };
  function validateType(typeName, attrName, type) {
    let types = type.split("|");
    return (value) => {
      let name = value === null ? "null" : typeof value;
      if (types.indexOf(name) < 0)
        throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
    };
  }
  var Attribute = class {
    constructor(typeName, attrName, options2) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(options2, "default");
      this.default = options2.default;
      this.validate = typeof options2.validate == "string" ? validateType(typeName, attrName, options2.validate) : options2.validate;
    }
    get isRequired() {
      return !this.hasDefault;
    }
  };
  var MarkType = class _MarkType {
    /**
    @internal
    */
    constructor(name, rank, schema, spec) {
      this.name = name;
      this.rank = rank;
      this.schema = schema;
      this.spec = spec;
      this.attrs = initAttrs(name, spec.attrs);
      this.excluded = null;
      let defaults3 = defaultAttrs(this.attrs);
      this.instance = defaults3 ? new Mark(this, defaults3) : null;
    }
    /**
    Create a mark of this type. `attrs` may be `null` or an object
    containing only some of the mark's attributes. The others, if
    they have defaults, will be added.
    */
    create(attrs = null) {
      if (!attrs && this.instance)
        return this.instance;
      return new Mark(this, computeAttrs(this.attrs, attrs));
    }
    /**
    @internal
    */
    static compile(marks, schema) {
      let result = /* @__PURE__ */ Object.create(null), rank = 0;
      marks.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema, spec));
      return result;
    }
    /**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */
    removeFromSet(set2) {
      for (var i = 0; i < set2.length; i++)
        if (set2[i].type == this) {
          set2 = set2.slice(0, i).concat(set2.slice(i + 1));
          i--;
        }
      return set2;
    }
    /**
    Tests whether there is a mark of this type in the given set.
    */
    isInSet(set2) {
      for (let i = 0; i < set2.length; i++)
        if (set2[i].type == this)
          return set2[i];
    }
    /**
    @internal
    */
    checkAttrs(attrs) {
      checkAttrs(this.attrs, attrs, "mark", this.name);
    }
    /**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */
    excludes(other) {
      return this.excluded.indexOf(other) > -1;
    }
  };
  var Schema2 = class {
    /**
    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
    */
    constructor(spec) {
      this.linebreakReplacement = null;
      this.cached = /* @__PURE__ */ Object.create(null);
      let instanceSpec = this.spec = {};
      for (let prop in spec)
        instanceSpec[prop] = spec[prop];
      instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
      this.marks = MarkType.compile(this.spec.marks, this);
      let contentExprCache = /* @__PURE__ */ Object.create(null);
      for (let prop in this.nodes) {
        if (prop in this.marks)
          throw new RangeError(prop + " can not be both a node and a mark");
        let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
        type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
        type.inlineContent = type.contentMatch.inlineContent;
        if (type.spec.linebreakReplacement) {
          if (this.linebreakReplacement)
            throw new RangeError("Multiple linebreak nodes defined");
          if (!type.isInline || !type.isLeaf)
            throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
          this.linebreakReplacement = type;
        }
        type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
      }
      for (let prop in this.marks) {
        let type = this.marks[prop], excl = type.spec.excludes;
        type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this);
      this.markFromJSON = this.markFromJSON.bind(this);
      this.topNodeType = this.nodes[this.spec.topNode || "doc"];
      this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    }
    /**
    Create a node in this schema. The `type` may be a string or a
    `NodeType` instance. Attributes will be extended with defaults,
    `content` may be a `Fragment`, `null`, a `Node`, or an array of
    nodes.
    */
    node(type, attrs = null, content5, marks) {
      if (typeof type == "string")
        type = this.nodeType(type);
      else if (!(type instanceof NodeType))
        throw new RangeError("Invalid node type: " + type);
      else if (type.schema != this)
        throw new RangeError("Node type from different schema used (" + type.name + ")");
      return type.createChecked(attrs, content5, marks);
    }
    /**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */
    text(text10, marks) {
      let type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, text10, Mark.setFrom(marks));
    }
    /**
    Create a mark with the given type and attributes.
    */
    mark(type, attrs) {
      if (typeof type == "string")
        type = this.marks[type];
      return type.create(attrs);
    }
    /**
    Deserialize a node from its JSON representation. This method is
    bound.
    */
    nodeFromJSON(json) {
      return Node2.fromJSON(this, json);
    }
    /**
    Deserialize a mark from its JSON representation. This method is
    bound.
    */
    markFromJSON(json) {
      return Mark.fromJSON(this, json);
    }
    /**
    @internal
    */
    nodeType(name) {
      let found2 = this.nodes[name];
      if (!found2)
        throw new RangeError("Unknown node type: " + name);
      return found2;
    }
  };
  function gatherMarks(schema, marks) {
    let found2 = [];
    for (let i = 0; i < marks.length; i++) {
      let name = marks[i], mark2 = schema.marks[name], ok3 = mark2;
      if (mark2) {
        found2.push(mark2);
      } else {
        for (let prop in schema.marks) {
          let mark3 = schema.marks[prop];
          if (name == "_" || mark3.spec.group && mark3.spec.group.split(" ").indexOf(name) > -1)
            found2.push(ok3 = mark3);
        }
      }
      if (!ok3)
        throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
    }
    return found2;
  }
  function isTagRule(rule) {
    return rule.tag != null;
  }
  function isStyleRule(rule) {
    return rule.style != null;
  }
  var DOMParser2 = class _DOMParser {
    /**
    Create a parser that targets the given schema, using the given
    parsing rules.
    */
    constructor(schema, rules) {
      this.schema = schema;
      this.rules = rules;
      this.tags = [];
      this.styles = [];
      let matchedStyles = this.matchedStyles = [];
      rules.forEach((rule) => {
        if (isTagRule(rule)) {
          this.tags.push(rule);
        } else if (isStyleRule(rule)) {
          let prop = /[^=]*/.exec(rule.style)[0];
          if (matchedStyles.indexOf(prop) < 0)
            matchedStyles.push(prop);
          this.styles.push(rule);
        }
      });
      this.normalizeLists = !this.tags.some((r) => {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
          return false;
        let node2 = schema.nodes[r.node];
        return node2.contentMatch.matchType(node2);
      });
    }
    /**
    Parse a document from the content of a DOM node.
    */
    parse(dom, options2 = {}) {
      let context = new ParseContext(this, options2, false);
      context.addAll(dom, Mark.none, options2.from, options2.to);
      return context.finish();
    }
    /**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */
    parseSlice(dom, options2 = {}) {
      let context = new ParseContext(this, options2, true);
      context.addAll(dom, Mark.none, options2.from, options2.to);
      return Slice.maxOpen(context.finish());
    }
    /**
    @internal
    */
    matchTag(dom, context, after) {
      for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
        let rule = this.tags[i];
        if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            let result = rule.getAttrs(dom);
            if (result === false)
              continue;
            rule.attrs = result || void 0;
          }
          return rule;
        }
      }
    }
    /**
    @internal
    */
    matchStyle(prop, value, context, after) {
      for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
        let rule = this.styles[i], style3 = rule.style;
        if (style3.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        style3.length > prop.length && (style3.charCodeAt(prop.length) != 61 || style3.slice(prop.length + 1) != value))
          continue;
        if (rule.getAttrs) {
          let result = rule.getAttrs(value);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
    /**
    @internal
    */
    static schemaRules(schema) {
      let result = [];
      function insert(rule) {
        let priority = rule.priority == null ? 50 : rule.priority, i = 0;
        for (; i < result.length; i++) {
          let next2 = result[i], nextPriority = next2.priority == null ? 50 : next2.priority;
          if (nextPriority < priority)
            break;
        }
        result.splice(i, 0, rule);
      }
      for (let name in schema.marks) {
        let rules = schema.marks[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy(rule));
            if (!(rule.mark || rule.ignore || rule.clearMark))
              rule.mark = name;
          });
      }
      for (let name in schema.nodes) {
        let rules = schema.nodes[name].spec.parseDOM;
        if (rules)
          rules.forEach((rule) => {
            insert(rule = copy(rule));
            if (!(rule.node || rule.ignore || rule.mark))
              rule.node = name;
          });
      }
      return result;
    }
    /**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */
    static fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new _DOMParser(schema, _DOMParser.schemaRules(schema)));
    }
  };
  var blockTags = {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    canvas: true,
    dd: true,
    div: true,
    dl: true,
    fieldset: true,
    figcaption: true,
    figure: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    li: true,
    noscript: true,
    ol: true,
    output: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    tfoot: true,
    ul: true
  };
  var ignoreTags = {
    head: true,
    noscript: true,
    object: true,
    script: true,
    style: true,
    title: true
  };
  var listTags = { ol: true, ul: true };
  var OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
  function wsOptionsFor(type, preserveWhitespace, base4) {
    if (preserveWhitespace != null)
      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
    return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base4 & ~OPT_OPEN_LEFT;
  }
  var NodeContext = class {
    constructor(type, attrs, marks, solid, match, options2) {
      this.type = type;
      this.attrs = attrs;
      this.marks = marks;
      this.solid = solid;
      this.options = options2;
      this.content = [];
      this.activeMarks = Mark.none;
      this.match = match || (options2 & OPT_OPEN_LEFT ? null : type.contentMatch);
    }
    findWrapping(node2) {
      if (!this.match) {
        if (!this.type)
          return [];
        let fill = this.type.contentMatch.fillBefore(Fragment.from(node2));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          let start = this.type.contentMatch, wrap5;
          if (wrap5 = start.findWrapping(node2.type)) {
            this.match = start;
            return wrap5;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node2.type);
    }
    finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        let last2 = this.content[this.content.length - 1], m;
        if (last2 && last2.isText && (m = /[ \t\r\n\u000c]+$/.exec(last2.text))) {
          let text10 = last2;
          if (last2.text.length == m[0].length)
            this.content.pop();
          else
            this.content[this.content.length - 1] = text10.withText(text10.text.slice(0, text10.text.length - m[0].length));
        }
      }
      let content5 = Fragment.from(this.content);
      if (!openEnd && this.match)
        content5 = content5.append(this.match.fillBefore(Fragment.empty, true));
      return this.type ? this.type.create(this.attrs, content5, this.marks) : content5;
    }
    inlineContext(node2) {
      if (this.type)
        return this.type.inlineContent;
      if (this.content.length)
        return this.content[0].isInline;
      return node2.parentNode && !blockTags.hasOwnProperty(node2.parentNode.nodeName.toLowerCase());
    }
  };
  var ParseContext = class {
    constructor(parser, options2, isOpen) {
      this.parser = parser;
      this.options = options2;
      this.isOpen = isOpen;
      this.open = 0;
      this.localPreserveWS = false;
      let topNode = options2.topNode, topContext;
      let topOptions = wsOptionsFor(null, options2.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
      if (topNode)
        topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options2.topMatch || topNode.type.contentMatch, topOptions);
      else if (isOpen)
        topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
      else
        topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
      this.nodes = [topContext];
      this.find = options2.findPositions;
      this.needsBlock = false;
    }
    get top() {
      return this.nodes[this.open];
    }
    // Add a DOM node to the content. Text is inserted as text node,
    // otherwise, the node is passed to `addElement` or, if it has a
    // `style` attribute, `addElementWithStyles`.
    addDOM(dom, marks) {
      if (dom.nodeType == 3)
        this.addTextNode(dom, marks);
      else if (dom.nodeType == 1)
        this.addElement(dom, marks);
    }
    addTextNode(dom, marks) {
      let value = dom.nodeValue;
      let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
      if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!preserveWS) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            let nodeBefore = top.content[top.content.length - 1];
            let domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
              value = value.slice(1);
          }
        } else if (preserveWS !== "full") {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value)
          this.insertNode(this.parser.schema.text(value), marks, !/\S/.test(value));
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    }
    // Try to find a handler for the given tag and use that to parse. If
    // none is found, the element's content nodes are added directly.
    addElement(dom, marks, matchAfter) {
      let outerWS = this.localPreserveWS, top = this.top;
      if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
        this.localPreserveWS = true;
      let name = dom.nodeName.toLowerCase(), ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
        normalizeList(dom);
      let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
      out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom, marks);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent)
          this.open = Math.max(0, this.open - 1);
        else if (rule && rule.skip.nodeType)
          dom = rule.skip;
        let sync, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top.content.length && top.content[0].isInline && this.open) {
            this.open--;
            top = this.top;
          }
          sync = true;
          if (!top.type)
            this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom, marks);
          break out;
        }
        let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
        if (innerMarks)
          this.addAll(dom, innerMarks);
        if (sync)
          this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        let innerMarks = this.readStyles(dom, marks);
        if (innerMarks)
          this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
      }
      this.localPreserveWS = outerWS;
    }
    // Called for leaf DOM nodes that would otherwise be ignored
    leafFallback(dom, marks) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
        this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
    }
    // Called for ignored nodes
    ignoreFallback(dom, marks) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
        this.findPlace(this.parser.schema.text("-"), marks, true);
    }
    // Run any style parser associated with the node's styles. Either
    // return an updated array of marks, or null to indicate some of the
    // styles had a rule with `ignore` set.
    readStyles(dom, marks) {
      let styles = dom.style;
      if (styles && styles.length)
        for (let i = 0; i < this.parser.matchedStyles.length; i++) {
          let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
          if (value)
            for (let after = void 0; ; ) {
              let rule = this.parser.matchStyle(name, value, this, after);
              if (!rule)
                break;
              if (rule.ignore)
                return null;
              if (rule.clearMark)
                marks = marks.filter((m) => !rule.clearMark(m));
              else
                marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
              if (rule.consuming === false)
                after = rule;
              else
                break;
            }
        }
      return marks;
    }
    // Look up a handler for the given node. If none are found, return
    // false. Otherwise, apply it, use its return value to drive the way
    // the node's content is wrapped, and return true.
    addElementByRule(dom, rule, marks, continueAfter) {
      let sync, nodeType;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
          if (inner) {
            sync = true;
            marks = inner;
          }
        } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
          this.leafFallback(dom, marks);
        }
      } else {
        let markType = this.parser.schema.marks[rule.mark];
        marks = marks.concat(markType.create(rule.attrs));
      }
      let startIn = this.top;
      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, marks, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach((node2) => this.insertNode(node2, marks, false));
      } else {
        let contentDOM = dom;
        if (typeof rule.contentElement == "string")
          contentDOM = dom.querySelector(rule.contentElement);
        else if (typeof rule.contentElement == "function")
          contentDOM = rule.contentElement(dom);
        else if (rule.contentElement)
          contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM, marks);
        this.findAround(dom, contentDOM, false);
      }
      if (sync && this.sync(startIn))
        this.open--;
    }
    // Add all child nodes between `startIndex` and `endIndex` (or the
    // whole node, if not given). If `sync` is passed, use it to
    // synchronize after every block element.
    addAll(parent, marks, startIndex, endIndex) {
      let index3 = startIndex || 0;
      for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index3) {
        this.findAtPoint(parent, index3);
        this.addDOM(dom, marks);
      }
      this.findAtPoint(parent, index3);
    }
    // Try to find a way to fit the given node type into the current
    // context. May add intermediate wrappers and/or leave non-solid
    // nodes that we're in.
    findPlace(node2, marks, cautious) {
      let route, sync;
      for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
        let cx = this.nodes[depth];
        let found2 = cx.findWrapping(node2);
        if (found2 && (!route || route.length > found2.length + penalty)) {
          route = found2;
          sync = cx;
          if (!found2.length)
            break;
        }
        if (cx.solid) {
          if (cautious)
            break;
          penalty += 2;
        }
      }
      if (!route)
        return null;
      this.sync(sync);
      for (let i = 0; i < route.length; i++)
        marks = this.enterInner(route[i], null, marks, false);
      return marks;
    }
    // Try to insert the given node, adjusting the context when needed.
    insertNode(node2, marks, cautious) {
      if (node2.isInline && this.needsBlock && !this.top.type) {
        let block = this.textblockFromContext();
        if (block)
          marks = this.enterInner(block, null, marks);
      }
      let innerMarks = this.findPlace(node2, marks, cautious);
      if (innerMarks) {
        this.closeExtra();
        let top = this.top;
        if (top.match)
          top.match = top.match.matchType(node2.type);
        let nodeMarks = Mark.none;
        for (let m of innerMarks.concat(node2.marks))
          if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node2.type))
            nodeMarks = m.addToSet(nodeMarks);
        top.content.push(node2.mark(nodeMarks));
        return true;
      }
      return false;
    }
    // Try to start a node of the given type, adjusting the context when
    // necessary.
    enter(type, attrs, marks, preserveWS) {
      let innerMarks = this.findPlace(type.create(attrs), marks, false);
      if (innerMarks)
        innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
      return innerMarks;
    }
    // Open a node of the given type
    enterInner(type, attrs, marks, solid = false, preserveWS) {
      this.closeExtra();
      let top = this.top;
      top.match = top.match && top.match.matchType(type);
      let options2 = wsOptionsFor(type, preserveWS, top.options);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
        options2 |= OPT_OPEN_LEFT;
      let applyMarks = Mark.none;
      marks = marks.filter((m) => {
        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
          applyMarks = m.addToSet(applyMarks);
          return false;
        }
        return true;
      });
      this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options2));
      this.open++;
      return marks;
    }
    // Make sure all nodes above this.open are finished and added to
    // their parents
    closeExtra(openEnd = false) {
      let i = this.nodes.length - 1;
      if (i > this.open) {
        for (; i > this.open; i--)
          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        this.nodes.length = this.open + 1;
      }
    }
    finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
    }
    sync(to2) {
      for (let i = this.open; i >= 0; i--) {
        if (this.nodes[i] == to2) {
          this.open = i;
          return true;
        } else if (this.localPreserveWS) {
          this.nodes[i].options |= OPT_PRESERVE_WS;
        }
      }
      return false;
    }
    get currentPos() {
      this.closeExtra();
      let pos = 0;
      for (let i = this.open; i >= 0; i--) {
        let content5 = this.nodes[i].content;
        for (let j2 = content5.length - 1; j2 >= 0; j2--)
          pos += content5[j2].nodeSize;
        if (i)
          pos++;
      }
      return pos;
    }
    findAtPoint(parent, offset) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].node == parent && this.find[i].offset == offset)
            this.find[i].pos = this.currentPos;
        }
    }
    findInside(parent) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
            this.find[i].pos = this.currentPos;
        }
    }
    findAround(parent, content5, before) {
      if (parent != content5 && this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
            let pos = content5.compareDocumentPosition(this.find[i].node);
            if (pos & (before ? 2 : 4))
              this.find[i].pos = this.currentPos;
          }
        }
    }
    findInText(textNode) {
      if (this.find)
        for (let i = 0; i < this.find.length; i++) {
          if (this.find[i].node == textNode)
            this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
        }
    }
    // Determines whether the given context string matches this context.
    matchesContext(context) {
      if (context.indexOf("|") > -1)
        return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      let parts = context.split("/");
      let option2 = this.options.context;
      let useRoot = !this.isOpen && (!option2 || option2.parent.type == this.nodes[0].type);
      let minDepth = -(option2 ? option2.depth + 1 : 0) + (useRoot ? 0 : 1);
      let match = (i, depth) => {
        for (; i >= 0; i--) {
          let part = parts[i];
          if (part == "") {
            if (i == parts.length - 1 || i == 0)
              continue;
            for (; depth >= minDepth; depth--)
              if (match(i - 1, depth))
                return true;
            return false;
          } else {
            let next2 = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option2 && depth >= minDepth ? option2.node(depth - minDepth).type : null;
            if (!next2 || next2.name != part && !next2.isInGroup(part))
              return false;
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    }
    textblockFromContext() {
      let $context = this.options.context;
      if ($context)
        for (let d = $context.depth; d >= 0; d--) {
          let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
          if (deflt && deflt.isTextblock && deflt.defaultAttrs)
            return deflt;
        }
      for (let name in this.parser.schema.nodes) {
        let type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs)
          return type;
      }
    }
  };
  function normalizeList(dom) {
    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
      let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
      if (name && listTags.hasOwnProperty(name) && prevItem) {
        prevItem.appendChild(child);
        child = prevItem;
      } else if (name == "li") {
        prevItem = child;
      } else if (name) {
        prevItem = null;
      }
    }
  }
  function matches(dom, selector) {
    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
  }
  function copy(obj) {
    let copy4 = {};
    for (let prop in obj)
      copy4[prop] = obj[prop];
    return copy4;
  }
  function markMayApply(markType, nodeType) {
    let nodes = nodeType.schema.nodes;
    for (let name in nodes) {
      let parent = nodes[name];
      if (!parent.allowsMarkType(markType))
        continue;
      let seen = [], scan = (match) => {
        seen.push(match);
        for (let i = 0; i < match.edgeCount; i++) {
          let { type, next: next2 } = match.edge(i);
          if (type == nodeType)
            return true;
          if (seen.indexOf(next2) < 0 && scan(next2))
            return true;
        }
      };
      if (scan(parent.contentMatch))
        return true;
    }
  }
  var DOMSerializer = class _DOMSerializer {
    /**
    Create a serializer. `nodes` should map node names to functions
    that take a node and return a description of the corresponding
    DOM. `marks` does the same for mark names, but also gets an
    argument that tells it whether the mark's content is block or
    inline content (for typical use, it'll always be inline). A mark
    serializer may be `null` to indicate that marks of that type
    should not be serialized.
    */
    constructor(nodes, marks) {
      this.nodes = nodes;
      this.marks = marks;
    }
    /**
    Serialize the content of this fragment to a DOM fragment. When
    not in the browser, the `document` option, containing a DOM
    document, should be passed so that the serializer can create
    nodes.
    */
    serializeFragment(fragment2, options2 = {}, target) {
      if (!target)
        target = doc(options2).createDocumentFragment();
      let top = target, active = [];
      fragment2.forEach((node2) => {
        if (active.length || node2.marks.length) {
          let keep = 0, rendered = 0;
          while (keep < active.length && rendered < node2.marks.length) {
            let next2 = node2.marks[rendered];
            if (!this.marks[next2.type.name]) {
              rendered++;
              continue;
            }
            if (!next2.eq(active[keep][0]) || next2.type.spec.spanning === false)
              break;
            keep++;
            rendered++;
          }
          while (keep < active.length)
            top = active.pop()[1];
          while (rendered < node2.marks.length) {
            let add3 = node2.marks[rendered++];
            let markDOM = this.serializeMark(add3, node2.isInline, options2);
            if (markDOM) {
              active.push([add3, top]);
              top.appendChild(markDOM.dom);
              top = markDOM.contentDOM || markDOM.dom;
            }
          }
        }
        top.appendChild(this.serializeNodeInner(node2, options2));
      });
      return target;
    }
    /**
    @internal
    */
    serializeNodeInner(node2, options2) {
      let { dom, contentDOM } = renderSpec(doc(options2), this.nodes[node2.type.name](node2), null, node2.attrs);
      if (contentDOM) {
        if (node2.isLeaf)
          throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(node2.content, options2, contentDOM);
      }
      return dom;
    }
    /**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */
    serializeNode(node2, options2 = {}) {
      let dom = this.serializeNodeInner(node2, options2);
      for (let i = node2.marks.length - 1; i >= 0; i--) {
        let wrap5 = this.serializeMark(node2.marks[i], node2.isInline, options2);
        if (wrap5) {
          (wrap5.contentDOM || wrap5.dom).appendChild(dom);
          dom = wrap5.dom;
        }
      }
      return dom;
    }
    /**
    @internal
    */
    serializeMark(mark2, inline, options2 = {}) {
      let toDOM = this.marks[mark2.type.name];
      return toDOM && renderSpec(doc(options2), toDOM(mark2, inline), null, mark2.attrs);
    }
    static renderSpec(doc4, structure, xmlNS = null, blockArraysIn) {
      return renderSpec(doc4, structure, xmlNS, blockArraysIn);
    }
    /**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */
    static fromSchema(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    }
    /**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */
    static nodesFromSchema(schema) {
      let result = gatherToDOM(schema.nodes);
      if (!result.text)
        result.text = (node2) => node2.text;
      return result;
    }
    /**
    Gather the serializers in a schema's mark specs into an object.
    */
    static marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    }
  };
  function gatherToDOM(obj) {
    let result = {};
    for (let name in obj) {
      let toDOM = obj[name].spec.toDOM;
      if (toDOM)
        result[name] = toDOM;
    }
    return result;
  }
  function doc(options2) {
    return options2.document || window.document;
  }
  var suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
  function suspiciousAttributes(attrs) {
    let value = suspiciousAttributeCache.get(attrs);
    if (value === void 0)
      suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
    return value;
  }
  function suspiciousAttributesInner(attrs) {
    let result = null;
    function scan(value) {
      if (value && typeof value == "object") {
        if (Array.isArray(value)) {
          if (typeof value[0] == "string") {
            if (!result)
              result = [];
            result.push(value);
          } else {
            for (let i = 0; i < value.length; i++)
              scan(value[i]);
          }
        } else {
          for (let prop in value)
            scan(value[prop]);
        }
      }
    }
    scan(attrs);
    return result;
  }
  function renderSpec(doc4, structure, xmlNS, blockArraysIn) {
    if (typeof structure == "string")
      return { dom: doc4.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    let tagName = structure[0], suspicious;
    if (typeof tagName != "string")
      throw new RangeError("Invalid array passed to renderSpec");
    if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
      throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
    let space2 = tagName.indexOf(" ");
    if (space2 > 0) {
      xmlNS = tagName.slice(0, space2);
      tagName = tagName.slice(space2 + 1);
    }
    let contentDOM;
    let dom = xmlNS ? doc4.createElementNS(xmlNS, tagName) : doc4.createElement(tagName);
    let attrs = structure[1], start = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start = 2;
      for (let name in attrs)
        if (attrs[name] != null) {
          let space3 = name.indexOf(" ");
          if (space3 > 0)
            dom.setAttributeNS(name.slice(0, space3), name.slice(space3 + 1), attrs[name]);
          else
            dom.setAttribute(name, attrs[name]);
        }
    }
    for (let i = start; i < structure.length; i++) {
      let child = structure[i];
      if (child === 0) {
        if (i < structure.length - 1 || i > start)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom, contentDOM: dom };
      } else {
        let { dom: inner, contentDOM: innerContent } = renderSpec(doc4, child, xmlNS, blockArraysIn);
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  }

  // node_modules/prosemirror-transform/dist/index.js
  var lower16 = 65535;
  var factor16 = Math.pow(2, 16);
  function makeRecover(index3, offset) {
    return index3 + offset * factor16;
  }
  function recoverIndex(value) {
    return value & lower16;
  }
  function recoverOffset(value) {
    return (value - (value & lower16)) / factor16;
  }
  var DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
  var MapResult = class {
    /**
    @internal
    */
    constructor(pos, delInfo, recover) {
      this.pos = pos;
      this.delInfo = delInfo;
      this.recover = recover;
    }
    /**
    Tells you whether the position was deleted, that is, whether the
    step removed the token on the side queried (via the `assoc`)
    argument from the document.
    */
    get deleted() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
    /**
    Tells you whether the token before the mapped position was deleted.
    */
    get deletedBefore() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
    /**
    True when the token after the mapped position was deleted.
    */
    get deletedAfter() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
    /**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */
    get deletedAcross() {
      return (this.delInfo & DEL_ACROSS) > 0;
    }
  };
  var StepMap = class _StepMap {
    /**
    Create a position map. The modifications to the document are
    represented as an array of numbers, in which each group of three
    represents a modified chunk as `[start, oldSize, newSize]`.
    */
    constructor(ranges, inverted = false) {
      this.ranges = ranges;
      this.inverted = inverted;
      if (!ranges.length && _StepMap.empty)
        return _StepMap.empty;
    }
    /**
    @internal
    */
    recover(value) {
      let diff = 0, index3 = recoverIndex(value);
      if (!this.inverted)
        for (let i = 0; i < index3; i++)
          diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      return this.ranges[index3 * 3] + diff + recoverOffset(value);
    }
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    map(pos, assoc = 1) {
      return this._map(pos, assoc, true);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0; i < this.ranges.length; i += 3) {
        let start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos)
          break;
        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
        if (pos <= end) {
          let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
          let result = start + diff + (side < 0 ? 0 : newSize);
          if (simple)
            return result;
          let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
          let del3 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start : pos != end)
            del3 |= DEL_SIDE;
          return new MapResult(result, del3, recover);
        }
        diff += newSize - oldSize;
      }
      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
    /**
    @internal
    */
    touches(pos, recover) {
      let diff = 0, index3 = recoverIndex(recover);
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0; i < this.ranges.length; i += 3) {
        let start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos)
          break;
        let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
        if (pos <= end && i == index3 * 3)
          return true;
        diff += this.ranges[i + newIndex] - oldSize;
      }
      return false;
    }
    /**
    Calls the given function on each of the changed ranges included in
    this map.
    */
    forEach(f) {
      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
        let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    }
    /**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */
    invert() {
      return new _StepMap(this.ranges, !this.inverted);
    }
    /**
    @internal
    */
    toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    /**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */
    static offset(n) {
      return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
  };
  StepMap.empty = new StepMap([]);
  var Mapping = class _Mapping {
    /**
    Create a new mapping with the given position maps.
    */
    constructor(maps, mirror, from4 = 0, to2 = maps ? maps.length : 0) {
      this.mirror = mirror;
      this.from = from4;
      this.to = to2;
      this._maps = maps || [];
      this.ownData = !(maps || mirror);
    }
    /**
    The step maps in this mapping.
    */
    get maps() {
      return this._maps;
    }
    /**
    Create a mapping that maps only through a part of this one.
    */
    slice(from4 = 0, to2 = this.maps.length) {
      return new _Mapping(this._maps, this.mirror, from4, to2);
    }
    /**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */
    appendMap(map9, mirrors) {
      if (!this.ownData) {
        this._maps = this._maps.slice();
        this.mirror = this.mirror && this.mirror.slice();
        this.ownData = true;
      }
      this.to = this._maps.push(map9);
      if (mirrors != null)
        this.setMirror(this._maps.length - 1, mirrors);
    }
    /**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */
    appendMapping(mapping) {
      for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
        let mirr = mapping.getMirror(i);
        this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
      }
    }
    /**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */
    getMirror(n) {
      if (this.mirror) {
        for (let i = 0; i < this.mirror.length; i++)
          if (this.mirror[i] == n)
            return this.mirror[i + (i % 2 ? -1 : 1)];
      }
    }
    /**
    @internal
    */
    setMirror(n, m) {
      if (!this.mirror)
        this.mirror = [];
      this.mirror.push(n, m);
    }
    /**
    Append the inverse of the given mapping to this one.
    */
    appendMappingInverted(mapping) {
      for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
        let mirr = mapping.getMirror(i);
        this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
      }
    }
    /**
    Create an inverted version of this mapping.
    */
    invert() {
      let inverse = new _Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    }
    /**
    Map a position through this mapping.
    */
    map(pos, assoc = 1) {
      if (this.mirror)
        return this._map(pos, assoc, true);
      for (let i = this.from; i < this.to; i++)
        pos = this._maps[i].map(pos, assoc);
      return pos;
    }
    /**
    Map a position through this mapping, returning a mapping
    result.
    */
    mapResult(pos, assoc = 1) {
      return this._map(pos, assoc, false);
    }
    /**
    @internal
    */
    _map(pos, assoc, simple) {
      let delInfo = 0;
      for (let i = this.from; i < this.to; i++) {
        let map9 = this._maps[i], result = map9.mapResult(pos, assoc);
        if (result.recover != null) {
          let corr = this.getMirror(i);
          if (corr != null && corr > i && corr < this.to) {
            i = corr;
            pos = this._maps[corr].recover(result.recover);
            continue;
          }
        }
        delInfo |= result.delInfo;
        pos = result.pos;
      }
      return simple ? pos : new MapResult(pos, delInfo, null);
    }
  };
  var stepsByID = /* @__PURE__ */ Object.create(null);
  var Step = class {
    /**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
    getMap() {
      return StepMap.empty;
    }
    /**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */
    merge(other) {
      return null;
    }
    /**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */
    static fromJSON(schema, json) {
      if (!json || !json.stepType)
        throw new RangeError("Invalid input for Step.fromJSON");
      let type = stepsByID[json.stepType];
      if (!type)
        throw new RangeError(`No step type ${json.stepType} defined`);
      return type.fromJSON(schema, json);
    }
    /**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */
    static jsonID(id2, stepClass) {
      if (id2 in stepsByID)
        throw new RangeError("Duplicate use of step JSON ID " + id2);
      stepsByID[id2] = stepClass;
      stepClass.prototype.jsonID = id2;
      return stepClass;
    }
  };
  var StepResult = class _StepResult {
    /**
    @internal
    */
    constructor(doc4, failed) {
      this.doc = doc4;
      this.failed = failed;
    }
    /**
    Create a successful step result.
    */
    static ok(doc4) {
      return new _StepResult(doc4, null);
    }
    /**
    Create a failed step result.
    */
    static fail(message) {
      return new _StepResult(null, message);
    }
    /**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */
    static fromReplace(doc4, from4, to2, slice2) {
      try {
        return _StepResult.ok(doc4.replace(from4, to2, slice2));
      } catch (e) {
        if (e instanceof ReplaceError)
          return _StepResult.fail(e.message);
        throw e;
      }
    }
  };
  function mapFragment(fragment2, f, parent) {
    let mapped = [];
    for (let i = 0; i < fragment2.childCount; i++) {
      let child = fragment2.child(i);
      if (child.content.size)
        child = child.copy(mapFragment(child.content, f, child));
      if (child.isInline)
        child = f(child, parent, i);
      mapped.push(child);
    }
    return Fragment.fromArray(mapped);
  }
  var AddMarkStep = class _AddMarkStep extends Step {
    /**
    Create a mark step.
    */
    constructor(from4, to2, mark2) {
      super();
      this.from = from4;
      this.to = to2;
      this.mark = mark2;
    }
    apply(doc4) {
      let oldSlice = doc4.slice(this.from, this.to), $from = doc4.resolve(this.from);
      let parent = $from.node($from.sharedDepth(this.to));
      let slice2 = new Slice(mapFragment(oldSlice.content, (node2, parent2) => {
        if (!node2.isAtom || !parent2.type.allowsMarkType(this.mark.type))
          return node2;
        return node2.mark(this.mark.addToSet(node2.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc4, this.from, this.to, slice2);
    }
    invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from4 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
      if (from4.deleted && to2.deleted || from4.pos >= to2.pos)
        return null;
      return new _AddMarkStep(from4.pos, to2.pos, this.mark);
    }
    merge(other) {
      if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new _AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("addMark", AddMarkStep);
  var RemoveMarkStep = class _RemoveMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(from4, to2, mark2) {
      super();
      this.from = from4;
      this.to = to2;
      this.mark = mark2;
    }
    apply(doc4) {
      let oldSlice = doc4.slice(this.from, this.to);
      let slice2 = new Slice(mapFragment(oldSlice.content, (node2) => {
        return node2.mark(this.mark.removeFromSet(node2.marks));
      }, doc4), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc4, this.from, this.to, slice2);
    }
    invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    }
    map(mapping) {
      let from4 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
      if (from4.deleted && to2.deleted || from4.pos >= to2.pos)
        return null;
      return new _RemoveMarkStep(from4.pos, to2.pos, this.mark);
    }
    merge(other) {
      if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
        return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
    toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new _RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("removeMark", RemoveMarkStep);
  var AddNodeMarkStep = class _AddNodeMarkStep extends Step {
    /**
    Create a node mark step.
    */
    constructor(pos, mark2) {
      super();
      this.pos = pos;
      this.mark = mark2;
    }
    apply(doc4) {
      let node2 = doc4.nodeAt(this.pos);
      if (!node2)
        return StepResult.fail("No node at mark step's position");
      let updated = node2.type.create(node2.attrs, null, this.mark.addToSet(node2.marks));
      return StepResult.fromReplace(doc4, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
    }
    invert(doc4) {
      let node2 = doc4.nodeAt(this.pos);
      if (node2) {
        let newSet = this.mark.addToSet(node2.marks);
        if (newSet.length == node2.marks.length) {
          for (let i = 0; i < node2.marks.length; i++)
            if (!node2.marks[i].isInSet(newSet))
              return new _AddNodeMarkStep(this.pos, node2.marks[i]);
          return new _AddNodeMarkStep(this.pos, this.mark);
        }
      }
      return new RemoveNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new _AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("addNodeMark", AddNodeMarkStep);
  var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {
    /**
    Create a mark-removing step.
    */
    constructor(pos, mark2) {
      super();
      this.pos = pos;
      this.mark = mark2;
    }
    apply(doc4) {
      let node2 = doc4.nodeAt(this.pos);
      if (!node2)
        return StepResult.fail("No node at mark step's position");
      let updated = node2.type.create(node2.attrs, null, this.mark.removeFromSet(node2.marks));
      return StepResult.fromReplace(doc4, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
    }
    invert(doc4) {
      let node2 = doc4.nodeAt(this.pos);
      if (!node2 || !this.mark.isInSet(node2.marks))
        return this;
      return new AddNodeMarkStep(this.pos, this.mark);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);
    }
    toJSON() {
      return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new _RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  };
  Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
  var ReplaceStep = class _ReplaceStep extends Step {
    /**
    The given `slice` should fit the 'gap' between `from` and
    `to`the depths must line up, and the surrounding nodes must be
    able to be joined with the open sides of the slice. When
    `structure` is true, the step will fail if the content between
    from and to is not just a sequence of closing and then opening
    tokens (this is to guard against rebased replace steps
    overwriting something they weren't supposed to).
    */
    constructor(from4, to2, slice2, structure = false) {
      super();
      this.from = from4;
      this.to = to2;
      this.slice = slice2;
      this.structure = structure;
    }
    apply(doc4) {
      if (this.structure && contentBetween(doc4, this.from, this.to))
        return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc4, this.from, this.to, this.slice);
    }
    getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
    invert(doc4) {
      return new _ReplaceStep(this.from, this.from + this.slice.size, doc4.slice(this.from, this.to));
    }
    map(mapping) {
      let from4 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
      if (from4.deletedAcross && to2.deletedAcross)
        return null;
      return new _ReplaceStep(from4.pos, Math.max(from4.pos, to2.pos), this.slice, this.structure);
    }
    merge(other) {
      if (!(other instanceof _ReplaceStep) || other.structure || this.structure)
        return null;
      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
        return new _ReplaceStep(other.from, this.to, slice2, this.structure);
      } else {
        return null;
      }
    }
    toJSON() {
      let json = { stepType: "replace", from: this.from, to: this.to };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number")
        throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
    }
  };
  Step.jsonID("replace", ReplaceStep);
  var ReplaceAroundStep = class _ReplaceAroundStep extends Step {
    /**
    Create a replace-around step with the given range and gap.
    `insert` should be the point in the slice into which the content
    of the gap should be moved. `structure` has the same meaning as
    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
    */
    constructor(from4, to2, gapFrom, gapTo, slice2, insert, structure = false) {
      super();
      this.from = from4;
      this.to = to2;
      this.gapFrom = gapFrom;
      this.gapTo = gapTo;
      this.slice = slice2;
      this.insert = insert;
      this.structure = structure;
    }
    apply(doc4) {
      if (this.structure && (contentBetween(doc4, this.from, this.gapFrom) || contentBetween(doc4, this.gapTo, this.to)))
        return StepResult.fail("Structure gap-replace would overwrite content");
      let gap = doc4.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd)
        return StepResult.fail("Gap is not a flat range");
      let inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted)
        return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc4, this.from, this.to, inserted);
    }
    getMap() {
      return new StepMap([
        this.from,
        this.gapFrom - this.from,
        this.insert,
        this.gapTo,
        this.to - this.gapTo,
        this.slice.size - this.insert
      ]);
    }
    invert(doc4) {
      let gap = this.gapTo - this.gapFrom;
      return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc4.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
    map(mapping) {
      let from4 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
      let gapFrom = this.from == this.gapFrom ? from4.pos : mapping.map(this.gapFrom, -1);
      let gapTo = this.to == this.gapTo ? to2.pos : mapping.map(this.gapTo, 1);
      if (from4.deletedAcross && to2.deletedAcross || gapFrom < from4.pos || gapTo > to2.pos)
        return null;
      return new _ReplaceAroundStep(from4.pos, to2.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    }
    toJSON() {
      let json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size)
        json.slice = this.slice.toJSON();
      if (this.structure)
        json.structure = true;
      return json;
    }
    /**
    @internal
    */
    static fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
        throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
    }
  };
  Step.jsonID("replaceAround", ReplaceAroundStep);
  function contentBetween(doc4, from4, to2) {
    let $from = doc4.resolve(from4), dist = to2 - from4, depth = $from.depth;
    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
      depth--;
      dist--;
    }
    if (dist > 0) {
      let next2 = $from.node(depth).maybeChild($from.indexAfter(depth));
      while (dist > 0) {
        if (!next2 || next2.isLeaf)
          return true;
        next2 = next2.firstChild;
        dist--;
      }
    }
    return false;
  }
  function addMark(tr3, from4, to2, mark2) {
    let removed = [], added = [];
    let removing, adding;
    tr3.doc.nodesBetween(from4, to2, (node2, pos, parent) => {
      if (!node2.isInline)
        return;
      let marks = node2.marks;
      if (!mark2.isInSet(marks) && parent.type.allowsMarkType(mark2.type)) {
        let start = Math.max(pos, from4), end = Math.min(pos + node2.nodeSize, to2);
        let newSet = mark2.addToSet(marks);
        for (let i = 0; i < marks.length; i++) {
          if (!marks[i].isInSet(newSet)) {
            if (removing && removing.to == start && removing.mark.eq(marks[i]))
              removing.to = end;
            else
              removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
          }
        }
        if (adding && adding.to == start)
          adding.to = end;
        else
          added.push(adding = new AddMarkStep(start, end, mark2));
      }
    });
    removed.forEach((s2) => tr3.step(s2));
    added.forEach((s2) => tr3.step(s2));
  }
  function removeMark(tr3, from4, to2, mark2) {
    let matched = [], step = 0;
    tr3.doc.nodesBetween(from4, to2, (node2, pos) => {
      if (!node2.isInline)
        return;
      step++;
      let toRemove = null;
      if (mark2 instanceof MarkType) {
        let set2 = node2.marks, found2;
        while (found2 = mark2.isInSet(set2)) {
          (toRemove || (toRemove = [])).push(found2);
          set2 = found2.removeFromSet(set2);
        }
      } else if (mark2) {
        if (mark2.isInSet(node2.marks))
          toRemove = [mark2];
      } else {
        toRemove = node2.marks;
      }
      if (toRemove && toRemove.length) {
        let end = Math.min(pos + node2.nodeSize, to2);
        for (let i = 0; i < toRemove.length; i++) {
          let style3 = toRemove[i], found2;
          for (let j2 = 0; j2 < matched.length; j2++) {
            let m = matched[j2];
            if (m.step == step - 1 && style3.eq(matched[j2].style))
              found2 = m;
          }
          if (found2) {
            found2.to = end;
            found2.step = step;
          } else {
            matched.push({ style: style3, from: Math.max(pos, from4), to: end, step });
          }
        }
      }
    });
    matched.forEach((m) => tr3.step(new RemoveMarkStep(m.from, m.to, m.style)));
  }
  function clearIncompatible(tr3, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
    let node2 = tr3.doc.nodeAt(pos);
    let replSteps = [], cur = pos + 1;
    for (let i = 0; i < node2.childCount; i++) {
      let child = node2.child(i), end = cur + child.nodeSize;
      let allowed = match.matchType(child.type);
      if (!allowed) {
        replSteps.push(new ReplaceStep(cur, end, Slice.empty));
      } else {
        match = allowed;
        for (let j2 = 0; j2 < child.marks.length; j2++)
          if (!parentType.allowsMarkType(child.marks[j2].type))
            tr3.step(new RemoveMarkStep(cur, end, child.marks[j2]));
        if (clearNewlines && child.isText && parentType.whitespace != "pre") {
          let m, newline = /\r?\n|\r/g, slice2;
          while (m = newline.exec(child.text)) {
            if (!slice2)
              slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
            replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));
          }
        }
      }
      cur = end;
    }
    if (!match.validEnd) {
      let fill = match.fillBefore(Fragment.empty, true);
      tr3.replace(cur, cur, new Slice(fill, 0, 0));
    }
    for (let i = replSteps.length - 1; i >= 0; i--)
      tr3.step(replSteps[i]);
  }
  function canCut(node2, start, end) {
    return (start == 0 || node2.canReplace(start, node2.childCount)) && (end == node2.childCount || node2.canReplace(0, end));
  }
  function liftTarget(range) {
    let parent = range.parent;
    let content5 = parent.content.cutByIndex(range.startIndex, range.endIndex);
    for (let depth = range.depth; ; --depth) {
      let node2 = range.$from.node(depth);
      let index3 = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
      if (depth < range.depth && node2.canReplace(index3, endIndex, content5))
        return depth;
      if (depth == 0 || node2.type.spec.isolating || !canCut(node2, index3, endIndex))
        break;
    }
    return null;
  }
  function lift(tr3, range, target) {
    let { $from, $to, depth } = range;
    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
    let start = gapStart, end = gapEnd;
    let before = Fragment.empty, openStart = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $from.index(d) > 0) {
        splitting = true;
        before = Fragment.from($from.node(d).copy(before));
        openStart++;
      } else {
        start--;
      }
    let after = Fragment.empty, openEnd = 0;
    for (let d = depth, splitting = false; d > target; d--)
      if (splitting || $to.after(d + 1) < $to.end(d)) {
        splitting = true;
        after = Fragment.from($to.node(d).copy(after));
        openEnd++;
      } else {
        end++;
      }
    tr3.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
  }
  function findWrapping(range, nodeType, attrs = null, innerRange = range) {
    let around = findWrappingOutside(range, nodeType);
    let inner = around && findWrappingInside(innerRange, nodeType);
    if (!inner)
      return null;
    return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
  }
  function withAttrs(type) {
    return { type, attrs: null };
  }
  function findWrappingOutside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let around = parent.contentMatchAt(startIndex).findWrapping(type);
    if (!around)
      return null;
    let outer = around.length ? around[0] : type;
    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
  }
  function findWrappingInside(range, type) {
    let { parent, startIndex, endIndex } = range;
    let inner = parent.child(startIndex);
    let inside = type.contentMatch.findWrapping(inner.type);
    if (!inside)
      return null;
    let lastType = inside.length ? inside[inside.length - 1] : type;
    let innerMatch = lastType.contentMatch;
    for (let i = startIndex; innerMatch && i < endIndex; i++)
      innerMatch = innerMatch.matchType(parent.child(i).type);
    if (!innerMatch || !innerMatch.validEnd)
      return null;
    return inside;
  }
  function wrap4(tr3, range, wrappers) {
    let content5 = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--) {
      if (content5.size) {
        let match = wrappers[i].type.contentMatch.matchFragment(content5);
        if (!match || !match.validEnd)
          throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
      }
      content5 = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content5));
    }
    let start = range.start, end = range.end;
    tr3.step(new ReplaceAroundStep(start, end, start, end, new Slice(content5, 0, 0), wrappers.length, true));
  }
  function setBlockType(tr3, from4, to2, type, attrs) {
    if (!type.isTextblock)
      throw new RangeError("Type given to setBlockType should be a textblock");
    let mapFrom = tr3.steps.length;
    tr3.doc.nodesBetween(from4, to2, (node2, pos) => {
      let attrsHere = typeof attrs == "function" ? attrs(node2) : attrs;
      if (node2.isTextblock && !node2.hasMarkup(type, attrsHere) && canChangeType(tr3.doc, tr3.mapping.slice(mapFrom).map(pos), type)) {
        let convertNewlines = null;
        if (type.schema.linebreakReplacement) {
          let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
          if (pre && !supportLinebreak)
            convertNewlines = false;
          else if (!pre && supportLinebreak)
            convertNewlines = true;
        }
        if (convertNewlines === false)
          replaceLinebreaks(tr3, node2, pos, mapFrom);
        clearIncompatible(tr3, tr3.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
        let mapping = tr3.mapping.slice(mapFrom);
        let startM = mapping.map(pos, 1), endM = mapping.map(pos + node2.nodeSize, 1);
        tr3.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node2.marks)), 0, 0), 1, true));
        if (convertNewlines === true)
          replaceNewlines2(tr3, node2, pos, mapFrom);
        return false;
      }
    });
  }
  function replaceNewlines2(tr3, node2, pos, mapFrom) {
    node2.forEach((child, offset) => {
      if (child.isText) {
        let m, newline = /\r?\n|\r/g;
        while (m = newline.exec(child.text)) {
          let start = tr3.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);
          tr3.replaceWith(start, start + 1, node2.type.schema.linebreakReplacement.create());
        }
      }
    });
  }
  function replaceLinebreaks(tr3, node2, pos, mapFrom) {
    node2.forEach((child, offset) => {
      if (child.type == child.type.schema.linebreakReplacement) {
        let start = tr3.mapping.slice(mapFrom).map(pos + 1 + offset);
        tr3.replaceWith(start, start + 1, node2.type.schema.text("\n"));
      }
    });
  }
  function canChangeType(doc4, pos, type) {
    let $pos = doc4.resolve(pos), index3 = $pos.index();
    return $pos.parent.canReplaceWith(index3, index3 + 1, type);
  }
  function setNodeMarkup(tr3, pos, type, attrs, marks) {
    let node2 = tr3.doc.nodeAt(pos);
    if (!node2)
      throw new RangeError("No node at given position");
    if (!type)
      type = node2.type;
    let newNode = type.create(attrs, null, marks || node2.marks);
    if (node2.isLeaf)
      return tr3.replaceWith(pos, pos + node2.nodeSize, newNode);
    if (!type.validContent(node2.content))
      throw new RangeError("Invalid content for node type " + type.name);
    tr3.step(new ReplaceAroundStep(pos, pos + node2.nodeSize, pos + 1, pos + node2.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
  }
  function canSplit(doc4, pos, depth = 1, typesAfter) {
    let $pos = doc4.resolve(pos), base4 = $pos.depth - depth;
    let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
    if (base4 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
      return false;
    for (let d = $pos.depth - 1, i = depth - 2; d > base4; d--, i--) {
      let node2 = $pos.node(d), index4 = $pos.index(d);
      if (node2.type.spec.isolating)
        return false;
      let rest = node2.content.cutByIndex(index4, node2.childCount);
      let overrideChild = typesAfter && typesAfter[i + 1];
      if (overrideChild)
        rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
      let after = typesAfter && typesAfter[i] || node2;
      if (!node2.canReplace(index4 + 1, node2.childCount) || !after.type.validContent(rest))
        return false;
    }
    let index3 = $pos.indexAfter(base4);
    let baseType = typesAfter && typesAfter[0];
    return $pos.node(base4).canReplaceWith(index3, index3, baseType ? baseType.type : $pos.node(base4 + 1).type);
  }
  function split2(tr3, pos, depth = 1, typesAfter) {
    let $pos = tr3.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
      before = Fragment.from($pos.node(d).copy(before));
      let typeAfter = typesAfter && typesAfter[i];
      after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
    }
    tr3.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
  }
  function canJoin(doc4, pos) {
    let $pos = doc4.resolve(pos), index3 = $pos.index();
    return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index3, index3 + 1);
  }
  function canAppendWithSubstitutedLinebreaks(a2, b) {
    if (!b.content.size)
      a2.type.compatibleContent(b.type);
    let match = a2.contentMatchAt(a2.childCount);
    let { linebreakReplacement } = a2.type.schema;
    for (let i = 0; i < b.childCount; i++) {
      let child = b.child(i);
      let type = child.type == linebreakReplacement ? a2.type.schema.nodes.text : child.type;
      match = match.matchType(type);
      if (!match)
        return false;
      if (!a2.type.allowsMarks(child.marks))
        return false;
    }
    return match.validEnd;
  }
  function joinable2(a2, b) {
    return !!(a2 && b && !a2.isLeaf && canAppendWithSubstitutedLinebreaks(a2, b));
  }
  function joinPoint(doc4, pos, dir = -1) {
    let $pos = doc4.resolve(pos);
    for (let d = $pos.depth; ; d--) {
      let before, after, index3 = $pos.index(d);
      if (d == $pos.depth) {
        before = $pos.nodeBefore;
        after = $pos.nodeAfter;
      } else if (dir > 0) {
        before = $pos.node(d + 1);
        index3++;
        after = $pos.node(d).maybeChild(index3);
      } else {
        before = $pos.node(d).maybeChild(index3 - 1);
        after = $pos.node(d + 1);
      }
      if (before && !before.isTextblock && joinable2(before, after) && $pos.node(d).canReplace(index3, index3 + 1))
        return pos;
      if (d == 0)
        break;
      pos = dir < 0 ? $pos.before(d) : $pos.after(d);
    }
  }
  function join3(tr3, pos, depth) {
    let convertNewlines = null;
    let { linebreakReplacement } = tr3.doc.type.schema;
    let $before = tr3.doc.resolve(pos - depth), beforeType = $before.node().type;
    if (linebreakReplacement && beforeType.inlineContent) {
      let pre = beforeType.whitespace == "pre";
      let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
      if (pre && !supportLinebreak)
        convertNewlines = false;
      else if (!pre && supportLinebreak)
        convertNewlines = true;
    }
    let mapFrom = tr3.steps.length;
    if (convertNewlines === false) {
      let $after = tr3.doc.resolve(pos + depth);
      replaceLinebreaks(tr3, $after.node(), $after.before(), mapFrom);
    }
    if (beforeType.inlineContent)
      clearIncompatible(tr3, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
    let mapping = tr3.mapping.slice(mapFrom), start = mapping.map(pos - depth);
    tr3.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
    if (convertNewlines === true) {
      let $full = tr3.doc.resolve(start);
      replaceNewlines2(tr3, $full.node(), $full.before(), tr3.steps.length);
    }
    return tr3;
  }
  function insertPoint(doc4, pos, nodeType) {
    let $pos = doc4.resolve(pos);
    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
      return pos;
    if ($pos.parentOffset == 0)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index3 = $pos.index(d);
        if ($pos.node(d).canReplaceWith(index3, index3, nodeType))
          return $pos.before(d + 1);
        if (index3 > 0)
          return null;
      }
    if ($pos.parentOffset == $pos.parent.content.size)
      for (let d = $pos.depth - 1; d >= 0; d--) {
        let index3 = $pos.indexAfter(d);
        if ($pos.node(d).canReplaceWith(index3, index3, nodeType))
          return $pos.after(d + 1);
        if (index3 < $pos.node(d).childCount)
          return null;
      }
    return null;
  }
  function dropPoint(doc4, pos, slice2) {
    let $pos = doc4.resolve(pos);
    if (!slice2.content.size)
      return pos;
    let content5 = slice2.content;
    for (let i = 0; i < slice2.openStart; i++)
      content5 = content5.firstChild.content;
    for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
      for (let d = $pos.depth; d >= 0; d--) {
        let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
        let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
        let parent = $pos.node(d), fits = false;
        if (pass == 1) {
          fits = parent.canReplace(insertPos, insertPos, content5);
        } else {
          let wrapping = parent.contentMatchAt(insertPos).findWrapping(content5.firstChild.type);
          fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
        }
        if (fits)
          return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
      }
    }
    return null;
  }
  function replaceStep(doc4, from4, to2 = from4, slice2 = Slice.empty) {
    if (from4 == to2 && !slice2.size)
      return null;
    let $from = doc4.resolve(from4), $to = doc4.resolve(to2);
    if (fitsTrivially($from, $to, slice2))
      return new ReplaceStep(from4, to2, slice2);
    return new Fitter($from, $to, slice2).fit();
  }
  function fitsTrivially($from, $to, slice2) {
    return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
  }
  var Fitter = class {
    constructor($from, $to, unplaced) {
      this.$from = $from;
      this.$to = $to;
      this.unplaced = unplaced;
      this.frontier = [];
      this.placed = Fragment.empty;
      for (let i = 0; i <= $from.depth; i++) {
        let node2 = $from.node(i);
        this.frontier.push({
          type: node2.type,
          match: node2.contentMatchAt($from.indexAfter(i))
        });
      }
      for (let i = $from.depth; i > 0; i--)
        this.placed = Fragment.from($from.node(i).copy(this.placed));
    }
    get depth() {
      return this.frontier.length - 1;
    }
    fit() {
      while (this.unplaced.size) {
        let fit = this.findFittable();
        if (fit)
          this.placeNodes(fit);
        else
          this.openMore() || this.dropNode();
      }
      let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
      let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to)
        return null;
      let content5 = this.placed, openStart = $from.depth, openEnd = $to.depth;
      while (openStart && openEnd && content5.childCount == 1) {
        content5 = content5.firstChild.content;
        openStart--;
        openEnd--;
      }
      let slice2 = new Slice(content5, openStart, openEnd);
      if (moveInline > -1)
        return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
      if (slice2.size || $from.pos != this.$to.pos)
        return new ReplaceStep($from.pos, $to.pos, slice2);
      return null;
    }
    // Find a position on the start spine of `this.unplaced` that has
    // content that can be moved somewhere on the frontier. Returns two
    // depths, one for the slice and one for the frontier.
    findFittable() {
      let startDepth = this.unplaced.openStart;
      for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
        let node2 = cur.firstChild;
        if (cur.childCount > 1)
          openEnd = 0;
        if (node2.type.spec.isolating && openEnd <= d) {
          startDepth = d;
          break;
        }
        cur = node2.content;
      }
      for (let pass = 1; pass <= 2; pass++) {
        for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          let fragment2, parent = null;
          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment2 = parent.content;
          } else {
            fragment2 = this.unplaced.content;
          }
          let first3 = fragment2.firstChild;
          for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            let { type, match } = this.frontier[frontierDepth], wrap5, inject = null;
            if (pass == 1 && (first3 ? match.matchType(first3.type) || (inject = match.fillBefore(Fragment.from(first3), false)) : parent && type.compatibleContent(parent.type)))
              return { sliceDepth, frontierDepth, parent, inject };
            else if (pass == 2 && first3 && (wrap5 = match.findWrapping(first3.type)))
              return { sliceDepth, frontierDepth, parent, wrap: wrap5 };
            if (parent && match.matchType(parent.type))
              break;
          }
        }
      }
    }
    openMore() {
      let { content: content5, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content5, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf)
        return false;
      this.unplaced = new Slice(content5, openStart + 1, Math.max(openEnd, inner.size + openStart >= content5.size - openEnd ? openStart + 1 : 0));
      return true;
    }
    dropNode() {
      let { content: content5, openStart, openEnd } = this.unplaced;
      let inner = contentAt(content5, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        let openAtEnd = content5.size - openStart <= openStart + inner.size;
        this.unplaced = new Slice(dropFromFragment(content5, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new Slice(dropFromFragment(content5, openStart, 1), openStart, openEnd);
      }
    }
    // Move content from the unplaced slice at `sliceDepth` to the
    // frontier node at `frontierDepth`. Close that frontier node when
    // applicable.
    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap5 }) {
      while (this.depth > frontierDepth)
        this.closeFrontierNode();
      if (wrap5)
        for (let i = 0; i < wrap5.length; i++)
          this.openFrontierNode(wrap5[i]);
      let slice2 = this.unplaced, fragment2 = parent ? parent.content : slice2.content;
      let openStart = slice2.openStart - sliceDepth;
      let taken = 0, add3 = [];
      let { match, type } = this.frontier[frontierDepth];
      if (inject) {
        for (let i = 0; i < inject.childCount; i++)
          add3.push(inject.child(i));
        match = match.matchFragment(inject);
      }
      let openEndCount = fragment2.size + sliceDepth - (slice2.content.size - slice2.openEnd);
      while (taken < fragment2.childCount) {
        let next2 = fragment2.child(taken), matches2 = match.matchType(next2.type);
        if (!matches2)
          break;
        taken++;
        if (taken > 1 || openStart == 0 || next2.content.size) {
          match = matches2;
          add3.push(closeNodeStart(next2.mark(type.allowedMarks(next2.marks)), taken == 1 ? openStart : 0, taken == fragment2.childCount ? openEndCount : -1));
        }
      }
      let toEnd = taken == fragment2.childCount;
      if (!toEnd)
        openEndCount = -1;
      this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add3));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
        this.closeFrontierNode();
      for (let i = 0, cur = fragment2; i < openEndCount; i++) {
        let node2 = cur.lastChild;
        this.frontier.push({ type: node2.type, match: node2.contentMatchAt(node2.childCount) });
        cur = node2.content;
      }
      this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
    }
    mustMoveInline() {
      if (!this.$to.parent.isTextblock)
        return -1;
      let top = this.frontier[this.depth], level;
      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
        return -1;
      let { depth } = this.$to, after = this.$to.after(depth);
      while (depth > 1 && after == this.$to.end(--depth))
        ++after;
      return after;
    }
    findCloseLevel($to) {
      scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        let { match, type } = this.frontier[i];
        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        let fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit)
          continue;
        for (let d = i - 1; d >= 0; d--) {
          let { match: match2, type: type2 } = this.frontier[d];
          let matches2 = contentAfterFits($to, d, type2, match2, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
    }
    close($to) {
      let close2 = this.findCloseLevel($to);
      if (!close2)
        return null;
      while (this.depth > close2.depth)
        this.closeFrontierNode();
      if (close2.fit.childCount)
        this.placed = addToFragment(this.placed, close2.depth, close2.fit);
      $to = close2.move;
      for (let d = close2.depth + 1; d <= $to.depth; d++) {
        let node2 = $to.node(d), add3 = node2.type.contentMatch.fillBefore(node2.content, true, $to.index(d));
        this.openFrontierNode(node2.type, node2.attrs, add3);
      }
      return $to;
    }
    openFrontierNode(type, attrs = null, content5) {
      let top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content5)));
      this.frontier.push({ type, match: type.contentMatch });
    }
    closeFrontierNode() {
      let open = this.frontier.pop();
      let add3 = open.match.fillBefore(Fragment.empty, true);
      if (add3.childCount)
        this.placed = addToFragment(this.placed, this.frontier.length, add3);
    }
  };
  function dropFromFragment(fragment2, depth, count) {
    if (depth == 0)
      return fragment2.cutByIndex(count, fragment2.childCount);
    return fragment2.replaceChild(0, fragment2.firstChild.copy(dropFromFragment(fragment2.firstChild.content, depth - 1, count)));
  }
  function addToFragment(fragment2, depth, content5) {
    if (depth == 0)
      return fragment2.append(content5);
    return fragment2.replaceChild(fragment2.childCount - 1, fragment2.lastChild.copy(addToFragment(fragment2.lastChild.content, depth - 1, content5)));
  }
  function contentAt(fragment2, depth) {
    for (let i = 0; i < depth; i++)
      fragment2 = fragment2.firstChild.content;
    return fragment2;
  }
  function closeNodeStart(node2, openStart, openEnd) {
    if (openStart <= 0)
      return node2;
    let frag = node2.content;
    if (openStart > 1)
      frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
    if (openStart > 0) {
      frag = node2.type.contentMatch.fillBefore(frag).append(frag);
      if (openEnd <= 0)
        frag = frag.append(node2.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
    return node2.copy(frag);
  }
  function contentAfterFits($to, depth, type, match, open) {
    let node2 = $to.node(depth), index3 = open ? $to.indexAfter(depth) : $to.index(depth);
    if (index3 == node2.childCount && !type.compatibleContent(node2.type))
      return null;
    let fit = match.fillBefore(node2.content, true, index3);
    return fit && !invalidMarks(type, node2.content, index3) ? fit : null;
  }
  function invalidMarks(type, fragment2, start) {
    for (let i = start; i < fragment2.childCount; i++)
      if (!type.allowsMarks(fragment2.child(i).marks))
        return true;
    return false;
  }
  function definesContent(type) {
    return type.spec.defining || type.spec.definingForContent;
  }
  function replaceRange(tr3, from4, to2, slice2) {
    if (!slice2.size)
      return tr3.deleteRange(from4, to2);
    let $from = tr3.doc.resolve(from4), $to = tr3.doc.resolve(to2);
    if (fitsTrivially($from, $to, slice2))
      return tr3.step(new ReplaceStep(from4, to2, slice2));
    let targetDepths = coveredDepths($from, tr3.doc.resolve(to2));
    if (targetDepths[targetDepths.length - 1] == 0)
      targetDepths.pop();
    let preferredTarget = -($from.depth + 1);
    targetDepths.unshift(preferredTarget);
    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
      let spec = $from.node(d).type.spec;
      if (spec.defining || spec.definingAsContext || spec.isolating)
        break;
      if (targetDepths.indexOf(d) > -1)
        preferredTarget = d;
      else if ($from.before(d) == pos)
        targetDepths.splice(1, 0, -d);
    }
    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
    let leftNodes = [], preferredDepth = slice2.openStart;
    for (let content5 = slice2.content, i = 0; ; i++) {
      let node2 = content5.firstChild;
      leftNodes.push(node2);
      if (i == slice2.openStart)
        break;
      content5 = node2.content;
    }
    for (let d = preferredDepth - 1; d >= 0; d--) {
      let leftNode = leftNodes[d], def = definesContent(leftNode.type);
      if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
        preferredDepth = d;
      else if (def || !leftNode.type.isTextblock)
        break;
    }
    for (let j2 = slice2.openStart; j2 >= 0; j2--) {
      let openDepth = (j2 + preferredDepth + 1) % (slice2.openStart + 1);
      let insert = leftNodes[openDepth];
      if (!insert)
        continue;
      for (let i = 0; i < targetDepths.length; i++) {
        let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
        if (targetDepth < 0) {
          expand = false;
          targetDepth = -targetDepth;
        }
        let parent = $from.node(targetDepth - 1), index3 = $from.index(targetDepth - 1);
        if (parent.canReplaceWith(index3, index3, insert.type, insert.marks))
          return tr3.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to2, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
      }
    }
    let startSteps = tr3.steps.length;
    for (let i = targetDepths.length - 1; i >= 0; i--) {
      tr3.replace(from4, to2, slice2);
      if (tr3.steps.length > startSteps)
        break;
      let depth = targetDepths[i];
      if (depth < 0)
        continue;
      from4 = $from.before(depth);
      to2 = $to.after(depth);
    }
  }
  function closeFragment(fragment2, depth, oldOpen, newOpen, parent) {
    if (depth < oldOpen) {
      let first3 = fragment2.firstChild;
      fragment2 = fragment2.replaceChild(0, first3.copy(closeFragment(first3.content, depth + 1, oldOpen, newOpen, first3)));
    }
    if (depth > newOpen) {
      let match = parent.contentMatchAt(0);
      let start = match.fillBefore(fragment2).append(fragment2);
      fragment2 = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
    }
    return fragment2;
  }
  function replaceRangeWith(tr3, from4, to2, node2) {
    if (!node2.isInline && from4 == to2 && tr3.doc.resolve(from4).parent.content.size) {
      let point5 = insertPoint(tr3.doc, from4, node2.type);
      if (point5 != null)
        from4 = to2 = point5;
    }
    tr3.replaceRange(from4, to2, new Slice(Fragment.from(node2), 0, 0));
  }
  function deleteRange(tr3, from4, to2) {
    let $from = tr3.doc.resolve(from4), $to = tr3.doc.resolve(to2);
    let covered = coveredDepths($from, $to);
    for (let i = 0; i < covered.length; i++) {
      let depth = covered[i], last2 = i == covered.length - 1;
      if (last2 && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
        return tr3.delete($from.start(depth), $to.end(depth));
      if (depth > 0 && (last2 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
        return tr3.delete($from.before(depth), $to.after(depth));
    }
    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
      if (from4 - $from.start(d) == $from.depth - d && to2 > $from.end(d) && $to.end(d) - to2 != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
        return tr3.delete($from.before(d), to2);
    }
    tr3.delete(from4, to2);
  }
  function coveredDepths($from, $to) {
    let result = [], minDepth = Math.min($from.depth, $to.depth);
    for (let d = minDepth; d >= 0; d--) {
      let start = $from.start(d);
      if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
        break;
      if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
        result.push(d);
    }
    return result;
  }
  var AttrStep = class _AttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(pos, attr, value) {
      super();
      this.pos = pos;
      this.attr = attr;
      this.value = value;
    }
    apply(doc4) {
      let node2 = doc4.nodeAt(this.pos);
      if (!node2)
        return StepResult.fail("No node at attribute step's position");
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in node2.attrs)
        attrs[name] = node2.attrs[name];
      attrs[this.attr] = this.value;
      let updated = node2.type.create(attrs, null, node2.marks);
      return StepResult.fromReplace(doc4, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc4) {
      return new _AttrStep(this.pos, this.attr, doc4.nodeAt(this.pos).attrs[this.attr]);
    }
    map(mapping) {
      let pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);
    }
    toJSON() {
      return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
    }
    static fromJSON(schema, json) {
      if (typeof json.pos != "number" || typeof json.attr != "string")
        throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new _AttrStep(json.pos, json.attr, json.value);
    }
  };
  Step.jsonID("attr", AttrStep);
  var DocAttrStep = class _DocAttrStep extends Step {
    /**
    Construct an attribute step.
    */
    constructor(attr, value) {
      super();
      this.attr = attr;
      this.value = value;
    }
    apply(doc4) {
      let attrs = /* @__PURE__ */ Object.create(null);
      for (let name in doc4.attrs)
        attrs[name] = doc4.attrs[name];
      attrs[this.attr] = this.value;
      let updated = doc4.type.create(attrs, doc4.content, doc4.marks);
      return StepResult.ok(updated);
    }
    getMap() {
      return StepMap.empty;
    }
    invert(doc4) {
      return new _DocAttrStep(this.attr, doc4.attrs[this.attr]);
    }
    map(mapping) {
      return this;
    }
    toJSON() {
      return { stepType: "docAttr", attr: this.attr, value: this.value };
    }
    static fromJSON(schema, json) {
      if (typeof json.attr != "string")
        throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new _DocAttrStep(json.attr, json.value);
    }
  };
  Step.jsonID("docAttr", DocAttrStep);
  var TransformError = class extends Error {
  };
  TransformError = function TransformError2(message) {
    let err = Error.call(this, message);
    err.__proto__ = TransformError2.prototype;
    return err;
  };
  TransformError.prototype = Object.create(Error.prototype);
  TransformError.prototype.constructor = TransformError;
  TransformError.prototype.name = "TransformError";
  var Transform = class {
    /**
    Create a transform that starts with the given document.
    */
    constructor(doc4) {
      this.doc = doc4;
      this.steps = [];
      this.docs = [];
      this.mapping = new Mapping();
    }
    /**
    The starting document.
    */
    get before() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
    /**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */
    step(step) {
      let result = this.maybeStep(step);
      if (result.failed)
        throw new TransformError(result.failed);
      return this;
    }
    /**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */
    maybeStep(step) {
      let result = step.apply(this.doc);
      if (!result.failed)
        this.addStep(step, result.doc);
      return result;
    }
    /**
    True when the document has been changed (when there are any
    steps).
    */
    get docChanged() {
      return this.steps.length > 0;
    }
    /**
    @internal
    */
    addStep(step, doc4) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc4;
    }
    /**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */
    replace(from4, to2 = from4, slice2 = Slice.empty) {
      let step = replaceStep(this.doc, from4, to2, slice2);
      if (step)
        this.step(step);
      return this;
    }
    /**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */
    replaceWith(from4, to2, content5) {
      return this.replace(from4, to2, new Slice(Fragment.from(content5), 0, 0));
    }
    /**
    Delete the content between the given positions.
    */
    delete(from4, to2) {
      return this.replace(from4, to2, Slice.empty);
    }
    /**
    Insert the given content at the given position.
    */
    insert(pos, content5) {
      return this.replaceWith(pos, pos, content5);
    }
    /**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */
    replaceRange(from4, to2, slice2) {
      replaceRange(this, from4, to2, slice2);
      return this;
    }
    /**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */
    replaceRangeWith(from4, to2, node2) {
      replaceRangeWith(this, from4, to2, node2);
      return this;
    }
    /**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */
    deleteRange(from4, to2) {
      deleteRange(this, from4, to2);
      return this;
    }
    /**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */
    lift(range, target) {
      lift(this, range, target);
      return this;
    }
    /**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */
    join(pos, depth = 1) {
      join3(this, pos, depth);
      return this;
    }
    /**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */
    wrap(range, wrappers) {
      wrap4(this, range, wrappers);
      return this;
    }
    /**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */
    setBlockType(from4, to2 = from4, type, attrs = null) {
      setBlockType(this, from4, to2, type, attrs);
      return this;
    }
    /**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */
    setNodeMarkup(pos, type, attrs = null, marks) {
      setNodeMarkup(this, pos, type, attrs, marks);
      return this;
    }
    /**
    Set a single attribute on a given node to a new value.
    The `pos` addresses the document content. Use `setDocAttribute`
    to set attributes on the document itself.
    */
    setNodeAttribute(pos, attr, value) {
      this.step(new AttrStep(pos, attr, value));
      return this;
    }
    /**
    Set a single attribute on the document to a new value.
    */
    setDocAttribute(attr, value) {
      this.step(new DocAttrStep(attr, value));
      return this;
    }
    /**
    Add a mark to the node at position `pos`.
    */
    addNodeMark(pos, mark2) {
      this.step(new AddNodeMarkStep(pos, mark2));
      return this;
    }
    /**
    Remove a mark (or all marks of the given type) from the node at
    position `pos`.
    */
    removeNodeMark(pos, mark2) {
      let node2 = this.doc.nodeAt(pos);
      if (!node2)
        throw new RangeError("No node at position " + pos);
      if (mark2 instanceof Mark) {
        if (mark2.isInSet(node2.marks))
          this.step(new RemoveNodeMarkStep(pos, mark2));
      } else {
        let set2 = node2.marks, found2, steps = [];
        while (found2 = mark2.isInSet(set2)) {
          steps.push(new RemoveNodeMarkStep(pos, found2));
          set2 = found2.removeFromSet(set2);
        }
        for (let i = steps.length - 1; i >= 0; i--)
          this.step(steps[i]);
      }
      return this;
    }
    /**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split (with the outermost nodes coming first).
    */
    split(pos, depth = 1, typesAfter) {
      split2(this, pos, depth, typesAfter);
      return this;
    }
    /**
    Add the given mark to the inline content between `from` and `to`.
    */
    addMark(from4, to2, mark2) {
      addMark(this, from4, to2, mark2);
      return this;
    }
    /**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */
    removeMark(from4, to2, mark2) {
      removeMark(this, from4, to2, mark2);
      return this;
    }
    /**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */
    clearIncompatible(pos, parentType, match) {
      clearIncompatible(this, pos, parentType, match);
      return this;
    }
  };

  // node_modules/prosemirror-state/dist/index.js
  var classesById = /* @__PURE__ */ Object.create(null);
  var Selection = class {
    /**
    Initialize a selection with the head and anchor and ranges. If no
    ranges are given, constructs a single range across `$anchor` and
    `$head`.
    */
    constructor($anchor, $head, ranges) {
      this.$anchor = $anchor;
      this.$head = $head;
      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
    }
    /**
    The selection's anchor, as an unresolved position.
    */
    get anchor() {
      return this.$anchor.pos;
    }
    /**
    The selection's head.
    */
    get head() {
      return this.$head.pos;
    }
    /**
    The lower bound of the selection's main range.
    */
    get from() {
      return this.$from.pos;
    }
    /**
    The upper bound of the selection's main range.
    */
    get to() {
      return this.$to.pos;
    }
    /**
    The resolved lower  bound of the selection's main range.
    */
    get $from() {
      return this.ranges[0].$from;
    }
    /**
    The resolved upper bound of the selection's main range.
    */
    get $to() {
      return this.ranges[0].$to;
    }
    /**
    Indicates whether the selection contains any content.
    */
    get empty() {
      let ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++)
        if (ranges[i].$from.pos != ranges[i].$to.pos)
          return false;
      return true;
    }
    /**
    Get the content of this selection as a slice.
    */
    content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
    /**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */
    replace(tr3, content5 = Slice.empty) {
      let lastNode = content5.content.lastChild, lastParent = null;
      for (let i = 0; i < content5.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }
      let mapFrom = tr3.steps.length, ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i], mapping = tr3.mapping.slice(mapFrom);
        tr3.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content5);
        if (i == 0)
          selectionToInsertionEnd(tr3, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
    /**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */
    replaceWith(tr3, node2) {
      let mapFrom = tr3.steps.length, ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++) {
        let { $from, $to } = ranges[i], mapping = tr3.mapping.slice(mapFrom);
        let from4 = mapping.map($from.pos), to2 = mapping.map($to.pos);
        if (i) {
          tr3.deleteRange(from4, to2);
        } else {
          tr3.replaceRangeWith(from4, to2, node2);
          selectionToInsertionEnd(tr3, mapFrom, node2.isInline ? -1 : 1);
        }
      }
    }
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
    static findFrom($pos, dir, textOnly = false) {
      let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner)
        return inner;
      for (let depth = $pos.depth - 1; depth >= 0; depth--) {
        let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found2)
          return found2;
      }
      return null;
    }
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
    static near($pos, bias = 1) {
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    }
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
    static atStart(doc4) {
      return findSelectionIn(doc4, doc4, 0, 0, 1) || new AllSelection(doc4);
    }
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
    static atEnd(doc4) {
      return findSelectionIn(doc4, doc4, doc4.content.size, doc4.childCount, -1) || new AllSelection(doc4);
    }
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
    static fromJSON(doc4, json) {
      if (!json || !json.type)
        throw new RangeError("Invalid input for Selection.fromJSON");
      let cls = classesById[json.type];
      if (!cls)
        throw new RangeError(`No selection type ${json.type} defined`);
      return cls.fromJSON(doc4, json);
    }
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
    static jsonID(id2, selectionClass) {
      if (id2 in classesById)
        throw new RangeError("Duplicate use of selection JSON ID " + id2);
      classesById[id2] = selectionClass;
      selectionClass.prototype.jsonID = id2;
      return selectionClass;
    }
    /**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */
    getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
  };
  Selection.prototype.visible = true;
  var SelectionRange = class {
    /**
    Create a range.
    */
    constructor($from, $to) {
      this.$from = $from;
      this.$to = $to;
    }
  };
  var warnedAboutTextSelection = false;
  function checkTextSelection($pos) {
    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
      warnedAboutTextSelection = true;
      console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
    }
  }
  var TextSelection = class _TextSelection extends Selection {
    /**
    Construct a text selection between the given points.
    */
    constructor($anchor, $head = $anchor) {
      checkTextSelection($anchor);
      checkTextSelection($head);
      super($anchor, $head);
    }
    /**
    Returns a resolved position if this is a cursor selection (an
    empty text selection), and null otherwise.
    */
    get $cursor() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
    map(doc4, mapping) {
      let $head = doc4.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent)
        return Selection.near($head);
      let $anchor = doc4.resolve(mapping.map(this.anchor));
      return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    }
    replace(tr3, content5 = Slice.empty) {
      super.replace(tr3, content5);
      if (content5 == Slice.empty) {
        let marks = this.$from.marksAcross(this.$to);
        if (marks)
          tr3.ensureMarks(marks);
      }
    }
    eq(other) {
      return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;
    }
    getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    }
    toJSON() {
      return { type: "text", anchor: this.anchor, head: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc4, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new _TextSelection(doc4.resolve(json.anchor), doc4.resolve(json.head));
    }
    /**
    Create a text selection from non-resolved positions.
    */
    static create(doc4, anchor, head2 = anchor) {
      let $anchor = doc4.resolve(anchor);
      return new this($anchor, head2 == anchor ? $anchor : doc4.resolve(head2));
    }
    /**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */
    static between($anchor, $head, bias) {
      let dPos = $anchor.pos - $head.pos;
      if (!bias || dPos)
        bias = dPos >= 0 ? 1 : -1;
      if (!$head.parent.inlineContent) {
        let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
        if (found2)
          $head = found2.$head;
        else
          return Selection.near($head, bias);
      }
      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0)
            $anchor = $head;
        }
      }
      return new _TextSelection($anchor, $head);
    }
  };
  Selection.jsonID("text", TextSelection);
  var TextBookmark = class _TextBookmark {
    constructor(anchor, head2) {
      this.anchor = anchor;
      this.head = head2;
    }
    map(mapping) {
      return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
    resolve(doc4) {
      return TextSelection.between(doc4.resolve(this.anchor), doc4.resolve(this.head));
    }
  };
  var NodeSelection = class _NodeSelection extends Selection {
    /**
    Create a node selection. Does not verify the validity of its
    argument.
    */
    constructor($pos) {
      let node2 = $pos.nodeAfter;
      let $end = $pos.node(0).resolve($pos.pos + node2.nodeSize);
      super($pos, $end);
      this.node = node2;
    }
    map(doc4, mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      let $pos = doc4.resolve(pos);
      if (deleted)
        return Selection.near($pos);
      return new _NodeSelection($pos);
    }
    content() {
      return new Slice(Fragment.from(this.node), 0, 0);
    }
    eq(other) {
      return other instanceof _NodeSelection && other.anchor == this.anchor;
    }
    toJSON() {
      return { type: "node", anchor: this.anchor };
    }
    getBookmark() {
      return new NodeBookmark(this.anchor);
    }
    /**
    @internal
    */
    static fromJSON(doc4, json) {
      if (typeof json.anchor != "number")
        throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new _NodeSelection(doc4.resolve(json.anchor));
    }
    /**
    Create a node selection from non-resolved positions.
    */
    static create(doc4, from4) {
      return new _NodeSelection(doc4.resolve(from4));
    }
    /**
    Determines whether the given node may be selected as a node
    selection.
    */
    static isSelectable(node2) {
      return !node2.isText && node2.type.spec.selectable !== false;
    }
  };
  NodeSelection.prototype.visible = false;
  Selection.jsonID("node", NodeSelection);
  var NodeBookmark = class _NodeBookmark {
    constructor(anchor) {
      this.anchor = anchor;
    }
    map(mapping) {
      let { deleted, pos } = mapping.mapResult(this.anchor);
      return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);
    }
    resolve(doc4) {
      let $pos = doc4.resolve(this.anchor), node2 = $pos.nodeAfter;
      if (node2 && NodeSelection.isSelectable(node2))
        return new NodeSelection($pos);
      return Selection.near($pos);
    }
  };
  var AllSelection = class _AllSelection extends Selection {
    /**
    Create an all-selection over the given document.
    */
    constructor(doc4) {
      super(doc4.resolve(0), doc4.resolve(doc4.content.size));
    }
    replace(tr3, content5 = Slice.empty) {
      if (content5 == Slice.empty) {
        tr3.delete(0, tr3.doc.content.size);
        let sel = Selection.atStart(tr3.doc);
        if (!sel.eq(tr3.selection))
          tr3.setSelection(sel);
      } else {
        super.replace(tr3, content5);
      }
    }
    toJSON() {
      return { type: "all" };
    }
    /**
    @internal
    */
    static fromJSON(doc4) {
      return new _AllSelection(doc4);
    }
    map(doc4) {
      return new _AllSelection(doc4);
    }
    eq(other) {
      return other instanceof _AllSelection;
    }
    getBookmark() {
      return AllBookmark;
    }
  };
  Selection.jsonID("all", AllSelection);
  var AllBookmark = {
    map() {
      return this;
    },
    resolve(doc4) {
      return new AllSelection(doc4);
    }
  };
  function findSelectionIn(doc4, node2, pos, index3, dir, text10 = false) {
    if (node2.inlineContent)
      return TextSelection.create(doc4, pos);
    for (let i = index3 - (dir > 0 ? 0 : 1); dir > 0 ? i < node2.childCount : i >= 0; i += dir) {
      let child = node2.child(i);
      if (!child.isAtom) {
        let inner = findSelectionIn(doc4, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text10);
        if (inner)
          return inner;
      } else if (!text10 && NodeSelection.isSelectable(child)) {
        return NodeSelection.create(doc4, pos - (dir < 0 ? child.nodeSize : 0));
      }
      pos += child.nodeSize * dir;
    }
    return null;
  }
  function selectionToInsertionEnd(tr3, startLen, bias) {
    let last2 = tr3.steps.length - 1;
    if (last2 < startLen)
      return;
    let step = tr3.steps[last2];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
      return;
    let map9 = tr3.mapping.maps[last2], end;
    map9.forEach((_from, _to, _newFrom, newTo) => {
      if (end == null)
        end = newTo;
    });
    tr3.setSelection(Selection.near(tr3.doc.resolve(end), bias));
  }
  var UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
  var Transaction = class extends Transform {
    /**
    @internal
    */
    constructor(state) {
      super(state.doc);
      this.curSelectionFor = 0;
      this.updated = 0;
      this.meta = /* @__PURE__ */ Object.create(null);
      this.time = Date.now();
      this.curSelection = state.selection;
      this.storedMarks = state.storedMarks;
    }
    /**
    The transaction's current selection. This defaults to the editor
    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
    transaction, but can be overwritten with
    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
    */
    get selection() {
      if (this.curSelectionFor < this.steps.length) {
        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
        this.curSelectionFor = this.steps.length;
      }
      return this.curSelection;
    }
    /**
    Update the transaction's current selection. Will determine the
    selection that the editor gets when the transaction is applied.
    */
    setSelection(selection) {
      if (selection.$from.doc != this.doc)
        throw new RangeError("Selection passed to setSelection must point at the current document");
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
      this.storedMarks = null;
      return this;
    }
    /**
    Whether the selection was explicitly updated by this transaction.
    */
    get selectionSet() {
      return (this.updated & UPDATED_SEL) > 0;
    }
    /**
    Set the current stored marks.
    */
    setStoredMarks(marks) {
      this.storedMarks = marks;
      this.updated |= UPDATED_MARKS;
      return this;
    }
    /**
    Make sure the current stored marks or, if that is null, the marks
    at the selection, match the given set of marks. Does nothing if
    this is already the case.
    */
    ensureMarks(marks) {
      if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
        this.setStoredMarks(marks);
      return this;
    }
    /**
    Add a mark to the set of stored marks.
    */
    addStoredMark(mark2) {
      return this.ensureMarks(mark2.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Remove a mark or mark type from the set of stored marks.
    */
    removeStoredMark(mark2) {
      return this.ensureMarks(mark2.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Whether the stored marks were explicitly set for this transaction.
    */
    get storedMarksSet() {
      return (this.updated & UPDATED_MARKS) > 0;
    }
    /**
    @internal
    */
    addStep(step, doc4) {
      super.addStep(step, doc4);
      this.updated = this.updated & ~UPDATED_MARKS;
      this.storedMarks = null;
    }
    /**
    Update the timestamp for the transaction.
    */
    setTime(time) {
      this.time = time;
      return this;
    }
    /**
    Replace the current selection with the given slice.
    */
    replaceSelection(slice2) {
      this.selection.replace(this, slice2);
      return this;
    }
    /**
    Replace the selection with the given node. When `inheritMarks` is
    true and the content is inline, it inherits the marks from the
    place where it is inserted.
    */
    replaceSelectionWith(node2, inheritMarks = true) {
      let selection = this.selection;
      if (inheritMarks)
        node2 = node2.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
      selection.replaceWith(this, node2);
      return this;
    }
    /**
    Delete the selection.
    */
    deleteSelection() {
      this.selection.replace(this);
      return this;
    }
    /**
    Replace the given range, or the selection if no range is given,
    with a text node containing the given string.
    */
    insertText(text10, from4, to2) {
      let schema = this.doc.type.schema;
      if (from4 == null) {
        if (!text10)
          return this.deleteSelection();
        return this.replaceSelectionWith(schema.text(text10), true);
      } else {
        if (to2 == null)
          to2 = from4;
        to2 = to2 == null ? from4 : to2;
        if (!text10)
          return this.deleteRange(from4, to2);
        let marks = this.storedMarks;
        if (!marks) {
          let $from = this.doc.resolve(from4);
          marks = to2 == from4 ? $from.marks() : $from.marksAcross(this.doc.resolve(to2));
        }
        this.replaceRangeWith(from4, to2, schema.text(text10, marks));
        if (!this.selection.empty)
          this.setSelection(Selection.near(this.selection.$to));
        return this;
      }
    }
    /**
    Store a metadata property in this transaction, keyed either by
    name or by plugin.
    */
    setMeta(key2, value) {
      this.meta[typeof key2 == "string" ? key2 : key2.key] = value;
      return this;
    }
    /**
    Retrieve a metadata property for a given name or plugin.
    */
    getMeta(key2) {
      return this.meta[typeof key2 == "string" ? key2 : key2.key];
    }
    /**
    Returns true if this transaction doesn't contain any metadata,
    and can thus safely be extended.
    */
    get isGeneric() {
      for (let _2 in this.meta)
        return false;
      return true;
    }
    /**
    Indicate that the editor should scroll the selection into view
    when updated to the state produced by this transaction.
    */
    scrollIntoView() {
      this.updated |= UPDATED_SCROLL;
      return this;
    }
    /**
    True when this transaction has had `scrollIntoView` called on it.
    */
    get scrolledIntoView() {
      return (this.updated & UPDATED_SCROLL) > 0;
    }
  };
  function bind(f, self2) {
    return !self2 || !f ? f : f.bind(self2);
  }
  var FieldDesc = class {
    constructor(name, desc, self2) {
      this.name = name;
      this.init = bind(desc.init, self2);
      this.apply = bind(desc.apply, self2);
    }
  };
  var baseFields = [
    new FieldDesc("doc", {
      init(config) {
        return config.doc || config.schema.topNodeType.createAndFill();
      },
      apply(tr3) {
        return tr3.doc;
      }
    }),
    new FieldDesc("selection", {
      init(config, instance) {
        return config.selection || Selection.atStart(instance.doc);
      },
      apply(tr3) {
        return tr3.selection;
      }
    }),
    new FieldDesc("storedMarks", {
      init(config) {
        return config.storedMarks || null;
      },
      apply(tr3, _marks, _old, state) {
        return state.selection.$cursor ? tr3.storedMarks : null;
      }
    }),
    new FieldDesc("scrollToSelection", {
      init() {
        return 0;
      },
      apply(tr3, prev) {
        return tr3.scrolledIntoView ? prev + 1 : prev;
      }
    })
  ];
  var Configuration = class {
    constructor(schema, plugins) {
      this.schema = schema;
      this.plugins = [];
      this.pluginsByKey = /* @__PURE__ */ Object.create(null);
      this.fields = baseFields.slice();
      if (plugins)
        plugins.forEach((plugin) => {
          if (this.pluginsByKey[plugin.key])
            throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
          this.plugins.push(plugin);
          this.pluginsByKey[plugin.key] = plugin;
          if (plugin.spec.state)
            this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
        });
    }
  };
  var EditorState = class _EditorState {
    /**
    @internal
    */
    constructor(config) {
      this.config = config;
    }
    /**
    The schema of the state's document.
    */
    get schema() {
      return this.config.schema;
    }
    /**
    The plugins that are active in this state.
    */
    get plugins() {
      return this.config.plugins;
    }
    /**
    Apply the given transaction to produce a new state.
    */
    apply(tr3) {
      return this.applyTransaction(tr3).state;
    }
    /**
    @internal
    */
    filterTransaction(tr3, ignore3 = -1) {
      for (let i = 0; i < this.config.plugins.length; i++)
        if (i != ignore3) {
          let plugin = this.config.plugins[i];
          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr3, this))
            return false;
        }
      return true;
    }
    /**
    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
    returns the precise transactions that were applied (which might
    be influenced by the [transaction
    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
    plugins) along with the new state.
    */
    applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr))
        return { state: this, transactions: [] };
      let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
      for (; ; ) {
        let haveNew = false;
        for (let i = 0; i < this.config.plugins.length; i++) {
          let plugin = this.config.plugins[i];
          if (plugin.spec.appendTransaction) {
            let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
            let tr3 = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
            if (tr3 && newState.filterTransaction(tr3, i)) {
              tr3.setMeta("appendedTransaction", rootTr);
              if (!seen) {
                seen = [];
                for (let j2 = 0; j2 < this.config.plugins.length; j2++)
                  seen.push(j2 < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
              }
              trs.push(tr3);
              newState = newState.applyInner(tr3);
              haveNew = true;
            }
            if (seen)
              seen[i] = { state: newState, n: trs.length };
          }
        }
        if (!haveNew)
          return { state: newState, transactions: trs };
      }
    }
    /**
    @internal
    */
    applyInner(tr3) {
      if (!tr3.before.eq(this.doc))
        throw new RangeError("Applying a mismatched transaction");
      let newInstance = new _EditorState(this.config), fields = this.config.fields;
      for (let i = 0; i < fields.length; i++) {
        let field = fields[i];
        newInstance[field.name] = field.apply(tr3, this[field.name], this, newInstance);
      }
      return newInstance;
    }
    /**
    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
    */
    get tr() {
      return new Transaction(this);
    }
    /**
    Create a new state.
    */
    static create(config) {
      let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
      let instance = new _EditorState($config);
      for (let i = 0; i < $config.fields.length; i++)
        instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
      return instance;
    }
    /**
    Create a new state based on this one, but with an adjusted set
    of active plugins. State fields that exist in both sets of
    plugins are kept unchanged. Those that no longer exist are
    dropped, and those that are new are initialized using their
    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
    configuration object..
    */
    reconfigure(config) {
      let $config = new Configuration(this.schema, config.plugins);
      let fields = $config.fields, instance = new _EditorState($config);
      for (let i = 0; i < fields.length; i++) {
        let name = fields[i].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
      }
      return instance;
    }
    /**
    Serialize this state to JSON. If you want to serialize the state
    of plugins, pass an object mapping property names to use in the
    resulting JSON object to plugin objects. The argument may also be
    a string or number, in which case it is ignored, to support the
    way `JSON.stringify` calls `toString` methods.
    */
    toJSON(pluginFields) {
      let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
      if (this.storedMarks)
        result.storedMarks = this.storedMarks.map((m) => m.toJSON());
      if (pluginFields && typeof pluginFields == "object")
        for (let prop in pluginFields) {
          if (prop == "doc" || prop == "selection")
            throw new RangeError("The JSON fields `doc` and `selection` are reserved");
          let plugin = pluginFields[prop], state = plugin.spec.state;
          if (state && state.toJSON)
            result[prop] = state.toJSON.call(plugin, this[plugin.key]);
        }
      return result;
    }
    /**
    Deserialize a JSON representation of a state. `config` should
    have at least a `schema` field, and should contain array of
    plugins to initialize the state with. `pluginFields` can be used
    to deserialize the state of plugins, by associating plugin
    instances with the property names they use in the JSON object.
    */
    static fromJSON(config, json, pluginFields) {
      if (!json)
        throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!config.schema)
        throw new RangeError("Required config field 'schema' missing");
      let $config = new Configuration(config.schema, config.plugins);
      let instance = new _EditorState($config);
      $config.fields.forEach((field) => {
        if (field.name == "doc") {
          instance.doc = Node2.fromJSON(config.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks)
            instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
        } else {
          if (pluginFields)
            for (let prop in pluginFields) {
              let plugin = pluginFields[prop], state = plugin.spec.state;
              if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
                return;
              }
            }
          instance[field.name] = field.init(config, instance);
        }
      });
      return instance;
    }
  };
  function bindProps(obj, self2, target) {
    for (let prop in obj) {
      let val = obj[prop];
      if (val instanceof Function)
        val = val.bind(self2);
      else if (prop == "handleDOMEvents")
        val = bindProps(val, self2, {});
      target[prop] = val;
    }
    return target;
  }
  var Plugin = class {
    /**
    Create a plugin.
    */
    constructor(spec) {
      this.spec = spec;
      this.props = {};
      if (spec.props)
        bindProps(spec.props, this, this.props);
      this.key = spec.key ? spec.key.key : createKey("plugin");
    }
    /**
    Extract the plugin's state field from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  };
  var keys2 = /* @__PURE__ */ Object.create(null);
  function createKey(name) {
    if (name in keys2)
      return name + "$" + ++keys2[name];
    keys2[name] = 0;
    return name + "$";
  }
  var PluginKey = class {
    /**
    Create a plugin key.
    */
    constructor(name = "key") {
      this.key = createKey(name);
    }
    /**
    Get the active plugin with this key, if any, from an editor
    state.
    */
    get(state) {
      return state.config.pluginsByKey[this.key];
    }
    /**
    Get the plugin's state from an editor state.
    */
    getState(state) {
      return state[this.key];
    }
  };

  // node_modules/prosemirror-view/dist/index.js
  var domIndex = function(node2) {
    for (var index3 = 0; ; index3++) {
      node2 = node2.previousSibling;
      if (!node2)
        return index3;
    }
  };
  var parentNode = function(node2) {
    let parent = node2.assignedSlot || node2.parentNode;
    return parent && parent.nodeType == 11 ? parent.host : parent;
  };
  var reusedRange = null;
  var textRange = function(node2, from4, to2) {
    let range = reusedRange || (reusedRange = document.createRange());
    range.setEnd(node2, to2 == null ? node2.nodeValue.length : to2);
    range.setStart(node2, from4 || 0);
    return range;
  };
  var clearReusedRange = function() {
    reusedRange = null;
  };
  var isEquivalentPosition = function(node2, off, targetNode, targetOff) {
    return targetNode && (scanFor(node2, off, targetNode, targetOff, -1) || scanFor(node2, off, targetNode, targetOff, 1));
  };
  var atomElements = /^(img|br|input|textarea|hr)$/i;
  function scanFor(node2, off, targetNode, targetOff, dir) {
    var _a3;
    for (; ; ) {
      if (node2 == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : nodeSize(node2))) {
        let parent = node2.parentNode;
        if (!parent || parent.nodeType != 1 || hasBlockDesc(node2) || atomElements.test(node2.nodeName) || node2.contentEditable == "false")
          return false;
        off = domIndex(node2) + (dir < 0 ? 0 : 1);
        node2 = parent;
      } else if (node2.nodeType == 1) {
        let child = node2.childNodes[off + (dir < 0 ? -1 : 0)];
        if (child.nodeType == 1 && child.contentEditable == "false") {
          if ((_a3 = child.pmViewDesc) === null || _a3 === void 0 ? void 0 : _a3.ignoreForSelection)
            off += dir;
          else
            return false;
        } else {
          node2 = child;
          off = dir < 0 ? nodeSize(node2) : 0;
        }
      } else {
        return false;
      }
    }
  }
  function nodeSize(node2) {
    return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
  }
  function textNodeBefore$1(node2, offset) {
    for (; ; ) {
      if (node2.nodeType == 3 && offset)
        return node2;
      if (node2.nodeType == 1 && offset > 0) {
        if (node2.contentEditable == "false")
          return null;
        node2 = node2.childNodes[offset - 1];
        offset = nodeSize(node2);
      } else if (node2.parentNode && !hasBlockDesc(node2)) {
        offset = domIndex(node2);
        node2 = node2.parentNode;
      } else {
        return null;
      }
    }
  }
  function textNodeAfter$1(node2, offset) {
    for (; ; ) {
      if (node2.nodeType == 3 && offset < node2.nodeValue.length)
        return node2;
      if (node2.nodeType == 1 && offset < node2.childNodes.length) {
        if (node2.contentEditable == "false")
          return null;
        node2 = node2.childNodes[offset];
        offset = 0;
      } else if (node2.parentNode && !hasBlockDesc(node2)) {
        offset = domIndex(node2) + 1;
        node2 = node2.parentNode;
      } else {
        return null;
      }
    }
  }
  function isOnEdge(node2, offset, parent) {
    for (let atStart = offset == 0, atEnd = offset == nodeSize(node2); atStart || atEnd; ) {
      if (node2 == parent)
        return true;
      let index3 = domIndex(node2);
      node2 = node2.parentNode;
      if (!node2)
        return false;
      atStart = atStart && index3 == 0;
      atEnd = atEnd && index3 == nodeSize(node2);
    }
  }
  function hasBlockDesc(dom) {
    let desc;
    for (let cur = dom; cur; cur = cur.parentNode)
      if (desc = cur.pmViewDesc)
        break;
    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
  }
  var selectionCollapsed = function(domSel) {
    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
  };
  function keyEvent(keyCode, key2) {
    let event = document.createEvent("Event");
    event.initEvent("keydown", true, true);
    event.keyCode = keyCode;
    event.key = event.code = key2;
    return event;
  }
  function deepActiveElement(doc4) {
    let elt = doc4.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function caretFromPoint(doc4, x, y) {
    if (doc4.caretPositionFromPoint) {
      try {
        let pos = doc4.caretPositionFromPoint(x, y);
        if (pos)
          return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
      } catch (_2) {
      }
    }
    if (doc4.caretRangeFromPoint) {
      let range = doc4.caretRangeFromPoint(x, y);
      if (range)
        return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
    }
  }
  var nav = typeof navigator != "undefined" ? navigator : null;
  var doc2 = typeof document != "undefined" ? document : null;
  var agent = nav && nav.userAgent || "";
  var ie_edge = /Edge\/(\d+)/.exec(agent);
  var ie_upto10 = /MSIE \d/.exec(agent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
  var ie = !!(ie_upto10 || ie_11up || ie_edge);
  var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
  var gecko = !ie && /gecko\/(\d+)/i.test(agent);
  gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
  var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
  var chrome = !!_chrome;
  var chrome_version = _chrome ? +_chrome[1] : 0;
  var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
  var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
  var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
  var windows = nav ? /Win/.test(nav.platform) : false;
  var android = /Android \d/.test(agent);
  var webkit = !!doc2 && "webkitFontSmoothing" in doc2.documentElement.style;
  var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
  function windowRect(doc4) {
    let vp = doc4.defaultView && doc4.defaultView.visualViewport;
    if (vp)
      return {
        left: 0,
        right: vp.width,
        top: 0,
        bottom: vp.height
      };
    return {
      left: 0,
      right: doc4.documentElement.clientWidth,
      top: 0,
      bottom: doc4.documentElement.clientHeight
    };
  }
  function getSide(value, side) {
    return typeof value == "number" ? value : value[side];
  }
  function clientRect(node2) {
    let rect = node2.getBoundingClientRect();
    let scaleX = rect.width / node2.offsetWidth || 1;
    let scaleY = rect.height / node2.offsetHeight || 1;
    return {
      left: rect.left,
      right: rect.left + node2.clientWidth * scaleX,
      top: rect.top,
      bottom: rect.top + node2.clientHeight * scaleY
    };
  }
  function scrollRectIntoView(view, rect, startDOM) {
    let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
    let doc4 = view.dom.ownerDocument;
    for (let parent = startDOM || view.dom; ; ) {
      if (!parent)
        break;
      if (parent.nodeType != 1) {
        parent = parentNode(parent);
        continue;
      }
      let elt = parent;
      let atTop = elt == doc4.body;
      let bounding = atTop ? windowRect(doc4) : clientRect(elt);
      let moveX = 0, moveY = 0;
      if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
        moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
      else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
        moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
      if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
        moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
      else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
        moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
      if (moveX || moveY) {
        if (atTop) {
          doc4.defaultView.scrollBy(moveX, moveY);
        } else {
          let startX = elt.scrollLeft, startY = elt.scrollTop;
          if (moveY)
            elt.scrollTop += moveY;
          if (moveX)
            elt.scrollLeft += moveX;
          let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
          rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
        }
      }
      let pos = atTop ? "fixed" : getComputedStyle(parent).position;
      if (/^(fixed|sticky)$/.test(pos))
        break;
      parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
    }
  }
  function storeScrollPos(view) {
    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
    let refDOM, refTop;
    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
      let dom = view.root.elementFromPoint(x, y);
      if (!dom || dom == view.dom || !view.dom.contains(dom))
        continue;
      let localRect = dom.getBoundingClientRect();
      if (localRect.top >= startY - 20) {
        refDOM = dom;
        refTop = localRect.top;
        break;
      }
    }
    return { refDOM, refTop, stack: scrollStack(view.dom) };
  }
  function scrollStack(dom) {
    let stack = [], doc4 = dom.ownerDocument;
    for (let cur = dom; cur; cur = parentNode(cur)) {
      stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
      if (dom == doc4)
        break;
    }
    return stack;
  }
  function resetScrollPos({ refDOM, refTop, stack }) {
    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
  }
  function restoreScrollStack(stack, dTop) {
    for (let i = 0; i < stack.length; i++) {
      let { dom, top, left } = stack[i];
      if (dom.scrollTop != top + dTop)
        dom.scrollTop = top + dTop;
      if (dom.scrollLeft != left)
        dom.scrollLeft = left;
    }
  }
  var preventScrollSupported = null;
  function focusPreventScroll(dom) {
    if (dom.setActive)
      return dom.setActive();
    if (preventScrollSupported)
      return dom.focus(preventScrollSupported);
    let stored = scrollStack(dom);
    dom.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      restoreScrollStack(stored, 0);
    }
  }
  function findOffsetInNode(node2, coords) {
    let closest, dxClosest = 2e8, coordsClosest, offset = 0;
    let rowBot = coords.top, rowTop = coords.top;
    let firstBelow, coordsBelow;
    for (let child = node2.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
      let rects;
      if (child.nodeType == 1)
        rects = child.getClientRects();
      else if (child.nodeType == 3)
        rects = textRange(child).getClientRects();
      else
        continue;
      for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (rect.top <= rowBot && rect.bottom >= rowTop) {
          rowBot = Math.max(rect.bottom, rowBot);
          rowTop = Math.min(rect.top, rowTop);
          let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
          if (dx < dxClosest) {
            closest = child;
            dxClosest = dx;
            coordsClosest = dx && closest.nodeType == 3 ? {
              left: rect.right < coords.left ? rect.right : rect.left,
              top: coords.top
            } : coords;
            if (child.nodeType == 1 && dx)
              offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
            continue;
          }
        } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
          firstBelow = child;
          coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
        }
        if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
          offset = childIndex + 1;
      }
    }
    if (!closest && firstBelow) {
      closest = firstBelow;
      coordsClosest = coordsBelow;
      dxClosest = 0;
    }
    if (closest && closest.nodeType == 3)
      return findOffsetInText(closest, coordsClosest);
    if (!closest || dxClosest && closest.nodeType == 1)
      return { node: node2, offset };
    return findOffsetInNode(closest, coordsClosest);
  }
  function findOffsetInText(node2, coords) {
    let len = node2.nodeValue.length;
    let range = document.createRange();
    for (let i = 0; i < len; i++) {
      range.setEnd(node2, i + 1);
      range.setStart(node2, i);
      let rect = singleRect(range, 1);
      if (rect.top == rect.bottom)
        continue;
      if (inRect(coords, rect))
        return { node: node2, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
    }
    return { node: node2, offset: 0 };
  }
  function inRect(coords, rect) {
    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
  }
  function targetKludge(dom, coords) {
    let parent = dom.parentNode;
    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
      return parent;
    return dom;
  }
  function posFromElement(view, elt, coords) {
    let { node: node2, offset } = findOffsetInNode(elt, coords), bias = -1;
    if (node2.nodeType == 1 && !node2.firstChild) {
      let rect = node2.getBoundingClientRect();
      bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
    }
    return view.docView.posFromDOM(node2, offset, bias);
  }
  function posFromCaret(view, node2, offset, coords) {
    let outsideBlock = -1;
    for (let cur = node2, sawBlock = false; ; ) {
      if (cur == view.dom)
        break;
      let desc = view.docView.nearestDesc(cur, true), rect;
      if (!desc)
        return null;
      if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
      ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
        if (desc.node.isBlock && desc.parent) {
          if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
            outsideBlock = desc.posBefore;
          else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
            outsideBlock = desc.posAfter;
          sawBlock = true;
        }
        if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
          let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
          return before ? desc.posBefore : desc.posAfter;
        }
      }
      cur = desc.dom.parentNode;
    }
    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node2, offset, -1);
  }
  function elementFromPoint(element7, coords, box) {
    let len = element7.childNodes.length;
    if (len && box.top < box.bottom) {
      for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
        let child = element7.childNodes[i];
        if (child.nodeType == 1) {
          let rects = child.getClientRects();
          for (let j2 = 0; j2 < rects.length; j2++) {
            let rect = rects[j2];
            if (inRect(coords, rect))
              return elementFromPoint(child, coords, rect);
          }
        }
        if ((i = (i + 1) % len) == startI)
          break;
      }
    }
    return element7;
  }
  function posAtCoords(view, coords) {
    let doc4 = view.dom.ownerDocument, node2, offset = 0;
    let caret = caretFromPoint(doc4, coords.left, coords.top);
    if (caret)
      ({ node: node2, offset } = caret);
    let elt = (view.root.elementFromPoint ? view.root : doc4).elementFromPoint(coords.left, coords.top);
    let pos;
    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
      let box = view.dom.getBoundingClientRect();
      if (!inRect(coords, box))
        return null;
      elt = elementFromPoint(view.dom, coords, box);
      if (!elt)
        return null;
    }
    if (safari) {
      for (let p5 = elt; node2 && p5; p5 = parentNode(p5))
        if (p5.draggable)
          node2 = void 0;
    }
    elt = targetKludge(elt, coords);
    if (node2) {
      if (gecko && node2.nodeType == 1) {
        offset = Math.min(offset, node2.childNodes.length);
        if (offset < node2.childNodes.length) {
          let next2 = node2.childNodes[offset], box;
          if (next2.nodeName == "IMG" && (box = next2.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
            offset++;
        }
      }
      let prev;
      if (webkit && offset && node2.nodeType == 1 && (prev = node2.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
        offset--;
      if (node2 == view.dom && offset == node2.childNodes.length - 1 && node2.lastChild.nodeType == 1 && coords.top > node2.lastChild.getBoundingClientRect().bottom)
        pos = view.state.doc.content.size;
      else if (offset == 0 || node2.nodeType != 1 || node2.childNodes[offset - 1].nodeName != "BR")
        pos = posFromCaret(view, node2, offset, coords);
    }
    if (pos == null)
      pos = posFromElement(view, elt, coords);
    let desc = view.docView.nearestDesc(elt, true);
    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
  }
  function nonZero(rect) {
    return rect.top < rect.bottom || rect.left < rect.right;
  }
  function singleRect(target, bias) {
    let rects = target.getClientRects();
    if (rects.length) {
      let first3 = rects[bias < 0 ? 0 : rects.length - 1];
      if (nonZero(first3))
        return first3;
    }
    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
  }
  var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function coordsAtPos(view, pos, side) {
    let { node: node2, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
    let supportEmptyRange = webkit || gecko;
    if (node2.nodeType == 3) {
      if (supportEmptyRange && (BIDI.test(node2.nodeValue) || (side < 0 ? !offset : offset == node2.nodeValue.length))) {
        let rect = singleRect(textRange(node2, offset, offset), side);
        if (gecko && offset && /\s/.test(node2.nodeValue[offset - 1]) && offset < node2.nodeValue.length) {
          let rectBefore = singleRect(textRange(node2, offset - 1, offset - 1), -1);
          if (rectBefore.top == rect.top) {
            let rectAfter = singleRect(textRange(node2, offset, offset + 1), -1);
            if (rectAfter.top != rect.top)
              return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
        return rect;
      } else {
        let from4 = offset, to2 = offset, takeSide = side < 0 ? 1 : -1;
        if (side < 0 && !offset) {
          to2++;
          takeSide = -1;
        } else if (side >= 0 && offset == node2.nodeValue.length) {
          from4--;
          takeSide = 1;
        } else if (side < 0) {
          from4--;
        } else {
          to2++;
        }
        return flattenV(singleRect(textRange(node2, from4, to2), takeSide), takeSide < 0);
      }
    }
    let $dom = view.state.doc.resolve(pos - (atom || 0));
    if (!$dom.parent.inlineContent) {
      if (atom == null && offset && (side < 0 || offset == nodeSize(node2))) {
        let before = node2.childNodes[offset - 1];
        if (before.nodeType == 1)
          return flattenH(before.getBoundingClientRect(), false);
      }
      if (atom == null && offset < nodeSize(node2)) {
        let after = node2.childNodes[offset];
        if (after.nodeType == 1)
          return flattenH(after.getBoundingClientRect(), true);
      }
      return flattenH(node2.getBoundingClientRect(), side >= 0);
    }
    if (atom == null && offset && (side < 0 || offset == nodeSize(node2))) {
      let before = node2.childNodes[offset - 1];
      let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
      if (target)
        return flattenV(singleRect(target, 1), false);
    }
    if (atom == null && offset < nodeSize(node2)) {
      let after = node2.childNodes[offset];
      while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
        after = after.nextSibling;
      let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
      if (target)
        return flattenV(singleRect(target, -1), true);
    }
    return flattenV(singleRect(node2.nodeType == 3 ? textRange(node2) : node2, -side), side >= 0);
  }
  function flattenV(rect, left) {
    if (rect.width == 0)
      return rect;
    let x = left ? rect.left : rect.right;
    return { top: rect.top, bottom: rect.bottom, left: x, right: x };
  }
  function flattenH(rect, top) {
    if (rect.height == 0)
      return rect;
    let y = top ? rect.top : rect.bottom;
    return { top: y, bottom: y, left: rect.left, right: rect.right };
  }
  function withFlushedState(view, state, f) {
    let viewState = view.state, active = view.root.activeElement;
    if (viewState != state)
      view.updateState(state);
    if (active != view.dom)
      view.focus();
    try {
      return f();
    } finally {
      if (viewState != state)
        view.updateState(viewState);
      if (active != view.dom && active)
        active.focus();
    }
  }
  function endOfTextblockVertical(view, state, dir) {
    let sel = state.selection;
    let $pos = dir == "up" ? sel.$from : sel.$to;
    return withFlushedState(view, state, () => {
      let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
      for (; ; ) {
        let nearest = view.docView.nearestDesc(dom, true);
        if (!nearest)
          break;
        if (nearest.node.isBlock) {
          dom = nearest.contentDOM || nearest.dom;
          break;
        }
        dom = nearest.dom.parentNode;
      }
      let coords = coordsAtPos(view, $pos.pos, 1);
      for (let child = dom.firstChild; child; child = child.nextSibling) {
        let boxes;
        if (child.nodeType == 1)
          boxes = child.getClientRects();
        else if (child.nodeType == 3)
          boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
        else
          continue;
        for (let i = 0; i < boxes.length; i++) {
          let box = boxes[i];
          if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
            return false;
        }
      }
      return true;
    });
  }
  var maybeRTL = /[\u0590-\u08ac]/;
  function endOfTextblockHorizontal(view, state, dir) {
    let { $head } = state.selection;
    if (!$head.parent.isTextblock)
      return false;
    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
    let sel = view.domSelection();
    if (!sel)
      return $head.pos == $head.start() || $head.pos == $head.end();
    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
      return dir == "left" || dir == "backward" ? atStart : atEnd;
    return withFlushedState(view, state, () => {
      let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
      let oldBidiLevel = sel.caretBidiLevel;
      sel.modify("move", dir, "character");
      let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
      let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
      let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
      try {
        sel.collapse(anchorNode, anchorOffset);
        if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
          sel.extend(oldNode, oldOff);
      } catch (_2) {
      }
      if (oldBidiLevel != null)
        sel.caretBidiLevel = oldBidiLevel;
      return result;
    });
  }
  var cachedState = null;
  var cachedDir = null;
  var cachedResult = false;
  function endOfTextblock(view, state, dir) {
    if (cachedState == state && cachedDir == dir)
      return cachedResult;
    cachedState = state;
    cachedDir = dir;
    return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
  }
  var NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
  var ViewDesc = class {
    constructor(parent, children, dom, contentDOM) {
      this.parent = parent;
      this.children = children;
      this.dom = dom;
      this.contentDOM = contentDOM;
      this.dirty = NOT_DIRTY;
      dom.pmViewDesc = this;
    }
    // Used to check whether a given description corresponds to a
    // widget/mark/node.
    matchesWidget(widget) {
      return false;
    }
    matchesMark(mark2) {
      return false;
    }
    matchesNode(node2, outerDeco, innerDeco) {
      return false;
    }
    matchesHack(nodeName) {
      return false;
    }
    // When parsing in-editor content (in domchange.js), we allow
    // descriptions to determine the parse rules that should be used to
    // parse them.
    parseRule() {
      return null;
    }
    // Used by the editor's event handler to ignore events that come
    // from certain descs.
    stopEvent(event) {
      return false;
    }
    // The size of the content represented by this desc.
    get size() {
      let size2 = 0;
      for (let i = 0; i < this.children.length; i++)
        size2 += this.children[i].size;
      return size2;
    }
    // For block nodes, this represents the space taken up by their
    // start/end tokens.
    get border() {
      return 0;
    }
    destroy() {
      this.parent = void 0;
      if (this.dom.pmViewDesc == this)
        this.dom.pmViewDesc = void 0;
      for (let i = 0; i < this.children.length; i++)
        this.children[i].destroy();
    }
    posBeforeChild(child) {
      for (let i = 0, pos = this.posAtStart; ; i++) {
        let cur = this.children[i];
        if (cur == child)
          return pos;
        pos += cur.size;
      }
    }
    get posBefore() {
      return this.parent.posBeforeChild(this);
    }
    get posAtStart() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
    get posAfter() {
      return this.posBefore + this.size;
    }
    get posAtEnd() {
      return this.posAtStart + this.size - 2 * this.border;
    }
    localPosFromDOM(dom, offset, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          let domBefore, desc;
          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset - 1];
          } else {
            while (dom.parentNode != this.contentDOM)
              dom = dom.parentNode;
            domBefore = dom.previousSibling;
          }
          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
            domBefore = domBefore.previousSibling;
          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          let domAfter, desc;
          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset];
          } else {
            while (dom.parentNode != this.contentDOM)
              dom = dom.parentNode;
            domAfter = dom.nextSibling;
          }
          while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
            domAfter = domAfter.nextSibling;
          return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
        }
      }
      let atEnd;
      if (dom == this.dom && this.contentDOM) {
        atEnd = offset > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset == 0)
          for (let search3 = dom; ; search3 = search3.parentNode) {
            if (search3 == this.dom) {
              atEnd = false;
              break;
            }
            if (search3.previousSibling)
              break;
          }
        if (atEnd == null && offset == dom.childNodes.length)
          for (let search3 = dom; ; search3 = search3.parentNode) {
            if (search3 == this.dom) {
              atEnd = true;
              break;
            }
            if (search3.nextSibling)
              break;
          }
      }
      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    }
    nearestDesc(dom, onlyNodes = false) {
      for (let first3 = true, cur = dom; cur; cur = cur.parentNode) {
        let desc = this.getDesc(cur), nodeDOM;
        if (desc && (!onlyNodes || desc.node)) {
          if (first3 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
            first3 = false;
          else
            return desc;
        }
      }
    }
    getDesc(dom) {
      let desc = dom.pmViewDesc;
      for (let cur = desc; cur; cur = cur.parent)
        if (cur == this)
          return desc;
    }
    posFromDOM(dom, offset, bias) {
      for (let scan = dom; scan; scan = scan.parentNode) {
        let desc = this.getDesc(scan);
        if (desc)
          return desc.localPosFromDOM(dom, offset, bias);
      }
      return -1;
    }
    // Find the desc for the node after the given pos, if any. (When a
    // parent node overrode rendering, there might not be one.)
    descAt(pos) {
      for (let i = 0, offset = 0; i < this.children.length; i++) {
        let child = this.children[i], end = offset + child.size;
        if (offset == pos && end != offset) {
          while (!child.border && child.children.length) {
            for (let i2 = 0; i2 < child.children.length; i2++) {
              let inner = child.children[i2];
              if (inner.size) {
                child = inner;
                break;
              }
            }
          }
          return child;
        }
        if (pos < end)
          return child.descAt(pos - offset - child.border);
        offset = end;
      }
    }
    domFromPos(pos, side) {
      if (!this.contentDOM)
        return { node: this.dom, offset: 0, atom: pos + 1 };
      let i = 0, offset = 0;
      for (let curPos = 0; i < this.children.length; i++) {
        let child = this.children[i], end = curPos + child.size;
        if (end > pos || child instanceof TrailingHackViewDesc) {
          offset = pos - curPos;
          break;
        }
        curPos = end;
      }
      if (offset)
        return this.children[i].domFromPos(offset - this.children[i].border, side);
      for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
      }
      if (side <= 0) {
        let prev, enter2 = true;
        for (; ; i--, enter2 = false) {
          prev = i ? this.children[i - 1] : null;
          if (!prev || prev.dom.parentNode == this.contentDOM)
            break;
        }
        if (prev && side && enter2 && !prev.border && !prev.domAtom)
          return prev.domFromPos(prev.size, side);
        return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
      } else {
        let next2, enter2 = true;
        for (; ; i++, enter2 = false) {
          next2 = i < this.children.length ? this.children[i] : null;
          if (!next2 || next2.dom.parentNode == this.contentDOM)
            break;
        }
        if (next2 && enter2 && !next2.border && !next2.domAtom)
          return next2.domFromPos(0, side);
        return { node: this.contentDOM, offset: next2 ? domIndex(next2.dom) : this.contentDOM.childNodes.length };
      }
    }
    // Used to find a DOM range in a single parent for a given changed
    // range.
    parseRange(from4, to2, base4 = 0) {
      if (this.children.length == 0)
        return { node: this.contentDOM, from: from4, to: to2, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
      let fromOffset = -1, toOffset = -1;
      for (let offset = base4, i = 0; ; i++) {
        let child = this.children[i], end = offset + child.size;
        if (fromOffset == -1 && from4 <= end) {
          let childBase = offset + child.border;
          if (from4 >= childBase && to2 <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
            return child.parseRange(from4, to2, childBase);
          from4 = offset;
          for (let j2 = i; j2 > 0; j2--) {
            let prev = this.children[j2 - 1];
            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }
            from4 -= prev.size;
          }
          if (fromOffset == -1)
            fromOffset = 0;
        }
        if (fromOffset > -1 && (end > to2 || i == this.children.length - 1)) {
          to2 = end;
          for (let j2 = i + 1; j2 < this.children.length; j2++) {
            let next2 = this.children[j2];
            if (next2.size && next2.dom.parentNode == this.contentDOM && !next2.emptyChildAt(-1)) {
              toOffset = domIndex(next2.dom);
              break;
            }
            to2 += next2.size;
          }
          if (toOffset == -1)
            toOffset = this.contentDOM.childNodes.length;
          break;
        }
        offset = end;
      }
      return { node: this.contentDOM, from: from4, to: to2, fromOffset, toOffset };
    }
    emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length)
        return false;
      let child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    }
    domAfterPos(pos) {
      let { node: node2, offset } = this.domFromPos(pos, 0);
      if (node2.nodeType != 1 || offset == node2.childNodes.length)
        throw new RangeError("No node after pos " + pos);
      return node2.childNodes[offset];
    }
    // View descs are responsible for setting any selection that falls
    // entirely inside of them, so that custom implementations can do
    // custom things with the selection. Note that this falls apart when
    // a selection starts in such a node and ends in another, in which
    // case we just use whatever domFromPos produces as a best effort.
    setSelection(anchor, head2, view, force = false) {
      let from4 = Math.min(anchor, head2), to2 = Math.max(anchor, head2);
      for (let i = 0, offset = 0; i < this.children.length; i++) {
        let child = this.children[i], end = offset + child.size;
        if (from4 > offset && to2 < end)
          return child.setSelection(anchor - offset - child.border, head2 - offset - child.border, view, force);
        offset = end;
      }
      let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      let headDOM = head2 == anchor ? anchorDOM : this.domFromPos(head2, head2 ? -1 : 1);
      let domSel = view.root.getSelection();
      let selRange = view.domSelectionRange();
      let brKludge = false;
      if ((gecko || safari) && anchor == head2) {
        let { node: node2, offset } = anchorDOM;
        if (node2.nodeType == 3) {
          brKludge = !!(offset && node2.nodeValue[offset - 1] == "\n");
          if (brKludge && offset == node2.nodeValue.length) {
            for (let scan = node2, after; scan; scan = scan.parentNode) {
              if (after = scan.nextSibling) {
                if (after.nodeName == "BR")
                  anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
                break;
              }
              let desc = scan.pmViewDesc;
              if (desc && desc.node && desc.node.isBlock)
                break;
            }
          }
        } else {
          let prev = node2.childNodes[offset - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }
      if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
        let after = selRange.focusNode.childNodes[selRange.focusOffset];
        if (after && after.contentEditable == "false")
          force = true;
      }
      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
        return;
      let domSelExtended = false;
      if ((domSel.extend || anchor == head2) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);
        try {
          if (anchor != head2)
            domSel.extend(headDOM.node, headDOM.offset);
          domSelExtended = true;
        } catch (_2) {
        }
      }
      if (!domSelExtended) {
        if (anchor > head2) {
          let tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }
        let range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    }
    ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    }
    get contentLost() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
    // Remove a subtree of the element tree that has been touched
    // by a DOM change, so that the next update will redraw it.
    markDirty(from4, to2) {
      for (let offset = 0, i = 0; i < this.children.length; i++) {
        let child = this.children[i], end = offset + child.size;
        if (offset == end ? from4 <= end && to2 >= offset : from4 < end && to2 > offset) {
          let startInside = offset + child.border, endInside = end - child.border;
          if (from4 >= startInside && to2 <= endInside) {
            this.dirty = from4 == offset || to2 == end ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from4 == startInside && to2 == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
              child.dirty = NODE_DIRTY;
            else
              child.markDirty(from4 - startInside, to2 - startInside);
            return;
          } else {
            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }
        offset = end;
      }
      this.dirty = CONTENT_DIRTY;
    }
    markParentsDirty() {
      let level = 1;
      for (let node2 = this.parent; node2; node2 = node2.parent, level++) {
        let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node2.dirty < dirty)
          node2.dirty = dirty;
      }
    }
    get domAtom() {
      return false;
    }
    get ignoreForCoords() {
      return false;
    }
    get ignoreForSelection() {
      return false;
    }
    isText(text10) {
      return false;
    }
  };
  var WidgetViewDesc = class extends ViewDesc {
    constructor(parent, widget, view, pos) {
      let self2, dom = widget.type.toDOM;
      if (typeof dom == "function")
        dom = dom(view, () => {
          if (!self2)
            return pos;
          if (self2.parent)
            return self2.parent.posBeforeChild(self2);
        });
      if (!widget.type.spec.raw) {
        if (dom.nodeType != 1) {
          let wrap5 = document.createElement("span");
          wrap5.appendChild(dom);
          dom = wrap5;
        }
        dom.contentEditable = "false";
        dom.classList.add("ProseMirror-widget");
      }
      super(parent, [], dom, null);
      this.widget = widget;
      this.widget = widget;
      self2 = this;
    }
    matchesWidget(widget) {
      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
    }
    parseRule() {
      return { ignore: true };
    }
    stopEvent(event) {
      let stop = this.widget.spec.stopEvent;
      return stop ? stop(event) : false;
    }
    ignoreMutation(mutation) {
      return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    }
    destroy() {
      this.widget.type.destroy(this.dom);
      super.destroy();
    }
    get domAtom() {
      return true;
    }
    get ignoreForSelection() {
      return !!this.widget.type.spec.relaxedSide;
    }
    get side() {
      return this.widget.type.side;
    }
  };
  var CompositionViewDesc = class extends ViewDesc {
    constructor(parent, dom, textDOM, text10) {
      super(parent, [], dom, null);
      this.textDOM = textDOM;
      this.text = text10;
    }
    get size() {
      return this.text.length;
    }
    localPosFromDOM(dom, offset) {
      if (dom != this.textDOM)
        return this.posAtStart + (offset ? this.size : 0);
      return this.posAtStart + offset;
    }
    domFromPos(pos) {
      return { node: this.textDOM, offset: pos };
    }
    ignoreMutation(mut) {
      return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
    }
  };
  var MarkViewDesc = class _MarkViewDesc extends ViewDesc {
    constructor(parent, mark2, dom, contentDOM, spec) {
      super(parent, [], dom, contentDOM);
      this.mark = mark2;
      this.spec = spec;
    }
    static create(parent, mark2, inline, view) {
      let custom = view.nodeViews[mark2.type.name];
      let spec = custom && custom(mark2, view, inline);
      if (!spec || !spec.dom)
        spec = DOMSerializer.renderSpec(document, mark2.type.spec.toDOM(mark2, inline), null, mark2.attrs);
      return new _MarkViewDesc(parent, mark2, spec.dom, spec.contentDOM || spec.dom, spec);
    }
    parseRule() {
      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
        return null;
      return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
    }
    matchesMark(mark2) {
      return this.dirty != NODE_DIRTY && this.mark.eq(mark2);
    }
    markDirty(from4, to2) {
      super.markDirty(from4, to2);
      if (this.dirty != NOT_DIRTY) {
        let parent = this.parent;
        while (!parent.node)
          parent = parent.parent;
        if (parent.dirty < this.dirty)
          parent.dirty = this.dirty;
        this.dirty = NOT_DIRTY;
      }
    }
    slice(from4, to2, view) {
      let copy4 = _MarkViewDesc.create(this.parent, this.mark, true, view);
      let nodes = this.children, size2 = this.size;
      if (to2 < size2)
        nodes = replaceNodes(nodes, to2, size2, view);
      if (from4 > 0)
        nodes = replaceNodes(nodes, 0, from4, view);
      for (let i = 0; i < nodes.length; i++)
        nodes[i].parent = copy4;
      copy4.children = nodes;
      return copy4;
    }
    ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
    }
    destroy() {
      if (this.spec.destroy)
        this.spec.destroy();
      super.destroy();
    }
  };
  var NodeViewDesc = class _NodeViewDesc extends ViewDesc {
    constructor(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
      super(parent, [], dom, contentDOM);
      this.node = node2;
      this.outerDeco = outerDeco;
      this.innerDeco = innerDeco;
      this.nodeDOM = nodeDOM;
    }
    // By default, a node is rendered using the `toDOM` method from the
    // node type spec. But client code can use the `nodeViews` spec to
    // supply a custom node view, which can influence various aspects of
    // the way the node works.
    //
    // (Using subclassing for this was intentionally decided against,
    // since it'd require exposing a whole slew of finicky
    // implementation details to the user code that they probably will
    // never need.)
    static create(parent, node2, outerDeco, innerDeco, view, pos) {
      let custom = view.nodeViews[node2.type.name], descObj;
      let spec = custom && custom(node2, view, () => {
        if (!descObj)
          return pos;
        if (descObj.parent)
          return descObj.parent.posBeforeChild(descObj);
      }, outerDeco, innerDeco);
      let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
      if (node2.isText) {
        if (!dom)
          dom = document.createTextNode(node2.text);
        else if (dom.nodeType != 3)
          throw new RangeError("Text must be rendered as a DOM text node");
      } else if (!dom) {
        let spec2 = DOMSerializer.renderSpec(document, node2.type.spec.toDOM(node2), null, node2.attrs);
        ({ dom, contentDOM } = spec2);
      }
      if (!contentDOM && !node2.isText && dom.nodeName != "BR") {
        if (!dom.hasAttribute("contenteditable"))
          dom.contentEditable = "false";
        if (node2.type.spec.draggable)
          dom.draggable = true;
      }
      let nodeDOM = dom;
      dom = applyOuterDeco(dom, outerDeco, node2);
      if (spec)
        return descObj = new CustomNodeViewDesc(parent, node2, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
      else if (node2.isText)
        return new TextViewDesc(parent, node2, outerDeco, innerDeco, dom, nodeDOM, view);
      else
        return new _NodeViewDesc(parent, node2, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
    }
    parseRule() {
      if (this.node.type.spec.reparseInView)
        return null;
      let rule = { node: this.node.type.name, attrs: this.node.attrs };
      if (this.node.type.whitespace == "pre")
        rule.preserveWhitespace = "full";
      if (!this.contentDOM) {
        rule.getContent = () => this.node.content;
      } else if (!this.contentLost) {
        rule.contentElement = this.contentDOM;
      } else {
        for (let i = this.children.length - 1; i >= 0; i--) {
          let child = this.children[i];
          if (this.dom.contains(child.dom.parentNode)) {
            rule.contentElement = child.dom.parentNode;
            break;
          }
        }
        if (!rule.contentElement)
          rule.getContent = () => Fragment.empty;
      }
      return rule;
    }
    matchesNode(node2, outerDeco, innerDeco) {
      return this.dirty == NOT_DIRTY && node2.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    }
    get size() {
      return this.node.nodeSize;
    }
    get border() {
      return this.node.isLeaf ? 0 : 1;
    }
    // Syncs `this.children` to match `this.node.content` and the local
    // decorations, possibly introducing nesting for marks. Then, in a
    // separate step, syncs the DOM inside `this.contentDOM` to
    // `this.children`.
    updateChildren(view, pos) {
      let inline = this.node.inlineContent, off = pos;
      let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
      let localComposition = composition && composition.pos > -1 ? composition : null;
      let compositionInChild = composition && composition.pos < 0;
      let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
      iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
        if (widget.spec.marks)
          updater.syncToMarks(widget.spec.marks, inline, view);
        else if (widget.type.side >= 0 && !insideNode)
          updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view);
        updater.placeWidget(widget, view, off);
      }, (child, outerDeco, innerDeco, i) => {
        updater.syncToMarks(child.marks, inline, view);
        let compIndex;
        if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
        else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
        else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;
        else {
          updater.addNode(child, outerDeco, innerDeco, view, off);
        }
        off += child.nodeSize;
      });
      updater.syncToMarks([], inline, view);
      if (this.node.isTextblock)
        updater.addTextblockHacks();
      updater.destroyRest();
      if (updater.changed || this.dirty == CONTENT_DIRTY) {
        if (localComposition)
          this.protectLocalComposition(view, localComposition);
        renderDescs(this.contentDOM, this.children, view);
        if (ios)
          iosHacks(this.dom);
      }
    }
    localCompositionInfo(view, pos) {
      let { from: from4, to: to2 } = view.state.selection;
      if (!(view.state.selection instanceof TextSelection) || from4 < pos || to2 > pos + this.node.content.size)
        return null;
      let textNode = view.input.compositionNode;
      if (!textNode || !this.dom.contains(textNode.parentNode))
        return null;
      if (this.node.inlineContent) {
        let text10 = textNode.nodeValue;
        let textPos = findTextInFragment(this.node.content, text10, from4 - pos, to2 - pos);
        return textPos < 0 ? null : { node: textNode, pos: textPos, text: text10 };
      } else {
        return { node: textNode, pos: -1, text: "" };
      }
    }
    protectLocalComposition(view, { node: node2, pos, text: text10 }) {
      if (this.getDesc(node2))
        return;
      let topNode = node2;
      for (; ; topNode = topNode.parentNode) {
        if (topNode.parentNode == this.contentDOM)
          break;
        while (topNode.previousSibling)
          topNode.parentNode.removeChild(topNode.previousSibling);
        while (topNode.nextSibling)
          topNode.parentNode.removeChild(topNode.nextSibling);
        if (topNode.pmViewDesc)
          topNode.pmViewDesc = void 0;
      }
      let desc = new CompositionViewDesc(this, topNode, node2, text10);
      view.input.compositionNodes.push(desc);
      this.children = replaceNodes(this.children, pos, pos + text10.length, view, desc);
    }
    // If this desc must be updated to match the given node decoration,
    // do so and return true.
    update(node2, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || !node2.sameMarkup(this.node))
        return false;
      this.updateInner(node2, outerDeco, innerDeco, view);
      return true;
    }
    updateInner(node2, outerDeco, innerDeco, view) {
      this.updateOuterDeco(outerDeco);
      this.node = node2;
      this.innerDeco = innerDeco;
      if (this.contentDOM)
        this.updateChildren(view, this.posAtStart);
      this.dirty = NOT_DIRTY;
    }
    updateOuterDeco(outerDeco) {
      if (sameOuterDeco(outerDeco, this.outerDeco))
        return;
      let needsWrap = this.nodeDOM.nodeType != 1;
      let oldDOM = this.dom;
      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
      if (this.dom != oldDOM) {
        oldDOM.pmViewDesc = void 0;
        this.dom.pmViewDesc = this;
      }
      this.outerDeco = outerDeco;
    }
    // Mark this node as being the selected node.
    selectNode() {
      if (this.nodeDOM.nodeType == 1)
        this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.draggable = true;
    }
    // Remove selected node marking from this node.
    deselectNode() {
      if (this.nodeDOM.nodeType == 1) {
        this.nodeDOM.classList.remove("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable)
          this.dom.removeAttribute("draggable");
      }
    }
    get domAtom() {
      return this.node.isAtom;
    }
  };
  function docViewDesc(doc4, outerDeco, innerDeco, dom, view) {
    applyOuterDeco(dom, outerDeco, doc4);
    let docView = new NodeViewDesc(void 0, doc4, outerDeco, innerDeco, dom, dom, dom, view, 0);
    if (docView.contentDOM)
      docView.updateChildren(view, 0);
    return docView;
  }
  var TextViewDesc = class _TextViewDesc extends NodeViewDesc {
    constructor(parent, node2, outerDeco, innerDeco, dom, nodeDOM, view) {
      super(parent, node2, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
    }
    parseRule() {
      let skip = this.nodeDOM.parentNode;
      while (skip && skip != this.dom && !skip.pmIsDeco)
        skip = skip.parentNode;
      return { skip: skip || true };
    }
    update(node2, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node2.sameMarkup(this.node))
        return false;
      this.updateOuterDeco(outerDeco);
      if ((this.dirty != NOT_DIRTY || node2.text != this.node.text) && node2.text != this.nodeDOM.nodeValue) {
        this.nodeDOM.nodeValue = node2.text;
        if (view.trackWrites == this.nodeDOM)
          view.trackWrites = null;
      }
      this.node = node2;
      this.dirty = NOT_DIRTY;
      return true;
    }
    inParent() {
      let parentDOM = this.parent.contentDOM;
      for (let n = this.nodeDOM; n; n = n.parentNode)
        if (n == parentDOM)
          return true;
      return false;
    }
    domFromPos(pos) {
      return { node: this.nodeDOM, offset: pos };
    }
    localPosFromDOM(dom, offset, bias) {
      if (dom == this.nodeDOM)
        return this.posAtStart + Math.min(offset, this.node.text.length);
      return super.localPosFromDOM(dom, offset, bias);
    }
    ignoreMutation(mutation) {
      return mutation.type != "characterData" && mutation.type != "selection";
    }
    slice(from4, to2, view) {
      let node2 = this.node.cut(from4, to2), dom = document.createTextNode(node2.text);
      return new _TextViewDesc(this.parent, node2, this.outerDeco, this.innerDeco, dom, dom, view);
    }
    markDirty(from4, to2) {
      super.markDirty(from4, to2);
      if (this.dom != this.nodeDOM && (from4 == 0 || to2 == this.nodeDOM.nodeValue.length))
        this.dirty = NODE_DIRTY;
    }
    get domAtom() {
      return false;
    }
    isText(text10) {
      return this.node.text == text10;
    }
  };
  var TrailingHackViewDesc = class extends ViewDesc {
    parseRule() {
      return { ignore: true };
    }
    matchesHack(nodeName) {
      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
    }
    get domAtom() {
      return true;
    }
    get ignoreForCoords() {
      return this.dom.nodeName == "IMG";
    }
  };
  var CustomNodeViewDesc = class extends NodeViewDesc {
    constructor(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
      super(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
      this.spec = spec;
    }
    // A custom `update` method gets to decide whether the update goes
    // through. If it does, and there's a `contentDOM` node, our logic
    // updates the children.
    update(node2, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY)
        return false;
      if (this.spec.update && (this.node.type == node2.type || this.spec.multiType)) {
        let result = this.spec.update(node2, outerDeco, innerDeco);
        if (result)
          this.updateInner(node2, outerDeco, innerDeco, view);
        return result;
      } else if (!this.contentDOM && !node2.isLeaf) {
        return false;
      } else {
        return super.update(node2, outerDeco, innerDeco, view);
      }
    }
    selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
    }
    deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
    }
    setSelection(anchor, head2, view, force) {
      this.spec.setSelection ? this.spec.setSelection(anchor, head2, view.root) : super.setSelection(anchor, head2, view, force);
    }
    destroy() {
      if (this.spec.destroy)
        this.spec.destroy();
      super.destroy();
    }
    stopEvent(event) {
      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    }
    ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
    }
  };
  function renderDescs(parentDOM, descs, view) {
    let dom = parentDOM.firstChild, written = false;
    for (let i = 0; i < descs.length; i++) {
      let desc = descs[i], childDOM = desc.dom;
      if (childDOM.parentNode == parentDOM) {
        while (childDOM != dom) {
          dom = rm(dom);
          written = true;
        }
        dom = dom.nextSibling;
      } else {
        written = true;
        parentDOM.insertBefore(childDOM, dom);
      }
      if (desc instanceof MarkViewDesc) {
        let pos = dom ? dom.previousSibling : parentDOM.lastChild;
        renderDescs(desc.contentDOM, desc.children, view);
        dom = pos ? pos.nextSibling : parentDOM.firstChild;
      }
    }
    while (dom) {
      dom = rm(dom);
      written = true;
    }
    if (written && view.trackWrites == parentDOM)
      view.trackWrites = null;
  }
  var OuterDecoLevel = function(nodeName) {
    if (nodeName)
      this.nodeName = nodeName;
  };
  OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
  var noDeco = [new OuterDecoLevel()];
  function computeOuterDeco(outerDeco, node2, needsWrap) {
    if (outerDeco.length == 0)
      return noDeco;
    let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
    for (let i = 0; i < outerDeco.length; i++) {
      let attrs = outerDeco[i].type.attrs;
      if (!attrs)
        continue;
      if (attrs.nodeName)
        result.push(top = new OuterDecoLevel(attrs.nodeName));
      for (let name in attrs) {
        let val = attrs[name];
        if (val == null)
          continue;
        if (needsWrap && result.length == 1)
          result.push(top = new OuterDecoLevel(node2.isInline ? "span" : "div"));
        if (name == "class")
          top.class = (top.class ? top.class + " " : "") + val;
        else if (name == "style")
          top.style = (top.style ? top.style + ";" : "") + val;
        else if (name != "nodeName")
          top[name] = val;
      }
    }
    return result;
  }
  function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
    if (prevComputed == noDeco && curComputed == noDeco)
      return nodeDOM;
    let curDOM = nodeDOM;
    for (let i = 0; i < curComputed.length; i++) {
      let deco = curComputed[i], prev = prevComputed[i];
      if (i) {
        let parent;
        if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
          curDOM = parent;
        } else {
          parent = document.createElement(deco.nodeName);
          parent.pmIsDeco = true;
          parent.appendChild(curDOM);
          prev = noDeco[0];
          curDOM = parent;
        }
      }
      patchAttributes(curDOM, prev || noDeco[0], deco);
    }
    return curDOM;
  }
  function patchAttributes(dom, prev, cur) {
    for (let name in prev)
      if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
        dom.removeAttribute(name);
    for (let name in cur)
      if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
        dom.setAttribute(name, cur[name]);
    if (prev.class != cur.class) {
      let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
      let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
      for (let i = 0; i < prevList.length; i++)
        if (curList.indexOf(prevList[i]) == -1)
          dom.classList.remove(prevList[i]);
      for (let i = 0; i < curList.length; i++)
        if (prevList.indexOf(curList[i]) == -1)
          dom.classList.add(curList[i]);
      if (dom.classList.length == 0)
        dom.removeAttribute("class");
    }
    if (prev.style != cur.style) {
      if (prev.style) {
        let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
        while (m = prop.exec(prev.style))
          dom.style.removeProperty(m[1]);
      }
      if (cur.style)
        dom.style.cssText += cur.style;
    }
  }
  function applyOuterDeco(dom, deco, node2) {
    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node2, dom.nodeType != 1));
  }
  function sameOuterDeco(a2, b) {
    if (a2.length != b.length)
      return false;
    for (let i = 0; i < a2.length; i++)
      if (!a2[i].type.eq(b[i].type))
        return false;
    return true;
  }
  function rm(dom) {
    let next2 = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next2;
  }
  var ViewTreeUpdater = class {
    constructor(top, lock, view) {
      this.lock = lock;
      this.view = view;
      this.index = 0;
      this.stack = [];
      this.changed = false;
      this.top = top;
      this.preMatch = preMatch(top.node.content, top);
    }
    // Destroy and remove the children between the given indices in
    // `this.top`.
    destroyBetween(start, end) {
      if (start == end)
        return;
      for (let i = start; i < end; i++)
        this.top.children[i].destroy();
      this.top.children.splice(start, end - start);
      this.changed = true;
    }
    // Destroy all remaining children in `this.top`.
    destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
    // Sync the current stack of mark descs with the given array of
    // marks, reusing existing mark descs when possible.
    syncToMarks(marks, inline, view) {
      let keep = 0, depth = this.stack.length >> 1;
      let maxKeep = Math.min(depth, marks.length);
      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
        keep++;
      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }
      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        let found2 = -1;
        for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
          let next2 = this.top.children[i];
          if (next2.matchesMark(marks[depth]) && !this.isLocked(next2.dom)) {
            found2 = i;
            break;
          }
        }
        if (found2 > -1) {
          if (found2 > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found2);
          }
          this.top = this.top.children[this.index];
        } else {
          let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }
        this.index = 0;
        depth++;
      }
    }
    // Try to find a node desc matching the given data. Skip over it and
    // return true when successful.
    findNodeMatch(node2, outerDeco, innerDeco, index3) {
      let found2 = -1, targetDesc;
      if (index3 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index3 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node2, outerDeco, innerDeco)) {
        found2 = this.top.children.indexOf(targetDesc, this.index);
      } else {
        for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
          let child = this.top.children[i];
          if (child.matchesNode(node2, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found2 = i;
            break;
          }
        }
      }
      if (found2 < 0)
        return false;
      this.destroyBetween(this.index, found2);
      this.index++;
      return true;
    }
    updateNodeAt(node2, outerDeco, innerDeco, index3, view) {
      let child = this.top.children[index3];
      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
        child.dirty = CONTENT_DIRTY;
      if (!child.update(node2, outerDeco, innerDeco, view))
        return false;
      this.destroyBetween(this.index, index3);
      this.index++;
      return true;
    }
    findIndexWithChild(domNode) {
      for (; ; ) {
        let parent = domNode.parentNode;
        if (!parent)
          return -1;
        if (parent == this.top.contentDOM) {
          let desc = domNode.pmViewDesc;
          if (desc)
            for (let i = this.index; i < this.top.children.length; i++) {
              if (this.top.children[i] == desc)
                return i;
            }
          return -1;
        }
        domNode = parent;
      }
    }
    // Try to update the next node, if any, to the given data. Checks
    // pre-matches to avoid overwriting nodes that could still be used.
    updateNextNode(node2, outerDeco, innerDeco, view, index3, pos) {
      for (let i = this.index; i < this.top.children.length; i++) {
        let next2 = this.top.children[i];
        if (next2 instanceof NodeViewDesc) {
          let preMatch2 = this.preMatch.matched.get(next2);
          if (preMatch2 != null && preMatch2 != index3)
            return false;
          let nextDOM = next2.dom, updated;
          let locked = this.isLocked(nextDOM) && !(node2.isText && next2.node && next2.node.isText && next2.nodeDOM.nodeValue == node2.text && next2.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next2.outerDeco));
          if (!locked && next2.update(node2, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i);
            if (next2.dom != nextDOM)
              this.changed = true;
            this.index++;
            return true;
          } else if (!locked && (updated = this.recreateWrapper(next2, node2, outerDeco, innerDeco, view, pos))) {
            this.destroyBetween(this.index, i);
            this.top.children[this.index] = updated;
            if (updated.contentDOM) {
              updated.dirty = CONTENT_DIRTY;
              updated.updateChildren(view, pos + 1);
              updated.dirty = NOT_DIRTY;
            }
            this.changed = true;
            this.index++;
            return true;
          }
          break;
        }
      }
      return false;
    }
    // When a node with content is replaced by a different node with
    // identical content, move over its children.
    recreateWrapper(next2, node2, outerDeco, innerDeco, view, pos) {
      if (next2.dirty || node2.isAtom || !next2.children.length || !next2.node.content.eq(node2.content) || !sameOuterDeco(outerDeco, next2.outerDeco) || !innerDeco.eq(next2.innerDeco))
        return null;
      let wrapper = NodeViewDesc.create(this.top, node2, outerDeco, innerDeco, view, pos);
      if (wrapper.contentDOM) {
        wrapper.children = next2.children;
        next2.children = [];
        for (let ch of wrapper.children)
          ch.parent = wrapper;
      }
      next2.destroy();
      return wrapper;
    }
    // Insert the node as a newly created node desc.
    addNode(node2, outerDeco, innerDeco, view, pos) {
      let desc = NodeViewDesc.create(this.top, node2, outerDeco, innerDeco, view, pos);
      if (desc.contentDOM)
        desc.updateChildren(view, pos + 1);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
    placeWidget(widget, view, pos) {
      let next2 = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (next2 && next2.matchesWidget(widget) && (widget == next2.widget || !next2.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        let desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    }
    // Make sure a textblock looks and behaves correctly in
    // contentEditable.
    addTextblockHacks() {
      let lastChild = this.top.children[this.index - 1], parent = this.top;
      while (lastChild instanceof MarkViewDesc) {
        parent = lastChild;
        lastChild = parent.children[parent.children.length - 1];
      }
      if (!lastChild || // Empty textblock
      !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
          this.addHackNode("IMG", parent);
        this.addHackNode("BR", this.top);
      }
    }
    addHackNode(nodeName, parent) {
      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        let dom = document.createElement(nodeName);
        if (nodeName == "IMG") {
          dom.className = "ProseMirror-separator";
          dom.alt = "";
        }
        if (nodeName == "BR")
          dom.className = "ProseMirror-trailingBreak";
        let hack = new TrailingHackViewDesc(this.top, [], dom, null);
        if (parent != this.top)
          parent.children.push(hack);
        else
          parent.children.splice(this.index++, 0, hack);
        this.changed = true;
      }
    }
    isLocked(node2) {
      return this.lock && (node2 == this.lock || node2.nodeType == 1 && node2.contains(this.lock.parentNode));
    }
  };
  function preMatch(frag, parentDesc) {
    let curDesc = parentDesc, descI = curDesc.children.length;
    let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
    outer: while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next2 = curDesc.children[descI - 1];
          if (next2 instanceof MarkViewDesc) {
            curDesc = next2;
            descI = next2.children.length;
          } else {
            desc = next2;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node2 = desc.node;
      if (!node2)
        continue;
      if (node2 != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
    return { index: fI, matched, matches: matches2.reverse() };
  }
  function compareSide(a2, b) {
    return a2.type.side - b.type.side;
  }
  function iterDeco(parent, deco, onWidget, onNode) {
    let locals = deco.locals(parent), offset = 0;
    if (locals.length == 0) {
      for (let i = 0; i < parent.childCount; i++) {
        let child = parent.child(i);
        onNode(child, locals, deco.forChild(offset, child), i);
        offset += child.nodeSize;
      }
      return;
    }
    let decoIndex = 0, active = [], restNode = null;
    for (let parentIndex = 0; ; ) {
      let widget, widgets;
      while (decoIndex < locals.length && locals[decoIndex].to == offset) {
        let next2 = locals[decoIndex++];
        if (next2.widget) {
          if (!widget)
            widget = next2;
          else
            (widgets || (widgets = [widget])).push(next2);
        }
      }
      if (widget) {
        if (widgets) {
          widgets.sort(compareSide);
          for (let i = 0; i < widgets.length; i++)
            onWidget(widgets[i], parentIndex, !!restNode);
        } else {
          onWidget(widget, parentIndex, !!restNode);
        }
      }
      let child, index3;
      if (restNode) {
        index3 = -1;
        child = restNode;
        restNode = null;
      } else if (parentIndex < parent.childCount) {
        index3 = parentIndex;
        child = parent.child(parentIndex++);
      } else {
        break;
      }
      for (let i = 0; i < active.length; i++)
        if (active[i].to <= offset)
          active.splice(i--, 1);
      while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
        active.push(locals[decoIndex++]);
      let end = offset + child.nodeSize;
      if (child.isText) {
        let cutAt = end;
        if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
          cutAt = locals[decoIndex].from;
        for (let i = 0; i < active.length; i++)
          if (active[i].to < cutAt)
            cutAt = active[i].to;
        if (cutAt < end) {
          restNode = child.cut(cutAt - offset);
          child = child.cut(0, cutAt - offset);
          end = cutAt;
          index3 = -1;
        }
      } else {
        while (decoIndex < locals.length && locals[decoIndex].to < end)
          decoIndex++;
      }
      let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
      onNode(child, outerDeco, deco.forChild(offset, child), index3);
      offset = end;
    }
  }
  function iosHacks(dom) {
    if (dom.nodeName == "UL" || dom.nodeName == "OL") {
      let oldCSS = dom.style.cssText;
      dom.style.cssText = oldCSS + "; list-style: square !important";
      window.getComputedStyle(dom).listStyle;
      dom.style.cssText = oldCSS;
    }
  }
  function findTextInFragment(frag, text10, from4, to2) {
    for (let i = 0, pos = 0; i < frag.childCount && pos <= to2; ) {
      let child = frag.child(i++), childStart = pos;
      pos += child.nodeSize;
      if (!child.isText)
        continue;
      let str = child.text;
      while (i < frag.childCount) {
        let next2 = frag.child(i++);
        pos += next2.nodeSize;
        if (!next2.isText)
          break;
        str += next2.text;
      }
      if (pos >= from4) {
        if (pos >= to2 && str.slice(to2 - text10.length - childStart, to2 - childStart) == text10)
          return to2 - text10.length;
        let found2 = childStart < to2 ? str.lastIndexOf(text10, to2 - childStart - 1) : -1;
        if (found2 >= 0 && found2 + text10.length + childStart >= from4)
          return childStart + found2;
        if (from4 == to2 && str.length >= to2 + text10.length - childStart && str.slice(to2 - childStart, to2 - childStart + text10.length) == text10)
          return to2;
      }
    }
    return -1;
  }
  function replaceNodes(nodes, from4, to2, view, replacement) {
    let result = [];
    for (let i = 0, off = 0; i < nodes.length; i++) {
      let child = nodes[i], start = off, end = off += child.size;
      if (start >= to2 || end <= from4) {
        result.push(child);
      } else {
        if (start < from4)
          result.push(child.slice(0, from4 - start, view));
        if (replacement) {
          result.push(replacement);
          replacement = void 0;
        }
        if (end > to2)
          result.push(child.slice(to2 - start, child.size, view));
      }
    }
    return result;
  }
  function selectionFromDOM(view, origin = null) {
    let domSel = view.domSelectionRange(), doc4 = view.state.doc;
    if (!domSel.focusNode)
      return null;
    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
    let head2 = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
    if (head2 < 0)
      return null;
    let $head = doc4.resolve(head2), anchor, selection;
    if (selectionCollapsed(domSel)) {
      anchor = head2;
      while (nearestDesc && !nearestDesc.node)
        nearestDesc = nearestDesc.parent;
      let nearestDescNode = nearestDesc.node;
      if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
        let pos = nearestDesc.posBefore;
        selection = new NodeSelection(head2 == pos ? $head : doc4.resolve(pos));
      }
    } else {
      if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
        let min2 = head2, max2 = head2;
        for (let i = 0; i < domSel.rangeCount; i++) {
          let range = domSel.getRangeAt(i);
          min2 = Math.min(min2, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
          max2 = Math.max(max2, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
        }
        if (min2 < 0)
          return null;
        [anchor, head2] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
        $head = doc4.resolve(head2);
      } else {
        anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
      }
      if (anchor < 0)
        return null;
    }
    let $anchor = doc4.resolve(anchor);
    if (!selection) {
      let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
      selection = selectionBetween(view, $anchor, $head, bias);
    }
    return selection;
  }
  function editorOwnsSelection(view) {
    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
  }
  function selectionToDOM(view, force = false) {
    let sel = view.state.selection;
    syncNodeSelection(view, sel);
    if (!editorOwnsSelection(view))
      return;
    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
      let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
      if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
        view.input.mouseDown.delayedSelectionSync = true;
        view.domObserver.setCurSelection();
        return;
      }
    }
    view.domObserver.disconnectSelection();
    if (view.cursorWrapper) {
      selectCursorWrapper(view);
    } else {
      let { anchor, head: head2 } = sel, resetEditableFrom, resetEditableTo;
      if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
        if (!sel.$from.parent.inlineContent)
          resetEditableFrom = temporarilyEditableNear(view, sel.from);
        if (!sel.empty && !sel.$from.parent.inlineContent)
          resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
      view.docView.setSelection(anchor, head2, view, force);
      if (brokenSelectBetweenUneditable) {
        if (resetEditableFrom)
          resetEditable(resetEditableFrom);
        if (resetEditableTo)
          resetEditable(resetEditableTo);
      }
      if (sel.visible) {
        view.dom.classList.remove("ProseMirror-hideselection");
      } else {
        view.dom.classList.add("ProseMirror-hideselection");
        if ("onselectionchange" in document)
          removeClassOnSelectionChange(view);
      }
    }
    view.domObserver.setCurSelection();
    view.domObserver.connectSelection();
  }
  var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
  function temporarilyEditableNear(view, pos) {
    let { node: node2, offset } = view.docView.domFromPos(pos, 0);
    let after = offset < node2.childNodes.length ? node2.childNodes[offset] : null;
    let before = offset ? node2.childNodes[offset - 1] : null;
    if (safari && after && after.contentEditable == "false")
      return setEditable(after);
    if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
      if (after)
        return setEditable(after);
      else if (before)
        return setEditable(before);
    }
  }
  function setEditable(element7) {
    element7.contentEditable = "true";
    if (safari && element7.draggable) {
      element7.draggable = false;
      element7.wasDraggable = true;
    }
    return element7;
  }
  function resetEditable(element7) {
    element7.contentEditable = "false";
    if (element7.wasDraggable) {
      element7.draggable = true;
      element7.wasDraggable = null;
    }
  }
  function removeClassOnSelectionChange(view) {
    let doc4 = view.dom.ownerDocument;
    doc4.removeEventListener("selectionchange", view.input.hideSelectionGuard);
    let domSel = view.domSelectionRange();
    let node2 = domSel.anchorNode, offset = domSel.anchorOffset;
    doc4.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
      if (domSel.anchorNode != node2 || domSel.anchorOffset != offset) {
        doc4.removeEventListener("selectionchange", view.input.hideSelectionGuard);
        setTimeout(() => {
          if (!editorOwnsSelection(view) || view.state.selection.visible)
            view.dom.classList.remove("ProseMirror-hideselection");
        }, 20);
      }
    });
  }
  function selectCursorWrapper(view) {
    let domSel = view.domSelection(), range = document.createRange();
    if (!domSel)
      return;
    let node2 = view.cursorWrapper.dom, img2 = node2.nodeName == "IMG";
    if (img2)
      range.setStart(node2.parentNode, domIndex(node2) + 1);
    else
      range.setStart(node2, 0);
    range.collapse(true);
    domSel.removeAllRanges();
    domSel.addRange(range);
    if (!img2 && !view.state.selection.visible && ie && ie_version <= 11) {
      node2.disabled = true;
      node2.disabled = false;
    }
  }
  function syncNodeSelection(view, sel) {
    if (sel instanceof NodeSelection) {
      let desc = view.docView.descAt(sel.from);
      if (desc != view.lastSelectedViewDesc) {
        clearNodeSelection(view);
        if (desc)
          desc.selectNode();
        view.lastSelectedViewDesc = desc;
      }
    } else {
      clearNodeSelection(view);
    }
  }
  function clearNodeSelection(view) {
    if (view.lastSelectedViewDesc) {
      if (view.lastSelectedViewDesc.parent)
        view.lastSelectedViewDesc.deselectNode();
      view.lastSelectedViewDesc = void 0;
    }
  }
  function selectionBetween(view, $anchor, $head, bias) {
    return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
  }
  function hasFocusAndSelection(view) {
    if (view.editable && !view.hasFocus())
      return false;
    return hasSelection(view);
  }
  function hasSelection(view) {
    let sel = view.domSelectionRange();
    if (!sel.anchorNode)
      return false;
    try {
      return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
    } catch (_2) {
      return false;
    }
  }
  function anchorInRightPlace(view) {
    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
    let domSel = view.domSelectionRange();
    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
  }
  function moveSelectionBlock(state, dir) {
    let { $anchor, $head } = state.selection;
    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
    return $start && Selection.findFrom($start, dir);
  }
  function apply(view, sel) {
    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
    return true;
  }
  function selectHorizontally(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection) {
      if (mods.indexOf("s") > -1) {
        let { $head } = sel, node2 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
        if (!node2 || node2.isText || !node2.isLeaf)
          return false;
        let $newHead = view.state.doc.resolve($head.pos + node2.nodeSize * (dir < 0 ? -1 : 1));
        return apply(view, new TextSelection(sel.$anchor, $newHead));
      } else if (!sel.empty) {
        return false;
      } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
        let next2 = moveSelectionBlock(view.state, dir);
        if (next2 && next2 instanceof NodeSelection)
          return apply(view, next2);
        return false;
      } else if (!(mac && mods.indexOf("m") > -1)) {
        let $head = sel.$head, node2 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
        if (!node2 || node2.isText)
          return false;
        let nodePos = dir < 0 ? $head.pos - node2.nodeSize : $head.pos;
        if (!(node2.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
          return false;
        if (NodeSelection.isSelectable(node2)) {
          return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node2.nodeSize) : $head));
        } else if (webkit) {
          return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node2.nodeSize)));
        } else {
          return false;
        }
      }
    } else if (sel instanceof NodeSelection && sel.node.isInline) {
      return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
    } else {
      let next2 = moveSelectionBlock(view.state, dir);
      if (next2)
        return apply(view, next2);
      return false;
    }
  }
  function nodeLen(node2) {
    return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
  }
  function isIgnorable(dom, dir) {
    let desc = dom.pmViewDesc;
    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
  }
  function skipIgnoredNodes(view, dir) {
    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
  }
  function skipIgnoredNodesBefore(view) {
    let sel = view.domSelectionRange();
    let node2 = sel.focusNode, offset = sel.focusOffset;
    if (!node2)
      return;
    let moveNode, moveOffset, force = false;
    if (gecko && node2.nodeType == 1 && offset < nodeLen(node2) && isIgnorable(node2.childNodes[offset], -1))
      force = true;
    for (; ; ) {
      if (offset > 0) {
        if (node2.nodeType != 1) {
          break;
        } else {
          let before = node2.childNodes[offset - 1];
          if (isIgnorable(before, -1)) {
            moveNode = node2;
            moveOffset = --offset;
          } else if (before.nodeType == 3) {
            node2 = before;
            offset = node2.nodeValue.length;
          } else
            break;
        }
      } else if (isBlockNode(node2)) {
        break;
      } else {
        let prev = node2.previousSibling;
        while (prev && isIgnorable(prev, -1)) {
          moveNode = node2.parentNode;
          moveOffset = domIndex(prev);
          prev = prev.previousSibling;
        }
        if (!prev) {
          node2 = node2.parentNode;
          if (node2 == view.dom)
            break;
          offset = 0;
        } else {
          node2 = prev;
          offset = nodeLen(node2);
        }
      }
    }
    if (force)
      setSelFocus(view, node2, offset);
    else if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function skipIgnoredNodesAfter(view) {
    let sel = view.domSelectionRange();
    let node2 = sel.focusNode, offset = sel.focusOffset;
    if (!node2)
      return;
    let len = nodeLen(node2);
    let moveNode, moveOffset;
    for (; ; ) {
      if (offset < len) {
        if (node2.nodeType != 1)
          break;
        let after = node2.childNodes[offset];
        if (isIgnorable(after, 1)) {
          moveNode = node2;
          moveOffset = ++offset;
        } else
          break;
      } else if (isBlockNode(node2)) {
        break;
      } else {
        let next2 = node2.nextSibling;
        while (next2 && isIgnorable(next2, 1)) {
          moveNode = next2.parentNode;
          moveOffset = domIndex(next2) + 1;
          next2 = next2.nextSibling;
        }
        if (!next2) {
          node2 = node2.parentNode;
          if (node2 == view.dom)
            break;
          offset = len = 0;
        } else {
          node2 = next2;
          offset = 0;
          len = nodeLen(node2);
        }
      }
    }
    if (moveNode)
      setSelFocus(view, moveNode, moveOffset);
  }
  function isBlockNode(dom) {
    let desc = dom.pmViewDesc;
    return desc && desc.node && desc.node.isBlock;
  }
  function textNodeAfter(node2, offset) {
    while (node2 && offset == node2.childNodes.length && !hasBlockDesc(node2)) {
      offset = domIndex(node2) + 1;
      node2 = node2.parentNode;
    }
    while (node2 && offset < node2.childNodes.length) {
      let next2 = node2.childNodes[offset];
      if (next2.nodeType == 3)
        return next2;
      if (next2.nodeType == 1 && next2.contentEditable == "false")
        break;
      node2 = next2;
      offset = 0;
    }
  }
  function textNodeBefore(node2, offset) {
    while (node2 && !offset && !hasBlockDesc(node2)) {
      offset = domIndex(node2);
      node2 = node2.parentNode;
    }
    while (node2 && offset) {
      let next2 = node2.childNodes[offset - 1];
      if (next2.nodeType == 3)
        return next2;
      if (next2.nodeType == 1 && next2.contentEditable == "false")
        break;
      node2 = next2;
      offset = node2.childNodes.length;
    }
  }
  function setSelFocus(view, node2, offset) {
    if (node2.nodeType != 3) {
      let before, after;
      if (after = textNodeAfter(node2, offset)) {
        node2 = after;
        offset = 0;
      } else if (before = textNodeBefore(node2, offset)) {
        node2 = before;
        offset = before.nodeValue.length;
      }
    }
    let sel = view.domSelection();
    if (!sel)
      return;
    if (selectionCollapsed(sel)) {
      let range = document.createRange();
      range.setEnd(node2, offset);
      range.setStart(node2, offset);
      sel.removeAllRanges();
      sel.addRange(range);
    } else if (sel.extend) {
      sel.extend(node2, offset);
    }
    view.domObserver.setCurSelection();
    let { state } = view;
    setTimeout(() => {
      if (view.state == state)
        selectionToDOM(view);
    }, 50);
  }
  function findDirection(view, pos) {
    let $pos = view.state.doc.resolve(pos);
    if (!(chrome || windows) && $pos.parent.inlineContent) {
      let coords = view.coordsAtPos(pos);
      if (pos > $pos.start()) {
        let before = view.coordsAtPos(pos - 1);
        let mid = (before.top + before.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
          return before.left < coords.left ? "ltr" : "rtl";
      }
      if (pos < $pos.end()) {
        let after = view.coordsAtPos(pos + 1);
        let mid = (after.top + after.bottom) / 2;
        if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
          return after.left > coords.left ? "ltr" : "rtl";
      }
    }
    let computed = getComputedStyle(view.dom).direction;
    return computed == "rtl" ? "rtl" : "ltr";
  }
  function selectVertically(view, dir, mods) {
    let sel = view.state.selection;
    if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
      return false;
    if (mac && mods.indexOf("m") > -1)
      return false;
    let { $from, $to } = sel;
    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
      let next2 = moveSelectionBlock(view.state, dir);
      if (next2 && next2 instanceof NodeSelection)
        return apply(view, next2);
    }
    if (!$from.parent.inlineContent) {
      let side = dir < 0 ? $from : $to;
      let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
      return beyond ? apply(view, beyond) : false;
    }
    return false;
  }
  function stopNativeHorizontalDelete(view, dir) {
    if (!(view.state.selection instanceof TextSelection))
      return true;
    let { $head, $anchor, empty: empty4 } = view.state.selection;
    if (!$head.sameParent($anchor))
      return true;
    if (!empty4)
      return false;
    if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
      return true;
    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
    if (nextNode && !nextNode.isText) {
      let tr3 = view.state.tr;
      if (dir < 0)
        tr3.delete($head.pos - nextNode.nodeSize, $head.pos);
      else
        tr3.delete($head.pos, $head.pos + nextNode.nodeSize);
      view.dispatch(tr3);
      return true;
    }
    return false;
  }
  function switchEditable(view, node2, state) {
    view.domObserver.stop();
    node2.contentEditable = state;
    view.domObserver.start();
  }
  function safariDownArrowBug(view) {
    if (!safari || view.state.selection.$head.parentOffset > 0)
      return false;
    let { focusNode, focusOffset } = view.domSelectionRange();
    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
      let child = focusNode.firstChild;
      switchEditable(view, child, "true");
      setTimeout(() => switchEditable(view, child, "false"), 20);
    }
    return false;
  }
  function getMods(event) {
    let result = "";
    if (event.ctrlKey)
      result += "c";
    if (event.metaKey)
      result += "m";
    if (event.altKey)
      result += "a";
    if (event.shiftKey)
      result += "s";
    return result;
  }
  function captureKeyDown(view, event) {
    let code5 = event.keyCode, mods = getMods(event);
    if (code5 == 8 || mac && code5 == 72 && mods == "c") {
      return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
    } else if (code5 == 46 && !event.shiftKey || mac && code5 == 68 && mods == "c") {
      return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
    } else if (code5 == 13 || code5 == 27) {
      return true;
    } else if (code5 == 37 || mac && code5 == 66 && mods == "c") {
      let dir = code5 == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code5 == 39 || mac && code5 == 70 && mods == "c") {
      let dir = code5 == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
    } else if (code5 == 38 || mac && code5 == 80 && mods == "c") {
      return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
    } else if (code5 == 40 || mac && code5 == 78 && mods == "c") {
      return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
    } else if (mods == (mac ? "m" : "c") && (code5 == 66 || code5 == 73 || code5 == 89 || code5 == 90)) {
      return true;
    }
    return false;
  }
  function serializeForClipboard(view, slice2) {
    view.someProp("transformCopied", (f) => {
      slice2 = f(slice2, view);
    });
    let context = [], { content: content5, openStart, openEnd } = slice2;
    while (openStart > 1 && openEnd > 1 && content5.childCount == 1 && content5.firstChild.childCount == 1) {
      openStart--;
      openEnd--;
      let node2 = content5.firstChild;
      context.push(node2.type.name, node2.attrs != node2.type.defaultAttrs ? node2.attrs : null);
      content5 = node2.content;
    }
    let serializer2 = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
    let doc4 = detachedDoc(), wrap5 = doc4.createElement("div");
    wrap5.appendChild(serializer2.serializeFragment(content5, { document: doc4 }));
    let firstChild = wrap5.firstChild, needsWrap, wrappers = 0;
    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
      for (let i = needsWrap.length - 1; i >= 0; i--) {
        let wrapper = doc4.createElement(needsWrap[i]);
        while (wrap5.firstChild)
          wrapper.appendChild(wrap5.firstChild);
        wrap5.appendChild(wrapper);
        wrappers++;
      }
      firstChild = wrap5.firstChild;
    }
    if (firstChild && firstChild.nodeType == 1)
      firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
    let text10 = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
    return { dom: wrap5, text: text10, slice: slice2 };
  }
  function parseFromClipboard(view, text10, html7, plainText, $context) {
    let inCode = $context.parent.type.spec.code;
    let dom, slice2;
    if (!html7 && !text10)
      return null;
    let asText = text10 && (plainText || inCode || !html7);
    if (asText) {
      view.someProp("transformPastedText", (f) => {
        text10 = f(text10, inCode || plainText, view);
      });
      if (inCode)
        return text10 ? new Slice(Fragment.from(view.state.schema.text(text10.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
      let parsed = view.someProp("clipboardTextParser", (f) => f(text10, $context, plainText, view));
      if (parsed) {
        slice2 = parsed;
      } else {
        let marks = $context.marks();
        let { schema } = view.state, serializer2 = DOMSerializer.fromSchema(schema);
        dom = document.createElement("div");
        text10.split(/(?:\r\n?|\n)+/).forEach((block) => {
          let p5 = dom.appendChild(document.createElement("p"));
          if (block)
            p5.appendChild(serializer2.serializeNode(schema.text(block, marks)));
        });
      }
    } else {
      view.someProp("transformPastedHTML", (f) => {
        html7 = f(html7, view);
      });
      dom = readHTML(html7);
      if (webkit)
        restoreReplacedSpaces(dom);
    }
    let contextNode = dom && dom.querySelector("[data-pm-slice]");
    let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
    if (sliceData && sliceData[3])
      for (let i = +sliceData[3]; i > 0; i--) {
        let child = dom.firstChild;
        while (child && child.nodeType != 1)
          child = child.nextSibling;
        if (!child)
          break;
        dom = child;
      }
    if (!slice2) {
      let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
      slice2 = parser.parseSlice(dom, {
        preserveWhitespace: !!(asText || sliceData),
        context: $context,
        ruleFromNode(dom2) {
          if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
            return { ignore: true };
          return null;
        }
      });
    }
    if (sliceData) {
      slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
    } else {
      slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
      if (slice2.openStart || slice2.openEnd) {
        let openStart = 0, openEnd = 0;
        for (let node2 = slice2.content.firstChild; openStart < slice2.openStart && !node2.type.spec.isolating; openStart++, node2 = node2.firstChild) {
        }
        for (let node2 = slice2.content.lastChild; openEnd < slice2.openEnd && !node2.type.spec.isolating; openEnd++, node2 = node2.lastChild) {
        }
        slice2 = closeSlice(slice2, openStart, openEnd);
      }
    }
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
    return slice2;
  }
  var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function normalizeSiblings(fragment2, $context) {
    if (fragment2.childCount < 2)
      return fragment2;
    for (let d = $context.depth; d >= 0; d--) {
      let parent = $context.node(d);
      let match = parent.contentMatchAt($context.index(d));
      let lastWrap, result = [];
      fragment2.forEach((node2) => {
        if (!result)
          return;
        let wrap5 = match.findWrapping(node2.type), inLast;
        if (!wrap5)
          return result = null;
        if (inLast = result.length && lastWrap.length && addToSibling(wrap5, lastWrap, node2, result[result.length - 1], 0)) {
          result[result.length - 1] = inLast;
        } else {
          if (result.length)
            result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
          let wrapped = withWrappers(node2, wrap5);
          result.push(wrapped);
          match = match.matchType(wrapped.type);
          lastWrap = wrap5;
        }
      });
      if (result)
        return Fragment.from(result);
    }
    return fragment2;
  }
  function withWrappers(node2, wrap5, from4 = 0) {
    for (let i = wrap5.length - 1; i >= from4; i--)
      node2 = wrap5[i].create(null, Fragment.from(node2));
    return node2;
  }
  function addToSibling(wrap5, lastWrap, node2, sibling, depth) {
    if (depth < wrap5.length && depth < lastWrap.length && wrap5[depth] == lastWrap[depth]) {
      let inner = addToSibling(wrap5, lastWrap, node2, sibling.lastChild, depth + 1);
      if (inner)
        return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
      let match = sibling.contentMatchAt(sibling.childCount);
      if (match.matchType(depth == wrap5.length - 1 ? node2.type : wrap5[depth + 1]))
        return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node2, wrap5, depth + 1))));
    }
  }
  function closeRight(node2, depth) {
    if (depth == 0)
      return node2;
    let fragment2 = node2.content.replaceChild(node2.childCount - 1, closeRight(node2.lastChild, depth - 1));
    let fill = node2.contentMatchAt(node2.childCount).fillBefore(Fragment.empty, true);
    return node2.copy(fragment2.append(fill));
  }
  function closeRange(fragment2, side, from4, to2, depth, openEnd) {
    let node2 = side < 0 ? fragment2.firstChild : fragment2.lastChild, inner = node2.content;
    if (fragment2.childCount > 1)
      openEnd = 0;
    if (depth < to2 - 1)
      inner = closeRange(inner, side, from4, to2, depth + 1, openEnd);
    if (depth >= from4)
      inner = side < 0 ? node2.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node2.contentMatchAt(node2.childCount).fillBefore(Fragment.empty, true));
    return fragment2.replaceChild(side < 0 ? 0 : fragment2.childCount - 1, node2.copy(inner));
  }
  function closeSlice(slice2, openStart, openEnd) {
    if (openStart < slice2.openStart)
      slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
    if (openEnd < slice2.openEnd)
      slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
    return slice2;
  }
  var wrapMap = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  };
  var _detachedDoc = null;
  function detachedDoc() {
    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
  }
  var _policy = null;
  function maybeWrapTrusted(html7) {
    let trustedTypes = window.trustedTypes;
    if (!trustedTypes)
      return html7;
    if (!_policy)
      _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s2) => s2 });
    return _policy.createHTML(html7);
  }
  function readHTML(html7) {
    let metas = /^(\s*<meta [^>]*>)*/.exec(html7);
    if (metas)
      html7 = html7.slice(metas[0].length);
    let elt = detachedDoc().createElement("div");
    let firstTag = /<([a-z][^>\s]+)/i.exec(html7), wrap5;
    if (wrap5 = firstTag && wrapMap[firstTag[1].toLowerCase()])
      html7 = wrap5.map((n) => "<" + n + ">").join("") + html7 + wrap5.map((n) => "</" + n + ">").reverse().join("");
    elt.innerHTML = maybeWrapTrusted(html7);
    if (wrap5)
      for (let i = 0; i < wrap5.length; i++)
        elt = elt.querySelector(wrap5[i]) || elt;
    return elt;
  }
  function restoreReplacedSpaces(dom) {
    let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
    for (let i = 0; i < nodes.length; i++) {
      let node2 = nodes[i];
      if (node2.childNodes.length == 1 && node2.textContent == "\xA0" && node2.parentNode)
        node2.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node2);
    }
  }
  function addContext(slice2, context) {
    if (!slice2.size)
      return slice2;
    let schema = slice2.content.firstChild.type.schema, array;
    try {
      array = JSON.parse(context);
    } catch (e) {
      return slice2;
    }
    let { content: content5, openStart, openEnd } = slice2;
    for (let i = array.length - 2; i >= 0; i -= 2) {
      let type = schema.nodes[array[i]];
      if (!type || type.hasRequiredAttrs())
        break;
      content5 = Fragment.from(type.create(array[i + 1], content5));
      openStart++;
      openEnd++;
    }
    return new Slice(content5, openStart, openEnd);
  }
  var handlers3 = {};
  var editHandlers = {};
  var passiveHandlers = { touchstart: true, touchmove: true };
  var InputState = class {
    constructor() {
      this.shiftKey = false;
      this.mouseDown = null;
      this.lastKeyCode = null;
      this.lastKeyCodeTime = 0;
      this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastIOSEnter = 0;
      this.lastIOSEnterFallbackTimeout = -1;
      this.lastFocus = 0;
      this.lastTouch = 0;
      this.lastChromeDelete = 0;
      this.composing = false;
      this.compositionNode = null;
      this.composingTimeout = -1;
      this.compositionNodes = [];
      this.compositionEndedAt = -2e8;
      this.compositionID = 1;
      this.compositionPendingChanges = 0;
      this.domChangeCount = 0;
      this.eventHandlers = /* @__PURE__ */ Object.create(null);
      this.hideSelectionGuard = null;
    }
  };
  function initInput(view) {
    for (let event in handlers3) {
      let handler = handlers3[event];
      view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
        if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
          handler(view, event2);
      }, passiveHandlers[event] ? { passive: true } : void 0);
    }
    if (safari)
      view.dom.addEventListener("input", () => null);
    ensureListeners(view);
  }
  function setSelectionOrigin(view, origin) {
    view.input.lastSelectionOrigin = origin;
    view.input.lastSelectionTime = Date.now();
  }
  function destroyInput(view) {
    view.domObserver.stop();
    for (let type in view.input.eventHandlers)
      view.dom.removeEventListener(type, view.input.eventHandlers[type]);
    clearTimeout(view.input.composingTimeout);
    clearTimeout(view.input.lastIOSEnterFallbackTimeout);
  }
  function ensureListeners(view) {
    view.someProp("handleDOMEvents", (currentHandlers) => {
      for (let type in currentHandlers)
        if (!view.input.eventHandlers[type])
          view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
    });
  }
  function runCustomHandler(view, event) {
    return view.someProp("handleDOMEvents", (handlers4) => {
      let handler = handlers4[event.type];
      return handler ? handler(view, event) || event.defaultPrevented : false;
    });
  }
  function eventBelongsToView(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node2 = event.target; node2 != view.dom; node2 = node2.parentNode)
      if (!node2 || node2.nodeType == 11 || node2.pmViewDesc && node2.pmViewDesc.stopEvent(event))
        return false;
    return true;
  }
  function dispatchEvent(view, event) {
    if (!runCustomHandler(view, event) && handlers3[event.type] && (view.editable || !(event.type in editHandlers)))
      handlers3[event.type](view, event);
  }
  editHandlers.keydown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
    if (inOrNearComposition(view, event))
      return;
    view.input.lastKeyCode = event.keyCode;
    view.input.lastKeyCodeTime = Date.now();
    if (android && chrome && event.keyCode == 13)
      return;
    if (event.keyCode != 229)
      view.domObserver.forceFlush();
    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
      let now = Date.now();
      view.input.lastIOSEnter = now;
      view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        if (view.input.lastIOSEnter == now) {
          view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
          view.input.lastIOSEnter = 0;
        }
      }, 200);
    } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "key");
    }
  };
  editHandlers.keyup = (view, event) => {
    if (event.keyCode == 16)
      view.input.shiftKey = false;
  };
  editHandlers.keypress = (view, _event) => {
    let event = _event;
    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
      return;
    if (view.someProp("handleKeyPress", (f) => f(view, event))) {
      event.preventDefault();
      return;
    }
    let sel = view.state.selection;
    if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
      let text10 = String.fromCharCode(event.charCode);
      let deflt = () => view.state.tr.insertText(text10).scrollIntoView();
      if (!/[\r\n]/.test(text10) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text10, deflt)))
        view.dispatch(deflt());
      event.preventDefault();
    }
  };
  function eventCoords(event) {
    return { left: event.clientX, top: event.clientY };
  }
  function isNear(event, click) {
    let dx = click.x - event.clientX, dy = click.y - event.clientY;
    return dx * dx + dy * dy < 100;
  }
  function runHandlerOnContext(view, propName, pos, inside, event) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
        return true;
    }
    return false;
  }
  function updateSelection(view, selection, origin) {
    if (!view.focused)
      view.focus();
    if (view.state.selection.eq(selection))
      return;
    let tr3 = view.state.tr.setSelection(selection);
    if (origin == "pointer")
      tr3.setMeta("pointer", true);
    view.dispatch(tr3);
  }
  function selectClickedLeaf(view, inside) {
    if (inside == -1)
      return false;
    let $pos = view.state.doc.resolve(inside), node2 = $pos.nodeAfter;
    if (node2 && node2.isAtom && NodeSelection.isSelectable(node2)) {
      updateSelection(view, new NodeSelection($pos), "pointer");
      return true;
    }
    return false;
  }
  function selectClickedNode(view, inside) {
    if (inside == -1)
      return false;
    let sel = view.state.selection, selectedNode, selectAt;
    if (sel instanceof NodeSelection)
      selectedNode = sel.node;
    let $pos = view.state.doc.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      let node2 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
      if (NodeSelection.isSelectable(node2)) {
        if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
          selectAt = $pos.before(sel.$from.depth);
        else
          selectAt = $pos.before(i);
        break;
      }
    }
    if (selectAt != null) {
      updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
      return true;
    } else {
      return false;
    }
  }
  function handleSingleClick(view, pos, inside, event, selectNode) {
    return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
  }
  function handleDoubleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
  }
  function handleTripleClick(view, pos, inside, event) {
    return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
  }
  function defaultTripleClick(view, inside, event) {
    if (event.button != 0)
      return false;
    let doc4 = view.state.doc;
    if (inside == -1) {
      if (doc4.inlineContent) {
        updateSelection(view, TextSelection.create(doc4, 0, doc4.content.size), "pointer");
        return true;
      }
      return false;
    }
    let $pos = doc4.resolve(inside);
    for (let i = $pos.depth + 1; i > 0; i--) {
      let node2 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
      let nodePos = $pos.before(i);
      if (node2.inlineContent)
        updateSelection(view, TextSelection.create(doc4, nodePos + 1, nodePos + 1 + node2.content.size), "pointer");
      else if (NodeSelection.isSelectable(node2))
        updateSelection(view, NodeSelection.create(doc4, nodePos), "pointer");
      else
        continue;
      return true;
    }
  }
  function forceDOMFlush(view) {
    return endComposition(view);
  }
  var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
  handlers3.mousedown = (view, _event) => {
    let event = _event;
    view.input.shiftKey = event.shiftKey;
    let flushed = forceDOMFlush(view);
    let now = Date.now(), type = "singleClick";
    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
      if (view.input.lastClick.type == "singleClick")
        type = "doubleClick";
      else if (view.input.lastClick.type == "doubleClick")
        type = "tripleClick";
    }
    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };
    let pos = view.posAtCoords(eventCoords(event));
    if (!pos)
      return;
    if (type == "singleClick") {
      if (view.input.mouseDown)
        view.input.mouseDown.done();
      view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
    } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
      event.preventDefault();
    } else {
      setSelectionOrigin(view, "pointer");
    }
  };
  var MouseDown = class {
    constructor(view, pos, event, flushed) {
      this.view = view;
      this.pos = pos;
      this.event = event;
      this.flushed = flushed;
      this.delayedSelectionSync = false;
      this.mightDrag = null;
      this.startDoc = view.state.doc;
      this.selectNode = !!event[selectNodeModifier];
      this.allowDefault = event.shiftKey;
      let targetNode, targetPos;
      if (pos.inside > -1) {
        targetNode = view.state.doc.nodeAt(pos.inside);
        targetPos = pos.inside;
      } else {
        let $pos = view.state.doc.resolve(pos.pos);
        targetNode = $pos.parent;
        targetPos = $pos.depth ? $pos.before() : 0;
      }
      const target = flushed ? null : event.target;
      const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
      this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
      let { selection } = view.state;
      if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
        this.mightDrag = {
          node: targetNode,
          pos: targetPos,
          addAttr: !!(this.target && !this.target.draggable),
          setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
        };
      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr)
          this.target.draggable = true;
        if (this.mightDrag.setUneditable)
          setTimeout(() => {
            if (this.view.input.mouseDown == this)
              this.target.setAttribute("contentEditable", "false");
          }, 20);
        this.view.domObserver.start();
      }
      view.root.addEventListener("mouseup", this.up = this.up.bind(this));
      view.root.addEventListener("mousemove", this.move = this.move.bind(this));
      setSelectionOrigin(view, "pointer");
    }
    done() {
      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);
      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr)
          this.target.removeAttribute("draggable");
        if (this.mightDrag.setUneditable)
          this.target.removeAttribute("contentEditable");
        this.view.domObserver.start();
      }
      if (this.delayedSelectionSync)
        setTimeout(() => selectionToDOM(this.view));
      this.view.input.mouseDown = null;
    }
    up(event) {
      this.done();
      if (!this.view.dom.contains(event.target))
        return;
      let pos = this.pos;
      if (this.view.state.doc != this.startDoc)
        pos = this.view.posAtCoords(eventCoords(event));
      this.updateAllowDefault(event);
      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
      safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
      // cursor, but still report that the node is selected
      // when asked through getSelection. You'll then get a
      // situation where clicking at the point where that
      // (hidden) cursor is doesn't change the selection, and
      // thus doesn't get a reaction from ProseMirror. This
      // works around that.
      chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
        updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    }
    move(event) {
      this.updateAllowDefault(event);
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0)
        this.done();
    }
    updateAllowDefault(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
        this.allowDefault = true;
    }
  };
  handlers3.touchstart = (view) => {
    view.input.lastTouch = Date.now();
    forceDOMFlush(view);
    setSelectionOrigin(view, "pointer");
  };
  handlers3.touchmove = (view) => {
    view.input.lastTouch = Date.now();
    setSelectionOrigin(view, "pointer");
  };
  handlers3.contextmenu = (view) => forceDOMFlush(view);
  function inOrNearComposition(view, event) {
    if (view.composing)
      return true;
    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
      view.input.compositionEndedAt = -2e8;
      return true;
    }
    return false;
  }
  var timeoutComposition = android ? 5e3 : -1;
  editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
    if (!view.composing) {
      view.domObserver.flush();
      let { state } = view, $pos = state.selection.$to;
      if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
        view.markCursor = view.state.storedMarks || $pos.marks();
        endComposition(view, true);
        view.markCursor = null;
      } else {
        endComposition(view, !state.selection.empty);
        if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
          let sel = view.domSelectionRange();
          for (let node2 = sel.focusNode, offset = sel.focusOffset; node2 && node2.nodeType == 1 && offset != 0; ) {
            let before = offset < 0 ? node2.lastChild : node2.childNodes[offset - 1];
            if (!before)
              break;
            if (before.nodeType == 3) {
              let sel2 = view.domSelection();
              if (sel2)
                sel2.collapse(before, before.nodeValue.length);
              break;
            } else {
              node2 = before;
              offset = -1;
            }
          }
        }
      }
      view.input.composing = true;
    }
    scheduleComposeEnd(view, timeoutComposition);
  };
  editHandlers.compositionend = (view, event) => {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = event.timeStamp;
      view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
      view.input.compositionNode = null;
      if (view.input.compositionPendingChanges)
        Promise.resolve().then(() => view.domObserver.flush());
      view.input.compositionID++;
      scheduleComposeEnd(view, 20);
    }
  };
  function scheduleComposeEnd(view, delay) {
    clearTimeout(view.input.composingTimeout);
    if (delay > -1)
      view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
  }
  function clearComposition(view) {
    if (view.composing) {
      view.input.composing = false;
      view.input.compositionEndedAt = timestampFromCustomEvent();
    }
    while (view.input.compositionNodes.length > 0)
      view.input.compositionNodes.pop().markParentsDirty();
  }
  function findCompositionNode(view) {
    let sel = view.domSelectionRange();
    if (!sel.focusNode)
      return null;
    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
    if (textBefore && textAfter && textBefore != textAfter) {
      let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
      if (textBefore == lastChanged || textAfter == lastChanged)
        return lastChanged;
      if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
        return textAfter;
      } else if (view.input.compositionNode == textAfter) {
        let descBefore = textBefore.pmViewDesc;
        if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
          return textAfter;
      }
    }
    return textBefore || textAfter;
  }
  function timestampFromCustomEvent() {
    let event = document.createEvent("Event");
    event.initEvent("event", true, true);
    return event.timeStamp;
  }
  function endComposition(view, restarting = false) {
    if (android && view.domObserver.flushingSoon >= 0)
      return;
    view.domObserver.forceFlush();
    clearComposition(view);
    if (restarting || view.docView && view.docView.dirty) {
      let sel = selectionFromDOM(view), cur = view.state.selection;
      if (sel && !sel.eq(cur))
        view.dispatch(view.state.tr.setSelection(sel));
      else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
        view.dispatch(view.state.tr.deleteSelection());
      else
        view.updateState(view.state);
      return true;
    }
    return false;
  }
  function captureCopy(view, dom) {
    if (!view.dom.parentNode)
      return;
    let wrap5 = view.dom.parentNode.appendChild(document.createElement("div"));
    wrap5.appendChild(dom);
    wrap5.style.cssText = "position: fixed; left: -10000px; top: 10px";
    let sel = getSelection(), range = document.createRange();
    range.selectNodeContents(dom);
    view.dom.blur();
    sel.removeAllRanges();
    sel.addRange(range);
    setTimeout(() => {
      if (wrap5.parentNode)
        wrap5.parentNode.removeChild(wrap5);
      view.focus();
    }, 50);
  }
  var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
  handlers3.copy = editHandlers.cut = (view, _event) => {
    let event = _event;
    let sel = view.state.selection, cut2 = event.type == "cut";
    if (sel.empty)
      return;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let slice2 = sel.content(), { dom, text: text10 } = serializeForClipboard(view, slice2);
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/html", dom.innerHTML);
      data.setData("text/plain", text10);
    } else {
      captureCopy(view, dom);
    }
    if (cut2)
      view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
  };
  function sliceSingleNode(slice2) {
    return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
  }
  function capturePaste(view, event) {
    if (!view.dom.parentNode)
      return;
    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
    if (!plainText)
      target.contentEditable = "true";
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    setTimeout(() => {
      view.focus();
      if (target.parentNode)
        target.parentNode.removeChild(target);
      if (plainText)
        doPaste(view, target.value, null, plain, event);
      else
        doPaste(view, target.textContent, target.innerHTML, plain, event);
    }, 50);
  }
  function doPaste(view, text10, html7, preferPlain, event) {
    let slice2 = parseFromClipboard(view, text10, html7, preferPlain, view.state.selection.$from);
    if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
      return true;
    if (!slice2)
      return false;
    let singleNode = sliceSingleNode(slice2);
    let tr3 = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
    view.dispatch(tr3.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
    return true;
  }
  function getText(clipboardData) {
    let text10 = clipboardData.getData("text/plain") || clipboardData.getData("Text");
    if (text10)
      return text10;
    let uris = clipboardData.getData("text/uri-list");
    return uris ? uris.replace(/\r?\n/g, " ") : "";
  }
  editHandlers.paste = (view, _event) => {
    let event = _event;
    if (view.composing && !android)
      return;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
    if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
      event.preventDefault();
    else
      capturePaste(view, event);
  };
  var Dragging = class {
    constructor(slice2, move, node2) {
      this.slice = slice2;
      this.move = move;
      this.node = node2;
    }
  };
  var dragCopyModifier = mac ? "altKey" : "ctrlKey";
  function dragMoves(view, event) {
    let moves = view.someProp("dragCopies", (test2) => !test2(event));
    return moves != null ? moves : !event[dragCopyModifier];
  }
  handlers3.dragstart = (view, _event) => {
    let event = _event;
    let mouseDown = view.input.mouseDown;
    if (mouseDown)
      mouseDown.done();
    if (!event.dataTransfer)
      return;
    let sel = view.state.selection;
    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
    let node2;
    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
    else if (mouseDown && mouseDown.mightDrag) {
      node2 = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
    } else if (event.target && event.target.nodeType == 1) {
      let desc = view.docView.nearestDesc(event.target, true);
      if (desc && desc.node.type.spec.draggable && desc != view.docView)
        node2 = NodeSelection.create(view.state.doc, desc.posBefore);
    }
    let draggedSlice = (node2 || view.state.selection).content();
    let { dom, text: text10, slice: slice2 } = serializeForClipboard(view, draggedSlice);
    if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
      event.dataTransfer.clearData();
    event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
    event.dataTransfer.effectAllowed = "copyMove";
    if (!brokenClipboardAPI)
      event.dataTransfer.setData("text/plain", text10);
    view.dragging = new Dragging(slice2, dragMoves(view, event), node2);
  };
  handlers3.dragend = (view) => {
    let dragging = view.dragging;
    window.setTimeout(() => {
      if (view.dragging == dragging)
        view.dragging = null;
    }, 50);
  };
  editHandlers.dragover = editHandlers.dragenter = (_2, e) => e.preventDefault();
  editHandlers.drop = (view, _event) => {
    let event = _event;
    let dragging = view.dragging;
    view.dragging = null;
    if (!event.dataTransfer)
      return;
    let eventPos = view.posAtCoords(eventCoords(event));
    if (!eventPos)
      return;
    let $mouse = view.state.doc.resolve(eventPos.pos);
    let slice2 = dragging && dragging.slice;
    if (slice2) {
      view.someProp("transformPasted", (f) => {
        slice2 = f(slice2, view);
      });
    } else {
      slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
    }
    let move = !!(dragging && dragMoves(view, event));
    if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
      event.preventDefault();
      return;
    }
    if (!slice2)
      return;
    event.preventDefault();
    let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
    if (insertPos == null)
      insertPos = $mouse.pos;
    let tr3 = view.state.tr;
    if (move) {
      let { node: node2 } = dragging;
      if (node2)
        node2.replace(tr3);
      else
        tr3.deleteSelection();
    }
    let pos = tr3.mapping.map(insertPos);
    let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
    let beforeInsert = tr3.doc;
    if (isNode2)
      tr3.replaceRangeWith(pos, pos, slice2.content.firstChild);
    else
      tr3.replaceRange(pos, pos, slice2);
    if (tr3.doc.eq(beforeInsert))
      return;
    let $pos = tr3.doc.resolve(pos);
    if (isNode2 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
      tr3.setSelection(new NodeSelection($pos));
    } else {
      let end = tr3.mapping.map(insertPos);
      tr3.mapping.maps[tr3.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
      tr3.setSelection(selectionBetween(view, $pos, tr3.doc.resolve(end)));
    }
    view.focus();
    view.dispatch(tr3.setMeta("uiEvent", "drop"));
  };
  handlers3.focus = (view) => {
    view.input.lastFocus = Date.now();
    if (!view.focused) {
      view.domObserver.stop();
      view.dom.classList.add("ProseMirror-focused");
      view.domObserver.start();
      view.focused = true;
      setTimeout(() => {
        if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
          selectionToDOM(view);
      }, 20);
    }
  };
  handlers3.blur = (view, _event) => {
    let event = _event;
    if (view.focused) {
      view.domObserver.stop();
      view.dom.classList.remove("ProseMirror-focused");
      view.domObserver.start();
      if (event.relatedTarget && view.dom.contains(event.relatedTarget))
        view.domObserver.currentSelection.clear();
      view.focused = false;
    }
  };
  handlers3.beforeinput = (view, _event) => {
    let event = _event;
    if (chrome && android && event.inputType == "deleteContentBackward") {
      view.domObserver.flushSoon();
      let { domChangeCount } = view.input;
      setTimeout(() => {
        if (view.input.domChangeCount != domChangeCount)
          return;
        view.dom.blur();
        view.focus();
        if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
          return;
        let { $cursor } = view.state.selection;
        if ($cursor && $cursor.pos > 0)
          view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
      }, 50);
    }
  };
  for (let prop in editHandlers)
    handlers3[prop] = editHandlers[prop];
  function compareObjs(a2, b) {
    if (a2 == b)
      return true;
    for (let p5 in a2)
      if (a2[p5] !== b[p5])
        return false;
    for (let p5 in b)
      if (!(p5 in a2))
        return false;
    return true;
  }
  var WidgetType = class _WidgetType {
    constructor(toDOM, spec) {
      this.toDOM = toDOM;
      this.spec = spec || noSpec;
      this.side = this.spec.side || 0;
    }
    map(mapping, span, offset, oldOffset) {
      let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
      return deleted ? null : new Decoration(pos - offset, pos - offset, this);
    }
    valid() {
      return true;
    }
    eq(other) {
      return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    }
    destroy(node2) {
      if (this.spec.destroy)
        this.spec.destroy(node2);
    }
  };
  var InlineType = class _InlineType {
    constructor(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    map(mapping, span, offset, oldOffset) {
      let from4 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
      let to2 = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
      return from4 >= to2 ? null : new Decoration(from4, to2, this);
    }
    valid(_2, span) {
      return span.from < span.to;
    }
    eq(other) {
      return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
    static is(span) {
      return span.type instanceof _InlineType;
    }
    destroy() {
    }
  };
  var NodeType2 = class _NodeType {
    constructor(attrs, spec) {
      this.attrs = attrs;
      this.spec = spec || noSpec;
    }
    map(mapping, span, offset, oldOffset) {
      let from4 = mapping.mapResult(span.from + oldOffset, 1);
      if (from4.deleted)
        return null;
      let to2 = mapping.mapResult(span.to + oldOffset, -1);
      if (to2.deleted || to2.pos <= from4.pos)
        return null;
      return new Decoration(from4.pos - offset, to2.pos - offset, this);
    }
    valid(node2, span) {
      let { index: index3, offset } = node2.content.findIndex(span.from), child;
      return offset == span.from && !(child = node2.child(index3)).isText && offset + child.nodeSize == span.to;
    }
    eq(other) {
      return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
    destroy() {
    }
  };
  var Decoration = class _Decoration {
    /**
    @internal
    */
    constructor(from4, to2, type) {
      this.from = from4;
      this.to = to2;
      this.type = type;
    }
    /**
    @internal
    */
    copy(from4, to2) {
      return new _Decoration(from4, to2, this.type);
    }
    /**
    @internal
    */
    eq(other, offset = 0) {
      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
    }
    /**
    @internal
    */
    map(mapping, offset, oldOffset) {
      return this.type.map(mapping, this, offset, oldOffset);
    }
    /**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */
    static widget(pos, toDOM, spec) {
      return new _Decoration(pos, pos, new WidgetType(toDOM, spec));
    }
    /**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */
    static inline(from4, to2, attrs, spec) {
      return new _Decoration(from4, to2, new InlineType(attrs, spec));
    }
    /**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */
    static node(from4, to2, attrs, spec) {
      return new _Decoration(from4, to2, new NodeType2(attrs, spec));
    }
    /**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */
    get spec() {
      return this.type.spec;
    }
    /**
    @internal
    */
    get inline() {
      return this.type instanceof InlineType;
    }
    /**
    @internal
    */
    get widget() {
      return this.type instanceof WidgetType;
    }
  };
  var none = [], noSpec = {};
  var DecorationSet = class _DecorationSet {
    /**
    @internal
    */
    constructor(local, children) {
      this.local = local.length ? local : none;
      this.children = children.length ? children : none;
    }
    /**
    Create a set of decorations, using the structure of the given
    document. This will consume (modify) the `decorations` array, so
    you must make a copy if you want need to preserve that.
    */
    static create(doc4, decorations) {
      return decorations.length ? buildTree(decorations, doc4, 0, noSpec) : empty3;
    }
    /**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */
    find(start, end, predicate) {
      let result = [];
      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
      return result;
    }
    findInner(start, end, result, offset, predicate) {
      for (let i = 0; i < this.local.length; i++) {
        let span = this.local[i];
        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
          result.push(span.copy(span.from + offset, span.to + offset));
      }
      for (let i = 0; i < this.children.length; i += 3) {
        if (this.children[i] < end && this.children[i + 1] > start) {
          let childOff = this.children[i] + 1;
          this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
        }
      }
    }
    /**
    Map the set of decorations in response to a change in the
    document.
    */
    map(mapping, doc4, options2) {
      if (this == empty3 || mapping.maps.length == 0)
        return this;
      return this.mapInner(mapping, doc4, 0, 0, options2 || noSpec);
    }
    /**
    @internal
    */
    mapInner(mapping, node2, offset, oldOffset, options2) {
      let newLocal;
      for (let i = 0; i < this.local.length; i++) {
        let mapped = this.local[i].map(mapping, offset, oldOffset);
        if (mapped && mapped.type.valid(node2, mapped))
          (newLocal || (newLocal = [])).push(mapped);
        else if (options2.onRemove)
          options2.onRemove(this.local[i].spec);
      }
      if (this.children.length)
        return mapChildren(this.children, newLocal || [], mapping, node2, offset, oldOffset, options2);
      else
        return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty3;
    }
    /**
    Add the given array of decorations to the ones in the set,
    producing a new set. Consumes the `decorations` array. Needs
    access to the current document to create the appropriate tree
    structure.
    */
    add(doc4, decorations) {
      if (!decorations.length)
        return this;
      if (this == empty3)
        return _DecorationSet.create(doc4, decorations);
      return this.addInner(doc4, decorations, 0);
    }
    addInner(doc4, decorations, offset) {
      let children, childIndex = 0;
      doc4.forEach((childNode, childOffset) => {
        let baseOffset = childOffset + offset, found2;
        if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
          return;
        if (!children)
          children = this.children.slice();
        while (childIndex < children.length && children[childIndex] < childOffset)
          childIndex += 3;
        if (children[childIndex] == childOffset)
          children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
        else
          children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
        childIndex += 3;
      });
      let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
      for (let i = 0; i < local.length; i++)
        if (!local[i].type.valid(doc4, local[i]))
          local.splice(i--, 1);
      return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    }
    /**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */
    remove(decorations) {
      if (decorations.length == 0 || this == empty3)
        return this;
      return this.removeInner(decorations, 0);
    }
    removeInner(decorations, offset) {
      let children = this.children, local = this.local;
      for (let i = 0; i < children.length; i += 3) {
        let found2;
        let from4 = children[i] + offset, to2 = children[i + 1] + offset;
        for (let j2 = 0, span; j2 < decorations.length; j2++)
          if (span = decorations[j2]) {
            if (span.from > from4 && span.to < to2) {
              decorations[j2] = null;
              (found2 || (found2 = [])).push(span);
            }
          }
        if (!found2)
          continue;
        if (children == this.children)
          children = this.children.slice();
        let removed = children[i + 2].removeInner(found2, from4 + 1);
        if (removed != empty3) {
          children[i + 2] = removed;
        } else {
          children.splice(i, 3);
          i -= 3;
        }
      }
      if (local.length) {
        for (let i = 0, span; i < decorations.length; i++)
          if (span = decorations[i]) {
            for (let j2 = 0; j2 < local.length; j2++)
              if (local[j2].eq(span, offset)) {
                if (local == this.local)
                  local = this.local.slice();
                local.splice(j2--, 1);
              }
          }
      }
      if (children == this.children && local == this.local)
        return this;
      return local.length || children.length ? new _DecorationSet(local, children) : empty3;
    }
    forChild(offset, node2) {
      if (this == empty3)
        return this;
      if (node2.isLeaf)
        return _DecorationSet.empty;
      let child, local;
      for (let i = 0; i < this.children.length; i += 3)
        if (this.children[i] >= offset) {
          if (this.children[i] == offset)
            child = this.children[i + 2];
          break;
        }
      let start = offset + 1, end = start + node2.content.size;
      for (let i = 0; i < this.local.length; i++) {
        let dec = this.local[i];
        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
          let from4 = Math.max(start, dec.from) - start, to2 = Math.min(end, dec.to) - start;
          if (from4 < to2)
            (local || (local = [])).push(dec.copy(from4, to2));
        }
      }
      if (local) {
        let localSet = new _DecorationSet(local.sort(byPos), none);
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }
      return child || empty3;
    }
    /**
    @internal
    */
    eq(other) {
      if (this == other)
        return true;
      if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
        return false;
      for (let i = 0; i < this.local.length; i++)
        if (!this.local[i].eq(other.local[i]))
          return false;
      for (let i = 0; i < this.children.length; i += 3)
        if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
          return false;
      return true;
    }
    /**
    @internal
    */
    locals(node2) {
      return removeOverlap(this.localsInner(node2));
    }
    /**
    @internal
    */
    localsInner(node2) {
      if (this == empty3)
        return none;
      if (node2.inlineContent || !this.local.some(InlineType.is))
        return this.local;
      let result = [];
      for (let i = 0; i < this.local.length; i++) {
        if (!(this.local[i].type instanceof InlineType))
          result.push(this.local[i]);
      }
      return result;
    }
    forEachSet(f) {
      f(this);
    }
  };
  DecorationSet.empty = new DecorationSet([], []);
  DecorationSet.removeOverlap = removeOverlap;
  var empty3 = DecorationSet.empty;
  var DecorationGroup = class _DecorationGroup {
    constructor(members) {
      this.members = members;
    }
    map(mapping, doc4) {
      const mappedDecos = this.members.map((member) => member.map(mapping, doc4, noSpec));
      return _DecorationGroup.from(mappedDecos);
    }
    forChild(offset, child) {
      if (child.isLeaf)
        return DecorationSet.empty;
      let found2 = [];
      for (let i = 0; i < this.members.length; i++) {
        let result = this.members[i].forChild(offset, child);
        if (result == empty3)
          continue;
        if (result instanceof _DecorationGroup)
          found2 = found2.concat(result.members);
        else
          found2.push(result);
      }
      return _DecorationGroup.from(found2);
    }
    eq(other) {
      if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)
        return false;
      for (let i = 0; i < this.members.length; i++)
        if (!this.members[i].eq(other.members[i]))
          return false;
      return true;
    }
    locals(node2) {
      let result, sorted = true;
      for (let i = 0; i < this.members.length; i++) {
        let locals = this.members[i].localsInner(node2);
        if (!locals.length)
          continue;
        if (!result) {
          result = locals;
        } else {
          if (sorted) {
            result = result.slice();
            sorted = false;
          }
          for (let j2 = 0; j2 < locals.length; j2++)
            result.push(locals[j2]);
        }
      }
      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
    }
    // Create a group for the given array of decoration sets, or return
    // a single set when possible.
    static from(members) {
      switch (members.length) {
        case 0:
          return empty3;
        case 1:
          return members[0];
        default:
          return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
      }
    }
    forEachSet(f) {
      for (let i = 0; i < this.members.length; i++)
        this.members[i].forEachSet(f);
    }
  };
  function mapChildren(oldChildren, newLocal, mapping, node2, offset, oldOffset, options2) {
    let children = oldChildren.slice();
    for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
      let moved = 0;
      mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
        let dSize = newEnd - newStart - (oldEnd - oldStart);
        for (let i2 = 0; i2 < children.length; i2 += 3) {
          let end = children[i2 + 1];
          if (end < 0 || oldStart > end + baseOffset - moved)
            continue;
          let start = children[i2] + baseOffset - moved;
          if (oldEnd >= start) {
            children[i2 + 1] = oldStart <= start ? -2 : -1;
          } else if (oldStart >= baseOffset && dSize) {
            children[i2] += dSize;
            children[i2 + 1] += dSize;
          }
        }
        moved += dSize;
      });
      baseOffset = mapping.maps[i].map(baseOffset, -1);
    }
    let mustRebuild = false;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        if (children[i + 1] == -2) {
          mustRebuild = true;
          children[i + 1] = -1;
          continue;
        }
        let from4 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from4 - offset;
        if (fromLocal < 0 || fromLocal >= node2.content.size) {
          mustRebuild = true;
          continue;
        }
        let to2 = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to2 - offset;
        let { index: index3, offset: childOffset } = node2.content.findIndex(fromLocal);
        let childNode = node2.maybeChild(index3);
        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
          let mapped = children[i + 2].mapInner(mapping, childNode, from4 + 1, oldChildren[i] + oldOffset + 1, options2);
          if (mapped != empty3) {
            children[i] = fromLocal;
            children[i + 1] = toLocal;
            children[i + 2] = mapped;
          } else {
            children[i + 1] = -2;
            mustRebuild = true;
          }
        } else {
          mustRebuild = true;
        }
      }
    if (mustRebuild) {
      let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options2);
      let built = buildTree(decorations, node2, 0, options2);
      newLocal = built.local;
      for (let i = 0; i < children.length; i += 3)
        if (children[i + 1] < 0) {
          children.splice(i, 3);
          i -= 3;
        }
      for (let i = 0, j2 = 0; i < built.children.length; i += 3) {
        let from4 = built.children[i];
        while (j2 < children.length && children[j2] < from4)
          j2 += 3;
        children.splice(j2, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
      }
    }
    return new DecorationSet(newLocal.sort(byPos), children);
  }
  function moveSpans(spans, offset) {
    if (!offset || !spans.length)
      return spans;
    let result = [];
    for (let i = 0; i < spans.length; i++) {
      let span = spans[i];
      result.push(new Decoration(span.from + offset, span.to + offset, span.type));
    }
    return result;
  }
  function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options2) {
    function gather(set2, oldOffset2) {
      for (let i = 0; i < set2.local.length; i++) {
        let mapped = set2.local[i].map(mapping, offset, oldOffset2);
        if (mapped)
          decorations.push(mapped);
        else if (options2.onRemove)
          options2.onRemove(set2.local[i].spec);
      }
      for (let i = 0; i < set2.children.length; i += 3)
        gather(set2.children[i + 2], set2.children[i] + oldOffset2 + 1);
    }
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] == -1)
        gather(children[i + 2], oldChildren[i] + oldOffset + 1);
    return decorations;
  }
  function takeSpansForNode(spans, node2, offset) {
    if (node2.isLeaf)
      return null;
    let end = offset + node2.nodeSize, found2 = null;
    for (let i = 0, span; i < spans.length; i++) {
      if ((span = spans[i]) && span.from > offset && span.to < end) {
        (found2 || (found2 = [])).push(span);
        spans[i] = null;
      }
    }
    return found2;
  }
  function withoutNulls(array) {
    let result = [];
    for (let i = 0; i < array.length; i++)
      if (array[i] != null)
        result.push(array[i]);
    return result;
  }
  function buildTree(spans, node2, offset, options2) {
    let children = [], hasNulls = false;
    node2.forEach((childNode, localStart) => {
      let found2 = takeSpansForNode(spans, childNode, localStart + offset);
      if (found2) {
        hasNulls = true;
        let subtree = buildTree(found2, childNode, offset + localStart + 1, options2);
        if (subtree != empty3)
          children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    });
    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
    for (let i = 0; i < locals.length; i++)
      if (!locals[i].type.valid(node2, locals[i])) {
        if (options2.onRemove)
          options2.onRemove(locals[i].spec);
        locals.splice(i--, 1);
      }
    return locals.length || children.length ? new DecorationSet(locals, children) : empty3;
  }
  function byPos(a2, b) {
    return a2.from - b.from || a2.to - b.to;
  }
  function removeOverlap(spans) {
    let working = spans;
    for (let i = 0; i < working.length - 1; i++) {
      let span = working[i];
      if (span.from != span.to)
        for (let j2 = i + 1; j2 < working.length; j2++) {
          let next2 = working[j2];
          if (next2.from == span.from) {
            if (next2.to != span.to) {
              if (working == spans)
                working = spans.slice();
              working[j2] = next2.copy(next2.from, span.to);
              insertAhead(working, j2 + 1, next2.copy(span.to, next2.to));
            }
            continue;
          } else {
            if (next2.from < span.to) {
              if (working == spans)
                working = spans.slice();
              working[i] = span.copy(span.from, next2.from);
              insertAhead(working, j2, span.copy(next2.from, span.to));
            }
            break;
          }
        }
    }
    return working;
  }
  function insertAhead(array, i, deco) {
    while (i < array.length && byPos(deco, array[i]) > 0)
      i++;
    array.splice(i, 0, deco);
  }
  function viewDecorations(view) {
    let found2 = [];
    view.someProp("decorations", (f) => {
      let result = f(view.state);
      if (result && result != empty3)
        found2.push(result);
    });
    if (view.cursorWrapper)
      found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
    return DecorationGroup.from(found2);
  }
  var observeOptions = {
    childList: true,
    characterData: true,
    characterDataOldValue: true,
    attributes: true,
    attributeOldValue: true,
    subtree: true
  };
  var useCharData = ie && ie_version <= 11;
  var SelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    }
    clear() {
      this.anchorNode = this.focusNode = null;
    }
    eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    }
  };
  var DOMObserver = class {
    constructor(view, handleDOMChange) {
      this.view = view;
      this.handleDOMChange = handleDOMChange;
      this.queue = [];
      this.flushingSoon = -1;
      this.observer = null;
      this.currentSelection = new SelectionState();
      this.onCharData = null;
      this.suppressingSelectionUpdates = false;
      this.lastChangedTextNode = null;
      this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
        for (let i = 0; i < mutations.length; i++)
          this.queue.push(mutations[i]);
        if (ie && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData) {
        this.onCharData = (e) => {
          this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
          this.flushSoon();
        };
      }
      this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    flushSoon() {
      if (this.flushingSoon < 0)
        this.flushingSoon = window.setTimeout(() => {
          this.flushingSoon = -1;
          this.flush();
        }, 20);
    }
    forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    }
    start() {
      if (this.observer) {
        this.observer.takeRecords();
        this.observer.observe(this.view.dom, observeOptions);
      }
      if (this.onCharData)
        this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.connectSelection();
    }
    stop() {
      if (this.observer) {
        let take = this.observer.takeRecords();
        if (take.length) {
          for (let i = 0; i < take.length; i++)
            this.queue.push(take[i]);
          window.setTimeout(() => this.flush(), 20);
        }
        this.observer.disconnect();
      }
      if (this.onCharData)
        this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      this.disconnectSelection();
    }
    connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
    disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
    suppressSelectionUpdates() {
      this.suppressingSelectionUpdates = true;
      setTimeout(() => this.suppressingSelectionUpdates = false, 50);
    }
    onSelectionChange() {
      if (!hasFocusAndSelection(this.view))
        return;
      if (this.suppressingSelectionUpdates)
        return selectionToDOM(this.view);
      if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
        let sel = this.view.domSelectionRange();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
    setCurSelection() {
      this.currentSelection.set(this.view.domSelectionRange());
    }
    ignoreSelectionChange(sel) {
      if (!sel.focusNode)
        return true;
      let ancestors = /* @__PURE__ */ new Set(), container;
      for (let scan = sel.focusNode; scan; scan = parentNode(scan))
        ancestors.add(scan);
      for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
        if (ancestors.has(scan)) {
          container = scan;
          break;
        }
      let desc = container && this.view.docView.nearestDesc(container);
      if (desc && desc.ignoreMutation({
        type: "selection",
        target: container.nodeType == 3 ? container.parentNode : container
      })) {
        this.setCurSelection();
        return true;
      }
    }
    pendingRecords() {
      if (this.observer)
        for (let mut of this.observer.takeRecords())
          this.queue.push(mut);
      return this.queue;
    }
    flush() {
      let { view } = this;
      if (!view.docView || this.flushingSoon > -1)
        return;
      let mutations = this.pendingRecords();
      if (mutations.length)
        this.queue = [];
      let sel = view.domSelectionRange();
      let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
      let from4 = -1, to2 = -1, typeOver = false, added = [];
      if (view.editable) {
        for (let i = 0; i < mutations.length; i++) {
          let result = this.registerMutation(mutations[i], added);
          if (result) {
            from4 = from4 < 0 ? result.from : Math.min(result.from, from4);
            to2 = to2 < 0 ? result.to : Math.max(result.to, to2);
            if (result.typeOver)
              typeOver = true;
          }
        }
      }
      if (gecko && added.length) {
        let brs = added.filter((n) => n.nodeName == "BR");
        if (brs.length == 2) {
          let [a2, b] = brs;
          if (a2.parentNode && a2.parentNode.parentNode == b.parentNode)
            b.remove();
          else
            a2.remove();
        } else {
          let { focusNode } = this.currentSelection;
          for (let br4 of brs) {
            let parent = br4.parentNode;
            if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
              br4.remove();
          }
        }
      }
      let readSel = null;
      if (from4 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
        view.input.lastFocus = 0;
        selectionToDOM(view);
        this.currentSelection.set(sel);
        view.scrollToSelection();
      } else if (from4 > -1 || newSel) {
        if (from4 > -1) {
          view.docView.markDirty(from4, to2);
          checkCSS(view);
        }
        this.handleDOMChange(from4, to2, typeOver, added);
        if (view.docView && view.docView.dirty)
          view.updateState(view.state);
        else if (!this.currentSelection.eq(sel))
          selectionToDOM(view);
        this.currentSelection.set(sel);
      }
    }
    registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1)
        return null;
      let desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
      mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
        return null;
      if (!desc || desc.ignoreMutation(mut))
        return null;
      if (mut.type == "childList") {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let node2 = mut.addedNodes[i];
          added.push(node2);
          if (node2.nodeType == 3)
            this.lastChangedTextNode = node2;
        }
        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
          return { from: desc.posBefore, to: desc.posAfter };
        let prev = mut.previousSibling, next2 = mut.nextSibling;
        if (ie && ie_version <= 11 && mut.addedNodes.length) {
          for (let i = 0; i < mut.addedNodes.length; i++) {
            let { previousSibling, nextSibling } = mut.addedNodes[i];
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
              prev = previousSibling;
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
              next2 = nextSibling;
          }
        }
        let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        let from4 = desc.localPosFromDOM(mut.target, fromOffset, -1);
        let toOffset = next2 && next2.parentNode == mut.target ? domIndex(next2) : mut.target.childNodes.length;
        let to2 = desc.localPosFromDOM(mut.target, toOffset, 1);
        return { from: from4, to: to2 };
      } else if (mut.type == "attributes") {
        return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
      } else {
        this.lastChangedTextNode = mut.target;
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    }
  };
  var cssChecked = /* @__PURE__ */ new WeakMap();
  var cssCheckWarned = false;
  function checkCSS(view) {
    if (cssChecked.has(view))
      return;
    cssChecked.set(view, null);
    if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
      view.requiresGeckoHackNode = gecko;
      if (cssCheckWarned)
        return;
      console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
      cssCheckWarned = true;
    }
  }
  function rangeToSelectionRange(view, range) {
    let anchorNode = range.startContainer, anchorOffset = range.startOffset;
    let focusNode = range.endContainer, focusOffset = range.endOffset;
    let currentAnchor = view.domAtPos(view.state.selection.anchor);
    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function safariShadowSelectionRange(view, selection) {
    if (selection.getComposedRanges) {
      let range = selection.getComposedRanges(view.root)[0];
      if (range)
        return rangeToSelectionRange(view, range);
    }
    let found2;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found2 = event.getTargetRanges()[0];
    }
    view.dom.addEventListener("beforeinput", read, true);
    document.execCommand("indent");
    view.dom.removeEventListener("beforeinput", read, true);
    return found2 ? rangeToSelectionRange(view, found2) : null;
  }
  function blockParent(view, node2) {
    for (let p5 = node2.parentNode; p5 && p5 != view.dom; p5 = p5.parentNode) {
      let desc = view.docView.nearestDesc(p5, true);
      if (desc && desc.node.isBlock)
        return p5;
    }
    return null;
  }
  function parseBetween(view, from_, to_) {
    let { node: parent, fromOffset, toOffset, from: from4, to: to2 } = view.docView.parseRange(from_, to_);
    let domSel = view.domSelectionRange();
    let find4;
    let anchor = domSel.anchorNode;
    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
      find4 = [{ node: anchor, offset: domSel.anchorOffset }];
      if (!selectionCollapsed(domSel))
        find4.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
    if (chrome && view.input.lastKeyCode === 8) {
      for (let off = toOffset; off > fromOffset; off--) {
        let node2 = parent.childNodes[off - 1], desc = node2.pmViewDesc;
        if (node2.nodeName == "BR" && !desc) {
          toOffset = off;
          break;
        }
        if (!desc || desc.size)
          break;
      }
    }
    let startDoc = view.state.doc;
    let parser = view.someProp("domParser") || DOMParser2.fromSchema(view.state.schema);
    let $from = startDoc.resolve(from4);
    let sel = null, doc4 = parser.parse(parent, {
      topNode: $from.parent,
      topMatch: $from.parent.contentMatchAt($from.index()),
      topOpen: true,
      from: fromOffset,
      to: toOffset,
      preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
      findPositions: find4,
      ruleFromNode,
      context: $from
    });
    if (find4 && find4[0].pos != null) {
      let anchor2 = find4[0].pos, head2 = find4[1] && find4[1].pos;
      if (head2 == null)
        head2 = anchor2;
      sel = { anchor: anchor2 + from4, head: head2 + from4 };
    }
    return { doc: doc4, sel, from: from4, to: to2 };
  }
  function ruleFromNode(dom) {
    let desc = dom.pmViewDesc;
    if (desc) {
      return desc.parseRule();
    } else if (dom.nodeName == "BR" && dom.parentNode) {
      if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
        let skip = document.createElement("div");
        skip.appendChild(document.createElement("li"));
        return { skip };
      } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
        return { ignore: true };
      }
    } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
      return { ignore: true };
    }
    return null;
  }
  var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function readDOMChange(view, from4, to2, typeOver, addedNodes) {
    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
    view.input.compositionPendingChanges = 0;
    if (from4 < 0) {
      let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
      let newSel = selectionFromDOM(view, origin);
      if (newSel && !view.state.selection.eq(newSel)) {
        if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
          return;
        let tr3 = view.state.tr.setSelection(newSel);
        if (origin == "pointer")
          tr3.setMeta("pointer", true);
        else if (origin == "key")
          tr3.scrollIntoView();
        if (compositionID)
          tr3.setMeta("composition", compositionID);
        view.dispatch(tr3);
      }
      return;
    }
    let $before = view.state.doc.resolve(from4);
    let shared = $before.sharedDepth(to2);
    from4 = $before.before(shared + 1);
    to2 = view.state.doc.resolve(to2).after(shared + 1);
    let sel = view.state.selection;
    let parse6 = parseBetween(view, from4, to2);
    let doc4 = view.state.doc, compare = doc4.slice(parse6.from, parse6.to);
    let preferredPos, preferredSide;
    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
      preferredPos = view.state.selection.to;
      preferredSide = "end";
    } else {
      preferredPos = view.state.selection.from;
      preferredSide = "start";
    }
    view.input.lastKeyCode = null;
    let change = findDiff(compare.content, parse6.doc.content, parse6.from, preferredPos, preferredSide);
    if (change)
      view.input.domChangeCount++;
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (!change) {
      if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse6.sel && parse6.sel.anchor != parse6.sel.head)) {
        change = { start: sel.from, endA: sel.to, endB: sel.to };
      } else {
        if (parse6.sel) {
          let sel2 = resolveSelection(view, view.state.doc, parse6.sel);
          if (sel2 && !sel2.eq(view.state.selection)) {
            let tr3 = view.state.tr.setSelection(sel2);
            if (compositionID)
              tr3.setMeta("composition", compositionID);
            view.dispatch(tr3);
          }
        }
        return;
      }
    }
    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
      if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse6.from) {
        change.start = view.state.selection.from;
      } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse6.to) {
        change.endB += view.state.selection.to - change.endA;
        change.endA = view.state.selection.to;
      }
    }
    if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse6.from && parse6.doc.textBetween(change.start - parse6.from - 1, change.start - parse6.from + 1) == " \xA0") {
      change.start--;
      change.endA--;
      change.endB--;
    }
    let $from = parse6.doc.resolveNoCache(change.start - parse6.from);
    let $to = parse6.doc.resolveNoCache(change.endB - parse6.from);
    let $fromA = doc4.resolve(change.start);
    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
    let nextSel;
    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse6.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && !/\S/.test(parse6.doc.textBetween($from.pos, $to.pos, "", "")) && (nextSel = Selection.findFrom(parse6.doc.resolve($from.pos + 1), 1, true)) && nextSel.head > $from.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
      view.input.lastIOSEnter = 0;
      return;
    }
    if (view.state.selection.anchor > change.start && looksLikeBackspace(doc4, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
      if (android && chrome)
        view.domObserver.suppressSelectionUpdates();
      return;
    }
    if (chrome && change.endB == change.start)
      view.input.lastChromeDelete = Date.now();
    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse6.sel && parse6.sel.anchor == parse6.sel.head && parse6.sel.head == change.endA) {
      change.endB -= 2;
      $to = parse6.doc.resolveNoCache(change.endB - parse6.from);
      setTimeout(() => {
        view.someProp("handleKeyDown", function(f) {
          return f(view, keyEvent(13, "Enter"));
        });
      }, 20);
    }
    let chFrom = change.start, chTo = change.endA;
    let mkTr = (base4) => {
      let tr3 = base4 || view.state.tr.replace(chFrom, chTo, parse6.doc.slice(change.start - parse6.from, change.endB - parse6.from));
      if (parse6.sel) {
        let sel2 = resolveSelection(view, tr3.doc, parse6.sel);
        if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr3.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))
          tr3.setSelection(sel2);
      }
      if (compositionID)
        tr3.setMeta("composition", compositionID);
      return tr3.scrollIntoView();
    };
    let markChange;
    if (inlineChange) {
      if ($from.pos == $to.pos) {
        if (ie && ie_version <= 11 && $from.parentOffset == 0) {
          view.domObserver.suppressSelectionUpdates();
          setTimeout(() => selectionToDOM(view), 20);
        }
        let tr3 = mkTr(view.state.tr.delete(chFrom, chTo));
        let marks = doc4.resolve(change.start).marksAcross(doc4.resolve(change.endA));
        if (marks)
          tr3.ensureMarks(marks);
        view.dispatch(tr3);
      } else if (
        // Adding or removing a mark
        change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
      ) {
        let tr3 = mkTr(view.state.tr);
        if (markChange.type == "add")
          tr3.addMark(chFrom, chTo, markChange.mark);
        else
          tr3.removeMark(chFrom, chTo, markChange.mark);
        view.dispatch(tr3);
      } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
        let text10 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
        let deflt = () => mkTr(view.state.tr.insertText(text10, chFrom, chTo));
        if (!view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text10, deflt)))
          view.dispatch(deflt());
      }
    } else {
      view.dispatch(mkTr());
    }
  }
  function resolveSelection(view, doc4, parsedSel) {
    if (Math.max(parsedSel.anchor, parsedSel.head) > doc4.content.size)
      return null;
    return selectionBetween(view, doc4.resolve(parsedSel.anchor), doc4.resolve(parsedSel.head));
  }
  function isMarkChange(cur, prev) {
    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
    let added = curMarks, removed = prevMarks, type, mark2, update;
    for (let i = 0; i < prevMarks.length; i++)
      added = prevMarks[i].removeFromSet(added);
    for (let i = 0; i < curMarks.length; i++)
      removed = curMarks[i].removeFromSet(removed);
    if (added.length == 1 && removed.length == 0) {
      mark2 = added[0];
      type = "add";
      update = (node2) => node2.mark(mark2.addToSet(node2.marks));
    } else if (added.length == 0 && removed.length == 1) {
      mark2 = removed[0];
      type = "remove";
      update = (node2) => node2.mark(mark2.removeFromSet(node2.marks));
    } else {
      return null;
    }
    let updated = [];
    for (let i = 0; i < prev.childCount; i++)
      updated.push(update(prev.child(i)));
    if (Fragment.from(updated).eq(cur))
      return { mark: mark2, type };
  }
  function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
    if (
      // The content must have shrunk
      end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
      skipClosingAndOpening($newStart, true, false) < $newEnd.pos
    )
      return false;
    let $start = old.resolve(start);
    if (!$newStart.parent.isTextblock) {
      let after = $start.nodeAfter;
      return after != null && end == start + after.nodeSize;
    }
    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
      return false;
    let $next = old.resolve(skipClosingAndOpening($start, true, true));
    if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
      return false;
    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
  }
  function skipClosingAndOpening($pos, fromEnd, mayOpen) {
    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
      depth--;
      end++;
      fromEnd = false;
    }
    if (mayOpen) {
      let next2 = $pos.node(depth).maybeChild($pos.indexAfter(depth));
      while (next2 && !next2.isLeaf) {
        next2 = next2.firstChild;
        end++;
      }
    }
    return end;
  }
  function findDiff(a2, b, pos, preferredPos, preferredSide) {
    let start = a2.findDiffStart(b, pos);
    if (start == null)
      return null;
    let { a: endA, b: endB } = a2.findDiffEnd(b, pos + a2.size, pos + b.size);
    if (preferredSide == "end") {
      let adjust = Math.max(0, start - Math.min(endA, endB));
      preferredPos -= endA + adjust - start;
    }
    if (endA < start && a2.size < b.size) {
      let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
      start -= move;
      if (start && start < b.size && isSurrogatePair2(b.textBetween(start - 1, start + 1)))
        start += move ? 1 : -1;
      endB = start + (endB - endA);
      endA = start;
    } else if (endB < start) {
      let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
      start -= move;
      if (start && start < a2.size && isSurrogatePair2(a2.textBetween(start - 1, start + 1)))
        start += move ? 1 : -1;
      endA = start + (endA - endB);
      endB = start;
    }
    return { start, endA, endB };
  }
  function isSurrogatePair2(str) {
    if (str.length != 2)
      return false;
    let a2 = str.charCodeAt(0), b = str.charCodeAt(1);
    return a2 >= 56320 && a2 <= 57343 && b >= 55296 && b <= 56319;
  }
  var __parseFromClipboard = parseFromClipboard;
  var __endComposition = endComposition;
  var EditorView = class {
    /**
    Create a view. `place` may be a DOM node that the editor should
    be appended to, a function that will place it into the document,
    or an object whose `mount` property holds the node to use as the
    document container. If it is `null`, the editor will not be
    added to the document.
    */
    constructor(place, props) {
      this._root = null;
      this.focused = false;
      this.trackWrites = null;
      this.mounted = false;
      this.markCursor = null;
      this.cursorWrapper = null;
      this.lastSelectedViewDesc = void 0;
      this.input = new InputState();
      this.prevDirectPlugins = [];
      this.pluginViews = [];
      this.requiresGeckoHackNode = false;
      this.dragging = null;
      this._props = props;
      this.state = props.state;
      this.directPlugins = props.plugins || [];
      this.directPlugins.forEach(checkStateComponent);
      this.dispatch = this.dispatch.bind(this);
      this.dom = place && place.mount || document.createElement("div");
      if (place) {
        if (place.appendChild)
          place.appendChild(this.dom);
        else if (typeof place == "function")
          place(this.dom);
        else if (place.mount)
          this.mounted = true;
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      this.nodeViews = buildNodeViews(this);
      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
      this.domObserver = new DOMObserver(this, (from4, to2, typeOver, added) => readDOMChange(this, from4, to2, typeOver, added));
      this.domObserver.start();
      initInput(this);
      this.updatePluginViews();
    }
    /**
    Holds `true` when a
    [composition](https://w3c.github.io/uievents/#events-compositionevents)
    is active.
    */
    get composing() {
      return this.input.composing;
    }
    /**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */
    get props() {
      if (this._props.state != this.state) {
        let prev = this._props;
        this._props = {};
        for (let name in prev)
          this._props[name] = prev[name];
        this._props.state = this.state;
      }
      return this._props;
    }
    /**
    Update the view's props. Will immediately cause an update to
    the DOM.
    */
    update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents)
        ensureListeners(this);
      let prevProps = this._props;
      this._props = props;
      if (props.plugins) {
        props.plugins.forEach(checkStateComponent);
        this.directPlugins = props.plugins;
      }
      this.updateStateInner(props.state, prevProps);
    }
    /**
    Update the view by updating existing props object with the object
    given as argument. Equivalent to `view.update(Object.assign({},
    view.props, props))`.
    */
    setProps(props) {
      let updated = {};
      for (let name in this._props)
        updated[name] = this._props[name];
      updated.state = this.state;
      for (let name in props)
        updated[name] = props[name];
      this.update(updated);
    }
    /**
    Update the editor's `state` prop, without touching any of the
    other props.
    */
    updateState(state) {
      this.updateStateInner(state, this._props);
    }
    updateStateInner(state, prevProps) {
      var _a3;
      let prev = this.state, redraw = false, updateSel = false;
      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }
      this.state = state;
      let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
      if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
        let nodeViews = buildNodeViews(this);
        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
      }
      if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
        ensureListeners(this);
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
      let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection))
        updateSel = true;
      let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
      if (updateSel) {
        this.domObserver.stop();
        let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
        if (updateDoc) {
          let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
          if (this.composing)
            this.input.compositionNode = findCompositionNode(this);
          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco(outerDeco);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }
          if (chromeKludge && !this.trackWrites)
            forceSelUpdate = true;
        }
        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }
        this.domObserver.start();
      }
      this.updatePluginViews(prev);
      if (((_a3 = this.dragging) === null || _a3 === void 0 ? void 0 : _a3.node) && !prev.doc.eq(state.doc))
        this.updateDraggedNode(this.dragging, prev);
      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        this.scrollToSelection();
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    }
    /**
    @internal
    */
    scrollToSelection() {
      let startDOM = this.domSelectionRange().focusNode;
      if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
      else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
      else if (this.state.selection instanceof NodeSelection) {
        let target = this.docView.domAfterPos(this.state.selection.from);
        if (target.nodeType == 1)
          scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
      } else {
        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
      }
    }
    destroyPluginViews() {
      let view;
      while (view = this.pluginViews.pop())
        if (view.destroy)
          view.destroy();
    }
    updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins;
        this.destroyPluginViews();
        for (let i = 0; i < this.directPlugins.length; i++) {
          let plugin = this.directPlugins[i];
          if (plugin.spec.view)
            this.pluginViews.push(plugin.spec.view(this));
        }
        for (let i = 0; i < this.state.plugins.length; i++) {
          let plugin = this.state.plugins[i];
          if (plugin.spec.view)
            this.pluginViews.push(plugin.spec.view(this));
        }
      } else {
        for (let i = 0; i < this.pluginViews.length; i++) {
          let pluginView = this.pluginViews[i];
          if (pluginView.update)
            pluginView.update(this, prevState);
        }
      }
    }
    updateDraggedNode(dragging, prev) {
      let sel = dragging.node, found2 = -1;
      if (this.state.doc.nodeAt(sel.from) == sel.node) {
        found2 = sel.from;
      } else {
        let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
        let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
        if (moved == sel.node)
          found2 = movedPos;
      }
      this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
    }
    someProp(propName, f) {
      let prop = this._props && this._props[propName], value;
      if (prop != null && (value = f ? f(prop) : prop))
        return value;
      for (let i = 0; i < this.directPlugins.length; i++) {
        let prop2 = this.directPlugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
      let plugins = this.state.plugins;
      if (plugins)
        for (let i = 0; i < plugins.length; i++) {
          let prop2 = plugins[i].props[propName];
          if (prop2 != null && (value = f ? f(prop2) : prop2))
            return value;
        }
    }
    /**
    Query whether the view has focus.
    */
    hasFocus() {
      if (ie) {
        let node2 = this.root.activeElement;
        if (node2 == this.dom)
          return true;
        if (!node2 || !this.dom.contains(node2))
          return false;
        while (node2 && this.dom != node2 && this.dom.contains(node2)) {
          if (node2.contentEditable == "false")
            return false;
          node2 = node2.parentElement;
        }
        return true;
      }
      return this.root.activeElement == this.dom;
    }
    /**
    Focus the editor.
    */
    focus() {
      this.domObserver.stop();
      if (this.editable)
        focusPreventScroll(this.dom);
      selectionToDOM(this);
      this.domObserver.start();
    }
    /**
    Get the document root in which the editor exists. This will
    usually be the top-level `document`, but might be a [shadow
    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    root if the editor is inside one.
    */
    get root() {
      let cached = this._root;
      if (cached == null)
        for (let search3 = this.dom.parentNode; search3; search3 = search3.parentNode) {
          if (search3.nodeType == 9 || search3.nodeType == 11 && search3.host) {
            if (!search3.getSelection)
              Object.getPrototypeOf(search3).getSelection = () => search3.ownerDocument.getSelection();
            return this._root = search3;
          }
        }
      return cached || document;
    }
    /**
    When an existing editor view is moved to a new document or
    shadow tree, call this to make it recompute its root.
    */
    updateRoot() {
      this._root = null;
    }
    /**
    Given a pair of viewport coordinates, return the document
    position that corresponds to them. May return null if the given
    coordinates aren't inside of the editor. When an object is
    returned, its `pos` property is the position nearest to the
    coordinates, and its `inside` property holds the position of the
    inner node that the position falls inside of, or -1 if it is at
    the top level, not in any node.
    */
    posAtCoords(coords) {
      return posAtCoords(this, coords);
    }
    /**
    Returns the viewport rectangle at a given document position.
    `left` and `right` will be the same number, as this returns a
    flat cursor-ish rectangle. If the position is between two things
    that aren't directly adjacent, `side` determines which element
    is used. When < 0, the element before the position is used,
    otherwise the element after.
    */
    coordsAtPos(pos, side = 1) {
      return coordsAtPos(this, pos, side);
    }
    /**
    Find the DOM position that corresponds to the given document
    position. When `side` is negative, find the position as close as
    possible to the content before the position. When positive,
    prefer positions close to the content after the position. When
    zero, prefer as shallow a position as possible.
    
    Note that you should **not** mutate the editor's internal DOM,
    only inspect it (and even that is usually not necessary).
    */
    domAtPos(pos, side = 0) {
      return this.docView.domFromPos(pos, side);
    }
    /**
    Find the DOM node that represents the document node after the
    given position. May return `null` when the position doesn't point
    in front of a node or if the node is inside an opaque node view.
    
    This is intended to be able to call things like
    `getBoundingClientRect` on that DOM node. Do **not** mutate the
    editor DOM directly, or add styling this way, since that will be
    immediately overriden by the editor as it redraws the node.
    */
    nodeDOM(pos) {
      let desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    }
    /**
    Find the document position that corresponds to a given DOM
    position. (Whenever possible, it is preferable to inspect the
    document structure directly, rather than poking around in the
    DOM, but sometimesfor example when interpreting an event
    targetyou don't have a choice.)
    
    The `bias` parameter can be used to influence which side of a DOM
    node to use when the position is inside a leaf node.
    */
    posAtDOM(node2, offset, bias = -1) {
      let pos = this.docView.posFromDOM(node2, offset, bias);
      if (pos == null)
        throw new RangeError("DOM position not inside the editor");
      return pos;
    }
    /**
    Find out whether the selection is at the end of a textblock when
    moving in a given direction. When, for example, given `"left"`,
    it will return true if moving left from the current cursor
    position would leave that position's parent textblock. Will apply
    to the view's current state by default, but it is possible to
    pass a different state.
    */
    endOfTextblock(dir, state) {
      return endOfTextblock(this, state || this.state, dir);
    }
    /**
    Run the editor's paste logic with the given HTML string. The
    `event`, if given, will be passed to the
    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
    */
    pasteHTML(html7, event) {
      return doPaste(this, "", html7, false, event || new ClipboardEvent("paste"));
    }
    /**
    Run the editor's paste logic with the given plain-text input.
    */
    pasteText(text10, event) {
      return doPaste(this, text10, null, true, event || new ClipboardEvent("paste"));
    }
    /**
    Serialize the given slice as it would be if it was copied from
    this editor. Returns a DOM element that contains a
    representation of the slice as its children, a textual
    representation, and the transformed slice (which can be
    different from the given input due to hooks like
    [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
    */
    serializeForClipboard(slice2) {
      return serializeForClipboard(this, slice2);
    }
    /**
    Removes the editor from the DOM and destroys all [node
    views](https://prosemirror.net/docs/ref/#view.NodeView).
    */
    destroy() {
      if (!this.docView)
        return;
      destroyInput(this);
      this.destroyPluginViews();
      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      this.docView.destroy();
      this.docView = null;
      clearReusedRange();
    }
    /**
    This is true when the view has been
    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
    used anymore).
    */
    get isDestroyed() {
      return this.docView == null;
    }
    /**
    Used for testing.
    */
    dispatchEvent(event) {
      return dispatchEvent(this, event);
    }
    /**
    @internal
    */
    domSelectionRange() {
      let sel = this.domSelection();
      if (!sel)
        return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
      return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
    }
    /**
    @internal
    */
    domSelection() {
      return this.root.getSelection();
    }
  };
  EditorView.prototype.dispatch = function(tr3) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr3);
    else
      this.updateState(this.state.apply(tr3));
  };
  function computeDocDeco(view) {
    let attrs = /* @__PURE__ */ Object.create(null);
    attrs.class = "ProseMirror";
    attrs.contenteditable = String(view.editable);
    view.someProp("attributes", (value) => {
      if (typeof value == "function")
        value = value(view.state);
      if (value)
        for (let attr in value) {
          if (attr == "class")
            attrs.class += " " + value[attr];
          else if (attr == "style")
            attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
          else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
            attrs[attr] = String(value[attr]);
        }
    });
    if (!attrs.translate)
      attrs.translate = "no";
    return [Decoration.node(0, view.state.doc.content.size, attrs)];
  }
  function updateCursorWrapper(view) {
    if (view.markCursor) {
      let dom = document.createElement("img");
      dom.className = "ProseMirror-separator";
      dom.setAttribute("mark-placeholder", "true");
      dom.setAttribute("alt", "");
      view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
    } else {
      view.cursorWrapper = null;
    }
  }
  function getEditable(view) {
    return !view.someProp("editable", (value) => value(view.state) === false);
  }
  function selectionContextChanged(sel1, sel2) {
    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
  }
  function buildNodeViews(view) {
    let result = /* @__PURE__ */ Object.create(null);
    function add3(obj) {
      for (let prop in obj)
        if (!Object.prototype.hasOwnProperty.call(result, prop))
          result[prop] = obj[prop];
    }
    view.someProp("nodeViews", add3);
    view.someProp("markViews", add3);
    return result;
  }
  function changedNodeViews(a2, b) {
    let nA = 0, nB = 0;
    for (let prop in a2) {
      if (a2[prop] != b[prop])
        return true;
      nA++;
    }
    for (let _2 in b)
      nB++;
    return nA != nB;
  }
  function checkStateComponent(plugin) {
    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
      throw new RangeError("Plugins passed directly to the view must not have a state component");
  }

  // node_modules/w3c-keyname/index.js
  var base3 = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var mac2 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  for (i = 0; i < 10; i++) base3[48 + i] = base3[96 + i] = String(i);
  for (i = 1; i <= 24; i++) base3[i + 111] = "F" + i;
  for (i = 65; i <= 90; i++) {
    base3[i] = String.fromCharCode(i + 32);
    shift[i] = String.fromCharCode(i);
  }
  for (code5 in base3) if (!shift.hasOwnProperty(code5)) shift[code5] = base3[code5];
  function keyName(event) {
    var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name = !ignoreKey && event.key || (event.shiftKey ? shift : base3)[event.keyCode] || event.key || "Unidentified";
    if (name == "Esc") name = "Escape";
    if (name == "Del") name = "Delete";
    if (name == "Left") name = "ArrowLeft";
    if (name == "Up") name = "ArrowUp";
    if (name == "Right") name = "ArrowRight";
    if (name == "Down") name = "ArrowDown";
    return name;
  }
  var i;
  var code5;

  // node_modules/prosemirror-keymap/dist/index.js
  var mac3 = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
  var windows2 = typeof navigator != "undefined" && /Win/.test(navigator.platform);
  function normalizeKeyName(name) {
    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta2;
    for (let i = 0; i < parts.length - 1; i++) {
      let mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (mac3)
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function normalize3(map9) {
    let copy4 = /* @__PURE__ */ Object.create(null);
    for (let prop in map9)
      copy4[normalizeKeyName(prop)] = map9[prop];
    return copy4;
  }
  function modifiers(name, event, shift2 = true) {
    if (event.altKey)
      name = "Alt-" + name;
    if (event.ctrlKey)
      name = "Ctrl-" + name;
    if (event.metaKey)
      name = "Meta-" + name;
    if (shift2 && event.shiftKey)
      name = "Shift-" + name;
    return name;
  }
  function keymap(bindings) {
    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
  }
  function keydownHandler(bindings) {
    let map9 = normalize3(bindings);
    return function(view, event) {
      let name = keyName(event), baseName, direct = map9[modifiers(name, event)];
      if (direct && direct(view.state, view.dispatch, view))
        return true;
      if (name.length == 1 && name != " ") {
        if (event.shiftKey) {
          let noShift = map9[modifiers(name, event, false)];
          if (noShift && noShift(view.state, view.dispatch, view))
            return true;
        }
        if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
        !(windows2 && event.ctrlKey && event.altKey) && (baseName = base3[event.keyCode]) && baseName != name) {
          let fromCode = map9[modifiers(baseName, event)];
          if (fromCode && fromCode(view.state, view.dispatch, view))
            return true;
        }
      }
      return false;
    };
  }

  // node_modules/prosemirror-commands/dist/index.js
  var deleteSelection = (state, dispatch) => {
    if (state.selection.empty)
      return false;
    if (dispatch)
      dispatch(state.tr.deleteSelection().scrollIntoView());
    return true;
  };
  function atBlockStart(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
      return null;
    return $cursor;
  }
  var joinBackward = (state, dispatch, view) => {
    let $cursor = atBlockStart(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutBefore($cursor);
    if (!$cut) {
      let range = $cursor.blockRange(), target = range && liftTarget(range);
      if (target == null)
        return false;
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    let before = $cut.nodeBefore;
    if (deleteBarrier(state, $cut, dispatch, -1))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
      for (let depth = $cursor.depth; ; depth--) {
        let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
        if (delStep && delStep.slice.size < delStep.to - delStep.from) {
          if (dispatch) {
            let tr3 = state.tr.step(delStep);
            tr3.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr3.doc.resolve(tr3.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr3.doc, $cut.pos - before.nodeSize));
            dispatch(tr3.scrollIntoView());
          }
          return true;
        }
        if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
          break;
      }
    }
    if (before.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
      return true;
    }
    return false;
  };
  var joinTextblockBackward = (state, dispatch, view) => {
    let $cursor = atBlockStart(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutBefore($cursor);
    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
  };
  var joinTextblockForward = (state, dispatch, view) => {
    let $cursor = atBlockEnd(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutAfter($cursor);
    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
  };
  function joinTextblocksAround(state, $cut, dispatch) {
    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;
    for (; !beforeText.isTextblock; beforePos--) {
      if (beforeText.type.spec.isolating)
        return false;
      let child = beforeText.lastChild;
      if (!child)
        return false;
      beforeText = child;
    }
    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;
    for (; !afterText.isTextblock; afterPos++) {
      if (afterText.type.spec.isolating)
        return false;
      let child = afterText.firstChild;
      if (!child)
        return false;
      afterText = child;
    }
    let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
    if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
      return false;
    if (dispatch) {
      let tr3 = state.tr.step(step);
      tr3.setSelection(TextSelection.create(tr3.doc, beforePos));
      dispatch(tr3.scrollIntoView());
    }
    return true;
  }
  function textblockAt(node2, side, only = false) {
    for (let scan = node2; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
      if (scan.isTextblock)
        return true;
      if (only && scan.childCount != 1)
        return false;
    }
    return false;
  }
  var selectNodeBackward = (state, dispatch, view) => {
    let { $head, empty: empty4 } = state.selection, $cut = $head;
    if (!empty4)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
        return false;
      $cut = findCutBefore($head);
    }
    let node2 = $cut && $cut.nodeBefore;
    if (!node2 || !NodeSelection.isSelectable(node2))
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node2.nodeSize)).scrollIntoView());
    return true;
  };
  function findCutBefore($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        if ($pos.index(i) > 0)
          return $pos.doc.resolve($pos.before(i + 1));
        if ($pos.node(i).type.spec.isolating)
          break;
      }
    return null;
  }
  function atBlockEnd(state, view) {
    let { $cursor } = state.selection;
    if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
      return null;
    return $cursor;
  }
  var joinForward = (state, dispatch, view) => {
    let $cursor = atBlockEnd(state, view);
    if (!$cursor)
      return false;
    let $cut = findCutAfter($cursor);
    if (!$cut)
      return false;
    let after = $cut.nodeAfter;
    if (deleteBarrier(state, $cut, dispatch, 1))
      return true;
    if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
      let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr3 = state.tr.step(delStep);
          tr3.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr3.doc.resolve(tr3.mapping.map($cut.pos)), 1) : NodeSelection.create(tr3.doc, tr3.mapping.map($cut.pos)));
          dispatch(tr3.scrollIntoView());
        }
        return true;
      }
    }
    if (after.isAtom && $cut.depth == $cursor.depth - 1) {
      if (dispatch)
        dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
      return true;
    }
    return false;
  };
  var selectNodeForward = (state, dispatch, view) => {
    let { $head, empty: empty4 } = state.selection, $cut = $head;
    if (!empty4)
      return false;
    if ($head.parent.isTextblock) {
      if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
        return false;
      $cut = findCutAfter($head);
    }
    let node2 = $cut && $cut.nodeAfter;
    if (!node2 || !NodeSelection.isSelectable(node2))
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
    return true;
  };
  function findCutAfter($pos) {
    if (!$pos.parent.type.spec.isolating)
      for (let i = $pos.depth - 1; i >= 0; i--) {
        let parent = $pos.node(i);
        if ($pos.index(i) + 1 < parent.childCount)
          return $pos.doc.resolve($pos.after(i + 1));
        if (parent.type.spec.isolating)
          break;
      }
    return null;
  }
  var joinUp = (state, dispatch) => {
    let sel = state.selection, nodeSel = sel instanceof NodeSelection, point5;
    if (nodeSel) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
        return false;
      point5 = sel.from;
    } else {
      point5 = joinPoint(state.doc, sel.from, -1);
      if (point5 == null)
        return false;
    }
    if (dispatch) {
      let tr3 = state.tr.join(point5);
      if (nodeSel)
        tr3.setSelection(NodeSelection.create(tr3.doc, point5 - state.doc.resolve(point5).nodeBefore.nodeSize));
      dispatch(tr3.scrollIntoView());
    }
    return true;
  };
  var joinDown = (state, dispatch) => {
    let sel = state.selection, point5;
    if (sel instanceof NodeSelection) {
      if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
        return false;
      point5 = sel.to;
    } else {
      point5 = joinPoint(state.doc, sel.to, 1);
      if (point5 == null)
        return false;
    }
    if (dispatch)
      dispatch(state.tr.join(point5).scrollIntoView());
    return true;
  };
  var lift2 = (state, dispatch) => {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  var newlineInCode = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    if (dispatch)
      dispatch(state.tr.insertText("\n").scrollIntoView());
    return true;
  };
  function defaultBlockAt(match) {
    for (let i = 0; i < match.edgeCount; i++) {
      let { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs())
        return type;
    }
    return null;
  }
  var exitCode = (state, dispatch) => {
    let { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
    if (!type || !above.canReplaceWith(after, after, type))
      return false;
    if (dispatch) {
      let pos = $head.after(), tr3 = state.tr.replaceWith(pos, pos, type.createAndFill());
      tr3.setSelection(Selection.near(tr3.doc.resolve(pos), 1));
      dispatch(tr3.scrollIntoView());
    }
    return true;
  };
  var createParagraphNear = (state, dispatch) => {
    let sel = state.selection, { $from, $to } = sel;
    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
      return false;
    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
    if (!type || !type.isTextblock)
      return false;
    if (dispatch) {
      let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
      let tr3 = state.tr.insert(side, type.createAndFill());
      tr3.setSelection(TextSelection.create(tr3.doc, side + 1));
      dispatch(tr3.scrollIntoView());
    }
    return true;
  };
  var liftEmptyBlock = (state, dispatch) => {
    let { $cursor } = state.selection;
    if (!$cursor || $cursor.parent.content.size)
      return false;
    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
      let before = $cursor.before();
      if (canSplit(state.doc, before)) {
        if (dispatch)
          dispatch(state.tr.split(before).scrollIntoView());
        return true;
      }
    }
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  };
  function splitBlockAs(splitNode) {
    return (state, dispatch) => {
      let { $from, $to } = state.selection;
      if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
        if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
          return false;
        if (dispatch)
          dispatch(state.tr.split($from.pos).scrollIntoView());
        return true;
      }
      if (!$from.depth)
        return false;
      let types = [];
      let splitDepth, deflt, atEnd = false, atStart = false;
      for (let d = $from.depth; ; d--) {
        let node2 = $from.node(d);
        if (node2.isBlock) {
          atEnd = $from.end(d) == $from.pos + ($from.depth - d);
          atStart = $from.start(d) == $from.pos - ($from.depth - d);
          deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
          let splitType = splitNode && splitNode($to.parent, atEnd, $from);
          types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));
          splitDepth = d;
          break;
        } else {
          if (d == 1)
            return false;
          types.unshift(null);
        }
      }
      let tr3 = state.tr;
      if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
        tr3.deleteSelection();
      let splitPos = tr3.mapping.map($from.pos);
      let can = canSplit(tr3.doc, splitPos, types.length, types);
      if (!can) {
        types[0] = deflt ? { type: deflt } : null;
        can = canSplit(tr3.doc, splitPos, types.length, types);
      }
      if (!can)
        return false;
      tr3.split(splitPos, types.length, types);
      if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
        let first3 = tr3.mapping.map($from.before(splitDepth)), $first = tr3.doc.resolve(first3);
        if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
          tr3.setNodeMarkup(tr3.mapping.map($from.before(splitDepth)), deflt);
      }
      if (dispatch)
        dispatch(tr3.scrollIntoView());
      return true;
    };
  }
  var splitBlock = splitBlockAs();
  var splitBlockKeepMarks = (state, dispatch) => {
    return splitBlock(state, dispatch && ((tr3) => {
      let marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
      if (marks)
        tr3.ensureMarks(marks);
      dispatch(tr3);
    }));
  };
  var selectParentNode = (state, dispatch) => {
    let { $from, to: to2 } = state.selection, pos;
    let same = $from.sharedDepth(to2);
    if (same == 0)
      return false;
    pos = $from.before(same);
    if (dispatch)
      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
    return true;
  };
  var selectAll = (state, dispatch) => {
    if (dispatch)
      dispatch(state.tr.setSelection(new AllSelection(state.doc)));
    return true;
  };
  function joinMaybeClear(state, $pos, dispatch) {
    let before = $pos.nodeBefore, after = $pos.nodeAfter, index3 = $pos.index();
    if (!before || !after || !before.type.compatibleContent(after.type))
      return false;
    if (!before.content.size && $pos.parent.canReplace(index3 - 1, index3)) {
      if (dispatch)
        dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
      return true;
    }
    if (!$pos.parent.canReplace(index3, index3 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
      return false;
    if (dispatch)
      dispatch(state.tr.join($pos.pos).scrollIntoView());
    return true;
  }
  function deleteBarrier(state, $cut, dispatch, dir) {
    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
    let isolated = before.type.spec.isolating || after.type.spec.isolating;
    if (!isolated && joinMaybeClear(state, $cut, dispatch))
      return true;
    let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
      if (dispatch) {
        let end = $cut.pos + after.nodeSize, wrap5 = Fragment.empty;
        for (let i = conn.length - 1; i >= 0; i--)
          wrap5 = Fragment.from(conn[i].create(null, wrap5));
        wrap5 = Fragment.from(before.copy(wrap5));
        let tr3 = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap5, 1, 0), conn.length, true));
        let $joinAt = tr3.doc.resolve(end + 2 * conn.length);
        if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr3.doc, $joinAt.pos))
          tr3.join($joinAt.pos);
        dispatch(tr3.scrollIntoView());
      }
      return true;
    }
    let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
    if (target != null && target >= $cut.depth) {
      if (dispatch)
        dispatch(state.tr.lift(range, target).scrollIntoView());
      return true;
    }
    if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
      let at2 = before, wrap5 = [];
      for (; ; ) {
        wrap5.push(at2);
        if (at2.isTextblock)
          break;
        at2 = at2.lastChild;
      }
      let afterText = after, afterDepth = 1;
      for (; !afterText.isTextblock; afterText = afterText.firstChild)
        afterDepth++;
      if (at2.canReplace(at2.childCount, at2.childCount, afterText.content)) {
        if (dispatch) {
          let end = Fragment.empty;
          for (let i = wrap5.length - 1; i >= 0; i--)
            end = Fragment.from(wrap5[i].copy(end));
          let tr3 = state.tr.step(new ReplaceAroundStep($cut.pos - wrap5.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap5.length, 0), 0, true));
          dispatch(tr3.scrollIntoView());
        }
        return true;
      }
    }
    return false;
  }
  function selectTextblockSide(side) {
    return function(state, dispatch) {
      let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
      let depth = $pos.depth;
      while ($pos.node(depth).isInline) {
        if (!depth)
          return false;
        depth--;
      }
      if (!$pos.node(depth).isTextblock)
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
      return true;
    };
  }
  var selectTextblockStart = selectTextblockSide(-1);
  var selectTextblockEnd = selectTextblockSide(1);
  function wrapIn(nodeType, attrs = null) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);
      if (!wrapping)
        return false;
      if (dispatch)
        dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
      return true;
    };
  }
  function setBlockType2(nodeType, attrs = null) {
    return function(state, dispatch) {
      let applicable = false;
      for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
        let { $from: { pos: from4 }, $to: { pos: to2 } } = state.selection.ranges[i];
        state.doc.nodesBetween(from4, to2, (node2, pos) => {
          if (applicable)
            return false;
          if (!node2.isTextblock || node2.hasMarkup(nodeType, attrs))
            return;
          if (node2.type == nodeType) {
            applicable = true;
          } else {
            let $pos = state.doc.resolve(pos), index3 = $pos.index();
            applicable = $pos.parent.canReplaceWith(index3, index3 + 1, nodeType);
          }
        });
      }
      if (!applicable)
        return false;
      if (dispatch) {
        let tr3 = state.tr;
        for (let i = 0; i < state.selection.ranges.length; i++) {
          let { $from: { pos: from4 }, $to: { pos: to2 } } = state.selection.ranges[i];
          tr3.setBlockType(from4, to2, nodeType, attrs);
        }
        dispatch(tr3.scrollIntoView());
      }
      return true;
    };
  }
  function markApplies(doc4, ranges, type, enterAtoms) {
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i];
      let can = $from.depth == 0 ? doc4.inlineContent && doc4.type.allowsMarkType(type) : false;
      doc4.nodesBetween($from.pos, $to.pos, (node2, pos) => {
        if (can || !enterAtoms && node2.isAtom && node2.isInline && pos >= $from.pos && pos + node2.nodeSize <= $to.pos)
          return false;
        can = node2.inlineContent && node2.type.allowsMarkType(type);
      });
      if (can)
        return true;
    }
    return false;
  }
  function removeInlineAtoms(ranges) {
    let result = [];
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i];
      $from.doc.nodesBetween($from.pos, $to.pos, (node2, pos) => {
        if (node2.isAtom && node2.content.size && node2.isInline && pos >= $from.pos && pos + node2.nodeSize <= $to.pos) {
          if (pos + 1 > $from.pos)
            result.push(new SelectionRange($from, $from.doc.resolve(pos + 1)));
          $from = $from.doc.resolve(pos + 1 + node2.content.size);
          return false;
        }
      });
      if ($from.pos < $to.pos)
        result.push(new SelectionRange($from, $to));
    }
    return result;
  }
  function toggleMark(markType, attrs = null, options2) {
    let removeWhenPresent = (options2 && options2.removeWhenPresent) !== false;
    let enterAtoms = (options2 && options2.enterInlineAtoms) !== false;
    let dropSpace = !(options2 && options2.includeWhitespace);
    return function(state, dispatch) {
      let { empty: empty4, $cursor, ranges } = state.selection;
      if (empty4 && !$cursor || !markApplies(state.doc, ranges, markType, enterAtoms))
        return false;
      if (dispatch) {
        if ($cursor) {
          if (markType.isInSet(state.storedMarks || $cursor.marks()))
            dispatch(state.tr.removeStoredMark(markType));
          else
            dispatch(state.tr.addStoredMark(markType.create(attrs)));
        } else {
          let add3, tr3 = state.tr;
          if (!enterAtoms)
            ranges = removeInlineAtoms(ranges);
          if (removeWhenPresent) {
            add3 = !ranges.some((r) => state.doc.rangeHasMark(r.$from.pos, r.$to.pos, markType));
          } else {
            add3 = !ranges.every((r) => {
              let missing = false;
              tr3.doc.nodesBetween(r.$from.pos, r.$to.pos, (node2, pos, parent) => {
                if (missing)
                  return false;
                missing = !markType.isInSet(node2.marks) && !!parent && parent.type.allowsMarkType(markType) && !(node2.isText && /^\s*$/.test(node2.textBetween(Math.max(0, r.$from.pos - pos), Math.min(node2.nodeSize, r.$to.pos - pos))));
              });
              return !missing;
            });
          }
          for (let i = 0; i < ranges.length; i++) {
            let { $from, $to } = ranges[i];
            if (!add3) {
              tr3.removeMark($from.pos, $to.pos, markType);
            } else {
              let from4 = $from.pos, to2 = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;
              let spaceStart = dropSpace && start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
              let spaceEnd = dropSpace && end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;
              if (from4 + spaceStart < to2) {
                from4 += spaceStart;
                to2 -= spaceEnd;
              }
              tr3.addMark(from4, to2, markType.create(attrs));
            }
          }
          dispatch(tr3.scrollIntoView());
        }
      }
      return true;
    };
  }
  function wrapDispatchForJoin(dispatch, isJoinable) {
    return (tr3) => {
      if (!tr3.isGeneric)
        return dispatch(tr3);
      let ranges = [];
      for (let i = 0; i < tr3.mapping.maps.length; i++) {
        let map9 = tr3.mapping.maps[i];
        for (let j2 = 0; j2 < ranges.length; j2++)
          ranges[j2] = map9.map(ranges[j2]);
        map9.forEach((_s2, _e2, from4, to2) => ranges.push(from4, to2));
      }
      let joinable3 = [];
      for (let i = 0; i < ranges.length; i += 2) {
        let from4 = ranges[i], to2 = ranges[i + 1];
        let $from = tr3.doc.resolve(from4), depth = $from.sharedDepth(to2), parent = $from.node(depth);
        for (let index3 = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to2; ++index3) {
          let after = parent.maybeChild(index3);
          if (!after)
            break;
          if (index3 && joinable3.indexOf(pos) == -1) {
            let before = parent.child(index3 - 1);
            if (before.type == after.type && isJoinable(before, after))
              joinable3.push(pos);
          }
          pos += after.nodeSize;
        }
      }
      joinable3.sort((a2, b) => a2 - b);
      for (let i = joinable3.length - 1; i >= 0; i--) {
        if (canJoin(tr3.doc, joinable3[i]))
          tr3.join(joinable3[i]);
      }
      dispatch(tr3);
    };
  }
  function autoJoin(command2, isJoinable) {
    let canJoin2 = Array.isArray(isJoinable) ? (node2) => isJoinable.indexOf(node2.type.name) > -1 : isJoinable;
    return (state, dispatch, view) => command2(state, dispatch && wrapDispatchForJoin(dispatch, canJoin2), view);
  }
  function chainCommands(...commands2) {
    return function(state, dispatch, view) {
      for (let i = 0; i < commands2.length; i++)
        if (commands2[i](state, dispatch, view))
          return true;
      return false;
    };
  }
  var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
  var del2 = chainCommands(deleteSelection, joinForward, selectNodeForward);
  var pcBaseKeymap = {
    "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
    "Mod-Enter": exitCode,
    "Backspace": backspace,
    "Mod-Backspace": backspace,
    "Shift-Backspace": backspace,
    "Delete": del2,
    "Mod-Delete": del2,
    "Mod-a": selectAll
  };
  var macBaseKeymap = {
    "Ctrl-h": pcBaseKeymap["Backspace"],
    "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
    "Ctrl-d": pcBaseKeymap["Delete"],
    "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
    "Alt-Delete": pcBaseKeymap["Mod-Delete"],
    "Alt-d": pcBaseKeymap["Mod-Delete"],
    "Ctrl-a": selectTextblockStart,
    "Ctrl-e": selectTextblockEnd
  };
  for (let key2 in pcBaseKeymap)
    macBaseKeymap[key2] = pcBaseKeymap[key2];
  var mac4 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
  var baseKeymap = mac4 ? macBaseKeymap : pcBaseKeymap;

  // node_modules/prosemirror-schema-list/dist/index.js
  var olDOM = ["ol", 0], ulDOM = ["ul", 0], liDOM = ["li", 0];
  var orderedList = {
    attrs: { order: { default: 1, validate: "number" } },
    parseDOM: [{ tag: "ol", getAttrs(dom) {
      return { order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1 };
    } }],
    toDOM(node2) {
      return node2.attrs.order == 1 ? olDOM : ["ol", { start: node2.attrs.order }, 0];
    }
  };
  var bulletList = {
    parseDOM: [{ tag: "ul" }],
    toDOM() {
      return ulDOM;
    }
  };
  var listItem3 = {
    parseDOM: [{ tag: "li" }],
    toDOM() {
      return liDOM;
    },
    defining: true
  };
  function add(obj, props) {
    let copy4 = {};
    for (let prop in obj)
      copy4[prop] = obj[prop];
    for (let prop in props)
      copy4[prop] = props[prop];
    return copy4;
  }
  function addListNodes(nodes, itemContent, listGroup) {
    return nodes.append({
      ordered_list: add(orderedList, { content: "list_item+", group: listGroup }),
      bullet_list: add(bulletList, { content: "list_item+", group: listGroup }),
      list_item: add(listItem3, { content: itemContent })
    });
  }
  function wrapInList(listType, attrs = null) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to);
      if (!range)
        return false;
      let tr3 = dispatch ? state.tr : null;
      if (!wrapRangeInList(tr3, range, listType, attrs))
        return false;
      if (dispatch)
        dispatch(tr3.scrollIntoView());
      return true;
    };
  }
  function wrapRangeInList(tr3, range, listType, attrs = null) {
    let doJoin = false, outerRange = range, doc4 = range.$from.doc;
    if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      if (range.$from.index(range.depth - 1) == 0)
        return false;
      let $insert = doc4.resolve(range.start - 2);
      outerRange = new NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount)
        range = new NodeRange(range.$from, doc4.resolve(range.$to.end(range.depth)), range.depth);
      doJoin = true;
    }
    let wrap5 = findWrapping(outerRange, listType, attrs, range);
    if (!wrap5)
      return false;
    if (tr3)
      doWrapInList(tr3, range, wrap5, doJoin, listType);
    return true;
  }
  function doWrapInList(tr3, range, wrappers, joinBefore, listType) {
    let content5 = Fragment.empty;
    for (let i = wrappers.length - 1; i >= 0; i--)
      content5 = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content5));
    tr3.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content5, 0, 0), wrappers.length, true));
    let found2 = 0;
    for (let i = 0; i < wrappers.length; i++)
      if (wrappers[i].type == listType)
        found2 = i + 1;
    let splitDepth = wrappers.length - found2;
    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
    for (let i = range.startIndex, e = range.endIndex, first3 = true; i < e; i++, first3 = false) {
      if (!first3 && canSplit(tr3.doc, splitPos, splitDepth)) {
        tr3.split(splitPos, splitDepth);
        splitPos += 2 * splitDepth;
      }
      splitPos += parent.child(i).nodeSize;
    }
    return tr3;
  }
  function splitListItem(itemType, itemAttrs) {
    return function(state, dispatch) {
      let { $from, $to, node: node2 } = state.selection;
      if (node2 && node2.isBlock || $from.depth < 2 || !$from.sameParent($to))
        return false;
      let grandParent = $from.node(-1);
      if (grandParent.type != itemType)
        return false;
      if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
        if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1)
          return false;
        if (dispatch) {
          let wrap5 = Fragment.empty;
          let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
          for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)
            wrap5 = Fragment.from($from.node(d).copy(wrap5));
          let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
          wrap5 = wrap5.append(Fragment.from(itemType.createAndFill()));
          let start = $from.before($from.depth - (depthBefore - 1));
          let tr4 = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap5, 4 - depthBefore, 0));
          let sel = -1;
          tr4.doc.nodesBetween(start, tr4.doc.content.size, (node3, pos) => {
            if (sel > -1)
              return false;
            if (node3.isTextblock && node3.content.size == 0)
              sel = pos + 1;
          });
          if (sel > -1)
            tr4.setSelection(Selection.near(tr4.doc.resolve(sel)));
          dispatch(tr4.scrollIntoView());
        }
        return true;
      }
      let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
      let tr3 = state.tr.delete($from.pos, $to.pos);
      let types = nextType ? [itemAttrs ? { type: itemType, attrs: itemAttrs } : null, { type: nextType }] : void 0;
      if (!canSplit(tr3.doc, $from.pos, 2, types))
        return false;
      if (dispatch)
        dispatch(tr3.split($from.pos, 2, types).scrollIntoView());
      return true;
    };
  }
  function splitListItemKeepMarks(itemType, itemAttrs) {
    let split3 = splitListItem(itemType, itemAttrs);
    return (state, dispatch) => {
      return split3(state, dispatch && ((tr3) => {
        let marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
        if (marks)
          tr3.ensureMarks(marks);
        dispatch(tr3);
      }));
    };
  }
  function liftListItem(itemType) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node2) => node2.childCount > 0 && node2.firstChild.type == itemType);
      if (!range)
        return false;
      if (!dispatch)
        return true;
      if ($from.node(range.depth - 1).type == itemType)
        return liftToOuterList(state, dispatch, itemType, range);
      else
        return liftOutOfList(state, dispatch, range);
    };
  }
  function liftToOuterList(state, dispatch, itemType, range) {
    let tr3 = state.tr, end = range.end, endOfList = range.$to.end(range.depth);
    if (end < endOfList) {
      tr3.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
      range = new NodeRange(tr3.doc.resolve(range.$from.pos), tr3.doc.resolve(endOfList), range.depth);
    }
    const target = liftTarget(range);
    if (target == null)
      return false;
    tr3.lift(range, target);
    let $after = tr3.doc.resolve(tr3.mapping.map(end, -1) - 1);
    if (canJoin(tr3.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
      tr3.join($after.pos);
    dispatch(tr3.scrollIntoView());
    return true;
  }
  function liftOutOfList(state, dispatch, range) {
    let tr3 = state.tr, list7 = range.parent;
    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
      pos -= list7.child(i).nodeSize;
      tr3.delete(pos - 1, pos + 1);
    }
    let $start = tr3.doc.resolve(range.start), item = $start.nodeAfter;
    if (tr3.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
      return false;
    let atStart = range.startIndex == 0, atEnd = range.endIndex == list7.childCount;
    let parent = $start.node(-1), indexBefore = $start.index(-1);
    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list7))))
      return false;
    let start = $start.pos, end = start + item.nodeSize;
    tr3.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list7.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list7.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
    dispatch(tr3.scrollIntoView());
    return true;
  }
  function sinkListItem(itemType) {
    return function(state, dispatch) {
      let { $from, $to } = state.selection;
      let range = $from.blockRange($to, (node2) => node2.childCount > 0 && node2.firstChild.type == itemType);
      if (!range)
        return false;
      let startIndex = range.startIndex;
      if (startIndex == 0)
        return false;
      let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
      if (nodeBefore.type != itemType)
        return false;
      if (dispatch) {
        let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
        let inner = Fragment.from(nestedBefore ? itemType.create() : null);
        let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
        let before = range.start, after = range.end;
        dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
      }
      return true;
    };
  }

  // node_modules/@tiptap/core/dist/index.js
  function createChainableState(config) {
    const { state, transaction } = config;
    let { selection } = transaction;
    let { doc: doc4 } = transaction;
    let { storedMarks } = transaction;
    return {
      ...state,
      apply: state.apply.bind(state),
      applyTransaction: state.applyTransaction.bind(state),
      plugins: state.plugins,
      schema: state.schema,
      reconfigure: state.reconfigure.bind(state),
      toJSON: state.toJSON.bind(state),
      get storedMarks() {
        return storedMarks;
      },
      get selection() {
        return selection;
      },
      get doc() {
        return doc4;
      },
      get tr() {
        selection = transaction.selection;
        doc4 = transaction.doc;
        storedMarks = transaction.storedMarks;
        return transaction;
      }
    };
  }
  var CommandManager = class {
    constructor(props) {
      this.editor = props.editor;
      this.rawCommands = this.editor.extensionManager.commands;
      this.customState = props.state;
    }
    get hasCustomState() {
      return !!this.customState;
    }
    get state() {
      return this.customState || this.editor.state;
    }
    get commands() {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const { tr: tr3 } = state;
      const props = this.buildProps(tr3);
      return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const method = (...args2) => {
          const callback = command2(...args2)(props);
          if (!tr3.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr3);
          }
          return callback;
        };
        return [name, method];
      }));
    }
    get chain() {
      return () => this.createChain();
    }
    get can() {
      return () => this.createCan();
    }
    createChain(startTr, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const callbacks = [];
      const hasStartTransaction = !!startTr;
      const tr3 = startTr || state.tr;
      const run3 = () => {
        if (!hasStartTransaction && shouldDispatch && !tr3.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr3);
        }
        return callbacks.every((callback) => callback === true);
      };
      const chain = {
        ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args2) => {
            const props = this.buildProps(tr3, shouldDispatch);
            const callback = command2(...args2)(props);
            callbacks.push(callback);
            return chain;
          };
          return [name, chainedCommand];
        })),
        run: run3
      };
      return chain;
    }
    createCan(startTr) {
      const { rawCommands, state } = this;
      const dispatch = false;
      const tr3 = startTr || state.tr;
      const props = this.buildProps(tr3, dispatch);
      const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args2) => command2(...args2)({ ...props, dispatch: void 0 })];
      }));
      return {
        ...formattedCommands,
        chain: () => this.createChain(tr3, dispatch)
      };
    }
    buildProps(tr3, shouldDispatch = true) {
      const { rawCommands, editor, state } = this;
      const { view } = editor;
      const props = {
        tr: tr3,
        editor,
        view,
        state: createChainableState({
          state,
          transaction: tr3
        }),
        dispatch: shouldDispatch ? () => void 0 : void 0,
        chain: () => this.createChain(tr3, shouldDispatch),
        can: () => this.createCan(tr3),
        get commands() {
          return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args2) => command2(...args2)(props)];
          }));
        }
      };
      return props;
    }
  };
  var EventEmitter = class {
    constructor() {
      this.callbacks = {};
    }
    on(event, fn2) {
      if (!this.callbacks[event]) {
        this.callbacks[event] = [];
      }
      this.callbacks[event].push(fn2);
      return this;
    }
    emit(event, ...args2) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        callbacks.forEach((callback) => callback.apply(this, args2));
      }
      return this;
    }
    off(event, fn2) {
      const callbacks = this.callbacks[event];
      if (callbacks) {
        if (fn2) {
          this.callbacks[event] = callbacks.filter((callback) => callback !== fn2);
        } else {
          delete this.callbacks[event];
        }
      }
      return this;
    }
    once(event, fn2) {
      const onceFn = (...args2) => {
        this.off(event, onceFn);
        fn2.apply(this, args2);
      };
      return this.on(event, onceFn);
    }
    removeAllListeners() {
      this.callbacks = {};
    }
  };
  function getExtensionField(extension2, field, context) {
    if (extension2.config[field] === void 0 && extension2.parent) {
      return getExtensionField(extension2.parent, field, context);
    }
    if (typeof extension2.config[field] === "function") {
      const value = extension2.config[field].bind({
        ...context,
        parent: extension2.parent ? getExtensionField(extension2.parent, field, context) : null
      });
      return value;
    }
    return extension2.config[field];
  }
  function splitExtensions(extensions) {
    const baseExtensions = extensions.filter((extension2) => extension2.type === "extension");
    const nodeExtensions = extensions.filter((extension2) => extension2.type === "node");
    const markExtensions = extensions.filter((extension2) => extension2.type === "mark");
    return {
      baseExtensions,
      nodeExtensions,
      markExtensions
    };
  }
  function getAttributesFromExtensions(extensions) {
    const extensionAttributes = [];
    const { nodeExtensions, markExtensions } = splitExtensions(extensions);
    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
    const defaultAttribute = {
      default: null,
      rendered: true,
      renderHTML: null,
      parseHTML: null,
      keepOnSplit: true,
      isRequired: false
    };
    extensions.forEach((extension2) => {
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage,
        extensions: nodeAndMarkExtensions
      };
      const addGlobalAttributes = getExtensionField(extension2, "addGlobalAttributes", context);
      if (!addGlobalAttributes) {
        return;
      }
      const globalAttributes = addGlobalAttributes();
      globalAttributes.forEach((globalAttribute) => {
        globalAttribute.types.forEach((type) => {
          Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
            extensionAttributes.push({
              type,
              name,
              attribute: {
                ...defaultAttribute,
                ...attribute
              }
            });
          });
        });
      });
    });
    nodeAndMarkExtensions.forEach((extension2) => {
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage
      };
      const addAttributes = getExtensionField(extension2, "addAttributes", context);
      if (!addAttributes) {
        return;
      }
      const attributes = addAttributes();
      Object.entries(attributes).forEach(([name, attribute]) => {
        const mergedAttr = {
          ...defaultAttribute,
          ...attribute
        };
        if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === "function") {
          mergedAttr.default = mergedAttr.default();
        }
        if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === void 0) {
          delete mergedAttr.default;
        }
        extensionAttributes.push({
          type: extension2.name,
          name,
          attribute: mergedAttr
        });
      });
    });
    return extensionAttributes;
  }
  function getNodeType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.nodes[nameOrType]) {
        throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.nodes[nameOrType];
    }
    return nameOrType;
  }
  function mergeAttributes(...objects) {
    return objects.filter((item) => !!item).reduce((items, item) => {
      const mergedAttributes = { ...items };
      Object.entries(item).forEach(([key2, value]) => {
        const exists = mergedAttributes[key2];
        if (!exists) {
          mergedAttributes[key2] = value;
          return;
        }
        if (key2 === "class") {
          const valueClasses = value ? String(value).split(" ") : [];
          const existingClasses = mergedAttributes[key2] ? mergedAttributes[key2].split(" ") : [];
          const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
          mergedAttributes[key2] = [...existingClasses, ...insertClasses].join(" ");
        } else if (key2 === "style") {
          const newStyles = value ? value.split(";").map((style3) => style3.trim()).filter(Boolean) : [];
          const existingStyles = mergedAttributes[key2] ? mergedAttributes[key2].split(";").map((style3) => style3.trim()).filter(Boolean) : [];
          const styleMap = /* @__PURE__ */ new Map();
          existingStyles.forEach((style3) => {
            const [property, val] = style3.split(":").map((part) => part.trim());
            styleMap.set(property, val);
          });
          newStyles.forEach((style3) => {
            const [property, val] = style3.split(":").map((part) => part.trim());
            styleMap.set(property, val);
          });
          mergedAttributes[key2] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join("; ");
        } else {
          mergedAttributes[key2] = value;
        }
      });
      return mergedAttributes;
    }, {});
  }
  function getRenderedAttributes(nodeOrMark, extensionAttributes) {
    return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
      if (!item.attribute.renderHTML) {
        return {
          [item.name]: nodeOrMark.attrs[item.name]
        };
      }
      return item.attribute.renderHTML(nodeOrMark.attrs) || {};
    }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function callOrReturn(value, context = void 0, ...props) {
    if (isFunction(value)) {
      if (context) {
        return value.bind(context)(...props);
      }
      return value(...props);
    }
    return value;
  }
  function isEmptyObject(value = {}) {
    return Object.keys(value).length === 0 && value.constructor === Object;
  }
  function fromString(value) {
    if (typeof value !== "string") {
      return value;
    }
    if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
      return Number(value);
    }
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return value;
  }
  function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
    if ("style" in parseRule) {
      return parseRule;
    }
    return {
      ...parseRule,
      getAttrs: (node2) => {
        const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node2) : parseRule.attrs;
        if (oldAttributes === false) {
          return false;
        }
        const newAttributes = extensionAttributes.reduce((items, item) => {
          const value = item.attribute.parseHTML ? item.attribute.parseHTML(node2) : fromString(node2.getAttribute(item.name));
          if (value === null || value === void 0) {
            return items;
          }
          return {
            ...items,
            [item.name]: value
          };
        }, {});
        return { ...oldAttributes, ...newAttributes };
      }
    };
  }
  function cleanUpSchemaItem(data) {
    return Object.fromEntries(
      // @ts-ignore
      Object.entries(data).filter(([key2, value]) => {
        if (key2 === "attrs" && isEmptyObject(value)) {
          return false;
        }
        return value !== null && value !== void 0;
      })
    );
  }
  function getSchemaByResolvedExtensions(extensions, editor) {
    var _a3;
    const allAttributes = getAttributesFromExtensions(extensions);
    const { nodeExtensions, markExtensions } = splitExtensions(extensions);
    const topNode = (_a3 = nodeExtensions.find((extension2) => getExtensionField(extension2, "topNode"))) === null || _a3 === void 0 ? void 0 : _a3.name;
    const nodes = Object.fromEntries(nodeExtensions.map((extension2) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension2.name);
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage,
        editor
      };
      const extraNodeFields = extensions.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension2) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraNodeFields,
        content: callOrReturn(getExtensionField(extension2, "content", context)),
        marks: callOrReturn(getExtensionField(extension2, "marks", context)),
        group: callOrReturn(getExtensionField(extension2, "group", context)),
        inline: callOrReturn(getExtensionField(extension2, "inline", context)),
        atom: callOrReturn(getExtensionField(extension2, "atom", context)),
        selectable: callOrReturn(getExtensionField(extension2, "selectable", context)),
        draggable: callOrReturn(getExtensionField(extension2, "draggable", context)),
        code: callOrReturn(getExtensionField(extension2, "code", context)),
        whitespace: callOrReturn(getExtensionField(extension2, "whitespace", context)),
        linebreakReplacement: callOrReturn(getExtensionField(extension2, "linebreakReplacement", context)),
        defining: callOrReturn(getExtensionField(extension2, "defining", context)),
        isolating: callOrReturn(getExtensionField(extension2, "isolating", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a4;
          return [extensionAttribute.name, { default: (_a4 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a4 === void 0 ? void 0 : _a4.default }];
        }))
      });
      const parseHTML = callOrReturn(getExtensionField(extension2, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension2, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (node2) => renderHTML({
          node: node2,
          HTMLAttributes: getRenderedAttributes(node2, extensionAttributes)
        });
      }
      const renderText = getExtensionField(extension2, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension2.name, schema];
    }));
    const marks = Object.fromEntries(markExtensions.map((extension2) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension2.name);
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage,
        editor
      };
      const extraMarkFields = extensions.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension2) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraMarkFields,
        inclusive: callOrReturn(getExtensionField(extension2, "inclusive", context)),
        excludes: callOrReturn(getExtensionField(extension2, "excludes", context)),
        group: callOrReturn(getExtensionField(extension2, "group", context)),
        spanning: callOrReturn(getExtensionField(extension2, "spanning", context)),
        code: callOrReturn(getExtensionField(extension2, "code", context)),
        attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
          var _a4;
          return [extensionAttribute.name, { default: (_a4 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a4 === void 0 ? void 0 : _a4.default }];
        }))
      });
      const parseHTML = callOrReturn(getExtensionField(extension2, "parseHTML", context));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
      }
      const renderHTML = getExtensionField(extension2, "renderHTML", context);
      if (renderHTML) {
        schema.toDOM = (mark2) => renderHTML({
          mark: mark2,
          HTMLAttributes: getRenderedAttributes(mark2, extensionAttributes)
        });
      }
      return [extension2.name, schema];
    }));
    return new Schema2({
      topNode,
      nodes,
      marks
    });
  }
  function getSchemaTypeByName(name, schema) {
    return schema.nodes[name] || schema.marks[name] || null;
  }
  function isExtensionRulesEnabled(extension2, enabled) {
    if (Array.isArray(enabled)) {
      return enabled.some((enabledExtension) => {
        const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
        return name === extension2.name;
      });
    }
    return enabled;
  }
  function getHTMLFromFragment(fragment2, schema) {
    const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment2);
    const temporaryDocument = document.implementation.createHTMLDocument();
    const container = temporaryDocument.createElement("div");
    container.appendChild(documentFragment);
    return container.innerHTML;
  }
  var getTextContentFromNodes = ($from, maxMatch = 500) => {
    let textBefore = "";
    const sliceEndPos = $from.parentOffset;
    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node2, pos, parent, index3) => {
      var _a3, _b;
      const chunk = ((_b = (_a3 = node2.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a3, {
        node: node2,
        pos,
        parent,
        index: index3
      })) || node2.textContent || "%leaf%";
      textBefore += node2.isAtom && !node2.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
    });
    return textBefore;
  };
  function isRegExp(value) {
    return Object.prototype.toString.call(value) === "[object RegExp]";
  }
  var InputRule = class {
    constructor(config) {
      this.find = config.find;
      this.handler = config.handler;
    }
  };
  var inputRuleMatcherHandler = (text10, find4) => {
    if (isRegExp(find4)) {
      return find4.exec(text10);
    }
    const inputRuleMatch = find4(text10);
    if (!inputRuleMatch) {
      return null;
    }
    const result = [inputRuleMatch.text];
    result.index = inputRuleMatch.index;
    result.input = text10;
    result.data = inputRuleMatch.data;
    if (inputRuleMatch.replaceWith) {
      if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
      }
      result.push(inputRuleMatch.replaceWith);
    }
    return result;
  };
  function run$1(config) {
    var _a3;
    const { editor, from: from4, to: to2, text: text10, rules, plugin } = config;
    const { view } = editor;
    if (view.composing) {
      return false;
    }
    const $from = view.state.doc.resolve(from4);
    if (
      // check for code node
      $from.parent.type.spec.code || !!((_a3 = $from.nodeBefore || $from.nodeAfter) === null || _a3 === void 0 ? void 0 : _a3.marks.find((mark2) => mark2.type.spec.code))
    ) {
      return false;
    }
    let matched = false;
    const textBefore = getTextContentFromNodes($from) + text10;
    rules.forEach((rule) => {
      if (matched) {
        return;
      }
      const match = inputRuleMatcherHandler(textBefore, rule.find);
      if (!match) {
        return;
      }
      const tr3 = view.state.tr;
      const state = createChainableState({
        state: view.state,
        transaction: tr3
      });
      const range = {
        from: from4 - (match[0].length - text10.length),
        to: to2
      };
      const { commands: commands2, chain, can } = new CommandManager({
        editor,
        state
      });
      const handler = rule.handler({
        state,
        range,
        match,
        commands: commands2,
        chain,
        can
      });
      if (handler === null || !tr3.steps.length) {
        return;
      }
      tr3.setMeta(plugin, {
        transform: tr3,
        from: from4,
        to: to2,
        text: text10
      });
      view.dispatch(tr3);
      matched = true;
    });
    return matched;
  }
  function inputRulesPlugin(props) {
    const { editor, rules } = props;
    const plugin = new Plugin({
      state: {
        init() {
          return null;
        },
        apply(tr3, prev, state) {
          const stored = tr3.getMeta(plugin);
          if (stored) {
            return stored;
          }
          const simulatedInputMeta = tr3.getMeta("applyInputRules");
          const isSimulatedInput = !!simulatedInputMeta;
          if (isSimulatedInput) {
            setTimeout(() => {
              let { text: text10 } = simulatedInputMeta;
              if (typeof text10 === "string") {
                text10 = text10;
              } else {
                text10 = getHTMLFromFragment(Fragment.from(text10), state.schema);
              }
              const { from: from4 } = simulatedInputMeta;
              const to2 = from4 + text10.length;
              run$1({
                editor,
                from: from4,
                to: to2,
                text: text10,
                rules,
                plugin
              });
            });
          }
          return tr3.selectionSet || tr3.docChanged ? null : prev;
        }
      },
      props: {
        handleTextInput(view, from4, to2, text10) {
          return run$1({
            editor,
            from: from4,
            to: to2,
            text: text10,
            rules,
            plugin
          });
        },
        handleDOMEvents: {
          compositionend: (view) => {
            setTimeout(() => {
              const { $cursor } = view.state.selection;
              if ($cursor) {
                run$1({
                  editor,
                  from: $cursor.pos,
                  to: $cursor.pos,
                  text: "",
                  rules,
                  plugin
                });
              }
            });
            return false;
          }
        },
        // add support for input rules to trigger on enter
        // this is useful for example for code blocks
        handleKeyDown(view, event) {
          if (event.key !== "Enter") {
            return false;
          }
          const { $cursor } = view.state.selection;
          if ($cursor) {
            return run$1({
              editor,
              from: $cursor.pos,
              to: $cursor.pos,
              text: "\n",
              rules,
              plugin
            });
          }
          return false;
        }
      },
      // @ts-ignore
      isInputRules: true
    });
    return plugin;
  }
  function getType(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  function isPlainObject2(value) {
    if (getType(value) !== "Object") {
      return false;
    }
    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
  }
  function mergeDeep(target, source) {
    const output = { ...target };
    if (isPlainObject2(target) && isPlainObject2(source)) {
      Object.keys(source).forEach((key2) => {
        if (isPlainObject2(source[key2]) && isPlainObject2(target[key2])) {
          output[key2] = mergeDeep(target[key2], source[key2]);
        } else {
          output[key2] = source[key2];
        }
      });
    }
    return output;
  }
  var Mark2 = class _Mark {
    constructor(config = {}) {
      this.type = "mark";
      this.name = "mark";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config
      };
      this.name = this.config.name;
      if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config = {}) {
      return new _Mark(config);
    }
    configure(options2 = {}) {
      const extension2 = this.extend({
        ...this.config,
        addOptions: () => {
          return mergeDeep(this.options, options2);
        }
      });
      extension2.name = this.name;
      extension2.parent = this.parent;
      return extension2;
    }
    extend(extendedConfig = {}) {
      const extension2 = new _Mark(extendedConfig);
      extension2.parent = this;
      this.child = extension2;
      extension2.name = extendedConfig.name ? extendedConfig.name : extension2.parent.name;
      if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension2.name}".`);
      }
      extension2.options = callOrReturn(getExtensionField(extension2, "addOptions", {
        name: extension2.name
      }));
      extension2.storage = callOrReturn(getExtensionField(extension2, "addStorage", {
        name: extension2.name,
        options: extension2.options
      }));
      return extension2;
    }
    static handleExit({ editor, mark: mark2 }) {
      const { tr: tr3 } = editor.state;
      const currentPos = editor.state.selection.$from;
      const isAtEnd = currentPos.pos === currentPos.end();
      if (isAtEnd) {
        const currentMarks = currentPos.marks();
        const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark2.name);
        if (!isInMark) {
          return false;
        }
        const removeMark2 = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark2.name);
        if (removeMark2) {
          tr3.removeStoredMark(removeMark2);
        }
        tr3.insertText(" ", currentPos.pos);
        editor.view.dispatch(tr3);
        return true;
      }
      return false;
    }
  };
  function isNumber2(value) {
    return typeof value === "number";
  }
  var PasteRule = class {
    constructor(config) {
      this.find = config.find;
      this.handler = config.handler;
    }
  };
  var pasteRuleMatcherHandler = (text10, find4, event) => {
    if (isRegExp(find4)) {
      return [...text10.matchAll(find4)];
    }
    const matches2 = find4(text10, event);
    if (!matches2) {
      return [];
    }
    return matches2.map((pasteRuleMatch) => {
      const result = [pasteRuleMatch.text];
      result.index = pasteRuleMatch.index;
      result.input = text10;
      result.data = pasteRuleMatch.data;
      if (pasteRuleMatch.replaceWith) {
        if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
          console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
        }
        result.push(pasteRuleMatch.replaceWith);
      }
      return result;
    });
  };
  function run(config) {
    const { editor, state, from: from4, to: to2, rule, pasteEvent, dropEvent } = config;
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state
    });
    const handlers4 = [];
    state.doc.nodesBetween(from4, to2, (node2, pos) => {
      if (!node2.isTextblock || node2.type.spec.code) {
        return;
      }
      const resolvedFrom = Math.max(from4, pos);
      const resolvedTo = Math.min(to2, pos + node2.content.size);
      const textToMatch = node2.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
      const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
      matches2.forEach((match) => {
        if (match.index === void 0) {
          return;
        }
        const start = resolvedFrom + match.index + 1;
        const end = start + match[0].length;
        const range = {
          from: state.tr.mapping.map(start),
          to: state.tr.mapping.map(end)
        };
        const handler = rule.handler({
          state,
          range,
          match,
          commands: commands2,
          chain,
          can,
          pasteEvent,
          dropEvent
        });
        handlers4.push(handler);
      });
    });
    const success = handlers4.every((handler) => handler !== null);
    return success;
  }
  var tiptapDragFromOtherEditor = null;
  var createClipboardPasteEvent = (text10) => {
    var _a3;
    const event = new ClipboardEvent("paste", {
      clipboardData: new DataTransfer()
    });
    (_a3 = event.clipboardData) === null || _a3 === void 0 ? void 0 : _a3.setData("text/html", text10);
    return event;
  };
  function pasteRulesPlugin(props) {
    const { editor, rules } = props;
    let dragSourceElement = null;
    let isPastedFromProseMirror = false;
    let isDroppedFromProseMirror = false;
    let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    let dropEvent;
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch {
      dropEvent = null;
    }
    const processEvent = ({ state, from: from4, to: to2, rule, pasteEvt }) => {
      const tr3 = state.tr;
      const chainableState = createChainableState({
        state,
        transaction: tr3
      });
      const handler = run({
        editor,
        state: chainableState,
        from: Math.max(from4 - 1, 0),
        to: to2.b - 1,
        rule,
        pasteEvent: pasteEvt,
        dropEvent
      });
      if (!handler || !tr3.steps.length) {
        return;
      }
      try {
        dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
      } catch {
        dropEvent = null;
      }
      pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
      return tr3;
    };
    const plugins = rules.map((rule) => {
      return new Plugin({
        // we register a global drag handler to track the current drag source element
        view(view) {
          const handleDragstart = (event) => {
            var _a3;
            dragSourceElement = ((_a3 = view.dom.parentElement) === null || _a3 === void 0 ? void 0 : _a3.contains(event.target)) ? view.dom.parentElement : null;
            if (dragSourceElement) {
              tiptapDragFromOtherEditor = editor;
            }
          };
          const handleDragend = () => {
            if (tiptapDragFromOtherEditor) {
              tiptapDragFromOtherEditor = null;
            }
          };
          window.addEventListener("dragstart", handleDragstart);
          window.addEventListener("dragend", handleDragend);
          return {
            destroy() {
              window.removeEventListener("dragstart", handleDragstart);
              window.removeEventListener("dragend", handleDragend);
            }
          };
        },
        props: {
          handleDOMEvents: {
            drop: (view, event) => {
              isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
              dropEvent = event;
              if (!isDroppedFromProseMirror) {
                const dragFromOtherEditor = tiptapDragFromOtherEditor;
                if (dragFromOtherEditor) {
                  setTimeout(() => {
                    const selection = dragFromOtherEditor.state.selection;
                    if (selection) {
                      dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                    }
                  }, 10);
                }
              }
              return false;
            },
            paste: (_view, event) => {
              var _a3;
              const html7 = (_a3 = event.clipboardData) === null || _a3 === void 0 ? void 0 : _a3.getData("text/html");
              pasteEvent = event;
              isPastedFromProseMirror = !!(html7 === null || html7 === void 0 ? void 0 : html7.includes("data-pm-slice"));
              return false;
            }
          }
        },
        appendTransaction: (transactions, oldState, state) => {
          const transaction = transactions[0];
          const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
          const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
          const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
          const isSimulatedPaste = !!simulatedPasteMeta;
          if (!isPaste && !isDrop && !isSimulatedPaste) {
            return;
          }
          if (isSimulatedPaste) {
            let { text: text10 } = simulatedPasteMeta;
            if (typeof text10 === "string") {
              text10 = text10;
            } else {
              text10 = getHTMLFromFragment(Fragment.from(text10), state.schema);
            }
            const { from: from5 } = simulatedPasteMeta;
            const to3 = from5 + text10.length;
            const pasteEvt = createClipboardPasteEvent(text10);
            return processEvent({
              rule,
              state,
              from: from5,
              to: { b: to3 },
              pasteEvt
            });
          }
          const from4 = oldState.doc.content.findDiffStart(state.doc.content);
          const to2 = oldState.doc.content.findDiffEnd(state.doc.content);
          if (!isNumber2(from4) || !to2 || from4 === to2.b) {
            return;
          }
          return processEvent({
            rule,
            state,
            from: from4,
            to: to2,
            pasteEvt: pasteEvent
          });
        }
      });
    });
    return plugins;
  }
  function findDuplicates(items) {
    const filtered = items.filter((el, index3) => items.indexOf(el) !== index3);
    return Array.from(new Set(filtered));
  }
  var ExtensionManager = class _ExtensionManager {
    constructor(extensions, editor) {
      this.splittableMarks = [];
      this.editor = editor;
      this.extensions = _ExtensionManager.resolve(extensions);
      this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
      this.setupExtensions();
    }
    /**
     * Returns a flattened and sorted extension list while
     * also checking for duplicated extensions and warns the user.
     * @param extensions An array of Tiptap extensions
     * @returns An flattened and sorted array of Tiptap extensions
     */
    static resolve(extensions) {
      const resolvedExtensions = _ExtensionManager.sort(_ExtensionManager.flatten(extensions));
      const duplicatedNames = findDuplicates(resolvedExtensions.map((extension2) => extension2.name));
      if (duplicatedNames.length) {
        console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`);
      }
      return resolvedExtensions;
    }
    /**
     * Create a flattened array of extensions by traversing the `addExtensions` field.
     * @param extensions An array of Tiptap extensions
     * @returns A flattened array of Tiptap extensions
     */
    static flatten(extensions) {
      return extensions.map((extension2) => {
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: extension2.storage
        };
        const addExtensions = getExtensionField(extension2, "addExtensions", context);
        if (addExtensions) {
          return [extension2, ...this.flatten(addExtensions())];
        }
        return extension2;
      }).flat(10);
    }
    /**
     * Sort extensions by priority.
     * @param extensions An array of Tiptap extensions
     * @returns A sorted array of Tiptap extensions by priority
     */
    static sort(extensions) {
      const defaultPriority = 100;
      return extensions.sort((a2, b) => {
        const priorityA = getExtensionField(a2, "priority") || defaultPriority;
        const priorityB = getExtensionField(b, "priority") || defaultPriority;
        if (priorityA > priorityB) {
          return -1;
        }
        if (priorityA < priorityB) {
          return 1;
        }
        return 0;
      });
    }
    /**
     * Get all commands from the extensions.
     * @returns An object with all commands where the key is the command name and the value is the command function
     */
    get commands() {
      return this.extensions.reduce((commands2, extension2) => {
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: extension2.storage,
          editor: this.editor,
          type: getSchemaTypeByName(extension2.name, this.schema)
        };
        const addCommands = getExtensionField(extension2, "addCommands", context);
        if (!addCommands) {
          return commands2;
        }
        return {
          ...commands2,
          ...addCommands()
        };
      }, {});
    }
    /**
     * Get all registered Prosemirror plugins from the extensions.
     * @returns An array of Prosemirror plugins
     */
    get plugins() {
      const { editor } = this;
      const extensions = _ExtensionManager.sort([...this.extensions].reverse());
      const inputRules = [];
      const pasteRules = [];
      const allPlugins = extensions.map((extension2) => {
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: extension2.storage,
          editor,
          type: getSchemaTypeByName(extension2.name, this.schema)
        };
        const plugins = [];
        const addKeyboardShortcuts = getExtensionField(extension2, "addKeyboardShortcuts", context);
        let defaultBindings = {};
        if (extension2.type === "mark" && getExtensionField(extension2, "exitable", context)) {
          defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension2 });
        }
        if (addKeyboardShortcuts) {
          const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
            return [shortcut, () => method({ editor })];
          }));
          defaultBindings = { ...defaultBindings, ...bindings };
        }
        const keyMapPlugin = keymap(defaultBindings);
        plugins.push(keyMapPlugin);
        const addInputRules = getExtensionField(extension2, "addInputRules", context);
        if (isExtensionRulesEnabled(extension2, editor.options.enableInputRules) && addInputRules) {
          inputRules.push(...addInputRules());
        }
        const addPasteRules = getExtensionField(extension2, "addPasteRules", context);
        if (isExtensionRulesEnabled(extension2, editor.options.enablePasteRules) && addPasteRules) {
          pasteRules.push(...addPasteRules());
        }
        const addProseMirrorPlugins = getExtensionField(extension2, "addProseMirrorPlugins", context);
        if (addProseMirrorPlugins) {
          const proseMirrorPlugins = addProseMirrorPlugins();
          plugins.push(...proseMirrorPlugins);
        }
        return plugins;
      }).flat();
      return [
        inputRulesPlugin({
          editor,
          rules: inputRules
        }),
        ...pasteRulesPlugin({
          editor,
          rules: pasteRules
        }),
        ...allPlugins
      ];
    }
    /**
     * Get all attributes from the extensions.
     * @returns An array of attributes
     */
    get attributes() {
      return getAttributesFromExtensions(this.extensions);
    }
    /**
     * Get all node views from the extensions.
     * @returns An object with all node views where the key is the node name and the value is the node view function
     */
    get nodeViews() {
      const { editor } = this;
      const { nodeExtensions } = splitExtensions(this.extensions);
      return Object.fromEntries(nodeExtensions.filter((extension2) => !!getExtensionField(extension2, "addNodeView")).map((extension2) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension2.name);
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: extension2.storage,
          editor,
          type: getNodeType(extension2.name, this.schema)
        };
        const addNodeView = getExtensionField(extension2, "addNodeView", context);
        if (!addNodeView) {
          return [];
        }
        const nodeview = (node2, view, getPos, decorations, innerDecorations) => {
          const HTMLAttributes = getRenderedAttributes(node2, extensionAttributes);
          return addNodeView()({
            // pass-through
            node: node2,
            view,
            getPos,
            decorations,
            innerDecorations,
            // tiptap-specific
            editor,
            extension: extension2,
            HTMLAttributes
          });
        };
        return [extension2.name, nodeview];
      }));
    }
    /**
     * Go through all extensions, create extension storages & setup marks
     * & bind editor event listener.
     */
    setupExtensions() {
      this.extensions.forEach((extension2) => {
        var _a3;
        this.editor.extensionStorage[extension2.name] = extension2.storage;
        const context = {
          name: extension2.name,
          options: extension2.options,
          storage: extension2.storage,
          editor: this.editor,
          type: getSchemaTypeByName(extension2.name, this.schema)
        };
        if (extension2.type === "mark") {
          const keepOnSplit = (_a3 = callOrReturn(getExtensionField(extension2, "keepOnSplit", context))) !== null && _a3 !== void 0 ? _a3 : true;
          if (keepOnSplit) {
            this.splittableMarks.push(extension2.name);
          }
        }
        const onBeforeCreate = getExtensionField(extension2, "onBeforeCreate", context);
        const onCreate = getExtensionField(extension2, "onCreate", context);
        const onUpdate = getExtensionField(extension2, "onUpdate", context);
        const onSelectionUpdate = getExtensionField(extension2, "onSelectionUpdate", context);
        const onTransaction = getExtensionField(extension2, "onTransaction", context);
        const onFocus = getExtensionField(extension2, "onFocus", context);
        const onBlur = getExtensionField(extension2, "onBlur", context);
        const onDestroy = getExtensionField(extension2, "onDestroy", context);
        if (onBeforeCreate) {
          this.editor.on("beforeCreate", onBeforeCreate);
        }
        if (onCreate) {
          this.editor.on("create", onCreate);
        }
        if (onUpdate) {
          this.editor.on("update", onUpdate);
        }
        if (onSelectionUpdate) {
          this.editor.on("selectionUpdate", onSelectionUpdate);
        }
        if (onTransaction) {
          this.editor.on("transaction", onTransaction);
        }
        if (onFocus) {
          this.editor.on("focus", onFocus);
        }
        if (onBlur) {
          this.editor.on("blur", onBlur);
        }
        if (onDestroy) {
          this.editor.on("destroy", onDestroy);
        }
      });
    }
  };
  var Extension = class _Extension {
    constructor(config = {}) {
      this.type = "extension";
      this.name = "extension";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config
      };
      this.name = this.config.name;
      if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config = {}) {
      return new _Extension(config);
    }
    configure(options2 = {}) {
      const extension2 = this.extend({
        ...this.config,
        addOptions: () => {
          return mergeDeep(this.options, options2);
        }
      });
      extension2.name = this.name;
      extension2.parent = this.parent;
      return extension2;
    }
    extend(extendedConfig = {}) {
      const extension2 = new _Extension({ ...this.config, ...extendedConfig });
      extension2.parent = this;
      this.child = extension2;
      extension2.name = extendedConfig.name ? extendedConfig.name : extension2.parent.name;
      if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension2.name}".`);
      }
      extension2.options = callOrReturn(getExtensionField(extension2, "addOptions", {
        name: extension2.name
      }));
      extension2.storage = callOrReturn(getExtensionField(extension2, "addStorage", {
        name: extension2.name,
        options: extension2.options
      }));
      return extension2;
    }
  };
  function getTextBetween(startNode, range, options2) {
    const { from: from4, to: to2 } = range;
    const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
    let text10 = "";
    startNode.nodesBetween(from4, to2, (node2, pos, parent, index3) => {
      var _a3;
      if (node2.isBlock && pos > from4) {
        text10 += blockSeparator;
      }
      const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node2.type.name];
      if (textSerializer) {
        if (parent) {
          text10 += textSerializer({
            node: node2,
            pos,
            parent,
            index: index3,
            range
          });
        }
        return false;
      }
      if (node2.isText) {
        text10 += (_a3 = node2 === null || node2 === void 0 ? void 0 : node2.text) === null || _a3 === void 0 ? void 0 : _a3.slice(Math.max(from4, pos) - pos, to2 - pos);
      }
    });
    return text10;
  }
  function getTextSerializersFromSchema(schema) {
    return Object.fromEntries(Object.entries(schema.nodes).filter(([, node2]) => node2.spec.toText).map(([name, node2]) => [name, node2.spec.toText]));
  }
  var ClipboardTextSerializer = Extension.create({
    name: "clipboardTextSerializer",
    addOptions() {
      return {
        blockSeparator: void 0
      };
    },
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("clipboardTextSerializer"),
          props: {
            clipboardTextSerializer: () => {
              const { editor } = this;
              const { state, schema } = editor;
              const { doc: doc4, selection } = state;
              const { ranges } = selection;
              const from4 = Math.min(...ranges.map((range2) => range2.$from.pos));
              const to2 = Math.max(...ranges.map((range2) => range2.$to.pos));
              const textSerializers = getTextSerializersFromSchema(schema);
              const range = { from: from4, to: to2 };
              return getTextBetween(doc4, range, {
                ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
                textSerializers
              });
            }
          }
        })
      ];
    }
  });
  var blur = () => ({ editor, view }) => {
    requestAnimationFrame(() => {
      var _a3;
      if (!editor.isDestroyed) {
        view.dom.blur();
        (_a3 = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a3 === void 0 ? void 0 : _a3.removeAllRanges();
      }
    });
    return true;
  };
  var clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
    return commands2.setContent("", emitUpdate);
  };
  var clearNodes = () => ({ state, tr: tr3, dispatch }) => {
    const { selection } = tr3;
    const { ranges } = selection;
    if (!dispatch) {
      return true;
    }
    ranges.forEach(({ $from, $to }) => {
      state.doc.nodesBetween($from.pos, $to.pos, (node2, pos) => {
        if (node2.type.isText) {
          return;
        }
        const { doc: doc4, mapping } = tr3;
        const $mappedFrom = doc4.resolve(mapping.map(pos));
        const $mappedTo = doc4.resolve(mapping.map(pos + node2.nodeSize));
        const nodeRange = $mappedFrom.blockRange($mappedTo);
        if (!nodeRange) {
          return;
        }
        const targetLiftDepth = liftTarget(nodeRange);
        if (node2.type.isTextblock) {
          const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
          tr3.setNodeMarkup(nodeRange.start, defaultType);
        }
        if (targetLiftDepth || targetLiftDepth === 0) {
          tr3.lift(nodeRange, targetLiftDepth);
        }
      });
    });
    return true;
  };
  var command = (fn2) => (props) => {
    return fn2(props);
  };
  var createParagraphNear2 = () => ({ state, dispatch }) => {
    return createParagraphNear(state, dispatch);
  };
  var cut = (originRange, targetPos) => ({ editor, tr: tr3 }) => {
    const { state } = editor;
    const contentSlice = state.doc.slice(originRange.from, originRange.to);
    tr3.deleteRange(originRange.from, originRange.to);
    const newPos = tr3.mapping.map(targetPos);
    tr3.insert(newPos, contentSlice.content);
    tr3.setSelection(new TextSelection(tr3.doc.resolve(newPos - 1)));
    return true;
  };
  var deleteCurrentNode = () => ({ tr: tr3, dispatch }) => {
    const { selection } = tr3;
    const currentNode = selection.$anchor.node();
    if (currentNode.content.size > 0) {
      return false;
    }
    const $pos = tr3.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node2 = $pos.node(depth);
      if (node2.type === currentNode.type) {
        if (dispatch) {
          const from4 = $pos.before(depth);
          const to2 = $pos.after(depth);
          tr3.delete(from4, to2).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
  var deleteNode = (typeOrName) => ({ tr: tr3, state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    const $pos = tr3.selection.$anchor;
    for (let depth = $pos.depth; depth > 0; depth -= 1) {
      const node2 = $pos.node(depth);
      if (node2.type === type) {
        if (dispatch) {
          const from4 = $pos.before(depth);
          const to2 = $pos.after(depth);
          tr3.delete(from4, to2).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
  var deleteRange2 = (range) => ({ tr: tr3, dispatch }) => {
    const { from: from4, to: to2 } = range;
    if (dispatch) {
      tr3.delete(from4, to2);
    }
    return true;
  };
  var deleteSelection2 = () => ({ state, dispatch }) => {
    return deleteSelection(state, dispatch);
  };
  var enter = () => ({ commands: commands2 }) => {
    return commands2.keyboardShortcut("Enter");
  };
  var exitCode2 = () => ({ state, dispatch }) => {
    return exitCode(state, dispatch);
  };
  function objectIncludes(object1, object2, options2 = { strict: true }) {
    const keys4 = Object.keys(object2);
    if (!keys4.length) {
      return true;
    }
    return keys4.every((key2) => {
      if (options2.strict) {
        return object2[key2] === object1[key2];
      }
      if (isRegExp(object2[key2])) {
        return object2[key2].test(object1[key2]);
      }
      return object2[key2] === object1[key2];
    });
  }
  function findMarkInSet(marks, type, attributes = {}) {
    return marks.find((item) => {
      return item.type === type && objectIncludes(
        // Only check equality for the attributes that are provided
        Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
        attributes
      );
    });
  }
  function isMarkInSet(marks, type, attributes = {}) {
    return !!findMarkInSet(marks, type, attributes);
  }
  function getMarkRange($pos, type, attributes) {
    var _a3;
    if (!$pos || !type) {
      return;
    }
    let start = $pos.parent.childAfter($pos.parentOffset);
    if (!start.node || !start.node.marks.some((mark3) => mark3.type === type)) {
      start = $pos.parent.childBefore($pos.parentOffset);
    }
    if (!start.node || !start.node.marks.some((mark3) => mark3.type === type)) {
      return;
    }
    attributes = attributes || ((_a3 = start.node.marks[0]) === null || _a3 === void 0 ? void 0 : _a3.attrs);
    const mark2 = findMarkInSet([...start.node.marks], type, attributes);
    if (!mark2) {
      return;
    }
    let startIndex = start.index;
    let startPos = $pos.start() + start.offset;
    let endIndex = startIndex + 1;
    let endPos = startPos + start.node.nodeSize;
    while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
      startIndex -= 1;
      startPos -= $pos.parent.child(startIndex).nodeSize;
    }
    while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
      endPos += $pos.parent.child(endIndex).nodeSize;
      endIndex += 1;
    }
    return {
      from: startPos,
      to: endPos
    };
  }
  function getMarkType(nameOrType, schema) {
    if (typeof nameOrType === "string") {
      if (!schema.marks[nameOrType]) {
        throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
      }
      return schema.marks[nameOrType];
    }
    return nameOrType;
  }
  var extendMarkRange = (typeOrName, attributes = {}) => ({ tr: tr3, state, dispatch }) => {
    const type = getMarkType(typeOrName, state.schema);
    const { doc: doc4, selection } = tr3;
    const { $from, from: from4, to: to2 } = selection;
    if (dispatch) {
      const range = getMarkRange($from, type, attributes);
      if (range && range.from <= from4 && range.to >= to2) {
        const newSelection = TextSelection.create(doc4, range.from, range.to);
        tr3.setSelection(newSelection);
      }
    }
    return true;
  };
  var first = (commands2) => (props) => {
    const items = typeof commands2 === "function" ? commands2(props) : commands2;
    for (let i = 0; i < items.length; i += 1) {
      if (items[i](props)) {
        return true;
      }
    }
    return false;
  };
  function isTextSelection(value) {
    return value instanceof TextSelection;
  }
  function minMax(value = 0, min2 = 0, max2 = 0) {
    return Math.min(Math.max(value, min2), max2);
  }
  function resolveFocusPosition(doc4, position4 = null) {
    if (!position4) {
      return null;
    }
    const selectionAtStart = Selection.atStart(doc4);
    const selectionAtEnd = Selection.atEnd(doc4);
    if (position4 === "start" || position4 === true) {
      return selectionAtStart;
    }
    if (position4 === "end") {
      return selectionAtEnd;
    }
    const minPos = selectionAtStart.from;
    const maxPos = selectionAtEnd.to;
    if (position4 === "all") {
      return TextSelection.create(doc4, minMax(0, minPos, maxPos), minMax(doc4.content.size, minPos, maxPos));
    }
    return TextSelection.create(doc4, minMax(position4, minPos, maxPos), minMax(position4, minPos, maxPos));
  }
  function isAndroid() {
    return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
  }
  function isiOS() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  var focus = (position4 = null, options2 = {}) => ({ editor, view, tr: tr3, dispatch }) => {
    options2 = {
      scrollIntoView: true,
      ...options2
    };
    const delayedFocus = () => {
      if (isiOS() || isAndroid()) {
        view.dom.focus();
      }
      requestAnimationFrame(() => {
        if (!editor.isDestroyed) {
          view.focus();
          if (options2 === null || options2 === void 0 ? void 0 : options2.scrollIntoView) {
            editor.commands.scrollIntoView();
          }
        }
      });
    };
    if (view.hasFocus() && position4 === null || position4 === false) {
      return true;
    }
    if (dispatch && position4 === null && !isTextSelection(editor.state.selection)) {
      delayedFocus();
      return true;
    }
    const selection = resolveFocusPosition(tr3.doc, position4) || editor.state.selection;
    const isSameSelection = editor.state.selection.eq(selection);
    if (dispatch) {
      if (!isSameSelection) {
        tr3.setSelection(selection);
      }
      if (isSameSelection && tr3.storedMarks) {
        tr3.setStoredMarks(tr3.storedMarks);
      }
      delayedFocus();
    }
    return true;
  };
  var forEach = (items, fn2) => (props) => {
    return items.every((item, index3) => fn2(item, { ...props, index: index3 }));
  };
  var insertContent = (value, options2) => ({ tr: tr3, commands: commands2 }) => {
    return commands2.insertContentAt({ from: tr3.selection.from, to: tr3.selection.to }, value, options2);
  };
  var removeWhitespaces = (node2) => {
    const children = node2.childNodes;
    for (let i = children.length - 1; i >= 0; i -= 1) {
      const child = children[i];
      if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
        node2.removeChild(child);
      } else if (child.nodeType === 1) {
        removeWhitespaces(child);
      }
    }
    return node2;
  };
  function elementFromString(value) {
    const wrappedValue = `<body>${value}</body>`;
    const html7 = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
    return removeWhitespaces(html7);
  }
  function createNodeFromContent(content5, schema, options2) {
    if (content5 instanceof Node2 || content5 instanceof Fragment) {
      return content5;
    }
    options2 = {
      slice: true,
      parseOptions: {},
      ...options2
    };
    const isJSONContent = typeof content5 === "object" && content5 !== null;
    const isTextContent = typeof content5 === "string";
    if (isJSONContent) {
      try {
        const isArrayContent = Array.isArray(content5) && content5.length > 0;
        if (isArrayContent) {
          return Fragment.fromArray(content5.map((item) => schema.nodeFromJSON(item)));
        }
        const node2 = schema.nodeFromJSON(content5);
        if (options2.errorOnInvalidContent) {
          node2.check();
        }
        return node2;
      } catch (error) {
        if (options2.errorOnInvalidContent) {
          throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
        }
        console.warn("[tiptap warn]: Invalid content.", "Passed value:", content5, "Error:", error);
        return createNodeFromContent("", schema, options2);
      }
    }
    if (isTextContent) {
      if (options2.errorOnInvalidContent) {
        let hasInvalidContent = false;
        let invalidContent = "";
        const contentCheckSchema = new Schema2({
          topNode: schema.spec.topNode,
          marks: schema.spec.marks,
          // Prosemirror's schemas are executed such that: the last to execute, matches last
          // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
          nodes: schema.spec.nodes.append({
            __tiptap__private__unknown__catch__all__node: {
              content: "inline*",
              group: "block",
              parseDOM: [
                {
                  tag: "*",
                  getAttrs: (e) => {
                    hasInvalidContent = true;
                    invalidContent = typeof e === "string" ? e : e.outerHTML;
                    return null;
                  }
                }
              ]
            }
          })
        });
        if (options2.slice) {
          DOMParser2.fromSchema(contentCheckSchema).parseSlice(elementFromString(content5), options2.parseOptions);
        } else {
          DOMParser2.fromSchema(contentCheckSchema).parse(elementFromString(content5), options2.parseOptions);
        }
        if (options2.errorOnInvalidContent && hasInvalidContent) {
          throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${invalidContent}`) });
        }
      }
      const parser = DOMParser2.fromSchema(schema);
      if (options2.slice) {
        return parser.parseSlice(elementFromString(content5), options2.parseOptions).content;
      }
      return parser.parse(elementFromString(content5), options2.parseOptions);
    }
    return createNodeFromContent("", schema, options2);
  }
  function selectionToInsertionEnd2(tr3, startLen, bias) {
    const last2 = tr3.steps.length - 1;
    if (last2 < startLen) {
      return;
    }
    const step = tr3.steps[last2];
    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
      return;
    }
    const map9 = tr3.mapping.maps[last2];
    let end = 0;
    map9.forEach((_from, _to, _newFrom, newTo) => {
      if (end === 0) {
        end = newTo;
      }
    });
    tr3.setSelection(Selection.near(tr3.doc.resolve(end), bias));
  }
  var isFragment = (nodeOrFragment) => {
    return !("type" in nodeOrFragment);
  };
  var insertContentAt = (position4, value, options2) => ({ tr: tr3, dispatch, editor }) => {
    var _a3;
    if (dispatch) {
      options2 = {
        parseOptions: editor.options.parseOptions,
        updateSelection: true,
        applyInputRules: false,
        applyPasteRules: false,
        ...options2
      };
      let content5;
      try {
        content5 = createNodeFromContent(value, editor.schema, {
          parseOptions: {
            preserveWhitespace: "full",
            ...options2.parseOptions
          },
          errorOnInvalidContent: (_a3 = options2.errorOnInvalidContent) !== null && _a3 !== void 0 ? _a3 : editor.options.enableContentCheck
        });
      } catch (e) {
        editor.emit("contentError", {
          editor,
          error: e,
          disableCollaboration: () => {
            if (editor.storage.collaboration) {
              editor.storage.collaboration.isDisabled = true;
            }
          }
        });
        return false;
      }
      let { from: from4, to: to2 } = typeof position4 === "number" ? { from: position4, to: position4 } : { from: position4.from, to: position4.to };
      let isOnlyTextContent = true;
      let isOnlyBlockContent = true;
      const nodes = isFragment(content5) ? content5 : [content5];
      nodes.forEach((node2) => {
        node2.check();
        isOnlyTextContent = isOnlyTextContent ? node2.isText && node2.marks.length === 0 : false;
        isOnlyBlockContent = isOnlyBlockContent ? node2.isBlock : false;
      });
      if (from4 === to2 && isOnlyBlockContent) {
        const { parent } = tr3.doc.resolve(from4);
        const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
        if (isEmptyTextBlock) {
          from4 -= 1;
          to2 += 1;
        }
      }
      let newContent;
      if (isOnlyTextContent) {
        if (Array.isArray(value)) {
          newContent = value.map((v2) => v2.text || "").join("");
        } else if (value instanceof Fragment) {
          let text10 = "";
          value.forEach((node2) => {
            if (node2.text) {
              text10 += node2.text;
            }
          });
          newContent = text10;
        } else if (typeof value === "object" && !!value && !!value.text) {
          newContent = value.text;
        } else {
          newContent = value;
        }
        tr3.insertText(newContent, from4, to2);
      } else {
        newContent = content5;
        tr3.replaceWith(from4, to2, newContent);
      }
      if (options2.updateSelection) {
        selectionToInsertionEnd2(tr3, tr3.steps.length - 1, -1);
      }
      if (options2.applyInputRules) {
        tr3.setMeta("applyInputRules", { from: from4, text: newContent });
      }
      if (options2.applyPasteRules) {
        tr3.setMeta("applyPasteRules", { from: from4, text: newContent });
      }
    }
    return true;
  };
  var joinUp2 = () => ({ state, dispatch }) => {
    return joinUp(state, dispatch);
  };
  var joinDown2 = () => ({ state, dispatch }) => {
    return joinDown(state, dispatch);
  };
  var joinBackward2 = () => ({ state, dispatch }) => {
    return joinBackward(state, dispatch);
  };
  var joinForward2 = () => ({ state, dispatch }) => {
    return joinForward(state, dispatch);
  };
  var joinItemBackward = () => ({ state, dispatch, tr: tr3 }) => {
    try {
      const point5 = joinPoint(state.doc, state.selection.$from.pos, -1);
      if (point5 === null || point5 === void 0) {
        return false;
      }
      tr3.join(point5, 2);
      if (dispatch) {
        dispatch(tr3);
      }
      return true;
    } catch {
      return false;
    }
  };
  var joinItemForward = () => ({ state, dispatch, tr: tr3 }) => {
    try {
      const point5 = joinPoint(state.doc, state.selection.$from.pos, 1);
      if (point5 === null || point5 === void 0) {
        return false;
      }
      tr3.join(point5, 2);
      if (dispatch) {
        dispatch(tr3);
      }
      return true;
    } catch {
      return false;
    }
  };
  var joinTextblockBackward2 = () => ({ state, dispatch }) => {
    return joinTextblockBackward(state, dispatch);
  };
  var joinTextblockForward2 = () => ({ state, dispatch }) => {
    return joinTextblockForward(state, dispatch);
  };
  function isMacOS() {
    return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
  }
  function normalizeKeyName2(name) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result === "Space") {
      result = " ";
    }
    let alt;
    let ctrl;
    let shift2;
    let meta2;
    for (let i = 0; i < parts.length - 1; i += 1) {
      const mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) {
        meta2 = true;
      } else if (/^a(lt)?$/i.test(mod)) {
        alt = true;
      } else if (/^(c|ctrl|control)$/i.test(mod)) {
        ctrl = true;
      } else if (/^s(hift)?$/i.test(mod)) {
        shift2 = true;
      } else if (/^mod$/i.test(mod)) {
        if (isiOS() || isMacOS()) {
          meta2 = true;
        } else {
          ctrl = true;
        }
      } else {
        throw new Error(`Unrecognized modifier name: ${mod}`);
      }
    }
    if (alt) {
      result = `Alt-${result}`;
    }
    if (ctrl) {
      result = `Ctrl-${result}`;
    }
    if (meta2) {
      result = `Meta-${result}`;
    }
    if (shift2) {
      result = `Shift-${result}`;
    }
    return result;
  }
  var keyboardShortcut = (name) => ({ editor, view, tr: tr3, dispatch }) => {
    const keys4 = normalizeKeyName2(name).split(/-(?!$)/);
    const key2 = keys4.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
    const event = new KeyboardEvent("keydown", {
      key: key2 === "Space" ? " " : key2,
      altKey: keys4.includes("Alt"),
      ctrlKey: keys4.includes("Ctrl"),
      metaKey: keys4.includes("Meta"),
      shiftKey: keys4.includes("Shift"),
      bubbles: true,
      cancelable: true
    });
    const capturedTransaction = editor.captureTransaction(() => {
      view.someProp("handleKeyDown", (f) => f(view, event));
    });
    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
      const newStep = step.map(tr3.mapping);
      if (newStep && dispatch) {
        tr3.maybeStep(newStep);
      }
    });
    return true;
  };
  function isNodeActive(state, typeOrName, attributes = {}) {
    const { from: from4, to: to2, empty: empty4 } = state.selection;
    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
    const nodeRanges = [];
    state.doc.nodesBetween(from4, to2, (node2, pos) => {
      if (node2.isText) {
        return;
      }
      const relativeFrom = Math.max(from4, pos);
      const relativeTo = Math.min(to2, pos + node2.nodeSize);
      nodeRanges.push({
        node: node2,
        from: relativeFrom,
        to: relativeTo
      });
    });
    const selectionRange = to2 - from4;
    const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
      if (!type) {
        return true;
      }
      return type.name === nodeRange.node.type.name;
    }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
    if (empty4) {
      return !!matchedNodeRanges.length;
    }
    const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
    return range >= selectionRange;
  }
  var lift3 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (!isActive2) {
      return false;
    }
    return lift2(state, dispatch);
  };
  var liftEmptyBlock2 = () => ({ state, dispatch }) => {
    return liftEmptyBlock(state, dispatch);
  };
  var liftListItem2 = (typeOrName) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return liftListItem(type)(state, dispatch);
  };
  var newlineInCode2 = () => ({ state, dispatch }) => {
    return newlineInCode(state, dispatch);
  };
  function getSchemaTypeNameByName(name, schema) {
    if (schema.nodes[name]) {
      return "node";
    }
    if (schema.marks[name]) {
      return "mark";
    }
    return null;
  }
  function deleteProps(obj, propOrProps) {
    const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
    return Object.keys(obj).reduce((newObj, prop) => {
      if (!props.includes(prop)) {
        newObj[prop] = obj[prop];
      }
      return newObj;
    }, {});
  }
  var resetAttributes = (typeOrName, attributes) => ({ tr: tr3, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr3.selection.ranges.forEach((range) => {
        state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node2, pos) => {
          if (nodeType && nodeType === node2.type) {
            tr3.setNodeMarkup(pos, void 0, deleteProps(node2.attrs, attributes));
          }
          if (markType && node2.marks.length) {
            node2.marks.forEach((mark2) => {
              if (markType === mark2.type) {
                tr3.addMark(pos, pos + node2.nodeSize, markType.create(deleteProps(mark2.attrs, attributes)));
              }
            });
          }
        });
      });
    }
    return true;
  };
  var scrollIntoView = () => ({ tr: tr3, dispatch }) => {
    if (dispatch) {
      tr3.scrollIntoView();
    }
    return true;
  };
  var selectAll2 = () => ({ tr: tr3, dispatch }) => {
    if (dispatch) {
      const selection = new AllSelection(tr3.doc);
      tr3.setSelection(selection);
    }
    return true;
  };
  var selectNodeBackward2 = () => ({ state, dispatch }) => {
    return selectNodeBackward(state, dispatch);
  };
  var selectNodeForward2 = () => ({ state, dispatch }) => {
    return selectNodeForward(state, dispatch);
  };
  var selectParentNode2 = () => ({ state, dispatch }) => {
    return selectParentNode(state, dispatch);
  };
  var selectTextblockEnd2 = () => ({ state, dispatch }) => {
    return selectTextblockEnd(state, dispatch);
  };
  var selectTextblockStart2 = () => ({ state, dispatch }) => {
    return selectTextblockStart(state, dispatch);
  };
  function createDocument(content5, schema, parseOptions = {}, options2 = {}) {
    return createNodeFromContent(content5, schema, {
      slice: false,
      parseOptions,
      errorOnInvalidContent: options2.errorOnInvalidContent
    });
  }
  var setContent = (content5, emitUpdate = false, parseOptions = {}, options2 = {}) => ({ editor, tr: tr3, dispatch, commands: commands2 }) => {
    var _a3, _b;
    const { doc: doc4 } = tr3;
    if (parseOptions.preserveWhitespace !== "full") {
      const document4 = createDocument(content5, editor.schema, parseOptions, {
        errorOnInvalidContent: (_a3 = options2.errorOnInvalidContent) !== null && _a3 !== void 0 ? _a3 : editor.options.enableContentCheck
      });
      if (dispatch) {
        tr3.replaceWith(0, doc4.content.size, document4).setMeta("preventUpdate", !emitUpdate);
      }
      return true;
    }
    if (dispatch) {
      tr3.setMeta("preventUpdate", !emitUpdate);
    }
    return commands2.insertContentAt({ from: 0, to: doc4.content.size }, content5, {
      parseOptions,
      errorOnInvalidContent: (_b = options2.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck
    });
  };
  function getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const { from: from4, to: to2, empty: empty4 } = state.selection;
    const marks = [];
    if (empty4) {
      if (state.storedMarks) {
        marks.push(...state.storedMarks);
      }
      marks.push(...state.selection.$head.marks());
    } else {
      state.doc.nodesBetween(from4, to2, (node2) => {
        marks.push(...node2.marks);
      });
    }
    const mark2 = marks.find((markItem) => markItem.type.name === type.name);
    if (!mark2) {
      return {};
    }
    return { ...mark2.attrs };
  }
  function combineTransactionSteps(oldDoc, transactions) {
    const transform2 = new Transform(oldDoc);
    transactions.forEach((transaction) => {
      transaction.steps.forEach((step) => {
        transform2.step(step);
      });
    });
    return transform2;
  }
  function defaultBlockAt2(match) {
    for (let i = 0; i < match.edgeCount; i += 1) {
      const { type } = match.edge(i);
      if (type.isTextblock && !type.hasRequiredAttrs()) {
        return type;
      }
    }
    return null;
  }
  function findChildren(node2, predicate) {
    const nodesWithPos = [];
    node2.descendants((child, pos) => {
      if (predicate(child)) {
        nodesWithPos.push({
          node: child,
          pos
        });
      }
    });
    return nodesWithPos;
  }
  function findChildrenInRange(node2, range, predicate) {
    const nodesWithPos = [];
    node2.nodesBetween(range.from, range.to, (child, pos) => {
      if (predicate(child)) {
        nodesWithPos.push({
          node: child,
          pos
        });
      }
    });
    return nodesWithPos;
  }
  function findParentNodeClosestToPos($pos, predicate) {
    for (let i = $pos.depth; i > 0; i -= 1) {
      const node2 = $pos.node(i);
      if (predicate(node2)) {
        return {
          pos: i > 0 ? $pos.before(i) : 0,
          start: $pos.start(i),
          depth: i,
          node: node2
        };
      }
    }
  }
  function findParentNode(predicate) {
    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
  }
  function getSchema(extensions, editor) {
    const resolvedExtensions = ExtensionManager.resolve(extensions);
    return getSchemaByResolvedExtensions(resolvedExtensions, editor);
  }
  function generateHTML(doc4, extensions) {
    const schema = getSchema(extensions);
    const contentNode = Node2.fromJSON(schema, doc4);
    return getHTMLFromFragment(contentNode.content, schema);
  }
  function generateJSON(html7, extensions) {
    const schema = getSchema(extensions);
    const dom = elementFromString(html7);
    return DOMParser2.fromSchema(schema).parse(dom).toJSON();
  }
  function getText2(node2, options2) {
    const range = {
      from: 0,
      to: node2.content.size
    };
    return getTextBetween(node2, range, options2);
  }
  function generateText(doc4, extensions, options2) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
    const schema = getSchema(extensions);
    const contentNode = Node2.fromJSON(schema, doc4);
    return getText2(contentNode, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(schema),
        ...textSerializers
      }
    });
  }
  function getNodeAttributes(state, typeOrName) {
    const type = getNodeType(typeOrName, state.schema);
    const { from: from4, to: to2 } = state.selection;
    const nodes = [];
    state.doc.nodesBetween(from4, to2, (node3) => {
      nodes.push(node3);
    });
    const node2 = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
    if (!node2) {
      return {};
    }
    return { ...node2.attrs };
  }
  function getAttributes(state, typeOrName) {
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (schemaType === "node") {
      return getNodeAttributes(state, typeOrName);
    }
    if (schemaType === "mark") {
      return getMarkAttributes(state, typeOrName);
    }
    return {};
  }
  function removeDuplicates(array, by = JSON.stringify) {
    const seen = {};
    return array.filter((item) => {
      const key2 = by(item);
      return Object.prototype.hasOwnProperty.call(seen, key2) ? false : seen[key2] = true;
    });
  }
  function simplifyChangedRanges(changes) {
    const uniqueChanges = removeDuplicates(changes);
    return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index3) => {
      const rest = uniqueChanges.filter((_2, i) => i !== index3);
      return !rest.some((otherChange) => {
        return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
      });
    });
  }
  function getChangedRanges(transform2) {
    const { mapping, steps } = transform2;
    const changes = [];
    mapping.maps.forEach((stepMap, index3) => {
      const ranges = [];
      if (!stepMap.ranges.length) {
        const { from: from4, to: to2 } = steps[index3];
        if (from4 === void 0 || to2 === void 0) {
          return;
        }
        ranges.push({ from: from4, to: to2 });
      } else {
        stepMap.forEach((from4, to2) => {
          ranges.push({ from: from4, to: to2 });
        });
      }
      ranges.forEach(({ from: from4, to: to2 }) => {
        const newStart = mapping.slice(index3).map(from4, -1);
        const newEnd = mapping.slice(index3).map(to2);
        const oldStart = mapping.invert().map(newStart, -1);
        const oldEnd = mapping.invert().map(newEnd);
        changes.push({
          oldRange: {
            from: oldStart,
            to: oldEnd
          },
          newRange: {
            from: newStart,
            to: newEnd
          }
        });
      });
    });
    return simplifyChangedRanges(changes);
  }
  function getDebugJSON(node2, startOffset = 0) {
    const isTopNode = node2.type === node2.type.schema.topNodeType;
    const increment2 = isTopNode ? 0 : 1;
    const from4 = startOffset;
    const to2 = from4 + node2.nodeSize;
    const marks = node2.marks.map((mark2) => {
      const output2 = {
        type: mark2.type.name
      };
      if (Object.keys(mark2.attrs).length) {
        output2.attrs = { ...mark2.attrs };
      }
      return output2;
    });
    const attrs = { ...node2.attrs };
    const output = {
      type: node2.type.name,
      from: from4,
      to: to2
    };
    if (Object.keys(attrs).length) {
      output.attrs = attrs;
    }
    if (marks.length) {
      output.marks = marks;
    }
    if (node2.content.childCount) {
      output.content = [];
      node2.forEach((child, offset) => {
        var _a3;
        (_a3 = output.content) === null || _a3 === void 0 ? void 0 : _a3.push(getDebugJSON(child, startOffset + offset + increment2));
      });
    }
    if (node2.text) {
      output.text = node2.text;
    }
    return output;
  }
  function getMarksBetween(from4, to2, doc4) {
    const marks = [];
    if (from4 === to2) {
      doc4.resolve(from4).marks().forEach((mark2) => {
        const $pos = doc4.resolve(from4);
        const range = getMarkRange($pos, mark2.type);
        if (!range) {
          return;
        }
        marks.push({
          mark: mark2,
          ...range
        });
      });
    } else {
      doc4.nodesBetween(from4, to2, (node2, pos) => {
        if (!node2 || (node2 === null || node2 === void 0 ? void 0 : node2.nodeSize) === void 0) {
          return;
        }
        marks.push(...node2.marks.map((mark2) => ({
          from: pos,
          to: pos + node2.nodeSize,
          mark: mark2
        })));
      });
    }
    return marks;
  }
  var getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {
    const $pos = state.doc.resolve(pos);
    let currentDepth = maxDepth;
    let node2 = null;
    while (currentDepth > 0 && node2 === null) {
      const currentNode = $pos.node(currentDepth);
      if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {
        node2 = currentNode;
      } else {
        currentDepth -= 1;
      }
    }
    return [node2, currentDepth];
  };
  function getSplittedAttributes(extensionAttributes, typeName, attributes) {
    return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    }));
  }
  function isMarkActive(state, typeOrName, attributes = {}) {
    const { empty: empty4, ranges } = state.selection;
    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
    if (empty4) {
      return !!(state.storedMarks || state.selection.$from.marks()).filter((mark2) => {
        if (!type) {
          return true;
        }
        return type.name === mark2.type.name;
      }).find((mark2) => objectIncludes(mark2.attrs, attributes, { strict: false }));
    }
    let selectionRange = 0;
    const markRanges = [];
    ranges.forEach(({ $from, $to }) => {
      const from4 = $from.pos;
      const to2 = $to.pos;
      state.doc.nodesBetween(from4, to2, (node2, pos) => {
        if (!node2.isText && !node2.marks.length) {
          return;
        }
        const relativeFrom = Math.max(from4, pos);
        const relativeTo = Math.min(to2, pos + node2.nodeSize);
        const range2 = relativeTo - relativeFrom;
        selectionRange += range2;
        markRanges.push(...node2.marks.map((mark2) => ({
          mark: mark2,
          from: relativeFrom,
          to: relativeTo
        })));
      });
    });
    if (selectionRange === 0) {
      return false;
    }
    const matchedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return type.name === markRange.mark.type.name;
    }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const excludedRange = markRanges.filter((markRange) => {
      if (!type) {
        return true;
      }
      return markRange.mark.type !== type && markRange.mark.type.excludes(type);
    }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
    return range >= selectionRange;
  }
  function isActive(state, name, attributes = {}) {
    if (!name) {
      return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
    }
    const schemaType = getSchemaTypeNameByName(name, state.schema);
    if (schemaType === "node") {
      return isNodeActive(state, name, attributes);
    }
    if (schemaType === "mark") {
      return isMarkActive(state, name, attributes);
    }
    return false;
  }
  var isAtEndOfNode = (state, nodeType) => {
    const { $from, $to, $anchor } = state.selection;
    if (nodeType) {
      const parentNode2 = findParentNode((node2) => node2.type.name === nodeType)(state.selection);
      if (!parentNode2) {
        return false;
      }
      const $parentPos = state.doc.resolve(parentNode2.pos + 1);
      if ($anchor.pos + 1 === $parentPos.end()) {
        return true;
      }
      return false;
    }
    if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {
      return false;
    }
    return true;
  };
  var isAtStartOfNode = (state) => {
    const { $from, $to } = state.selection;
    if ($from.parentOffset > 0 || $from.pos !== $to.pos) {
      return false;
    }
    return true;
  };
  function isList(name, extensions) {
    const { nodeExtensions } = splitExtensions(extensions);
    const extension2 = nodeExtensions.find((item) => item.name === name);
    if (!extension2) {
      return false;
    }
    const context = {
      name: extension2.name,
      options: extension2.options,
      storage: extension2.storage
    };
    const group2 = callOrReturn(getExtensionField(extension2, "group", context));
    if (typeof group2 !== "string") {
      return false;
    }
    return group2.split(" ").includes("list");
  }
  function isNodeEmpty(node2, { checkChildren = true, ignoreWhitespace = false } = {}) {
    var _a3;
    if (ignoreWhitespace) {
      if (node2.type.name === "hardBreak") {
        return true;
      }
      if (node2.isText) {
        return /^\s*$/m.test((_a3 = node2.text) !== null && _a3 !== void 0 ? _a3 : "");
      }
    }
    if (node2.isText) {
      return !node2.text;
    }
    if (node2.isAtom || node2.isLeaf) {
      return false;
    }
    if (node2.content.childCount === 0) {
      return true;
    }
    if (checkChildren) {
      let isContentEmpty = true;
      node2.content.forEach((childNode) => {
        if (isContentEmpty === false) {
          return;
        }
        if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
          isContentEmpty = false;
        }
      });
      return isContentEmpty;
    }
    return false;
  }
  function isNodeSelection(value) {
    return value instanceof NodeSelection;
  }
  function posToDOMRect(view, from4, to2) {
    const minPos = 0;
    const maxPos = view.state.doc.content.size;
    const resolvedFrom = minMax(from4, minPos, maxPos);
    const resolvedEnd = minMax(to2, minPos, maxPos);
    const start = view.coordsAtPos(resolvedFrom);
    const end = view.coordsAtPos(resolvedEnd, -1);
    const top = Math.min(start.top, end.top);
    const bottom = Math.max(start.bottom, end.bottom);
    const left = Math.min(start.left, end.left);
    const right = Math.max(start.right, end.right);
    const width = right - left;
    const height = bottom - top;
    const x = left;
    const y = top;
    const data = {
      top,
      bottom,
      left,
      right,
      width,
      height,
      x,
      y
    };
    return {
      ...data,
      toJSON: () => data
    };
  }
  function rewriteUnknownContentInner({ json, validMarks, validNodes, options: options2, rewrittenContent = [] }) {
    if (json.marks && Array.isArray(json.marks)) {
      json.marks = json.marks.filter((mark2) => {
        const name = typeof mark2 === "string" ? mark2 : mark2.type;
        if (validMarks.has(name)) {
          return true;
        }
        rewrittenContent.push({
          original: JSON.parse(JSON.stringify(mark2)),
          unsupported: name
        });
        return false;
      });
    }
    if (json.content && Array.isArray(json.content)) {
      json.content = json.content.map((value) => rewriteUnknownContentInner({
        json: value,
        validMarks,
        validNodes,
        options: options2,
        rewrittenContent
      }).json).filter((a2) => a2 !== null && a2 !== void 0);
    }
    if (json.type && !validNodes.has(json.type)) {
      rewrittenContent.push({
        original: JSON.parse(JSON.stringify(json)),
        unsupported: json.type
      });
      if (json.content && Array.isArray(json.content) && (options2 === null || options2 === void 0 ? void 0 : options2.fallbackToParagraph) !== false) {
        json.type = "paragraph";
        return {
          json,
          rewrittenContent
        };
      }
      return {
        json: null,
        rewrittenContent
      };
    }
    return { json, rewrittenContent };
  }
  function rewriteUnknownContent(json, schema, options2) {
    return rewriteUnknownContentInner({
      json,
      validNodes: new Set(Object.keys(schema.nodes)),
      validMarks: new Set(Object.keys(schema.marks)),
      options: options2
    });
  }
  function canSetMark(state, tr3, newMarkType) {
    var _a3;
    const { selection } = tr3;
    let cursor = null;
    if (isTextSelection(selection)) {
      cursor = selection.$cursor;
    }
    if (cursor) {
      const currentMarks = (_a3 = state.storedMarks) !== null && _a3 !== void 0 ? _a3 : cursor.marks();
      return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark2) => mark2.type.excludes(newMarkType));
    }
    const { ranges } = selection;
    return ranges.some(({ $from, $to }) => {
      let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
      state.doc.nodesBetween($from.pos, $to.pos, (node2, _pos, parent) => {
        if (someNodeSupportsMark) {
          return false;
        }
        if (node2.isInline) {
          const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
          const currentMarksAllowMarkType = !!newMarkType.isInSet(node2.marks) || !node2.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
          someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
        }
        return !someNodeSupportsMark;
      });
      return someNodeSupportsMark;
    });
  }
  var setMark = (typeOrName, attributes = {}) => ({ tr: tr3, state, dispatch }) => {
    const { selection } = tr3;
    const { empty: empty4, ranges } = selection;
    const type = getMarkType(typeOrName, state.schema);
    if (dispatch) {
      if (empty4) {
        const oldAttributes = getMarkAttributes(state, type);
        tr3.addStoredMark(type.create({
          ...oldAttributes,
          ...attributes
        }));
      } else {
        ranges.forEach((range) => {
          const from4 = range.$from.pos;
          const to2 = range.$to.pos;
          state.doc.nodesBetween(from4, to2, (node2, pos) => {
            const trimmedFrom = Math.max(pos, from4);
            const trimmedTo = Math.min(pos + node2.nodeSize, to2);
            const someHasMark = node2.marks.find((mark2) => mark2.type === type);
            if (someHasMark) {
              node2.marks.forEach((mark2) => {
                if (type === mark2.type) {
                  tr3.addMark(trimmedFrom, trimmedTo, type.create({
                    ...mark2.attrs,
                    ...attributes
                  }));
                }
              });
            } else {
              tr3.addMark(trimmedFrom, trimmedTo, type.create(attributes));
            }
          });
        });
      }
    }
    return canSetMark(state, tr3, type);
  };
  var setMeta = (key2, value) => ({ tr: tr3 }) => {
    tr3.setMeta(key2, value);
    return true;
  };
  var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
    const type = getNodeType(typeOrName, state.schema);
    let attributesToCopy;
    if (state.selection.$anchor.sameParent(state.selection.$head)) {
      attributesToCopy = state.selection.$anchor.parent.attrs;
    }
    if (!type.isTextblock) {
      console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
      return false;
    }
    return chain().command(({ commands: commands2 }) => {
      const canSetBlock = setBlockType2(type, { ...attributesToCopy, ...attributes })(state);
      if (canSetBlock) {
        return true;
      }
      return commands2.clearNodes();
    }).command(({ state: updatedState }) => {
      return setBlockType2(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);
    }).run();
  };
  var setNodeSelection = (position4) => ({ tr: tr3, dispatch }) => {
    if (dispatch) {
      const { doc: doc4 } = tr3;
      const from4 = minMax(position4, 0, doc4.content.size);
      const selection = NodeSelection.create(doc4, from4);
      tr3.setSelection(selection);
    }
    return true;
  };
  var setTextSelection = (position4) => ({ tr: tr3, dispatch }) => {
    if (dispatch) {
      const { doc: doc4 } = tr3;
      const { from: from4, to: to2 } = typeof position4 === "number" ? { from: position4, to: position4 } : position4;
      const minPos = TextSelection.atStart(doc4).from;
      const maxPos = TextSelection.atEnd(doc4).to;
      const resolvedFrom = minMax(from4, minPos, maxPos);
      const resolvedEnd = minMax(to2, minPos, maxPos);
      const selection = TextSelection.create(doc4, resolvedFrom, resolvedEnd);
      tr3.setSelection(selection);
    }
    return true;
  };
  var sinkListItem2 = (typeOrName) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return sinkListItem(type)(state, dispatch);
  };
  function ensureMarks(state, splittableMarks) {
    const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks) {
      const filteredMarks = marks.filter((mark2) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark2.type.name));
      state.tr.ensureMarks(filteredMarks);
    }
  }
  var splitBlock2 = ({ keepMarks = true } = {}) => ({ tr: tr3, state, dispatch, editor }) => {
    const { selection, doc: doc4 } = tr3;
    const { $from, $to } = selection;
    const extensionAttributes = editor.extensionManager.attributes;
    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    if (selection instanceof NodeSelection && selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(doc4, $from.pos)) {
        return false;
      }
      if (dispatch) {
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr3.split($from.pos).scrollIntoView();
      }
      return true;
    }
    if (!$from.parent.isBlock) {
      return false;
    }
    const atEnd = $to.parentOffset === $to.parent.content.size;
    const deflt = $from.depth === 0 ? void 0 : defaultBlockAt2($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd && deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
    let can = canSplit(tr3.doc, tr3.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr3.doc, tr3.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types = deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
    }
    if (dispatch) {
      if (can) {
        if (selection instanceof TextSelection) {
          tr3.deleteSelection();
        }
        tr3.split(tr3.mapping.map($from.pos), 1, types);
        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
          const first3 = tr3.mapping.map($from.before());
          const $first = tr3.doc.resolve(first3);
          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
            tr3.setNodeMarkup(tr3.mapping.map($from.before()), deflt);
          }
        }
      }
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr3.scrollIntoView();
    }
    return can;
  };
  var splitListItem2 = (typeOrName, overrideAttrs = {}) => ({ tr: tr3, state, dispatch, editor }) => {
    var _a3;
    const type = getNodeType(typeOrName, state.schema);
    const { $from, $to } = state.selection;
    const node2 = state.selection.node;
    if (node2 && node2.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    const grandParent = $from.node(-1);
    if (grandParent.type !== type) {
      return false;
    }
    const extensionAttributes = editor.extensionManager.attributes;
    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
      if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch) {
        let wrap5 = Fragment.empty;
        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
          wrap5 = Fragment.from($from.node(d).copy(wrap5));
        }
        const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        const newNextTypeAttributes2 = {
          ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
          ...overrideAttrs
        };
        const nextType2 = ((_a3 = type.contentMatch.defaultType) === null || _a3 === void 0 ? void 0 : _a3.createAndFill(newNextTypeAttributes2)) || void 0;
        wrap5 = wrap5.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
        const start = $from.before($from.depth - (depthBefore - 1));
        tr3.replace(start, $from.after(-depthAfter), new Slice(wrap5, 4 - depthBefore, 0));
        let sel = -1;
        tr3.doc.nodesBetween(start, tr3.doc.content.size, (n, pos) => {
          if (sel > -1) {
            return false;
          }
          if (n.isTextblock && n.content.size === 0) {
            sel = pos + 1;
          }
        });
        if (sel > -1) {
          tr3.setSelection(TextSelection.near(tr3.doc.resolve(sel)));
        }
        tr3.scrollIntoView();
      }
      return true;
    }
    const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    const newTypeAttributes = {
      ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
      ...overrideAttrs
    };
    const newNextTypeAttributes = {
      ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
      ...overrideAttrs
    };
    tr3.delete($from.pos, $to.pos);
    const types = nextType ? [
      { type, attrs: newTypeAttributes },
      { type: nextType, attrs: newNextTypeAttributes }
    ] : [{ type, attrs: newTypeAttributes }];
    if (!canSplit(tr3.doc, $from.pos, 2)) {
      return false;
    }
    if (dispatch) {
      const { selection, storedMarks } = state;
      const { splittableMarks } = editor.extensionManager;
      const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      tr3.split($from.pos, 2, types).scrollIntoView();
      if (!marks || !dispatch) {
        return true;
      }
      const filteredMarks = marks.filter((mark2) => splittableMarks.includes(mark2.type.name));
      tr3.ensureMarks(filteredMarks);
    }
    return true;
  };
  var joinListBackwards = (tr3, listType) => {
    const list7 = findParentNode((node2) => node2.type === listType)(tr3.selection);
    if (!list7) {
      return true;
    }
    const before = tr3.doc.resolve(Math.max(0, list7.pos - 1)).before(list7.depth);
    if (before === void 0) {
      return true;
    }
    const nodeBefore = tr3.doc.nodeAt(before);
    const canJoinBackwards = list7.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr3.doc, list7.pos);
    if (!canJoinBackwards) {
      return true;
    }
    tr3.join(list7.pos);
    return true;
  };
  var joinListForwards = (tr3, listType) => {
    const list7 = findParentNode((node2) => node2.type === listType)(tr3.selection);
    if (!list7) {
      return true;
    }
    const after = tr3.doc.resolve(list7.start).after(list7.depth);
    if (after === void 0) {
      return true;
    }
    const nodeAfter = tr3.doc.nodeAt(after);
    const canJoinForwards = list7.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr3.doc, after);
    if (!canJoinForwards) {
      return true;
    }
    tr3.join(after);
    return true;
  };
  var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr: tr3, state, dispatch, chain, commands: commands2, can }) => {
    const { extensions, splittableMarks } = editor.extensionManager;
    const listType = getNodeType(listTypeOrName, state.schema);
    const itemType = getNodeType(itemTypeOrName, state.schema);
    const { selection, storedMarks } = state;
    const { $from, $to } = selection;
    const range = $from.blockRange($to);
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    if (!range) {
      return false;
    }
    const parentList = findParentNode((node2) => isList(node2.type.name, extensions))(selection);
    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
      if (parentList.node.type === listType) {
        return commands2.liftListItem(itemType);
      }
      if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
        return chain().command(() => {
          tr3.setNodeMarkup(parentList.pos, listType);
          return true;
        }).command(() => joinListBackwards(tr3, listType)).command(() => joinListForwards(tr3, listType)).run();
      }
    }
    if (!keepMarks || !marks || !dispatch) {
      return chain().command(() => {
        const canWrapInList = can().wrapInList(listType, attributes);
        if (canWrapInList) {
          return true;
        }
        return commands2.clearNodes();
      }).wrapInList(listType, attributes).command(() => joinListBackwards(tr3, listType)).command(() => joinListForwards(tr3, listType)).run();
    }
    return chain().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      const filteredMarks = marks.filter((mark2) => splittableMarks.includes(mark2.type.name));
      tr3.ensureMarks(filteredMarks);
      if (canWrapInList) {
        return true;
      }
      return commands2.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr3, listType)).command(() => joinListForwards(tr3, listType)).run();
  };
  var toggleMark2 = (typeOrName, attributes = {}, options2 = {}) => ({ state, commands: commands2 }) => {
    const { extendEmptyMarkRange = false } = options2;
    const type = getMarkType(typeOrName, state.schema);
    const isActive2 = isMarkActive(state, type, attributes);
    if (isActive2) {
      return commands2.unsetMark(type, { extendEmptyMarkRange });
    }
    return commands2.setMark(type, attributes);
  };
  var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const toggleType = getNodeType(toggleTypeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    let attributesToCopy;
    if (state.selection.$anchor.sameParent(state.selection.$head)) {
      attributesToCopy = state.selection.$anchor.parent.attrs;
    }
    if (isActive2) {
      return commands2.setNode(toggleType, attributesToCopy);
    }
    return commands2.setNode(type, { ...attributesToCopy, ...attributes });
  };
  var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
    const type = getNodeType(typeOrName, state.schema);
    const isActive2 = isNodeActive(state, type, attributes);
    if (isActive2) {
      return commands2.lift(type);
    }
    return commands2.wrapIn(type, attributes);
  };
  var undoInputRule = () => ({ state, dispatch }) => {
    const plugins = state.plugins;
    for (let i = 0; i < plugins.length; i += 1) {
      const plugin = plugins[i];
      let undoable;
      if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
        if (dispatch) {
          const tr3 = state.tr;
          const toUndo = undoable.transform;
          for (let j2 = toUndo.steps.length - 1; j2 >= 0; j2 -= 1) {
            tr3.step(toUndo.steps[j2].invert(toUndo.docs[j2]));
          }
          if (undoable.text) {
            const marks = tr3.doc.resolve(undoable.from).marks();
            tr3.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
          } else {
            tr3.delete(undoable.from, undoable.to);
          }
        }
        return true;
      }
    }
    return false;
  };
  var unsetAllMarks = () => ({ tr: tr3, dispatch }) => {
    const { selection } = tr3;
    const { empty: empty4, ranges } = selection;
    if (empty4) {
      return true;
    }
    if (dispatch) {
      ranges.forEach((range) => {
        tr3.removeMark(range.$from.pos, range.$to.pos);
      });
    }
    return true;
  };
  var unsetMark = (typeOrName, options2 = {}) => ({ tr: tr3, state, dispatch }) => {
    var _a3;
    const { extendEmptyMarkRange = false } = options2;
    const { selection } = tr3;
    const type = getMarkType(typeOrName, state.schema);
    const { $from, empty: empty4, ranges } = selection;
    if (!dispatch) {
      return true;
    }
    if (empty4 && extendEmptyMarkRange) {
      let { from: from4, to: to2 } = selection;
      const attrs = (_a3 = $from.marks().find((mark2) => mark2.type === type)) === null || _a3 === void 0 ? void 0 : _a3.attrs;
      const range = getMarkRange($from, type, attrs);
      if (range) {
        from4 = range.from;
        to2 = range.to;
      }
      tr3.removeMark(from4, to2, type);
    } else {
      ranges.forEach((range) => {
        tr3.removeMark(range.$from.pos, range.$to.pos, type);
      });
    }
    tr3.removeStoredMark(type);
    return true;
  };
  var updateAttributes = (typeOrName, attributes = {}) => ({ tr: tr3, state, dispatch }) => {
    let nodeType = null;
    let markType = null;
    const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === "node") {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === "mark") {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr3.selection.ranges.forEach((range) => {
        const from4 = range.$from.pos;
        const to2 = range.$to.pos;
        let lastPos;
        let lastNode;
        let trimmedFrom;
        let trimmedTo;
        if (tr3.selection.empty) {
          state.doc.nodesBetween(from4, to2, (node2, pos) => {
            if (nodeType && nodeType === node2.type) {
              trimmedFrom = Math.max(pos, from4);
              trimmedTo = Math.min(pos + node2.nodeSize, to2);
              lastPos = pos;
              lastNode = node2;
            }
          });
        } else {
          state.doc.nodesBetween(from4, to2, (node2, pos) => {
            if (pos < from4 && nodeType && nodeType === node2.type) {
              trimmedFrom = Math.max(pos, from4);
              trimmedTo = Math.min(pos + node2.nodeSize, to2);
              lastPos = pos;
              lastNode = node2;
            }
            if (pos >= from4 && pos <= to2) {
              if (nodeType && nodeType === node2.type) {
                tr3.setNodeMarkup(pos, void 0, {
                  ...node2.attrs,
                  ...attributes
                });
              }
              if (markType && node2.marks.length) {
                node2.marks.forEach((mark2) => {
                  if (markType === mark2.type) {
                    const trimmedFrom2 = Math.max(pos, from4);
                    const trimmedTo2 = Math.min(pos + node2.nodeSize, to2);
                    tr3.addMark(trimmedFrom2, trimmedTo2, markType.create({
                      ...mark2.attrs,
                      ...attributes
                    }));
                  }
                });
              }
            }
          });
        }
        if (lastNode) {
          if (lastPos !== void 0) {
            tr3.setNodeMarkup(lastPos, void 0, {
              ...lastNode.attrs,
              ...attributes
            });
          }
          if (markType && lastNode.marks.length) {
            lastNode.marks.forEach((mark2) => {
              if (markType === mark2.type) {
                tr3.addMark(trimmedFrom, trimmedTo, markType.create({
                  ...mark2.attrs,
                  ...attributes
                }));
              }
            });
          }
        }
      });
    }
    return true;
  };
  var wrapIn2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapIn(type, attributes)(state, dispatch);
  };
  var wrapInList2 = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
    const type = getNodeType(typeOrName, state.schema);
    return wrapInList(type, attributes)(state, dispatch);
  };
  var commands = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    blur,
    clearContent,
    clearNodes,
    command,
    createParagraphNear: createParagraphNear2,
    cut,
    deleteCurrentNode,
    deleteNode,
    deleteRange: deleteRange2,
    deleteSelection: deleteSelection2,
    enter,
    exitCode: exitCode2,
    extendMarkRange,
    first,
    focus,
    forEach,
    insertContent,
    insertContentAt,
    joinBackward: joinBackward2,
    joinDown: joinDown2,
    joinForward: joinForward2,
    joinItemBackward,
    joinItemForward,
    joinTextblockBackward: joinTextblockBackward2,
    joinTextblockForward: joinTextblockForward2,
    joinUp: joinUp2,
    keyboardShortcut,
    lift: lift3,
    liftEmptyBlock: liftEmptyBlock2,
    liftListItem: liftListItem2,
    newlineInCode: newlineInCode2,
    resetAttributes,
    scrollIntoView,
    selectAll: selectAll2,
    selectNodeBackward: selectNodeBackward2,
    selectNodeForward: selectNodeForward2,
    selectParentNode: selectParentNode2,
    selectTextblockEnd: selectTextblockEnd2,
    selectTextblockStart: selectTextblockStart2,
    setContent,
    setMark,
    setMeta,
    setNode,
    setNodeSelection,
    setTextSelection,
    sinkListItem: sinkListItem2,
    splitBlock: splitBlock2,
    splitListItem: splitListItem2,
    toggleList,
    toggleMark: toggleMark2,
    toggleNode,
    toggleWrap,
    undoInputRule,
    unsetAllMarks,
    unsetMark,
    updateAttributes,
    wrapIn: wrapIn2,
    wrapInList: wrapInList2
  });
  var Commands = Extension.create({
    name: "commands",
    addCommands() {
      return {
        ...commands
      };
    }
  });
  var Drop = Extension.create({
    name: "drop",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("tiptapDrop"),
          props: {
            handleDrop: (_2, e, slice2, moved) => {
              this.editor.emit("drop", {
                editor: this.editor,
                event: e,
                slice: slice2,
                moved
              });
            }
          }
        })
      ];
    }
  });
  var Editable = Extension.create({
    name: "editable",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("editable"),
          props: {
            editable: () => this.editor.options.editable
          }
        })
      ];
    }
  });
  var focusEventsPluginKey = new PluginKey("focusEvents");
  var FocusEvents = Extension.create({
    name: "focusEvents",
    addProseMirrorPlugins() {
      const { editor } = this;
      return [
        new Plugin({
          key: focusEventsPluginKey,
          props: {
            handleDOMEvents: {
              focus: (view, event) => {
                editor.isFocused = true;
                const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              },
              blur: (view, event) => {
                editor.isFocused = false;
                const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
                view.dispatch(transaction);
                return false;
              }
            }
          }
        })
      ];
    }
  });
  var Keymap = Extension.create({
    name: "keymap",
    addKeyboardShortcuts() {
      const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.undoInputRule(),
        // maybe convert first text block node to default node
        () => commands2.command(({ tr: tr3 }) => {
          const { selection, doc: doc4 } = tr3;
          const { empty: empty4, $anchor } = selection;
          const { pos, parent } = $anchor;
          const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr3.doc.resolve(pos - 1) : $anchor;
          const parentIsIsolating = $parentPos.parent.type.spec.isolating;
          const parentPos = $anchor.pos - $anchor.parentOffset;
          const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc4).from === pos;
          if (!empty4 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
            return false;
          }
          return commands2.clearNodes();
        }),
        () => commands2.deleteSelection(),
        () => commands2.joinBackward(),
        () => commands2.selectNodeBackward()
      ]);
      const handleDelete2 = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.deleteSelection(),
        () => commands2.deleteCurrentNode(),
        () => commands2.joinForward(),
        () => commands2.selectNodeForward()
      ]);
      const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
        () => commands2.newlineInCode(),
        () => commands2.createParagraphNear(),
        () => commands2.liftEmptyBlock(),
        () => commands2.splitBlock()
      ]);
      const baseKeymap2 = {
        Enter: handleEnter,
        "Mod-Enter": () => this.editor.commands.exitCode(),
        Backspace: handleBackspace,
        "Mod-Backspace": handleBackspace,
        "Shift-Backspace": handleBackspace,
        Delete: handleDelete2,
        "Mod-Delete": handleDelete2,
        "Mod-a": () => this.editor.commands.selectAll()
      };
      const pcKeymap = {
        ...baseKeymap2
      };
      const macKeymap = {
        ...baseKeymap2,
        "Ctrl-h": handleBackspace,
        "Alt-Backspace": handleBackspace,
        "Ctrl-d": handleDelete2,
        "Ctrl-Alt-Backspace": handleDelete2,
        "Alt-Delete": handleDelete2,
        "Alt-d": handleDelete2,
        "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
        "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
      };
      if (isiOS() || isMacOS()) {
        return macKeymap;
      }
      return pcKeymap;
    },
    addProseMirrorPlugins() {
      return [
        // With this plugin we check if the whole document was selected and deleted.
        // In this case we will additionally call `clearNodes()` to convert e.g. a heading
        // to a paragraph if necessary.
        // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
        // with many other commands.
        new Plugin({
          key: new PluginKey("clearDocument"),
          appendTransaction: (transactions, oldState, newState) => {
            if (transactions.some((tr4) => tr4.getMeta("composition"))) {
              return;
            }
            const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
            const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
            if (!docChanges || ignoreTr) {
              return;
            }
            const { empty: empty4, from: from4, to: to2 } = oldState.selection;
            const allFrom = Selection.atStart(oldState.doc).from;
            const allEnd = Selection.atEnd(oldState.doc).to;
            const allWasSelected = from4 === allFrom && to2 === allEnd;
            if (empty4 || !allWasSelected) {
              return;
            }
            const isEmpty3 = isNodeEmpty(newState.doc);
            if (!isEmpty3) {
              return;
            }
            const tr3 = newState.tr;
            const state = createChainableState({
              state: newState,
              transaction: tr3
            });
            const { commands: commands2 } = new CommandManager({
              editor: this.editor,
              state
            });
            commands2.clearNodes();
            if (!tr3.steps.length) {
              return;
            }
            return tr3;
          }
        })
      ];
    }
  });
  var Paste = Extension.create({
    name: "paste",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("tiptapPaste"),
          props: {
            handlePaste: (_view, e, slice2) => {
              this.editor.emit("paste", {
                editor: this.editor,
                event: e,
                slice: slice2
              });
            }
          }
        })
      ];
    }
  });
  var Tabindex = Extension.create({
    name: "tabindex",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          key: new PluginKey("tabindex"),
          props: {
            attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
          }
        })
      ];
    }
  });
  var index2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ClipboardTextSerializer,
    Commands,
    Drop,
    Editable,
    FocusEvents,
    Keymap,
    Paste,
    Tabindex,
    focusEventsPluginKey
  });
  var NodePos = class _NodePos {
    get name() {
      return this.node.type.name;
    }
    constructor(pos, editor, isBlock = false, node2 = null) {
      this.currentNode = null;
      this.actualDepth = null;
      this.isBlock = isBlock;
      this.resolvedPos = pos;
      this.editor = editor;
      this.currentNode = node2;
    }
    get node() {
      return this.currentNode || this.resolvedPos.node();
    }
    get element() {
      return this.editor.view.domAtPos(this.pos).node;
    }
    get depth() {
      var _a3;
      return (_a3 = this.actualDepth) !== null && _a3 !== void 0 ? _a3 : this.resolvedPos.depth;
    }
    get pos() {
      return this.resolvedPos.pos;
    }
    get content() {
      return this.node.content;
    }
    set content(content5) {
      let from4 = this.from;
      let to2 = this.to;
      if (this.isBlock) {
        if (this.content.size === 0) {
          console.error(`You can\u2019t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
          return;
        }
        from4 = this.from + 1;
        to2 = this.to - 1;
      }
      this.editor.commands.insertContentAt({ from: from4, to: to2 }, content5);
    }
    get attributes() {
      return this.node.attrs;
    }
    get textContent() {
      return this.node.textContent;
    }
    get size() {
      return this.node.nodeSize;
    }
    get from() {
      if (this.isBlock) {
        return this.pos;
      }
      return this.resolvedPos.start(this.resolvedPos.depth);
    }
    get range() {
      return {
        from: this.from,
        to: this.to
      };
    }
    get to() {
      if (this.isBlock) {
        return this.pos + this.size;
      }
      return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
    }
    get parent() {
      if (this.depth === 0) {
        return null;
      }
      const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
      const $pos = this.resolvedPos.doc.resolve(parentPos);
      return new _NodePos($pos, this.editor);
    }
    get before() {
      let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
      if ($pos.depth !== this.depth) {
        $pos = this.resolvedPos.doc.resolve(this.from - 3);
      }
      return new _NodePos($pos, this.editor);
    }
    get after() {
      let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
      if ($pos.depth !== this.depth) {
        $pos = this.resolvedPos.doc.resolve(this.to + 3);
      }
      return new _NodePos($pos, this.editor);
    }
    get children() {
      const children = [];
      this.node.content.forEach((node2, offset) => {
        const isBlock = node2.isBlock && !node2.isTextblock;
        const isNonTextAtom = node2.isAtom && !node2.isText;
        const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);
        const $pos = this.resolvedPos.doc.resolve(targetPos);
        if (!isBlock && $pos.depth <= this.depth) {
          return;
        }
        const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node2 : null);
        if (isBlock) {
          childNodePos.actualDepth = this.depth + 1;
        }
        children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node2 : null));
      });
      return children;
    }
    get firstChild() {
      return this.children[0] || null;
    }
    get lastChild() {
      const children = this.children;
      return children[children.length - 1] || null;
    }
    closest(selector, attributes = {}) {
      let node2 = null;
      let currentNode = this.parent;
      while (currentNode && !node2) {
        if (currentNode.node.type.name === selector) {
          if (Object.keys(attributes).length > 0) {
            const nodeAttributes = currentNode.node.attrs;
            const attrKeys = Object.keys(attributes);
            for (let index3 = 0; index3 < attrKeys.length; index3 += 1) {
              const key2 = attrKeys[index3];
              if (nodeAttributes[key2] !== attributes[key2]) {
                break;
              }
            }
          } else {
            node2 = currentNode;
          }
        }
        currentNode = currentNode.parent;
      }
      return node2;
    }
    querySelector(selector, attributes = {}) {
      return this.querySelectorAll(selector, attributes, true)[0] || null;
    }
    querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
      let nodes = [];
      if (!this.children || this.children.length === 0) {
        return nodes;
      }
      const attrKeys = Object.keys(attributes);
      this.children.forEach((childPos) => {
        if (firstItemOnly && nodes.length > 0) {
          return;
        }
        if (childPos.node.type.name === selector) {
          const doesAllAttributesMatch = attrKeys.every((key2) => attributes[key2] === childPos.node.attrs[key2]);
          if (doesAllAttributesMatch) {
            nodes.push(childPos);
          }
        }
        if (firstItemOnly && nodes.length > 0) {
          return;
        }
        nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
      });
      return nodes;
    }
    setAttribute(attributes) {
      const { tr: tr3 } = this.editor.state;
      tr3.setNodeMarkup(this.from, void 0, {
        ...this.node.attrs,
        ...attributes
      });
      this.editor.view.dispatch(tr3);
    }
  };
  var style2 = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
  function createStyleTag(style3, nonce, suffix) {
    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ""}]`);
    if (tiptapStyleTag !== null) {
      return tiptapStyleTag;
    }
    const styleNode = document.createElement("style");
    if (nonce) {
      styleNode.setAttribute("nonce", nonce);
    }
    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ""}`, "");
    styleNode.innerHTML = style3;
    document.getElementsByTagName("head")[0].appendChild(styleNode);
    return styleNode;
  }
  var Editor = class extends EventEmitter {
    constructor(options2 = {}) {
      super();
      this.isFocused = false;
      this.isInitialized = false;
      this.extensionStorage = {};
      this.options = {
        element: document.createElement("div"),
        content: "",
        injectCSS: true,
        injectNonce: void 0,
        extensions: [],
        autofocus: false,
        editable: true,
        editorProps: {},
        parseOptions: {},
        coreExtensionOptions: {},
        enableInputRules: true,
        enablePasteRules: true,
        enableCoreExtensions: true,
        enableContentCheck: false,
        onBeforeCreate: () => null,
        onCreate: () => null,
        onUpdate: () => null,
        onSelectionUpdate: () => null,
        onTransaction: () => null,
        onFocus: () => null,
        onBlur: () => null,
        onDestroy: () => null,
        onContentError: ({ error }) => {
          throw error;
        },
        onPaste: () => null,
        onDrop: () => null
      };
      this.isCapturingTransaction = false;
      this.capturedTransaction = null;
      this.setOptions(options2);
      this.createExtensionManager();
      this.createCommandManager();
      this.createSchema();
      this.on("beforeCreate", this.options.onBeforeCreate);
      this.emit("beforeCreate", { editor: this });
      this.on("contentError", this.options.onContentError);
      this.createView();
      this.injectCSS();
      this.on("create", this.options.onCreate);
      this.on("update", this.options.onUpdate);
      this.on("selectionUpdate", this.options.onSelectionUpdate);
      this.on("transaction", this.options.onTransaction);
      this.on("focus", this.options.onFocus);
      this.on("blur", this.options.onBlur);
      this.on("destroy", this.options.onDestroy);
      this.on("drop", ({ event, slice: slice2, moved }) => this.options.onDrop(event, slice2, moved));
      this.on("paste", ({ event, slice: slice2 }) => this.options.onPaste(event, slice2));
      window.setTimeout(() => {
        if (this.isDestroyed) {
          return;
        }
        this.commands.focus(this.options.autofocus);
        this.emit("create", { editor: this });
        this.isInitialized = true;
      }, 0);
    }
    /**
     * Returns the editor storage.
     */
    get storage() {
      return this.extensionStorage;
    }
    /**
     * An object of all registered commands.
     */
    get commands() {
      return this.commandManager.commands;
    }
    /**
     * Create a command chain to call multiple commands at once.
     */
    chain() {
      return this.commandManager.chain();
    }
    /**
     * Check if a command or a command chain can be executed. Without executing it.
     */
    can() {
      return this.commandManager.can();
    }
    /**
     * Inject CSS styles.
     */
    injectCSS() {
      if (this.options.injectCSS && document) {
        this.css = createStyleTag(style2, this.options.injectNonce);
      }
    }
    /**
     * Update editor options.
     *
     * @param options A list of options
     */
    setOptions(options2 = {}) {
      this.options = {
        ...this.options,
        ...options2
      };
      if (!this.view || !this.state || this.isDestroyed) {
        return;
      }
      if (this.options.editorProps) {
        this.view.setProps(this.options.editorProps);
      }
      this.view.updateState(this.state);
    }
    /**
     * Update editable state of the editor.
     */
    setEditable(editable, emitUpdate = true) {
      this.setOptions({ editable });
      if (emitUpdate) {
        this.emit("update", { editor: this, transaction: this.state.tr });
      }
    }
    /**
     * Returns whether the editor is editable.
     */
    get isEditable() {
      return this.options.editable && this.view && this.view.editable;
    }
    /**
     * Returns the editor state.
     */
    get state() {
      return this.view.state;
    }
    /**
     * Register a ProseMirror plugin.
     *
     * @param plugin A ProseMirror plugin
     * @param handlePlugins Control how to merge the plugin into the existing plugins.
     * @returns The new editor state
     */
    registerPlugin(plugin, handlePlugins) {
      const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
      const state = this.state.reconfigure({ plugins });
      this.view.updateState(state);
      return state;
    }
    /**
     * Unregister a ProseMirror plugin.
     *
     * @param nameOrPluginKeyToRemove The plugins name
     * @returns The new editor state or undefined if the editor is destroyed
     */
    unregisterPlugin(nameOrPluginKeyToRemove) {
      if (this.isDestroyed) {
        return void 0;
      }
      const prevPlugins = this.state.plugins;
      let plugins = prevPlugins;
      [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
        const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
        plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));
      });
      if (prevPlugins.length === plugins.length) {
        return void 0;
      }
      const state = this.state.reconfigure({
        plugins
      });
      this.view.updateState(state);
      return state;
    }
    /**
     * Creates an extension manager.
     */
    createExtensionManager() {
      var _a3, _b;
      const coreExtensions = this.options.enableCoreExtensions ? [
        Editable,
        ClipboardTextSerializer.configure({
          blockSeparator: (_b = (_a3 = this.options.coreExtensionOptions) === null || _a3 === void 0 ? void 0 : _a3.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator
        }),
        Commands,
        FocusEvents,
        Keymap,
        Tabindex,
        Drop,
        Paste
      ].filter((ext) => {
        if (typeof this.options.enableCoreExtensions === "object") {
          return this.options.enableCoreExtensions[ext.name] !== false;
        }
        return true;
      }) : [];
      const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension2) => {
        return ["extension", "node", "mark"].includes(extension2 === null || extension2 === void 0 ? void 0 : extension2.type);
      });
      this.extensionManager = new ExtensionManager(allExtensions, this);
    }
    /**
     * Creates an command manager.
     */
    createCommandManager() {
      this.commandManager = new CommandManager({
        editor: this
      });
    }
    /**
     * Creates a ProseMirror schema.
     */
    createSchema() {
      this.schema = this.extensionManager.schema;
    }
    /**
     * Creates a ProseMirror view.
     */
    createView() {
      var _a3;
      let doc4;
      try {
        doc4 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });
      } catch (e) {
        if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
          throw e;
        }
        this.emit("contentError", {
          editor: this,
          error: e,
          disableCollaboration: () => {
            if (this.storage.collaboration) {
              this.storage.collaboration.isDisabled = true;
            }
            this.options.extensions = this.options.extensions.filter((extension2) => extension2.name !== "collaboration");
            this.createExtensionManager();
          }
        });
        doc4 = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });
      }
      const selection = resolveFocusPosition(doc4, this.options.autofocus);
      this.view = new EditorView(this.options.element, {
        ...this.options.editorProps,
        attributes: {
          // add `role="textbox"` to the editor element
          role: "textbox",
          ...(_a3 = this.options.editorProps) === null || _a3 === void 0 ? void 0 : _a3.attributes
        },
        dispatchTransaction: this.dispatchTransaction.bind(this),
        state: EditorState.create({
          doc: doc4,
          selection: selection || void 0
        })
      });
      const newState = this.state.reconfigure({
        plugins: this.extensionManager.plugins
      });
      this.view.updateState(newState);
      this.createNodeViews();
      this.prependClass();
      const dom = this.view.dom;
      dom.editor = this;
    }
    /**
     * Creates all node views.
     */
    createNodeViews() {
      if (this.view.isDestroyed) {
        return;
      }
      this.view.setProps({
        nodeViews: this.extensionManager.nodeViews
      });
    }
    /**
     * Prepend class name to element.
     */
    prependClass() {
      this.view.dom.className = `tiptap ${this.view.dom.className}`;
    }
    captureTransaction(fn2) {
      this.isCapturingTransaction = true;
      fn2();
      this.isCapturingTransaction = false;
      const tr3 = this.capturedTransaction;
      this.capturedTransaction = null;
      return tr3;
    }
    /**
     * The callback over which to send transactions (state updates) produced by the view.
     *
     * @param transaction An editor state transaction
     */
    dispatchTransaction(transaction) {
      if (this.view.isDestroyed) {
        return;
      }
      if (this.isCapturingTransaction) {
        if (!this.capturedTransaction) {
          this.capturedTransaction = transaction;
          return;
        }
        transaction.steps.forEach((step) => {
          var _a3;
          return (_a3 = this.capturedTransaction) === null || _a3 === void 0 ? void 0 : _a3.step(step);
        });
        return;
      }
      const state = this.state.apply(transaction);
      const selectionHasChanged = !this.state.selection.eq(state.selection);
      this.emit("beforeTransaction", {
        editor: this,
        transaction,
        nextState: state
      });
      this.view.updateState(state);
      this.emit("transaction", {
        editor: this,
        transaction
      });
      if (selectionHasChanged) {
        this.emit("selectionUpdate", {
          editor: this,
          transaction
        });
      }
      const focus2 = transaction.getMeta("focus");
      const blur2 = transaction.getMeta("blur");
      if (focus2) {
        this.emit("focus", {
          editor: this,
          event: focus2.event,
          transaction
        });
      }
      if (blur2) {
        this.emit("blur", {
          editor: this,
          event: blur2.event,
          transaction
        });
      }
      if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
        return;
      }
      this.emit("update", {
        editor: this,
        transaction
      });
    }
    /**
     * Get attributes of the currently selected node or mark.
     */
    getAttributes(nameOrType) {
      return getAttributes(this.state, nameOrType);
    }
    isActive(nameOrAttributes, attributesOrUndefined) {
      const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
      const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
      return isActive(this.state, name, attributes);
    }
    /**
     * Get the document as JSON.
     */
    getJSON() {
      return this.state.doc.toJSON();
    }
    /**
     * Get the document as HTML.
     */
    getHTML() {
      return getHTMLFromFragment(this.state.doc.content, this.schema);
    }
    /**
     * Get the document as text.
     */
    getText(options2) {
      const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
      return getText2(this.state.doc, {
        blockSeparator,
        textSerializers: {
          ...getTextSerializersFromSchema(this.schema),
          ...textSerializers
        }
      });
    }
    /**
     * Check if there is no content.
     */
    get isEmpty() {
      return isNodeEmpty(this.state.doc);
    }
    /**
     * Get the number of characters for the current document.
     *
     * @deprecated
     */
    getCharacterCount() {
      console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
      return this.state.doc.content.size - 2;
    }
    /**
     * Destroy the editor.
     */
    destroy() {
      this.emit("destroy");
      if (this.view) {
        const dom = this.view.dom;
        if (dom && dom.editor) {
          delete dom.editor;
        }
        this.view.destroy();
      }
      this.removeAllListeners();
    }
    /**
     * Check if the editor is already destroyed.
     */
    get isDestroyed() {
      var _a3;
      return !((_a3 = this.view) === null || _a3 === void 0 ? void 0 : _a3.docView);
    }
    $node(selector, attributes) {
      var _a3;
      return ((_a3 = this.$doc) === null || _a3 === void 0 ? void 0 : _a3.querySelector(selector, attributes)) || null;
    }
    $nodes(selector, attributes) {
      var _a3;
      return ((_a3 = this.$doc) === null || _a3 === void 0 ? void 0 : _a3.querySelectorAll(selector, attributes)) || null;
    }
    $pos(pos) {
      const $pos = this.state.doc.resolve(pos);
      return new NodePos($pos, this);
    }
    get $doc() {
      return this.$pos(0);
    }
  };
  function markInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr: tr3 } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr3.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr3.delete(range.from + startSpaces, textStart);
          }
          const markEnd = range.from + startSpaces + captureGroup.length;
          tr3.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
          tr3.removeStoredMark(config.type);
        }
      }
    });
  }
  function nodeInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
        const { tr: tr3 } = state;
        const start = range.from;
        let end = range.to;
        const newNode = config.type.create(attributes);
        if (match[1]) {
          const offset = match[0].lastIndexOf(match[1]);
          let matchStart = start + offset;
          if (matchStart > end) {
            matchStart = end;
          } else {
            end = matchStart + match[1].length;
          }
          const lastChar = match[0][match[0].length - 1];
          tr3.insertText(lastChar, start + match[0].length - 1);
          tr3.replaceWith(matchStart, end, newNode);
        } else if (match[0]) {
          const insertionStart = config.type.isInline ? start : start - 1;
          tr3.insert(insertionStart, config.type.create(attributes)).delete(tr3.mapping.map(start), tr3.mapping.map(end));
        }
        tr3.scrollIntoView();
      }
    });
  }
  function textblockTypeInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        const $start = state.doc.resolve(range.from);
        const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
          return null;
        }
        state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
      }
    });
  }
  function textInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        let insert = config.replace;
        let start = range.from;
        const end = range.to;
        if (match[1]) {
          const offset = match[0].lastIndexOf(match[1]);
          insert += match[0].slice(offset + match[1].length);
          start += offset;
          const cutOff = start - end;
          if (cutOff > 0) {
            insert = match[0].slice(offset - cutOff, offset) + insert;
            start = end;
          }
        }
        state.tr.insertText(insert, start, end);
      }
    });
  }
  function wrappingInputRule(config) {
    return new InputRule({
      find: config.find,
      handler: ({ state, range, match, chain }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
        const tr3 = state.tr.delete(range.from, range.to);
        const $start = tr3.doc.resolve(range.from);
        const blockRange = $start.blockRange();
        const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
        if (!wrapping) {
          return null;
        }
        tr3.wrap(blockRange, wrapping);
        if (config.keepMarks && config.editor) {
          const { selection, storedMarks } = state;
          const { splittableMarks } = config.editor.extensionManager;
          const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
          if (marks) {
            const filteredMarks = marks.filter((mark2) => splittableMarks.includes(mark2.type.name));
            tr3.ensureMarks(filteredMarks);
          }
        }
        if (config.keepAttributes) {
          const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
          chain().updateAttributes(nodeType, attributes).run();
        }
        const before = tr3.doc.resolve(range.from - 1).nodeBefore;
        if (before && before.type === config.type && canJoin(tr3.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
          tr3.join(range.from - 1);
        }
      }
    });
  }
  var Node3 = class _Node {
    constructor(config = {}) {
      this.type = "node";
      this.name = "node";
      this.parent = null;
      this.child = null;
      this.config = {
        name: this.name,
        defaultOptions: {}
      };
      this.config = {
        ...this.config,
        ...config
      };
      this.name = this.config.name;
      if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
      }
      this.options = this.config.defaultOptions;
      if (this.config.addOptions) {
        this.options = callOrReturn(getExtensionField(this, "addOptions", {
          name: this.name
        }));
      }
      this.storage = callOrReturn(getExtensionField(this, "addStorage", {
        name: this.name,
        options: this.options
      })) || {};
    }
    static create(config = {}) {
      return new _Node(config);
    }
    configure(options2 = {}) {
      const extension2 = this.extend({
        ...this.config,
        addOptions: () => {
          return mergeDeep(this.options, options2);
        }
      });
      extension2.name = this.name;
      extension2.parent = this.parent;
      return extension2;
    }
    extend(extendedConfig = {}) {
      const extension2 = new _Node(extendedConfig);
      extension2.parent = this;
      this.child = extension2;
      extension2.name = extendedConfig.name ? extendedConfig.name : extension2.parent.name;
      if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {
        console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension2.name}".`);
      }
      extension2.options = callOrReturn(getExtensionField(extension2, "addOptions", {
        name: extension2.name
      }));
      extension2.storage = callOrReturn(getExtensionField(extension2, "addStorage", {
        name: extension2.name,
        options: extension2.options
      }));
      return extension2;
    }
  };
  var NodeView = class {
    constructor(component, props, options2) {
      this.isDragging = false;
      this.component = component;
      this.editor = props.editor;
      this.options = {
        stopEvent: null,
        ignoreMutation: null,
        ...options2
      };
      this.extension = props.extension;
      this.node = props.node;
      this.decorations = props.decorations;
      this.innerDecorations = props.innerDecorations;
      this.view = props.view;
      this.HTMLAttributes = props.HTMLAttributes;
      this.getPos = props.getPos;
      this.mount();
    }
    mount() {
      return;
    }
    get dom() {
      return this.editor.view.dom;
    }
    get contentDOM() {
      return null;
    }
    onDragStart(event) {
      var _a3, _b, _c2, _d, _e2, _f, _g;
      const { view } = this.editor;
      const target = event.target;
      const dragHandle = target.nodeType === 3 ? (_a3 = target.parentElement) === null || _a3 === void 0 ? void 0 : _a3.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
      if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {
        return;
      }
      let x = 0;
      let y = 0;
      if (this.dom !== dragHandle) {
        const domBox = this.dom.getBoundingClientRect();
        const handleBox = dragHandle.getBoundingClientRect();
        const offsetX = (_c2 = event.offsetX) !== null && _c2 !== void 0 ? _c2 : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;
        const offsetY = (_e2 = event.offsetY) !== null && _e2 !== void 0 ? _e2 : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;
        x = handleBox.x - domBox.x + offsetX;
        y = handleBox.y - domBox.y + offsetY;
      }
      const clonedNode = this.dom.cloneNode(true);
      (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(clonedNode, x, y);
      const pos = this.getPos();
      if (typeof pos !== "number") {
        return;
      }
      const selection = NodeSelection.create(view.state.doc, pos);
      const transaction = view.state.tr.setSelection(selection);
      view.dispatch(transaction);
    }
    stopEvent(event) {
      var _a3;
      if (!this.dom) {
        return false;
      }
      if (typeof this.options.stopEvent === "function") {
        return this.options.stopEvent({ event });
      }
      const target = event.target;
      const isInElement = this.dom.contains(target) && !((_a3 = this.contentDOM) === null || _a3 === void 0 ? void 0 : _a3.contains(target));
      if (!isInElement) {
        return false;
      }
      const isDragEvent = event.type.startsWith("drag");
      const isDropEvent = event.type === "drop";
      const isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
      if (isInput && !isDropEvent && !isDragEvent) {
        return true;
      }
      const { isEditable } = this.editor;
      const { isDragging } = this;
      const isDraggable = !!this.node.type.spec.draggable;
      const isSelectable = NodeSelection.isSelectable(this.node);
      const isCopyEvent = event.type === "copy";
      const isPasteEvent = event.type === "paste";
      const isCutEvent = event.type === "cut";
      const isClickEvent = event.type === "mousedown";
      if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {
        event.preventDefault();
      }
      if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {
        event.preventDefault();
        return false;
      }
      if (isDraggable && isEditable && !isDragging && isClickEvent) {
        const dragHandle = target.closest("[data-drag-handle]");
        const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
        if (isValidDragHandle) {
          this.isDragging = true;
          document.addEventListener("dragend", () => {
            this.isDragging = false;
          }, { once: true });
          document.addEventListener("drop", () => {
            this.isDragging = false;
          }, { once: true });
          document.addEventListener("mouseup", () => {
            this.isDragging = false;
          }, { once: true });
        }
      }
      if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
        return false;
      }
      return true;
    }
    /**
     * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
     * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
     * @return `true` if it can safely be ignored.
     */
    ignoreMutation(mutation) {
      if (!this.dom || !this.contentDOM) {
        return true;
      }
      if (typeof this.options.ignoreMutation === "function") {
        return this.options.ignoreMutation({ mutation });
      }
      if (this.node.isLeaf || this.node.isAtom) {
        return true;
      }
      if (mutation.type === "selection") {
        return false;
      }
      if (this.dom.contains(mutation.target) && mutation.type === "childList" && (isiOS() || isAndroid()) && this.editor.isFocused) {
        const changedNodes = [
          ...Array.from(mutation.addedNodes),
          ...Array.from(mutation.removedNodes)
        ];
        if (changedNodes.every((node2) => node2.isContentEditable)) {
          return false;
        }
      }
      if (this.contentDOM === mutation.target && mutation.type === "attributes") {
        return true;
      }
      if (this.contentDOM.contains(mutation.target)) {
        return false;
      }
      return true;
    }
    /**
     * Update the attributes of the prosemirror node.
     */
    updateAttributes(attributes) {
      this.editor.commands.command(({ tr: tr3 }) => {
        const pos = this.getPos();
        if (typeof pos !== "number") {
          return false;
        }
        tr3.setNodeMarkup(pos, void 0, {
          ...this.node.attrs,
          ...attributes
        });
        return true;
      });
    }
    /**
     * Delete the node.
     */
    deleteNode() {
      const from4 = this.getPos();
      if (typeof from4 !== "number") {
        return;
      }
      const to2 = from4 + this.node.nodeSize;
      this.editor.commands.deleteRange({ from: from4, to: to2 });
    }
  };
  function markPasteRule(config) {
    return new PasteRule({
      find: config.find,
      handler: ({ state, range, match, pasteEvent }) => {
        const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
        if (attributes === false || attributes === null) {
          return null;
        }
        const { tr: tr3 } = state;
        const captureGroup = match[match.length - 1];
        const fullMatch = match[0];
        let markEnd = range.to;
        if (captureGroup) {
          const startSpaces = fullMatch.search(/\S/);
          const textStart = range.from + fullMatch.indexOf(captureGroup);
          const textEnd = textStart + captureGroup.length;
          const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {
            const excluded = item.mark.type.excluded;
            return excluded.find((type) => type === config.type && type !== item.mark.type);
          }).filter((item) => item.to > textStart);
          if (excludedMarks.length) {
            return null;
          }
          if (textEnd < range.to) {
            tr3.delete(textEnd, range.to);
          }
          if (textStart > range.from) {
            tr3.delete(range.from + startSpaces, textStart);
          }
          markEnd = range.from + startSpaces + captureGroup.length;
          tr3.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
          tr3.removeStoredMark(config.type);
        }
      }
    });
  }
  function escapeForRegEx(string3) {
    return string3.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  function isString(value) {
    return typeof value === "string";
  }
  function nodePasteRule(config) {
    return new PasteRule({
      find: config.find,
      handler({ match, chain, range, pasteEvent }) {
        const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
        const content5 = callOrReturn(config.getContent, void 0, attributes);
        if (attributes === false || attributes === null) {
          return null;
        }
        const node2 = { type: config.type.name, attrs: attributes };
        if (content5) {
          node2.content = content5;
        }
        if (match.input) {
          chain().deleteRange(range).insertContentAt(range.from, node2);
        }
      }
    });
  }
  function textPasteRule(config) {
    return new PasteRule({
      find: config.find,
      handler: ({ state, range, match }) => {
        let insert = config.replace;
        let start = range.from;
        const end = range.to;
        if (match[1]) {
          const offset = match[0].lastIndexOf(match[1]);
          insert += match[0].slice(offset + match[1].length);
          start += offset;
          const cutOff = start - end;
          if (cutOff > 0) {
            insert = match[0].slice(offset - cutOff, offset) + insert;
            start = end;
          }
        }
        state.tr.insertText(insert, start, end);
      }
    });
  }
  var Tracker = class {
    constructor(transaction) {
      this.transaction = transaction;
      this.currentStep = this.transaction.steps.length;
    }
    map(position4) {
      let deleted = false;
      const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {
        const mapResult = step.getMap().mapResult(newPosition);
        if (mapResult.deleted) {
          deleted = true;
        }
        return mapResult.pos;
      }, position4);
      return {
        position: mappedPosition,
        deleted
      };
    }
  };

  // node_modules/uuid/dist/esm-browser/rng.js
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }

  // node_modules/uuid/dist/esm-browser/regex.js
  var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

  // node_modules/uuid/dist/esm-browser/validate.js
  function validate(uuid) {
    return typeof uuid === "string" && regex_default.test(uuid);
  }
  var validate_default = validate;

  // node_modules/uuid/dist/esm-browser/stringify.js
  var byteToHex = [];
  for (i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  function stringify3(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate_default(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var stringify_default = stringify3;
  var i;

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options2, buf, offset) {
    options2 = options2 || {};
    var rnds = options2.random || (options2.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return stringify_default(rnds);
  }
  var v4_default = v4;

  // node_modules/prosemirror-highlight/dist/index.js
  var DecorationCache = class _DecorationCache {
    constructor(cache) {
      this.cache = new Map(cache);
    }
    /**
     * Gets the cache entry at the given doc position, or null if it doesn't exist
     * @param pos The doc position of the node you want the cache for
     */
    get(pos) {
      return this.cache.get(pos);
    }
    /**
     * Sets the cache entry at the given position with the give node/decoration
     * values
     * @param pos The doc position of the node to set the cache for
     * @param node The node to place in cache
     * @param decorations The decorations to place in cache
     */
    set(pos, node2, decorations) {
      if (pos < 0) {
        return;
      }
      this.cache.set(pos, [node2, decorations]);
    }
    /**
     * Removes the value at the oldPos (if it exists) and sets the new position to
     * the given values
     * @param oldPos The old node position to overwrite
     * @param newPos The new node position to set the cache for
     * @param node The new node to place in cache
     * @param decorations The new decorations to place in cache
     */
    replace(oldPos, newPos, node2, decorations) {
      this.remove(oldPos);
      this.set(newPos, node2, decorations);
    }
    /**
     * Removes the cache entry at the given position
     * @param pos The doc position to remove from cache
     */
    remove(pos) {
      this.cache.delete(pos);
    }
    /**
     * Invalidates the cache by removing all decoration entries on nodes that have
     * changed, updating the positions of the nodes that haven't and removing all
     * the entries that have been deleted; NOTE: this does not affect the current
     * cache, but returns an entirely new one
     * @param tr A transaction to map the current cache to
     */
    invalidate(tr3) {
      const returnCache = new _DecorationCache(this.cache);
      const mapping = tr3.mapping;
      this.cache.forEach(([node2, decorations], pos) => {
        if (pos < 0) {
          return;
        }
        const result = mapping.mapResult(pos);
        const mappedNode = tr3.doc.nodeAt(result.pos);
        if (result.deleted || !(mappedNode == null ? void 0 : mappedNode.eq(node2))) {
          returnCache.remove(pos);
        } else if (pos !== result.pos) {
          const updatedDecorations = decorations.map((d) => {
            return d.map(mapping, 0, 0);
          }).filter((d) => d != null);
          returnCache.replace(pos, result.pos, mappedNode, updatedDecorations);
        }
      });
      return returnCache;
    }
  };
  function createHighlightPlugin({
    parser,
    nodeTypes = ["code_block", "codeBlock"],
    languageExtractor = (node2) => node2.attrs.language
  }) {
    const key2 = new PluginKey("prosemirror-highlight");
    return new Plugin({
      key: key2,
      state: {
        init(_2, instance) {
          const cache = new DecorationCache();
          const [decorations, promises] = calculateDecoration(
            instance.doc,
            parser,
            nodeTypes,
            languageExtractor,
            cache
          );
          return { cache, decorations, promises };
        },
        apply: (tr3, data) => {
          const cache = data.cache.invalidate(tr3);
          const refresh = !!tr3.getMeta("prosemirror-highlight-refresh");
          if (!tr3.docChanged && !refresh) {
            const decorations2 = data.decorations.map(tr3.mapping, tr3.doc);
            const promises2 = data.promises;
            return { cache, decorations: decorations2, promises: promises2 };
          }
          const [decorations, promises] = calculateDecoration(
            tr3.doc,
            parser,
            nodeTypes,
            languageExtractor,
            cache
          );
          return { cache, decorations, promises };
        }
      },
      view: (view) => {
        const promises = /* @__PURE__ */ new Set();
        const refresh = () => {
          if (promises.size > 0) {
            return;
          }
          const tr3 = view.state.tr.setMeta("prosemirror-highlight-refresh", true);
          view.dispatch(tr3);
        };
        const check = () => {
          var _a3;
          const state = key2.getState(view.state);
          for (const promise of (_a3 = state == null ? void 0 : state.promises) != null ? _a3 : []) {
            promises.add(promise);
            promise.then(() => {
              promises.delete(promise);
              refresh();
            }).catch(() => {
              promises.delete(promise);
            });
          }
        };
        check();
        return {
          update: () => {
            check();
          }
        };
      },
      props: {
        decorations(state) {
          var _a3;
          return (_a3 = this.getState(state)) == null ? void 0 : _a3.decorations;
        }
      }
    });
  }
  function calculateDecoration(doc4, parser, nodeTypes, languageExtractor, cache) {
    const result = [];
    const promises = [];
    doc4.descendants((node2, pos) => {
      if (!node2.type.isTextblock) {
        return true;
      }
      if (nodeTypes.includes(node2.type.name)) {
        const language = languageExtractor(node2);
        const cached = cache.get(pos);
        if (cached) {
          const [_2, decorations] = cached;
          result.push(...decorations);
        } else {
          const decorations = parser({
            content: node2.textContent,
            language: language || void 0,
            pos,
            size: node2.nodeSize
          });
          if (decorations && Array.isArray(decorations)) {
            cache.set(pos, node2, decorations);
            result.push(...decorations);
          } else if (decorations instanceof Promise) {
            cache.remove(pos);
            promises.push(decorations);
          }
        }
      }
      return false;
    });
    return [DecorationSet.create(doc4, result), promises];
  }

  // node_modules/prosemirror-highlight/dist/shiki.js
  function createParser(highlighter, options2) {
    return function parser({ content: content5, language, pos, size: size2 }) {
      var _a3;
      const decorations = [];
      const { tokens, fg, bg, rootStyle } = highlighter.codeToTokens(content5, {
        lang: language,
        // Use provided options for themes or just use first loaded theme
        ...options2 != null ? options2 : {
          theme: highlighter.getLoadedThemes()[0]
        }
      });
      const style3 = rootStyle || (fg && bg ? `--prosemirror-highlight:${fg};--prosemirror-highlight-bg:${bg}` : "");
      if (style3) {
        const decoration = Decoration.node(pos, pos + size2, { style: style3 });
        decorations.push(decoration);
      }
      let from4 = pos + 1;
      for (const line of tokens) {
        for (const token of line) {
          const to2 = from4 + token.content.length;
          const decoration = Decoration.inline(from4, to2, {
            // When using `options.themes` the `htmlStyle` field will be set, otherwise `color` will be set
            style: stringifyTokenStyle(
              (_a3 = token.htmlStyle) != null ? _a3 : `color: ${token.color}`
            ),
            class: "shiki"
          });
          decorations.push(decoration);
          from4 = to2;
        }
        from4 += 1;
      }
      return decorations;
    };
  }
  function stringifyTokenStyle(token) {
    if (typeof token === "string") return token;
    return Object.entries(token).map(([key2, value]) => `${key2}:${value}`).join(";");
  }

  // node_modules/@tiptap/extension-bold/dist/index.js
  var starInputRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
  var starPasteRegex = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
  var underscoreInputRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
  var underscorePasteRegex = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
  var Bold = Mark2.create({
    name: "bold",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "strong"
        },
        {
          tag: "b",
          getAttrs: (node2) => node2.style.fontWeight !== "normal" && null
        },
        {
          style: "font-weight=400",
          clearMark: (mark2) => mark2.type.name === this.name
        },
        {
          style: "font-weight",
          getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setBold: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleBold: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetBold: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-b": () => this.editor.commands.toggleBold(),
        "Mod-B": () => this.editor.commands.toggleBold()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: starInputRegex,
          type: this.type
        }),
        markInputRule({
          find: underscoreInputRegex,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: starPasteRegex,
          type: this.type
        }),
        markPasteRule({
          find: underscorePasteRegex,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-code/dist/index.js
  var inputRegex = /(^|[^`])`([^`]+)`(?!`)/;
  var pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;
  var Code = Mark2.create({
    name: "code",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    excludes: "_",
    code: true,
    exitable: true,
    parseHTML() {
      return [
        { tag: "code" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setCode: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleCode: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetCode: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-e": () => this.editor.commands.toggleCode()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: inputRegex,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: pasteRegex,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-italic/dist/index.js
  var starInputRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
  var starPasteRegex2 = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
  var underscoreInputRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
  var underscorePasteRegex2 = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
  var Italic = Mark2.create({
    name: "italic",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "em"
        },
        {
          tag: "i",
          getAttrs: (node2) => node2.style.fontStyle !== "normal" && null
        },
        {
          style: "font-style=normal",
          clearMark: (mark2) => mark2.type.name === this.name
        },
        {
          style: "font-style=italic"
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setItalic: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleItalic: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetItalic: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-i": () => this.editor.commands.toggleItalic(),
        "Mod-I": () => this.editor.commands.toggleItalic()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: starInputRegex2,
          type: this.type
        }),
        markInputRule({
          find: underscoreInputRegex2,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: starPasteRegex2,
          type: this.type
        }),
        markPasteRule({
          find: underscorePasteRegex2,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-strike/dist/index.js
  var inputRegex2 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
  var pasteRegex2 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
  var Strike = Mark2.create({
    name: "strike",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "s"
        },
        {
          tag: "del"
        },
        {
          tag: "strike"
        },
        {
          style: "text-decoration",
          consuming: false,
          getAttrs: (style3) => style3.includes("line-through") ? {} : false
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setStrike: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleStrike: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetStrike: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Shift-s": () => this.editor.commands.toggleStrike()
      };
    },
    addInputRules() {
      return [
        markInputRule({
          find: inputRegex2,
          type: this.type
        })
      ];
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: pasteRegex2,
          type: this.type
        })
      ];
    }
  });

  // node_modules/@tiptap/extension-underline/dist/index.js
  var Underline = Mark2.create({
    name: "underline",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    parseHTML() {
      return [
        {
          tag: "u"
        },
        {
          style: "text-decoration",
          consuming: false,
          getAttrs: (style3) => style3.includes("underline") ? {} : false
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setUnderline: () => ({ commands: commands2 }) => {
          return commands2.setMark(this.name);
        },
        toggleUnderline: () => ({ commands: commands2 }) => {
          return commands2.toggleMark(this.name);
        },
        unsetUnderline: () => ({ commands: commands2 }) => {
          return commands2.unsetMark(this.name);
        }
      };
    },
    addKeyboardShortcuts() {
      return {
        "Mod-u": () => this.editor.commands.toggleUnderline(),
        "Mod-U": () => this.editor.commands.toggleUnderline()
      };
    }
  });

  // node_modules/@tiptap/extension-table-cell/dist/index.js
  var TableCell = Node3.create({
    name: "tableCell",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "block+",
    addAttributes() {
      return {
        colspan: {
          default: 1
        },
        rowspan: {
          default: 1
        },
        colwidth: {
          default: null,
          parseHTML: (element7) => {
            const colwidth = element7.getAttribute("colwidth");
            const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
            return value;
          }
        }
      };
    },
    tableRole: "cell",
    isolating: true,
    parseHTML() {
      return [
        { tag: "td" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["td", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    }
  });

  // node_modules/@tiptap/extension-table-header/dist/index.js
  var TableHeader = Node3.create({
    name: "tableHeader",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "block+",
    addAttributes() {
      return {
        colspan: {
          default: 1
        },
        rowspan: {
          default: 1
        },
        colwidth: {
          default: null,
          parseHTML: (element7) => {
            const colwidth = element7.getAttribute("colwidth");
            const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
            return value;
          }
        }
      };
    },
    tableRole: "header_cell",
    isolating: true,
    parseHTML() {
      return [
        { tag: "th" }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      return ["th", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    }
  });

  // node_modules/prosemirror-tables/dist/index.js
  var readFromCache;
  var addToCache;
  if (typeof WeakMap != "undefined") {
    let cache = /* @__PURE__ */ new WeakMap();
    readFromCache = (key2) => cache.get(key2);
    addToCache = (key2, value) => {
      cache.set(key2, value);
      return value;
    };
  } else {
    const cache = [];
    const cacheSize = 10;
    let cachePos = 0;
    readFromCache = (key2) => {
      for (let i = 0; i < cache.length; i += 2)
        if (cache[i] == key2) return cache[i + 1];
    };
    addToCache = (key2, value) => {
      if (cachePos == cacheSize) cachePos = 0;
      cache[cachePos++] = key2;
      return cache[cachePos++] = value;
    };
  }
  var TableMap = class {
    constructor(width, height, map9, problems) {
      this.width = width;
      this.height = height;
      this.map = map9;
      this.problems = problems;
    }
    // Find the dimensions of the cell at the given position.
    findCell(pos) {
      for (let i = 0; i < this.map.length; i++) {
        const curPos = this.map[i];
        if (curPos != pos) continue;
        const left = i % this.width;
        const top = i / this.width | 0;
        let right = left + 1;
        let bottom = top + 1;
        for (let j2 = 1; right < this.width && this.map[i + j2] == curPos; j2++) {
          right++;
        }
        for (let j2 = 1; bottom < this.height && this.map[i + this.width * j2] == curPos; j2++) {
          bottom++;
        }
        return { left, top, right, bottom };
      }
      throw new RangeError(`No cell with offset ${pos} found`);
    }
    // Find the left side of the cell at the given position.
    colCount(pos) {
      for (let i = 0; i < this.map.length; i++) {
        if (this.map[i] == pos) {
          return i % this.width;
        }
      }
      throw new RangeError(`No cell with offset ${pos} found`);
    }
    // Find the next cell in the given direction, starting from the cell
    // at `pos`, if any.
    nextCell(pos, axis, dir) {
      const { left, right, top, bottom } = this.findCell(pos);
      if (axis == "horiz") {
        if (dir < 0 ? left == 0 : right == this.width) return null;
        return this.map[top * this.width + (dir < 0 ? left - 1 : right)];
      } else {
        if (dir < 0 ? top == 0 : bottom == this.height) return null;
        return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];
      }
    }
    // Get the rectangle spanning the two given cells.
    rectBetween(a2, b) {
      const {
        left: leftA,
        right: rightA,
        top: topA,
        bottom: bottomA
      } = this.findCell(a2);
      const {
        left: leftB,
        right: rightB,
        top: topB,
        bottom: bottomB
      } = this.findCell(b);
      return {
        left: Math.min(leftA, leftB),
        top: Math.min(topA, topB),
        right: Math.max(rightA, rightB),
        bottom: Math.max(bottomA, bottomB)
      };
    }
    // Return the position of all cells that have the top left corner in
    // the given rectangle.
    cellsInRect(rect) {
      const result = [];
      const seen = {};
      for (let row2 = rect.top; row2 < rect.bottom; row2++) {
        for (let col = rect.left; col < rect.right; col++) {
          const index3 = row2 * this.width + col;
          const pos = this.map[index3];
          if (seen[pos]) continue;
          seen[pos] = true;
          if (col == rect.left && col && this.map[index3 - 1] == pos || row2 == rect.top && row2 && this.map[index3 - this.width] == pos) {
            continue;
          }
          result.push(pos);
        }
      }
      return result;
    }
    // Return the position at which the cell at the given row and column
    // starts, or would start, if a cell started there.
    positionAt(row2, col, table3) {
      for (let i = 0, rowStart = 0; ; i++) {
        const rowEnd = rowStart + table3.child(i).nodeSize;
        if (i == row2) {
          let index3 = col + row2 * this.width;
          const rowEndIndex = (row2 + 1) * this.width;
          while (index3 < rowEndIndex && this.map[index3] < rowStart) index3++;
          return index3 == rowEndIndex ? rowEnd - 1 : this.map[index3];
        }
        rowStart = rowEnd;
      }
    }
    // Find the table map for the given table node.
    static get(table3) {
      return readFromCache(table3) || addToCache(table3, computeMap(table3));
    }
  };
  function computeMap(table3) {
    if (table3.type.spec.tableRole != "table")
      throw new RangeError("Not a table node: " + table3.type.name);
    const width = findWidth(table3), height = table3.childCount;
    const map9 = [];
    let mapPos = 0;
    let problems = null;
    const colWidths = [];
    for (let i = 0, e = width * height; i < e; i++) map9[i] = 0;
    for (let row2 = 0, pos = 0; row2 < height; row2++) {
      const rowNode = table3.child(row2);
      pos++;
      for (let i = 0; ; i++) {
        while (mapPos < map9.length && map9[mapPos] != 0) mapPos++;
        if (i == rowNode.childCount) break;
        const cellNode = rowNode.child(i);
        const { colspan, rowspan, colwidth } = cellNode.attrs;
        for (let h2 = 0; h2 < rowspan; h2++) {
          if (h2 + row2 >= height) {
            (problems || (problems = [])).push({
              type: "overlong_rowspan",
              pos,
              n: rowspan - h2
            });
            break;
          }
          const start = mapPos + h2 * width;
          for (let w = 0; w < colspan; w++) {
            if (map9[start + w] == 0) map9[start + w] = pos;
            else
              (problems || (problems = [])).push({
                type: "collision",
                row: row2,
                pos,
                n: colspan - w
              });
            const colW = colwidth && colwidth[w];
            if (colW) {
              const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];
              if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
                colWidths[widthIndex] = colW;
                colWidths[widthIndex + 1] = 1;
              } else if (prev == colW) {
                colWidths[widthIndex + 1]++;
              }
            }
          }
        }
        mapPos += colspan;
        pos += cellNode.nodeSize;
      }
      const expectedPos = (row2 + 1) * width;
      let missing = 0;
      while (mapPos < expectedPos) if (map9[mapPos++] == 0) missing++;
      if (missing)
        (problems || (problems = [])).push({ type: "missing", row: row2, n: missing });
      pos++;
    }
    if (width === 0 || height === 0)
      (problems || (problems = [])).push({ type: "zero_sized" });
    const tableMap = new TableMap(width, height, map9, problems);
    let badWidths = false;
    for (let i = 0; !badWidths && i < colWidths.length; i += 2)
      if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;
    if (badWidths) findBadColWidths(tableMap, colWidths, table3);
    return tableMap;
  }
  function findWidth(table3) {
    let width = -1;
    let hasRowSpan = false;
    for (let row2 = 0; row2 < table3.childCount; row2++) {
      const rowNode = table3.child(row2);
      let rowWidth = 0;
      if (hasRowSpan)
        for (let j2 = 0; j2 < row2; j2++) {
          const prevRow = table3.child(j2);
          for (let i = 0; i < prevRow.childCount; i++) {
            const cell2 = prevRow.child(i);
            if (j2 + cell2.attrs.rowspan > row2) rowWidth += cell2.attrs.colspan;
          }
        }
      for (let i = 0; i < rowNode.childCount; i++) {
        const cell2 = rowNode.child(i);
        rowWidth += cell2.attrs.colspan;
        if (cell2.attrs.rowspan > 1) hasRowSpan = true;
      }
      if (width == -1) width = rowWidth;
      else if (width != rowWidth) width = Math.max(width, rowWidth);
    }
    return width;
  }
  function findBadColWidths(map9, colWidths, table3) {
    if (!map9.problems) map9.problems = [];
    const seen = {};
    for (let i = 0; i < map9.map.length; i++) {
      const pos = map9.map[i];
      if (seen[pos]) continue;
      seen[pos] = true;
      const node2 = table3.nodeAt(pos);
      if (!node2) {
        throw new RangeError(`No cell with offset ${pos} found`);
      }
      let updated = null;
      const attrs = node2.attrs;
      for (let j2 = 0; j2 < attrs.colspan; j2++) {
        const col = (i + j2) % map9.width;
        const colWidth = colWidths[col * 2];
        if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j2] != colWidth))
          (updated || (updated = freshColWidth(attrs)))[j2] = colWidth;
      }
      if (updated)
        map9.problems.unshift({
          type: "colwidth mismatch",
          pos,
          colwidth: updated
        });
    }
  }
  function freshColWidth(attrs) {
    if (attrs.colwidth) return attrs.colwidth.slice();
    const result = [];
    for (let i = 0; i < attrs.colspan; i++) result.push(0);
    return result;
  }
  function getCellAttrs(dom, extraAttrs) {
    if (typeof dom === "string") {
      return {};
    }
    const widthAttr = dom.getAttribute("data-colwidth");
    const widths = widthAttr && /^\d+(,\d+)*$/.test(widthAttr) ? widthAttr.split(",").map((s2) => Number(s2)) : null;
    const colspan = Number(dom.getAttribute("colspan") || 1);
    const result = {
      colspan,
      rowspan: Number(dom.getAttribute("rowspan") || 1),
      colwidth: widths && widths.length == colspan ? widths : null
    };
    for (const prop in extraAttrs) {
      const getter = extraAttrs[prop].getFromDOM;
      const value = getter && getter(dom);
      if (value != null) {
        result[prop] = value;
      }
    }
    return result;
  }
  function setCellAttrs(node2, extraAttrs) {
    const attrs = {};
    if (node2.attrs.colspan != 1) attrs.colspan = node2.attrs.colspan;
    if (node2.attrs.rowspan != 1) attrs.rowspan = node2.attrs.rowspan;
    if (node2.attrs.colwidth)
      attrs["data-colwidth"] = node2.attrs.colwidth.join(",");
    for (const prop in extraAttrs) {
      const setter = extraAttrs[prop].setDOMAttr;
      if (setter) setter(node2.attrs[prop], attrs);
    }
    return attrs;
  }
  function validateColwidth(value) {
    if (value === null) {
      return;
    }
    if (!Array.isArray(value)) {
      throw new TypeError("colwidth must be null or an array");
    }
    for (const item of value) {
      if (typeof item !== "number") {
        throw new TypeError("colwidth must be null or an array of numbers");
      }
    }
  }
  function tableNodes(options2) {
    const extraAttrs = options2.cellAttributes || {};
    const cellAttrs = {
      colspan: { default: 1, validate: "number" },
      rowspan: { default: 1, validate: "number" },
      colwidth: { default: null, validate: validateColwidth }
    };
    for (const prop in extraAttrs)
      cellAttrs[prop] = {
        default: extraAttrs[prop].default,
        validate: extraAttrs[prop].validate
      };
    return {
      table: {
        content: "table_row+",
        tableRole: "table",
        isolating: true,
        group: options2.tableGroup,
        parseDOM: [{ tag: "table" }],
        toDOM() {
          return ["table", ["tbody", 0]];
        }
      },
      table_row: {
        content: "(table_cell | table_header)*",
        tableRole: "row",
        parseDOM: [{ tag: "tr" }],
        toDOM() {
          return ["tr", 0];
        }
      },
      table_cell: {
        content: options2.cellContent,
        attrs: cellAttrs,
        tableRole: "cell",
        isolating: true,
        parseDOM: [
          { tag: "td", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }
        ],
        toDOM(node2) {
          return ["td", setCellAttrs(node2, extraAttrs), 0];
        }
      },
      table_header: {
        content: options2.cellContent,
        attrs: cellAttrs,
        tableRole: "header_cell",
        isolating: true,
        parseDOM: [
          { tag: "th", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }
        ],
        toDOM(node2) {
          return ["th", setCellAttrs(node2, extraAttrs), 0];
        }
      }
    };
  }
  function tableNodeTypes(schema) {
    let result = schema.cached.tableNodeTypes;
    if (!result) {
      result = schema.cached.tableNodeTypes = {};
      for (const name in schema.nodes) {
        const type = schema.nodes[name], role = type.spec.tableRole;
        if (role) result[role] = type;
      }
    }
    return result;
  }
  var tableEditingKey = new PluginKey("selectingCells");
  function cellAround($pos) {
    for (let d = $pos.depth - 1; d > 0; d--)
      if ($pos.node(d).type.spec.tableRole == "row")
        return $pos.node(0).resolve($pos.before(d + 1));
    return null;
  }
  function cellWrapping($pos) {
    for (let d = $pos.depth; d > 0; d--) {
      const role = $pos.node(d).type.spec.tableRole;
      if (role === "cell" || role === "header_cell") return $pos.node(d);
    }
    return null;
  }
  function isInTable(state) {
    const $head = state.selection.$head;
    for (let d = $head.depth; d > 0; d--)
      if ($head.node(d).type.spec.tableRole == "row") return true;
    return false;
  }
  function selectionCell(state) {
    const sel = state.selection;
    if ("$anchorCell" in sel && sel.$anchorCell) {
      return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
    } else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") {
      return sel.$anchor;
    }
    const $cell = cellAround(sel.$head) || cellNear(sel.$head);
    if ($cell) {
      return $cell;
    }
    throw new RangeError(`No cell found around position ${sel.head}`);
  }
  function cellNear($pos) {
    for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
      const role = after.type.spec.tableRole;
      if (role == "cell" || role == "header_cell") return $pos.doc.resolve(pos);
    }
    for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {
      const role = before.type.spec.tableRole;
      if (role == "cell" || role == "header_cell")
        return $pos.doc.resolve(pos - before.nodeSize);
    }
  }
  function pointsAtCell($pos) {
    return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
  }
  function moveCellForward($pos) {
    return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
  }
  function inSameTable($cellA, $cellB) {
    return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
  }
  function findCell($pos) {
    return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));
  }
  function colCount($pos) {
    return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));
  }
  function nextCell($pos, axis, dir) {
    const table3 = $pos.node(-1);
    const map9 = TableMap.get(table3);
    const tableStart = $pos.start(-1);
    const moved = map9.nextCell($pos.pos - tableStart, axis, dir);
    return moved == null ? null : $pos.node(0).resolve(tableStart + moved);
  }
  function removeColSpan(attrs, pos, n = 1) {
    const result = { ...attrs, colspan: attrs.colspan - n };
    if (result.colwidth) {
      result.colwidth = result.colwidth.slice();
      result.colwidth.splice(pos, n);
      if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;
    }
    return result;
  }
  function addColSpan(attrs, pos, n = 1) {
    const result = { ...attrs, colspan: attrs.colspan + n };
    if (result.colwidth) {
      result.colwidth = result.colwidth.slice();
      for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);
    }
    return result;
  }
  function columnIsHeader(map9, table3, col) {
    const headerCell = tableNodeTypes(table3.type.schema).header_cell;
    for (let row2 = 0; row2 < map9.height; row2++)
      if (table3.nodeAt(map9.map[col + row2 * map9.width]).type != headerCell)
        return false;
    return true;
  }
  var CellSelection = class _CellSelection extends Selection {
    // A table selection is identified by its anchor and head cells. The
    // positions given to this constructor should point _before_ two
    // cells in the same table. They may be the same, to select a single
    // cell.
    constructor($anchorCell, $headCell = $anchorCell) {
      const table3 = $anchorCell.node(-1);
      const map9 = TableMap.get(table3);
      const tableStart = $anchorCell.start(-1);
      const rect = map9.rectBetween(
        $anchorCell.pos - tableStart,
        $headCell.pos - tableStart
      );
      const doc4 = $anchorCell.node(0);
      const cells2 = map9.cellsInRect(rect).filter((p5) => p5 != $headCell.pos - tableStart);
      cells2.unshift($headCell.pos - tableStart);
      const ranges = cells2.map((pos) => {
        const cell2 = table3.nodeAt(pos);
        if (!cell2) {
          throw RangeError(`No cell with offset ${pos} found`);
        }
        const from4 = tableStart + pos + 1;
        return new SelectionRange(
          doc4.resolve(from4),
          doc4.resolve(from4 + cell2.content.size)
        );
      });
      super(ranges[0].$from, ranges[0].$to, ranges);
      this.$anchorCell = $anchorCell;
      this.$headCell = $headCell;
    }
    map(doc4, mapping) {
      const $anchorCell = doc4.resolve(mapping.map(this.$anchorCell.pos));
      const $headCell = doc4.resolve(mapping.map(this.$headCell.pos));
      if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
        const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
        if (tableChanged && this.isRowSelection())
          return _CellSelection.rowSelection($anchorCell, $headCell);
        else if (tableChanged && this.isColSelection())
          return _CellSelection.colSelection($anchorCell, $headCell);
        else return new _CellSelection($anchorCell, $headCell);
      }
      return TextSelection.between($anchorCell, $headCell);
    }
    // Returns a rectangular slice of table rows containing the selected
    // cells.
    content() {
      const table3 = this.$anchorCell.node(-1);
      const map9 = TableMap.get(table3);
      const tableStart = this.$anchorCell.start(-1);
      const rect = map9.rectBetween(
        this.$anchorCell.pos - tableStart,
        this.$headCell.pos - tableStart
      );
      const seen = {};
      const rows = [];
      for (let row2 = rect.top; row2 < rect.bottom; row2++) {
        const rowContent = [];
        for (let index3 = row2 * map9.width + rect.left, col = rect.left; col < rect.right; col++, index3++) {
          const pos = map9.map[index3];
          if (seen[pos]) continue;
          seen[pos] = true;
          const cellRect = map9.findCell(pos);
          let cell2 = table3.nodeAt(pos);
          if (!cell2) {
            throw RangeError(`No cell with offset ${pos} found`);
          }
          const extraLeft = rect.left - cellRect.left;
          const extraRight = cellRect.right - rect.right;
          if (extraLeft > 0 || extraRight > 0) {
            let attrs = cell2.attrs;
            if (extraLeft > 0) {
              attrs = removeColSpan(attrs, 0, extraLeft);
            }
            if (extraRight > 0) {
              attrs = removeColSpan(
                attrs,
                attrs.colspan - extraRight,
                extraRight
              );
            }
            if (cellRect.left < rect.left) {
              cell2 = cell2.type.createAndFill(attrs);
              if (!cell2) {
                throw RangeError(
                  `Could not create cell with attrs ${JSON.stringify(attrs)}`
                );
              }
            } else {
              cell2 = cell2.type.create(attrs, cell2.content);
            }
          }
          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
            const attrs = {
              ...cell2.attrs,
              rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
            };
            if (cellRect.top < rect.top) {
              cell2 = cell2.type.createAndFill(attrs);
            } else {
              cell2 = cell2.type.create(attrs, cell2.content);
            }
          }
          rowContent.push(cell2);
        }
        rows.push(table3.child(row2).copy(Fragment.from(rowContent)));
      }
      const fragment2 = this.isColSelection() && this.isRowSelection() ? table3 : rows;
      return new Slice(Fragment.from(fragment2), 1, 1);
    }
    replace(tr3, content5 = Slice.empty) {
      const mapFrom = tr3.steps.length, ranges = this.ranges;
      for (let i = 0; i < ranges.length; i++) {
        const { $from, $to } = ranges[i], mapping = tr3.mapping.slice(mapFrom);
        tr3.replace(
          mapping.map($from.pos),
          mapping.map($to.pos),
          i ? Slice.empty : content5
        );
      }
      const sel = Selection.findFrom(
        tr3.doc.resolve(tr3.mapping.slice(mapFrom).map(this.to)),
        -1
      );
      if (sel) tr3.setSelection(sel);
    }
    replaceWith(tr3, node2) {
      this.replace(tr3, new Slice(Fragment.from(node2), 0, 0));
    }
    forEachCell(f) {
      const table3 = this.$anchorCell.node(-1);
      const map9 = TableMap.get(table3);
      const tableStart = this.$anchorCell.start(-1);
      const cells2 = map9.cellsInRect(
        map9.rectBetween(
          this.$anchorCell.pos - tableStart,
          this.$headCell.pos - tableStart
        )
      );
      for (let i = 0; i < cells2.length; i++) {
        f(table3.nodeAt(cells2[i]), tableStart + cells2[i]);
      }
    }
    // True if this selection goes all the way from the top to the
    // bottom of the table.
    isColSelection() {
      const anchorTop = this.$anchorCell.index(-1);
      const headTop = this.$headCell.index(-1);
      if (Math.min(anchorTop, headTop) > 0) return false;
      const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
      const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
      return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
    }
    // Returns the smallest column selection that covers the given anchor
    // and head cell.
    static colSelection($anchorCell, $headCell = $anchorCell) {
      const table3 = $anchorCell.node(-1);
      const map9 = TableMap.get(table3);
      const tableStart = $anchorCell.start(-1);
      const anchorRect = map9.findCell($anchorCell.pos - tableStart);
      const headRect = map9.findCell($headCell.pos - tableStart);
      const doc4 = $anchorCell.node(0);
      if (anchorRect.top <= headRect.top) {
        if (anchorRect.top > 0)
          $anchorCell = doc4.resolve(tableStart + map9.map[anchorRect.left]);
        if (headRect.bottom < map9.height)
          $headCell = doc4.resolve(
            tableStart + map9.map[map9.width * (map9.height - 1) + headRect.right - 1]
          );
      } else {
        if (headRect.top > 0)
          $headCell = doc4.resolve(tableStart + map9.map[headRect.left]);
        if (anchorRect.bottom < map9.height)
          $anchorCell = doc4.resolve(
            tableStart + map9.map[map9.width * (map9.height - 1) + anchorRect.right - 1]
          );
      }
      return new _CellSelection($anchorCell, $headCell);
    }
    // True if this selection goes all the way from the left to the
    // right of the table.
    isRowSelection() {
      const table3 = this.$anchorCell.node(-1);
      const map9 = TableMap.get(table3);
      const tableStart = this.$anchorCell.start(-1);
      const anchorLeft = map9.colCount(this.$anchorCell.pos - tableStart);
      const headLeft = map9.colCount(this.$headCell.pos - tableStart);
      if (Math.min(anchorLeft, headLeft) > 0) return false;
      const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
      const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
      return Math.max(anchorRight, headRight) == map9.width;
    }
    eq(other) {
      return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
    }
    // Returns the smallest row selection that covers the given anchor
    // and head cell.
    static rowSelection($anchorCell, $headCell = $anchorCell) {
      const table3 = $anchorCell.node(-1);
      const map9 = TableMap.get(table3);
      const tableStart = $anchorCell.start(-1);
      const anchorRect = map9.findCell($anchorCell.pos - tableStart);
      const headRect = map9.findCell($headCell.pos - tableStart);
      const doc4 = $anchorCell.node(0);
      if (anchorRect.left <= headRect.left) {
        if (anchorRect.left > 0)
          $anchorCell = doc4.resolve(
            tableStart + map9.map[anchorRect.top * map9.width]
          );
        if (headRect.right < map9.width)
          $headCell = doc4.resolve(
            tableStart + map9.map[map9.width * (headRect.top + 1) - 1]
          );
      } else {
        if (headRect.left > 0)
          $headCell = doc4.resolve(tableStart + map9.map[headRect.top * map9.width]);
        if (anchorRect.right < map9.width)
          $anchorCell = doc4.resolve(
            tableStart + map9.map[map9.width * (anchorRect.top + 1) - 1]
          );
      }
      return new _CellSelection($anchorCell, $headCell);
    }
    toJSON() {
      return {
        type: "cell",
        anchor: this.$anchorCell.pos,
        head: this.$headCell.pos
      };
    }
    static fromJSON(doc4, json) {
      return new _CellSelection(doc4.resolve(json.anchor), doc4.resolve(json.head));
    }
    static create(doc4, anchorCell, headCell = anchorCell) {
      return new _CellSelection(doc4.resolve(anchorCell), doc4.resolve(headCell));
    }
    getBookmark() {
      return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
    }
  };
  CellSelection.prototype.visible = false;
  Selection.jsonID("cell", CellSelection);
  var CellBookmark = class _CellBookmark {
    constructor(anchor, head2) {
      this.anchor = anchor;
      this.head = head2;
    }
    map(mapping) {
      return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
    resolve(doc4) {
      const $anchorCell = doc4.resolve(this.anchor), $headCell = doc4.resolve(this.head);
      if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
        return new CellSelection($anchorCell, $headCell);
      else return Selection.near($headCell, 1);
    }
  };
  function drawCellSelection(state) {
    if (!(state.selection instanceof CellSelection)) return null;
    const cells2 = [];
    state.selection.forEachCell((node2, pos) => {
      cells2.push(
        Decoration.node(pos, pos + node2.nodeSize, { class: "selectedCell" })
      );
    });
    return DecorationSet.create(state.doc, cells2);
  }
  function isCellBoundarySelection({ $from, $to }) {
    if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;
    let afterFrom = $from.pos;
    let beforeTo = $to.pos;
    let depth = $from.depth;
    for (; depth >= 0; depth--, afterFrom++)
      if ($from.after(depth + 1) < $from.end(depth)) break;
    for (let d = $to.depth; d >= 0; d--, beforeTo--)
      if ($to.before(d + 1) > $to.start(d)) break;
    return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
  }
  function isTextSelectionAcrossCells({ $from, $to }) {
    let fromCellBoundaryNode;
    let toCellBoundaryNode;
    for (let i = $from.depth; i > 0; i--) {
      const node2 = $from.node(i);
      if (node2.type.spec.tableRole === "cell" || node2.type.spec.tableRole === "header_cell") {
        fromCellBoundaryNode = node2;
        break;
      }
    }
    for (let i = $to.depth; i > 0; i--) {
      const node2 = $to.node(i);
      if (node2.type.spec.tableRole === "cell" || node2.type.spec.tableRole === "header_cell") {
        toCellBoundaryNode = node2;
        break;
      }
    }
    return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
  }
  function normalizeSelection(state, tr3, allowTableNodeSelection) {
    const sel = (tr3 || state).selection;
    const doc4 = (tr3 || state).doc;
    let normalize4;
    let role;
    if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
      if (role == "cell" || role == "header_cell") {
        normalize4 = CellSelection.create(doc4, sel.from);
      } else if (role == "row") {
        const $cell = doc4.resolve(sel.from + 1);
        normalize4 = CellSelection.rowSelection($cell, $cell);
      } else if (!allowTableNodeSelection) {
        const map9 = TableMap.get(sel.node);
        const start = sel.from + 1;
        const lastCell = start + map9.map[map9.width * map9.height - 1];
        normalize4 = CellSelection.create(doc4, start + 1, lastCell);
      }
    } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
      normalize4 = TextSelection.create(doc4, sel.from);
    } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
      normalize4 = TextSelection.create(doc4, sel.$from.start(), sel.$from.end());
    }
    if (normalize4) (tr3 || (tr3 = state.tr)).setSelection(normalize4);
    return tr3;
  }
  var fixTablesKey = new PluginKey("fix-tables");
  function changedDescendants(old, cur, offset, f) {
    const oldSize = old.childCount, curSize = cur.childCount;
    outer: for (let i = 0, j2 = 0; i < curSize; i++) {
      const child = cur.child(i);
      for (let scan = j2, e = Math.min(oldSize, i + 3); scan < e; scan++) {
        if (old.child(scan) == child) {
          j2 = scan + 1;
          offset += child.nodeSize;
          continue outer;
        }
      }
      f(child, offset);
      if (j2 < oldSize && old.child(j2).sameMarkup(child))
        changedDescendants(old.child(j2), child, offset + 1, f);
      else child.nodesBetween(0, child.content.size, f, offset + 1);
      offset += child.nodeSize;
    }
  }
  function fixTables(state, oldState) {
    let tr3;
    const check = (node2, pos) => {
      if (node2.type.spec.tableRole == "table")
        tr3 = fixTable(state, node2, pos, tr3);
    };
    if (!oldState) state.doc.descendants(check);
    else if (oldState.doc != state.doc)
      changedDescendants(oldState.doc, state.doc, 0, check);
    return tr3;
  }
  function fixTable(state, table3, tablePos, tr3) {
    const map9 = TableMap.get(table3);
    if (!map9.problems) return tr3;
    if (!tr3) tr3 = state.tr;
    const mustAdd = [];
    for (let i = 0; i < map9.height; i++) mustAdd.push(0);
    for (let i = 0; i < map9.problems.length; i++) {
      const prob = map9.problems[i];
      if (prob.type == "collision") {
        const cell2 = table3.nodeAt(prob.pos);
        if (!cell2) continue;
        const attrs = cell2.attrs;
        for (let j2 = 0; j2 < attrs.rowspan; j2++) mustAdd[prob.row + j2] += prob.n;
        tr3.setNodeMarkup(
          tr3.mapping.map(tablePos + 1 + prob.pos),
          null,
          removeColSpan(attrs, attrs.colspan - prob.n, prob.n)
        );
      } else if (prob.type == "missing") {
        mustAdd[prob.row] += prob.n;
      } else if (prob.type == "overlong_rowspan") {
        const cell2 = table3.nodeAt(prob.pos);
        if (!cell2) continue;
        tr3.setNodeMarkup(tr3.mapping.map(tablePos + 1 + prob.pos), null, {
          ...cell2.attrs,
          rowspan: cell2.attrs.rowspan - prob.n
        });
      } else if (prob.type == "colwidth mismatch") {
        const cell2 = table3.nodeAt(prob.pos);
        if (!cell2) continue;
        tr3.setNodeMarkup(tr3.mapping.map(tablePos + 1 + prob.pos), null, {
          ...cell2.attrs,
          colwidth: prob.colwidth
        });
      } else if (prob.type == "zero_sized") {
        const pos = tr3.mapping.map(tablePos);
        tr3.delete(pos, pos + table3.nodeSize);
      }
    }
    let first3, last2;
    for (let i = 0; i < mustAdd.length; i++)
      if (mustAdd[i]) {
        if (first3 == null) first3 = i;
        last2 = i;
      }
    for (let i = 0, pos = tablePos + 1; i < map9.height; i++) {
      const row2 = table3.child(i);
      const end = pos + row2.nodeSize;
      const add3 = mustAdd[i];
      if (add3 > 0) {
        let role = "cell";
        if (row2.firstChild) {
          role = row2.firstChild.type.spec.tableRole;
        }
        const nodes = [];
        for (let j2 = 0; j2 < add3; j2++) {
          const node2 = tableNodeTypes(state.schema)[role].createAndFill();
          if (node2) nodes.push(node2);
        }
        const side = (i == 0 || first3 == i - 1) && last2 == i ? pos + 1 : end - 1;
        tr3.insert(tr3.mapping.map(side), nodes);
      }
      pos = end;
    }
    return tr3.setMeta(fixTablesKey, { fixTables: true });
  }
  function selectedRect(state) {
    const sel = state.selection;
    const $pos = selectionCell(state);
    const table3 = $pos.node(-1);
    const tableStart = $pos.start(-1);
    const map9 = TableMap.get(table3);
    const rect = sel instanceof CellSelection ? map9.rectBetween(
      sel.$anchorCell.pos - tableStart,
      sel.$headCell.pos - tableStart
    ) : map9.findCell($pos.pos - tableStart);
    return { ...rect, tableStart, map: map9, table: table3 };
  }
  function addColumn(tr3, { map: map9, tableStart, table: table3 }, col) {
    let refColumn = col > 0 ? -1 : 0;
    if (columnIsHeader(map9, table3, col + refColumn)) {
      refColumn = col == 0 || col == map9.width ? null : 0;
    }
    for (let row2 = 0; row2 < map9.height; row2++) {
      const index3 = row2 * map9.width + col;
      if (col > 0 && col < map9.width && map9.map[index3 - 1] == map9.map[index3]) {
        const pos = map9.map[index3];
        const cell2 = table3.nodeAt(pos);
        tr3.setNodeMarkup(
          tr3.mapping.map(tableStart + pos),
          null,
          addColSpan(cell2.attrs, col - map9.colCount(pos))
        );
        row2 += cell2.attrs.rowspan - 1;
      } else {
        const type = refColumn == null ? tableNodeTypes(table3.type.schema).cell : table3.nodeAt(map9.map[index3 + refColumn]).type;
        const pos = map9.positionAt(row2, col, table3);
        tr3.insert(tr3.mapping.map(tableStart + pos), type.createAndFill());
      }
    }
    return tr3;
  }
  function addColumnBefore(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const rect = selectedRect(state);
      dispatch(addColumn(state.tr, rect, rect.left));
    }
    return true;
  }
  function addColumnAfter(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const rect = selectedRect(state);
      dispatch(addColumn(state.tr, rect, rect.right));
    }
    return true;
  }
  function removeColumn(tr3, { map: map9, table: table3, tableStart }, col) {
    const mapStart = tr3.mapping.maps.length;
    for (let row2 = 0; row2 < map9.height; ) {
      const index3 = row2 * map9.width + col;
      const pos = map9.map[index3];
      const cell2 = table3.nodeAt(pos);
      const attrs = cell2.attrs;
      if (col > 0 && map9.map[index3 - 1] == pos || col < map9.width - 1 && map9.map[index3 + 1] == pos) {
        tr3.setNodeMarkup(
          tr3.mapping.slice(mapStart).map(tableStart + pos),
          null,
          removeColSpan(attrs, col - map9.colCount(pos))
        );
      } else {
        const start = tr3.mapping.slice(mapStart).map(tableStart + pos);
        tr3.delete(start, start + cell2.nodeSize);
      }
      row2 += attrs.rowspan;
    }
  }
  function deleteColumn(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const rect = selectedRect(state);
      const tr3 = state.tr;
      if (rect.left == 0 && rect.right == rect.map.width) return false;
      for (let i = rect.right - 1; ; i--) {
        removeColumn(tr3, rect, i);
        if (i == rect.left) break;
        const table3 = rect.tableStart ? tr3.doc.nodeAt(rect.tableStart - 1) : tr3.doc;
        if (!table3) {
          throw RangeError("No table found");
        }
        rect.table = table3;
        rect.map = TableMap.get(table3);
      }
      dispatch(tr3);
    }
    return true;
  }
  function rowIsHeader(map9, table3, row2) {
    var _a3;
    const headerCell = tableNodeTypes(table3.type.schema).header_cell;
    for (let col = 0; col < map9.width; col++)
      if (((_a3 = table3.nodeAt(map9.map[col + row2 * map9.width])) == null ? void 0 : _a3.type) != headerCell)
        return false;
    return true;
  }
  function addRow(tr3, { map: map9, tableStart, table: table3 }, row2) {
    var _a3;
    let rowPos = tableStart;
    for (let i = 0; i < row2; i++) rowPos += table3.child(i).nodeSize;
    const cells2 = [];
    let refRow = row2 > 0 ? -1 : 0;
    if (rowIsHeader(map9, table3, row2 + refRow))
      refRow = row2 == 0 || row2 == map9.height ? null : 0;
    for (let col = 0, index3 = map9.width * row2; col < map9.width; col++, index3++) {
      if (row2 > 0 && row2 < map9.height && map9.map[index3] == map9.map[index3 - map9.width]) {
        const pos = map9.map[index3];
        const attrs = table3.nodeAt(pos).attrs;
        tr3.setNodeMarkup(tableStart + pos, null, {
          ...attrs,
          rowspan: attrs.rowspan + 1
        });
        col += attrs.colspan - 1;
      } else {
        const type = refRow == null ? tableNodeTypes(table3.type.schema).cell : (_a3 = table3.nodeAt(map9.map[index3 + refRow * map9.width])) == null ? void 0 : _a3.type;
        const node2 = type == null ? void 0 : type.createAndFill();
        if (node2) cells2.push(node2);
      }
    }
    tr3.insert(rowPos, tableNodeTypes(table3.type.schema).row.create(null, cells2));
    return tr3;
  }
  function addRowBefore(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const rect = selectedRect(state);
      dispatch(addRow(state.tr, rect, rect.top));
    }
    return true;
  }
  function addRowAfter(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const rect = selectedRect(state);
      dispatch(addRow(state.tr, rect, rect.bottom));
    }
    return true;
  }
  function removeRow(tr3, { map: map9, table: table3, tableStart }, row2) {
    let rowPos = 0;
    for (let i = 0; i < row2; i++) rowPos += table3.child(i).nodeSize;
    const nextRow = rowPos + table3.child(row2).nodeSize;
    const mapFrom = tr3.mapping.maps.length;
    tr3.delete(rowPos + tableStart, nextRow + tableStart);
    const seen = /* @__PURE__ */ new Set();
    for (let col = 0, index3 = row2 * map9.width; col < map9.width; col++, index3++) {
      const pos = map9.map[index3];
      if (seen.has(pos)) continue;
      seen.add(pos);
      if (row2 > 0 && pos == map9.map[index3 - map9.width]) {
        const attrs = table3.nodeAt(pos).attrs;
        tr3.setNodeMarkup(tr3.mapping.slice(mapFrom).map(pos + tableStart), null, {
          ...attrs,
          rowspan: attrs.rowspan - 1
        });
        col += attrs.colspan - 1;
      } else if (row2 < map9.height && pos == map9.map[index3 + map9.width]) {
        const cell2 = table3.nodeAt(pos);
        const attrs = cell2.attrs;
        const copy4 = cell2.type.create(
          { ...attrs, rowspan: cell2.attrs.rowspan - 1 },
          cell2.content
        );
        const newPos = map9.positionAt(row2 + 1, col, table3);
        tr3.insert(tr3.mapping.slice(mapFrom).map(tableStart + newPos), copy4);
        col += attrs.colspan - 1;
      }
    }
  }
  function deleteRow(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const rect = selectedRect(state), tr3 = state.tr;
      if (rect.top == 0 && rect.bottom == rect.map.height) return false;
      for (let i = rect.bottom - 1; ; i--) {
        removeRow(tr3, rect, i);
        if (i == rect.top) break;
        const table3 = rect.tableStart ? tr3.doc.nodeAt(rect.tableStart - 1) : tr3.doc;
        if (!table3) {
          throw RangeError("No table found");
        }
        rect.table = table3;
        rect.map = TableMap.get(rect.table);
      }
      dispatch(tr3);
    }
    return true;
  }
  function isEmpty(cell2) {
    const c = cell2.content;
    return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;
  }
  function cellsOverlapRectangle({ width, height, map: map9 }, rect) {
    let indexTop = rect.top * width + rect.left, indexLeft = indexTop;
    let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
    for (let i = rect.top; i < rect.bottom; i++) {
      if (rect.left > 0 && map9[indexLeft] == map9[indexLeft - 1] || rect.right < width && map9[indexRight] == map9[indexRight + 1])
        return true;
      indexLeft += width;
      indexRight += width;
    }
    for (let i = rect.left; i < rect.right; i++) {
      if (rect.top > 0 && map9[indexTop] == map9[indexTop - width] || rect.bottom < height && map9[indexBottom] == map9[indexBottom + width])
        return true;
      indexTop++;
      indexBottom++;
    }
    return false;
  }
  function mergeCells(state, dispatch) {
    const sel = state.selection;
    if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)
      return false;
    const rect = selectedRect(state), { map: map9 } = rect;
    if (cellsOverlapRectangle(map9, rect)) return false;
    if (dispatch) {
      const tr3 = state.tr;
      const seen = {};
      let content5 = Fragment.empty;
      let mergedPos;
      let mergedCell;
      for (let row2 = rect.top; row2 < rect.bottom; row2++) {
        for (let col = rect.left; col < rect.right; col++) {
          const cellPos = map9.map[row2 * map9.width + col];
          const cell2 = rect.table.nodeAt(cellPos);
          if (seen[cellPos] || !cell2) continue;
          seen[cellPos] = true;
          if (mergedPos == null) {
            mergedPos = cellPos;
            mergedCell = cell2;
          } else {
            if (!isEmpty(cell2)) content5 = content5.append(cell2.content);
            const mapped = tr3.mapping.map(cellPos + rect.tableStart);
            tr3.delete(mapped, mapped + cell2.nodeSize);
          }
        }
      }
      if (mergedPos == null || mergedCell == null) {
        return true;
      }
      tr3.setNodeMarkup(mergedPos + rect.tableStart, null, {
        ...addColSpan(
          mergedCell.attrs,
          mergedCell.attrs.colspan,
          rect.right - rect.left - mergedCell.attrs.colspan
        ),
        rowspan: rect.bottom - rect.top
      });
      if (content5.size) {
        const end = mergedPos + 1 + mergedCell.content.size;
        const start = isEmpty(mergedCell) ? mergedPos + 1 : end;
        tr3.replaceWith(start + rect.tableStart, end + rect.tableStart, content5);
      }
      tr3.setSelection(
        new CellSelection(tr3.doc.resolve(mergedPos + rect.tableStart))
      );
      dispatch(tr3);
    }
    return true;
  }
  function splitCell(state, dispatch) {
    const nodeTypes = tableNodeTypes(state.schema);
    return splitCellWithType(({ node: node2 }) => {
      return nodeTypes[node2.type.spec.tableRole];
    })(state, dispatch);
  }
  function splitCellWithType(getCellType) {
    return (state, dispatch) => {
      var _a3;
      const sel = state.selection;
      let cellNode;
      let cellPos;
      if (!(sel instanceof CellSelection)) {
        cellNode = cellWrapping(sel.$from);
        if (!cellNode) return false;
        cellPos = (_a3 = cellAround(sel.$from)) == null ? void 0 : _a3.pos;
      } else {
        if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
        cellNode = sel.$anchorCell.nodeAfter;
        cellPos = sel.$anchorCell.pos;
      }
      if (cellNode == null || cellPos == null) {
        return false;
      }
      if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
        return false;
      }
      if (dispatch) {
        let baseAttrs = cellNode.attrs;
        const attrs = [];
        const colwidth = baseAttrs.colwidth;
        if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };
        if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };
        const rect = selectedRect(state), tr3 = state.tr;
        for (let i = 0; i < rect.right - rect.left; i++)
          attrs.push(
            colwidth ? {
              ...baseAttrs,
              colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null
            } : baseAttrs
          );
        let lastCell;
        for (let row2 = rect.top; row2 < rect.bottom; row2++) {
          let pos = rect.map.positionAt(row2, rect.left, rect.table);
          if (row2 == rect.top) pos += cellNode.nodeSize;
          for (let col = rect.left, i = 0; col < rect.right; col++, i++) {
            if (col == rect.left && row2 == rect.top) continue;
            tr3.insert(
              lastCell = tr3.mapping.map(pos + rect.tableStart, 1),
              getCellType({ node: cellNode, row: row2, col }).createAndFill(attrs[i])
            );
          }
        }
        tr3.setNodeMarkup(
          cellPos,
          getCellType({ node: cellNode, row: rect.top, col: rect.left }),
          attrs[0]
        );
        if (sel instanceof CellSelection)
          tr3.setSelection(
            new CellSelection(
              tr3.doc.resolve(sel.$anchorCell.pos),
              lastCell ? tr3.doc.resolve(lastCell) : void 0
            )
          );
        dispatch(tr3);
      }
      return true;
    };
  }
  function setCellAttr(name, value) {
    return function(state, dispatch) {
      if (!isInTable(state)) return false;
      const $cell = selectionCell(state);
      if ($cell.nodeAfter.attrs[name] === value) return false;
      if (dispatch) {
        const tr3 = state.tr;
        if (state.selection instanceof CellSelection)
          state.selection.forEachCell((node2, pos) => {
            if (node2.attrs[name] !== value)
              tr3.setNodeMarkup(pos, null, {
                ...node2.attrs,
                [name]: value
              });
          });
        else
          tr3.setNodeMarkup($cell.pos, null, {
            ...$cell.nodeAfter.attrs,
            [name]: value
          });
        dispatch(tr3);
      }
      return true;
    };
  }
  function deprecated_toggleHeader(type) {
    return function(state, dispatch) {
      if (!isInTable(state)) return false;
      if (dispatch) {
        const types = tableNodeTypes(state.schema);
        const rect = selectedRect(state), tr3 = state.tr;
        const cells2 = rect.map.cellsInRect(
          type == "column" ? {
            left: rect.left,
            top: 0,
            right: rect.right,
            bottom: rect.map.height
          } : type == "row" ? {
            left: 0,
            top: rect.top,
            right: rect.map.width,
            bottom: rect.bottom
          } : rect
        );
        const nodes = cells2.map((pos) => rect.table.nodeAt(pos));
        for (let i = 0; i < cells2.length; i++)
          if (nodes[i].type == types.header_cell)
            tr3.setNodeMarkup(
              rect.tableStart + cells2[i],
              types.cell,
              nodes[i].attrs
            );
        if (tr3.steps.length == 0)
          for (let i = 0; i < cells2.length; i++)
            tr3.setNodeMarkup(
              rect.tableStart + cells2[i],
              types.header_cell,
              nodes[i].attrs
            );
        dispatch(tr3);
      }
      return true;
    };
  }
  function isHeaderEnabledByType(type, rect, types) {
    const cellPositions = rect.map.cellsInRect({
      left: 0,
      top: 0,
      right: type == "row" ? rect.map.width : 1,
      bottom: type == "column" ? rect.map.height : 1
    });
    for (let i = 0; i < cellPositions.length; i++) {
      const cell2 = rect.table.nodeAt(cellPositions[i]);
      if (cell2 && cell2.type !== types.header_cell) {
        return false;
      }
    }
    return true;
  }
  function toggleHeader(type, options2) {
    options2 = options2 || { useDeprecatedLogic: false };
    if (options2.useDeprecatedLogic) return deprecated_toggleHeader(type);
    return function(state, dispatch) {
      if (!isInTable(state)) return false;
      if (dispatch) {
        const types = tableNodeTypes(state.schema);
        const rect = selectedRect(state), tr3 = state.tr;
        const isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
        const isHeaderColumnEnabled = isHeaderEnabledByType(
          "column",
          rect,
          types
        );
        const isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
        const selectionStartsAt = isHeaderEnabled ? 1 : 0;
        const cellsRect = type == "column" ? {
          left: 0,
          top: selectionStartsAt,
          right: 1,
          bottom: rect.map.height
        } : type == "row" ? {
          left: selectionStartsAt,
          top: 0,
          right: rect.map.width,
          bottom: 1
        } : rect;
        const newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
        rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
          const cellPos = relativeCellPos + rect.tableStart;
          const cell2 = tr3.doc.nodeAt(cellPos);
          if (cell2) {
            tr3.setNodeMarkup(cellPos, newType, cell2.attrs);
          }
        });
        dispatch(tr3);
      }
      return true;
    };
  }
  var toggleHeaderRow = toggleHeader("row", {
    useDeprecatedLogic: true
  });
  var toggleHeaderColumn = toggleHeader("column", {
    useDeprecatedLogic: true
  });
  var toggleHeaderCell = toggleHeader("cell", {
    useDeprecatedLogic: true
  });
  function findNextCell($cell, dir) {
    if (dir < 0) {
      const before = $cell.nodeBefore;
      if (before) return $cell.pos - before.nodeSize;
      for (let row2 = $cell.index(-1) - 1, rowEnd = $cell.before(); row2 >= 0; row2--) {
        const rowNode = $cell.node(-1).child(row2);
        const lastChild = rowNode.lastChild;
        if (lastChild) {
          return rowEnd - 1 - lastChild.nodeSize;
        }
        rowEnd -= rowNode.nodeSize;
      }
    } else {
      if ($cell.index() < $cell.parent.childCount - 1) {
        return $cell.pos + $cell.nodeAfter.nodeSize;
      }
      const table3 = $cell.node(-1);
      for (let row2 = $cell.indexAfter(-1), rowStart = $cell.after(); row2 < table3.childCount; row2++) {
        const rowNode = table3.child(row2);
        if (rowNode.childCount) return rowStart + 1;
        rowStart += rowNode.nodeSize;
      }
    }
    return null;
  }
  function goToNextCell(direction) {
    return function(state, dispatch) {
      if (!isInTable(state)) return false;
      const cell2 = findNextCell(selectionCell(state), direction);
      if (cell2 == null) return false;
      if (dispatch) {
        const $cell = state.doc.resolve(cell2);
        dispatch(
          state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView()
        );
      }
      return true;
    };
  }
  function deleteTable(state, dispatch) {
    const $pos = state.selection.$anchor;
    for (let d = $pos.depth; d > 0; d--) {
      const node2 = $pos.node(d);
      if (node2.type.spec.tableRole == "table") {
        if (dispatch)
          dispatch(
            state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()
          );
        return true;
      }
    }
    return false;
  }
  function deleteCellSelection(state, dispatch) {
    const sel = state.selection;
    if (!(sel instanceof CellSelection)) return false;
    if (dispatch) {
      const tr3 = state.tr;
      const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
      sel.forEachCell((cell2, pos) => {
        if (!cell2.content.eq(baseContent))
          tr3.replace(
            tr3.mapping.map(pos + 1),
            tr3.mapping.map(pos + cell2.nodeSize - 1),
            new Slice(baseContent, 0, 0)
          );
      });
      if (tr3.docChanged) dispatch(tr3);
    }
    return true;
  }
  function pastedCells(slice2) {
    if (!slice2.size) return null;
    let { content: content5, openStart, openEnd } = slice2;
    while (content5.childCount == 1 && (openStart > 0 && openEnd > 0 || content5.child(0).type.spec.tableRole == "table")) {
      openStart--;
      openEnd--;
      content5 = content5.child(0).content;
    }
    const first3 = content5.child(0);
    const role = first3.type.spec.tableRole;
    const schema = first3.type.schema, rows = [];
    if (role == "row") {
      for (let i = 0; i < content5.childCount; i++) {
        let cells2 = content5.child(i).content;
        const left = i ? 0 : Math.max(0, openStart - 1);
        const right = i < content5.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
        if (left || right)
          cells2 = fitSlice(
            tableNodeTypes(schema).row,
            new Slice(cells2, left, right)
          ).content;
        rows.push(cells2);
      }
    } else if (role == "cell" || role == "header_cell") {
      rows.push(
        openStart || openEnd ? fitSlice(
          tableNodeTypes(schema).row,
          new Slice(content5, openStart, openEnd)
        ).content : content5
      );
    } else {
      return null;
    }
    return ensureRectangular(schema, rows);
  }
  function ensureRectangular(schema, rows) {
    const widths = [];
    for (let i = 0; i < rows.length; i++) {
      const row2 = rows[i];
      for (let j2 = row2.childCount - 1; j2 >= 0; j2--) {
        const { rowspan, colspan } = row2.child(j2).attrs;
        for (let r = i; r < i + rowspan; r++)
          widths[r] = (widths[r] || 0) + colspan;
      }
    }
    let width = 0;
    for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);
    for (let r = 0; r < widths.length; r++) {
      if (r >= rows.length) rows.push(Fragment.empty);
      if (widths[r] < width) {
        const empty4 = tableNodeTypes(schema).cell.createAndFill();
        const cells2 = [];
        for (let i = widths[r]; i < width; i++) {
          cells2.push(empty4);
        }
        rows[r] = rows[r].append(Fragment.from(cells2));
      }
    }
    return { height: rows.length, width, rows };
  }
  function fitSlice(nodeType, slice2) {
    const node2 = nodeType.createAndFill();
    const tr3 = new Transform(node2).replace(0, node2.content.size, slice2);
    return tr3.doc;
  }
  function clipCells({ width, height, rows }, newWidth, newHeight) {
    if (width != newWidth) {
      const added = [];
      const newRows = [];
      for (let row2 = 0; row2 < rows.length; row2++) {
        const frag = rows[row2], cells2 = [];
        for (let col = added[row2] || 0, i = 0; col < newWidth; i++) {
          let cell2 = frag.child(i % frag.childCount);
          if (col + cell2.attrs.colspan > newWidth)
            cell2 = cell2.type.createChecked(
              removeColSpan(
                cell2.attrs,
                cell2.attrs.colspan,
                col + cell2.attrs.colspan - newWidth
              ),
              cell2.content
            );
          cells2.push(cell2);
          col += cell2.attrs.colspan;
          for (let j2 = 1; j2 < cell2.attrs.rowspan; j2++)
            added[row2 + j2] = (added[row2 + j2] || 0) + cell2.attrs.colspan;
        }
        newRows.push(Fragment.from(cells2));
      }
      rows = newRows;
      width = newWidth;
    }
    if (height != newHeight) {
      const newRows = [];
      for (let row2 = 0, i = 0; row2 < newHeight; row2++, i++) {
        const cells2 = [], source = rows[i % height];
        for (let j2 = 0; j2 < source.childCount; j2++) {
          let cell2 = source.child(j2);
          if (row2 + cell2.attrs.rowspan > newHeight)
            cell2 = cell2.type.create(
              {
                ...cell2.attrs,
                rowspan: Math.max(1, newHeight - cell2.attrs.rowspan)
              },
              cell2.content
            );
          cells2.push(cell2);
        }
        newRows.push(Fragment.from(cells2));
      }
      rows = newRows;
      height = newHeight;
    }
    return { width, height, rows };
  }
  function growTable(tr3, map9, table3, start, width, height, mapFrom) {
    const schema = tr3.doc.type.schema;
    const types = tableNodeTypes(schema);
    let empty4;
    let emptyHead;
    if (width > map9.width) {
      for (let row2 = 0, rowEnd = 0; row2 < map9.height; row2++) {
        const rowNode = table3.child(row2);
        rowEnd += rowNode.nodeSize;
        const cells2 = [];
        let add3;
        if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)
          add3 = empty4 || (empty4 = types.cell.createAndFill());
        else add3 = emptyHead || (emptyHead = types.header_cell.createAndFill());
        for (let i = map9.width; i < width; i++) cells2.push(add3);
        tr3.insert(tr3.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells2);
      }
    }
    if (height > map9.height) {
      const cells2 = [];
      for (let i = 0, start2 = (map9.height - 1) * map9.width; i < Math.max(map9.width, width); i++) {
        const header = i >= map9.width ? false : table3.nodeAt(map9.map[start2 + i]).type == types.header_cell;
        cells2.push(
          header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty4 || (empty4 = types.cell.createAndFill())
        );
      }
      const emptyRow = types.row.create(null, Fragment.from(cells2)), rows = [];
      for (let i = map9.height; i < height; i++) rows.push(emptyRow);
      tr3.insert(tr3.mapping.slice(mapFrom).map(start + table3.nodeSize - 2), rows);
    }
    return !!(empty4 || emptyHead);
  }
  function isolateHorizontal(tr3, map9, table3, start, left, right, top, mapFrom) {
    if (top == 0 || top == map9.height) return false;
    let found2 = false;
    for (let col = left; col < right; col++) {
      const index3 = top * map9.width + col, pos = map9.map[index3];
      if (map9.map[index3 - map9.width] == pos) {
        found2 = true;
        const cell2 = table3.nodeAt(pos);
        const { top: cellTop, left: cellLeft } = map9.findCell(pos);
        tr3.setNodeMarkup(tr3.mapping.slice(mapFrom).map(pos + start), null, {
          ...cell2.attrs,
          rowspan: top - cellTop
        });
        tr3.insert(
          tr3.mapping.slice(mapFrom).map(map9.positionAt(top, cellLeft, table3)),
          cell2.type.createAndFill({
            ...cell2.attrs,
            rowspan: cellTop + cell2.attrs.rowspan - top
          })
        );
        col += cell2.attrs.colspan - 1;
      }
    }
    return found2;
  }
  function isolateVertical(tr3, map9, table3, start, top, bottom, left, mapFrom) {
    if (left == 0 || left == map9.width) return false;
    let found2 = false;
    for (let row2 = top; row2 < bottom; row2++) {
      const index3 = row2 * map9.width + left, pos = map9.map[index3];
      if (map9.map[index3 - 1] == pos) {
        found2 = true;
        const cell2 = table3.nodeAt(pos);
        const cellLeft = map9.colCount(pos);
        const updatePos = tr3.mapping.slice(mapFrom).map(pos + start);
        tr3.setNodeMarkup(
          updatePos,
          null,
          removeColSpan(
            cell2.attrs,
            left - cellLeft,
            cell2.attrs.colspan - (left - cellLeft)
          )
        );
        tr3.insert(
          updatePos + cell2.nodeSize,
          cell2.type.createAndFill(
            removeColSpan(cell2.attrs, 0, left - cellLeft)
          )
        );
        row2 += cell2.attrs.rowspan - 1;
      }
    }
    return found2;
  }
  function insertCells(state, dispatch, tableStart, rect, cells2) {
    let table3 = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;
    if (!table3) {
      throw new Error("No table found");
    }
    let map9 = TableMap.get(table3);
    const { top, left } = rect;
    const right = left + cells2.width, bottom = top + cells2.height;
    const tr3 = state.tr;
    let mapFrom = 0;
    function recomp() {
      table3 = tableStart ? tr3.doc.nodeAt(tableStart - 1) : tr3.doc;
      if (!table3) {
        throw new Error("No table found");
      }
      map9 = TableMap.get(table3);
      mapFrom = tr3.mapping.maps.length;
    }
    if (growTable(tr3, map9, table3, tableStart, right, bottom, mapFrom)) recomp();
    if (isolateHorizontal(tr3, map9, table3, tableStart, left, right, top, mapFrom))
      recomp();
    if (isolateHorizontal(tr3, map9, table3, tableStart, left, right, bottom, mapFrom))
      recomp();
    if (isolateVertical(tr3, map9, table3, tableStart, top, bottom, left, mapFrom))
      recomp();
    if (isolateVertical(tr3, map9, table3, tableStart, top, bottom, right, mapFrom))
      recomp();
    for (let row2 = top; row2 < bottom; row2++) {
      const from4 = map9.positionAt(row2, left, table3), to2 = map9.positionAt(row2, right, table3);
      tr3.replace(
        tr3.mapping.slice(mapFrom).map(from4 + tableStart),
        tr3.mapping.slice(mapFrom).map(to2 + tableStart),
        new Slice(cells2.rows[row2 - top], 0, 0)
      );
    }
    recomp();
    tr3.setSelection(
      new CellSelection(
        tr3.doc.resolve(tableStart + map9.positionAt(top, left, table3)),
        tr3.doc.resolve(tableStart + map9.positionAt(bottom - 1, right - 1, table3))
      )
    );
    dispatch(tr3);
  }
  var handleKeyDown = keydownHandler({
    ArrowLeft: arrow("horiz", -1),
    ArrowRight: arrow("horiz", 1),
    ArrowUp: arrow("vert", -1),
    ArrowDown: arrow("vert", 1),
    "Shift-ArrowLeft": shiftArrow("horiz", -1),
    "Shift-ArrowRight": shiftArrow("horiz", 1),
    "Shift-ArrowUp": shiftArrow("vert", -1),
    "Shift-ArrowDown": shiftArrow("vert", 1),
    Backspace: deleteCellSelection,
    "Mod-Backspace": deleteCellSelection,
    Delete: deleteCellSelection,
    "Mod-Delete": deleteCellSelection
  });
  function maybeSetSelection(state, dispatch, selection) {
    if (selection.eq(state.selection)) return false;
    if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());
    return true;
  }
  function arrow(axis, dir) {
    return (state, dispatch, view) => {
      if (!view) return false;
      const sel = state.selection;
      if (sel instanceof CellSelection) {
        return maybeSetSelection(
          state,
          dispatch,
          Selection.near(sel.$headCell, dir)
        );
      }
      if (axis != "horiz" && !sel.empty) return false;
      const end = atEndOfCell(view, axis, dir);
      if (end == null) return false;
      if (axis == "horiz") {
        return maybeSetSelection(
          state,
          dispatch,
          Selection.near(state.doc.resolve(sel.head + dir), dir)
        );
      } else {
        const $cell = state.doc.resolve(end);
        const $next = nextCell($cell, axis, dir);
        let newSel;
        if ($next) newSel = Selection.near($next, 1);
        else if (dir < 0)
          newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
        else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
        return maybeSetSelection(state, dispatch, newSel);
      }
    };
  }
  function shiftArrow(axis, dir) {
    return (state, dispatch, view) => {
      if (!view) return false;
      const sel = state.selection;
      let cellSel;
      if (sel instanceof CellSelection) {
        cellSel = sel;
      } else {
        const end = atEndOfCell(view, axis, dir);
        if (end == null) return false;
        cellSel = new CellSelection(state.doc.resolve(end));
      }
      const $head = nextCell(cellSel.$headCell, axis, dir);
      if (!$head) return false;
      return maybeSetSelection(
        state,
        dispatch,
        new CellSelection(cellSel.$anchorCell, $head)
      );
    };
  }
  function handleTripleClick2(view, pos) {
    const doc4 = view.state.doc, $cell = cellAround(doc4.resolve(pos));
    if (!$cell) return false;
    view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
    return true;
  }
  function handlePaste(view, _2, slice2) {
    if (!isInTable(view.state)) return false;
    let cells2 = pastedCells(slice2);
    const sel = view.state.selection;
    if (sel instanceof CellSelection) {
      if (!cells2)
        cells2 = {
          width: 1,
          height: 1,
          rows: [
            Fragment.from(
              fitSlice(tableNodeTypes(view.state.schema).cell, slice2)
            )
          ]
        };
      const table3 = sel.$anchorCell.node(-1);
      const start = sel.$anchorCell.start(-1);
      const rect = TableMap.get(table3).rectBetween(
        sel.$anchorCell.pos - start,
        sel.$headCell.pos - start
      );
      cells2 = clipCells(cells2, rect.right - rect.left, rect.bottom - rect.top);
      insertCells(view.state, view.dispatch, start, rect, cells2);
      return true;
    } else if (cells2) {
      const $cell = selectionCell(view.state);
      const start = $cell.start(-1);
      insertCells(
        view.state,
        view.dispatch,
        start,
        TableMap.get($cell.node(-1)).findCell($cell.pos - start),
        cells2
      );
      return true;
    } else {
      return false;
    }
  }
  function handleMouseDown(view, startEvent) {
    var _a3;
    if (startEvent.ctrlKey || startEvent.metaKey) return;
    const startDOMCell = domInCell(view, startEvent.target);
    let $anchor;
    if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
      setCellSelection(view.state.selection.$anchorCell, startEvent);
      startEvent.preventDefault();
    } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a3 = cellUnderMouse(view, startEvent)) == null ? void 0 : _a3.pos) != $anchor.pos) {
      setCellSelection($anchor, startEvent);
      startEvent.preventDefault();
    } else if (!startDOMCell) {
      return;
    }
    function setCellSelection($anchor2, event) {
      let $head = cellUnderMouse(view, event);
      const starting = tableEditingKey.getState(view.state) == null;
      if (!$head || !inSameTable($anchor2, $head)) {
        if (starting) $head = $anchor2;
        else return;
      }
      const selection = new CellSelection($anchor2, $head);
      if (starting || !view.state.selection.eq(selection)) {
        const tr3 = view.state.tr.setSelection(selection);
        if (starting) tr3.setMeta(tableEditingKey, $anchor2.pos);
        view.dispatch(tr3);
      }
    }
    function stop() {
      view.root.removeEventListener("mouseup", stop);
      view.root.removeEventListener("dragstart", stop);
      view.root.removeEventListener("mousemove", move);
      if (tableEditingKey.getState(view.state) != null)
        view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
    }
    function move(_event) {
      const event = _event;
      const anchor = tableEditingKey.getState(view.state);
      let $anchor2;
      if (anchor != null) {
        $anchor2 = view.state.doc.resolve(anchor);
      } else if (domInCell(view, event.target) != startDOMCell) {
        $anchor2 = cellUnderMouse(view, startEvent);
        if (!$anchor2) return stop();
      }
      if ($anchor2) setCellSelection($anchor2, event);
    }
    view.root.addEventListener("mouseup", stop);
    view.root.addEventListener("dragstart", stop);
    view.root.addEventListener("mousemove", move);
  }
  function atEndOfCell(view, axis, dir) {
    if (!(view.state.selection instanceof TextSelection)) return null;
    const { $head } = view.state.selection;
    for (let d = $head.depth - 1; d >= 0; d--) {
      const parent = $head.node(d), index3 = dir < 0 ? $head.index(d) : $head.indexAfter(d);
      if (index3 != (dir < 0 ? 0 : parent.childCount)) return null;
      if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
        const cellPos = $head.before(d);
        const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
        return view.endOfTextblock(dirStr) ? cellPos : null;
      }
    }
    return null;
  }
  function domInCell(view, dom) {
    for (; dom && dom != view.dom; dom = dom.parentNode) {
      if (dom.nodeName == "TD" || dom.nodeName == "TH") {
        return dom;
      }
    }
    return null;
  }
  function cellUnderMouse(view, event) {
    const mousePos = view.posAtCoords({
      left: event.clientX,
      top: event.clientY
    });
    if (!mousePos) return null;
    return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
  }
  var TableView = class {
    constructor(node2, defaultCellMinWidth) {
      this.node = node2;
      this.defaultCellMinWidth = defaultCellMinWidth;
      this.dom = document.createElement("div");
      this.dom.className = "tableWrapper";
      this.table = this.dom.appendChild(document.createElement("table"));
      this.table.style.setProperty(
        "--default-cell-min-width",
        `${defaultCellMinWidth}px`
      );
      this.colgroup = this.table.appendChild(document.createElement("colgroup"));
      updateColumnsOnResize(node2, this.colgroup, this.table, defaultCellMinWidth);
      this.contentDOM = this.table.appendChild(document.createElement("tbody"));
    }
    update(node2) {
      if (node2.type != this.node.type) return false;
      this.node = node2;
      updateColumnsOnResize(
        node2,
        this.colgroup,
        this.table,
        this.defaultCellMinWidth
      );
      return true;
    }
    ignoreMutation(record) {
      return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
    }
  };
  function updateColumnsOnResize(node2, colgroup2, table3, defaultCellMinWidth, overrideCol, overrideValue) {
    var _a3;
    let totalWidth = 0;
    let fixedWidth = true;
    let nextDOM = colgroup2.firstChild;
    const row2 = node2.firstChild;
    if (!row2) return;
    for (let i = 0, col = 0; i < row2.childCount; i++) {
      const { colspan, colwidth } = row2.child(i).attrs;
      for (let j2 = 0; j2 < colspan; j2++, col++) {
        const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j2];
        const cssWidth = hasWidth ? hasWidth + "px" : "";
        totalWidth += hasWidth || defaultCellMinWidth;
        if (!hasWidth) fixedWidth = false;
        if (!nextDOM) {
          const col2 = document.createElement("col");
          col2.style.width = cssWidth;
          colgroup2.appendChild(col2);
        } else {
          if (nextDOM.style.width != cssWidth) {
            nextDOM.style.width = cssWidth;
          }
          nextDOM = nextDOM.nextSibling;
        }
      }
    }
    while (nextDOM) {
      const after = nextDOM.nextSibling;
      (_a3 = nextDOM.parentNode) == null ? void 0 : _a3.removeChild(nextDOM);
      nextDOM = after;
    }
    if (fixedWidth) {
      table3.style.width = totalWidth + "px";
      table3.style.minWidth = "";
    } else {
      table3.style.width = "";
      table3.style.minWidth = totalWidth + "px";
    }
  }
  var columnResizingPluginKey = new PluginKey(
    "tableColumnResizing"
  );
  function columnResizing({
    handleWidth = 5,
    cellMinWidth = 25,
    defaultCellMinWidth = 100,
    View = TableView,
    lastColumnResizable = true
  } = {}) {
    const plugin = new Plugin({
      key: columnResizingPluginKey,
      state: {
        init(_2, state) {
          var _a3, _b;
          const nodeViews = (_b = (_a3 = plugin.spec) == null ? void 0 : _a3.props) == null ? void 0 : _b.nodeViews;
          const tableName = tableNodeTypes(state.schema).table.name;
          if (View && nodeViews) {
            nodeViews[tableName] = (node2, view) => {
              return new View(node2, defaultCellMinWidth, view);
            };
          }
          return new ResizeState(-1, false);
        },
        apply(tr3, prev) {
          return prev.apply(tr3);
        }
      },
      props: {
        attributes: (state) => {
          const pluginState = columnResizingPluginKey.getState(state);
          return pluginState && pluginState.activeHandle > -1 ? { class: "resize-cursor" } : {};
        },
        handleDOMEvents: {
          mousemove: (view, event) => {
            handleMouseMove(view, event, handleWidth, lastColumnResizable);
          },
          mouseleave: (view) => {
            handleMouseLeave(view);
          },
          mousedown: (view, event) => {
            handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);
          }
        },
        decorations: (state) => {
          const pluginState = columnResizingPluginKey.getState(state);
          if (pluginState && pluginState.activeHandle > -1) {
            return handleDecorations(state, pluginState.activeHandle);
          }
        },
        nodeViews: {}
      }
    });
    return plugin;
  }
  var ResizeState = class _ResizeState {
    constructor(activeHandle, dragging) {
      this.activeHandle = activeHandle;
      this.dragging = dragging;
    }
    apply(tr3) {
      const state = this;
      const action = tr3.getMeta(columnResizingPluginKey);
      if (action && action.setHandle != null)
        return new _ResizeState(action.setHandle, false);
      if (action && action.setDragging !== void 0)
        return new _ResizeState(state.activeHandle, action.setDragging);
      if (state.activeHandle > -1 && tr3.docChanged) {
        let handle4 = tr3.mapping.map(state.activeHandle, -1);
        if (!pointsAtCell(tr3.doc.resolve(handle4))) {
          handle4 = -1;
        }
        return new _ResizeState(handle4, state.dragging);
      }
      return state;
    }
  };
  function handleMouseMove(view, event, handleWidth, lastColumnResizable) {
    if (!view.editable) return;
    const pluginState = columnResizingPluginKey.getState(view.state);
    if (!pluginState) return;
    if (!pluginState.dragging) {
      const target = domCellAround(event.target);
      let cell2 = -1;
      if (target) {
        const { left, right } = target.getBoundingClientRect();
        if (event.clientX - left <= handleWidth)
          cell2 = edgeCell(view, event, "left", handleWidth);
        else if (right - event.clientX <= handleWidth)
          cell2 = edgeCell(view, event, "right", handleWidth);
      }
      if (cell2 != pluginState.activeHandle) {
        if (!lastColumnResizable && cell2 !== -1) {
          const $cell = view.state.doc.resolve(cell2);
          const table3 = $cell.node(-1);
          const map9 = TableMap.get(table3);
          const tableStart = $cell.start(-1);
          const col = map9.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;
          if (col == map9.width - 1) {
            return;
          }
        }
        updateHandle(view, cell2);
      }
    }
  }
  function handleMouseLeave(view) {
    if (!view.editable) return;
    const pluginState = columnResizingPluginKey.getState(view.state);
    if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)
      updateHandle(view, -1);
  }
  function handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {
    var _a3;
    if (!view.editable) return false;
    const win = (_a3 = view.dom.ownerDocument.defaultView) != null ? _a3 : window;
    const pluginState = columnResizingPluginKey.getState(view.state);
    if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)
      return false;
    const cell2 = view.state.doc.nodeAt(pluginState.activeHandle);
    const width = currentColWidth(view, pluginState.activeHandle, cell2.attrs);
    view.dispatch(
      view.state.tr.setMeta(columnResizingPluginKey, {
        setDragging: { startX: event.clientX, startWidth: width }
      })
    );
    function finish(event2) {
      win.removeEventListener("mouseup", finish);
      win.removeEventListener("mousemove", move);
      const pluginState2 = columnResizingPluginKey.getState(view.state);
      if (pluginState2 == null ? void 0 : pluginState2.dragging) {
        updateColumnWidth(
          view,
          pluginState2.activeHandle,
          draggedWidth(pluginState2.dragging, event2, cellMinWidth)
        );
        view.dispatch(
          view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })
        );
      }
    }
    function move(event2) {
      if (!event2.which) return finish(event2);
      const pluginState2 = columnResizingPluginKey.getState(view.state);
      if (!pluginState2) return;
      if (pluginState2.dragging) {
        const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
        displayColumnWidth(
          view,
          pluginState2.activeHandle,
          dragged,
          defaultCellMinWidth
        );
      }
    }
    displayColumnWidth(
      view,
      pluginState.activeHandle,
      width,
      defaultCellMinWidth
    );
    win.addEventListener("mouseup", finish);
    win.addEventListener("mousemove", move);
    event.preventDefault();
    return true;
  }
  function currentColWidth(view, cellPos, { colspan, colwidth }) {
    const width = colwidth && colwidth[colwidth.length - 1];
    if (width) return width;
    const dom = view.domAtPos(cellPos);
    const node2 = dom.node.childNodes[dom.offset];
    let domWidth = node2.offsetWidth, parts = colspan;
    if (colwidth) {
      for (let i = 0; i < colspan; i++)
        if (colwidth[i]) {
          domWidth -= colwidth[i];
          parts--;
        }
    }
    return domWidth / parts;
  }
  function domCellAround(target) {
    while (target && target.nodeName != "TD" && target.nodeName != "TH")
      target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
    return target;
  }
  function edgeCell(view, event, side, handleWidth) {
    const offset = side == "right" ? -handleWidth : handleWidth;
    const found2 = view.posAtCoords({
      left: event.clientX + offset,
      top: event.clientY
    });
    if (!found2) return -1;
    const { pos } = found2;
    const $cell = cellAround(view.state.doc.resolve(pos));
    if (!$cell) return -1;
    if (side == "right") return $cell.pos;
    const map9 = TableMap.get($cell.node(-1)), start = $cell.start(-1);
    const index3 = map9.map.indexOf($cell.pos - start);
    return index3 % map9.width == 0 ? -1 : start + map9.map[index3 - 1];
  }
  function draggedWidth(dragging, event, resizeMinWidth) {
    const offset = event.clientX - dragging.startX;
    return Math.max(resizeMinWidth, dragging.startWidth + offset);
  }
  function updateHandle(view, value) {
    view.dispatch(
      view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })
    );
  }
  function updateColumnWidth(view, cell2, width) {
    const $cell = view.state.doc.resolve(cell2);
    const table3 = $cell.node(-1), map9 = TableMap.get(table3), start = $cell.start(-1);
    const col = map9.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
    const tr3 = view.state.tr;
    for (let row2 = 0; row2 < map9.height; row2++) {
      const mapIndex = row2 * map9.width + col;
      if (row2 && map9.map[mapIndex] == map9.map[mapIndex - map9.width]) continue;
      const pos = map9.map[mapIndex];
      const attrs = table3.nodeAt(pos).attrs;
      const index3 = attrs.colspan == 1 ? 0 : col - map9.colCount(pos);
      if (attrs.colwidth && attrs.colwidth[index3] == width) continue;
      const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
      colwidth[index3] = width;
      tr3.setNodeMarkup(start + pos, null, { ...attrs, colwidth });
    }
    if (tr3.docChanged) view.dispatch(tr3);
  }
  function displayColumnWidth(view, cell2, width, defaultCellMinWidth) {
    const $cell = view.state.doc.resolve(cell2);
    const table3 = $cell.node(-1), start = $cell.start(-1);
    const col = TableMap.get(table3).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
    let dom = view.domAtPos($cell.start(-1)).node;
    while (dom && dom.nodeName != "TABLE") {
      dom = dom.parentNode;
    }
    if (!dom) return;
    updateColumnsOnResize(
      table3,
      dom.firstChild,
      dom,
      defaultCellMinWidth,
      col,
      width
    );
  }
  function zeroes(n) {
    return Array(n).fill(0);
  }
  function handleDecorations(state, cell2) {
    var _a3;
    const decorations = [];
    const $cell = state.doc.resolve(cell2);
    const table3 = $cell.node(-1);
    if (!table3) {
      return DecorationSet.empty;
    }
    const map9 = TableMap.get(table3);
    const start = $cell.start(-1);
    const col = map9.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
    for (let row2 = 0; row2 < map9.height; row2++) {
      const index3 = col + row2 * map9.width;
      if ((col == map9.width - 1 || map9.map[index3] != map9.map[index3 + 1]) && (row2 == 0 || map9.map[index3] != map9.map[index3 - map9.width])) {
        const cellPos = map9.map[index3];
        const pos = start + cellPos + table3.nodeAt(cellPos).nodeSize - 1;
        const dom = document.createElement("div");
        dom.className = "column-resize-handle";
        if ((_a3 = columnResizingPluginKey.getState(state)) == null ? void 0 : _a3.dragging) {
          decorations.push(
            Decoration.node(
              start + cellPos,
              start + cellPos + table3.nodeAt(cellPos).nodeSize,
              {
                class: "column-resize-dragging"
              }
            )
          );
        }
        decorations.push(Decoration.widget(pos, dom));
      }
    }
    return DecorationSet.create(state.doc, decorations);
  }
  function tableEditing({
    allowTableNodeSelection = false
  } = {}) {
    return new Plugin({
      key: tableEditingKey,
      // This piece of state is used to remember when a mouse-drag
      // cell-selection is happening, so that it can continue even as
      // transactions (which might move its anchor cell) come in.
      state: {
        init() {
          return null;
        },
        apply(tr3, cur) {
          const set2 = tr3.getMeta(tableEditingKey);
          if (set2 != null) return set2 == -1 ? null : set2;
          if (cur == null || !tr3.docChanged) return cur;
          const { deleted, pos } = tr3.mapping.mapResult(cur);
          return deleted ? null : pos;
        }
      },
      props: {
        decorations: drawCellSelection,
        handleDOMEvents: {
          mousedown: handleMouseDown
        },
        createSelectionBetween(view) {
          return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
        },
        handleTripleClick: handleTripleClick2,
        handleKeyDown,
        handlePaste
      },
      appendTransaction(_2, oldState, state) {
        return normalizeSelection(
          state,
          fixTables(state, oldState),
          allowTableNodeSelection
        );
      }
    });
  }

  // node_modules/prosemirror-gapcursor/dist/index.js
  var GapCursor = class _GapCursor extends Selection {
    /**
    Create a gap cursor.
    */
    constructor($pos) {
      super($pos, $pos);
    }
    map(doc4, mapping) {
      let $pos = doc4.resolve(mapping.map(this.head));
      return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
    }
    content() {
      return Slice.empty;
    }
    eq(other) {
      return other instanceof _GapCursor && other.head == this.head;
    }
    toJSON() {
      return { type: "gapcursor", pos: this.head };
    }
    /**
    @internal
    */
    static fromJSON(doc4, json) {
      if (typeof json.pos != "number")
        throw new RangeError("Invalid input for GapCursor.fromJSON");
      return new _GapCursor(doc4.resolve(json.pos));
    }
    /**
    @internal
    */
    getBookmark() {
      return new GapBookmark(this.anchor);
    }
    /**
    @internal
    */
    static valid($pos) {
      let parent = $pos.parent;
      if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
        return false;
      let override = parent.type.spec.allowGapCursor;
      if (override != null)
        return override;
      let deflt = parent.contentMatchAt($pos.index()).defaultType;
      return deflt && deflt.isTextblock;
    }
    /**
    @internal
    */
    static findGapCursorFrom($pos, dir, mustMove = false) {
      search: for (; ; ) {
        if (!mustMove && _GapCursor.valid($pos))
          return $pos;
        let pos = $pos.pos, next2 = null;
        for (let d = $pos.depth; ; d--) {
          let parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next2 = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        for (; ; ) {
          let inside = dir > 0 ? next2.firstChild : next2.lastChild;
          if (!inside) {
            if (next2.isAtom && !next2.isText && !NodeSelection.isSelectable(next2)) {
              $pos = $pos.doc.resolve(pos + next2.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next2 = inside;
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        return null;
      }
    }
  };
  GapCursor.prototype.visible = false;
  GapCursor.findFrom = GapCursor.findGapCursorFrom;
  Selection.jsonID("gapcursor", GapCursor);
  var GapBookmark = class _GapBookmark {
    constructor(pos) {
      this.pos = pos;
    }
    map(mapping) {
      return new _GapBookmark(mapping.map(this.pos));
    }
    resolve(doc4) {
      let $pos = doc4.resolve(this.pos);
      return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
    }
  };
  function closedBefore($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
      let index3 = $pos.index(d), parent = $pos.node(d);
      if (index3 == 0) {
        if (parent.type.spec.isolating)
          return true;
        continue;
      }
      for (let before = parent.child(index3 - 1); ; before = before.lastChild) {
        if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
          return true;
        if (before.inlineContent)
          return false;
      }
    }
    return true;
  }
  function closedAfter($pos) {
    for (let d = $pos.depth; d >= 0; d--) {
      let index3 = $pos.indexAfter(d), parent = $pos.node(d);
      if (index3 == parent.childCount) {
        if (parent.type.spec.isolating)
          return true;
        continue;
      }
      for (let after = parent.child(index3); ; after = after.firstChild) {
        if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
          return true;
        if (after.inlineContent)
          return false;
      }
    }
    return true;
  }
  function gapCursor() {
    return new Plugin({
      props: {
        decorations: drawGapCursor,
        createSelectionBetween(_view, $anchor, $head) {
          return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
        },
        handleClick,
        handleKeyDown: handleKeyDown2,
        handleDOMEvents: { beforeinput }
      }
    });
  }
  var handleKeyDown2 = keydownHandler({
    "ArrowLeft": arrow2("horiz", -1),
    "ArrowRight": arrow2("horiz", 1),
    "ArrowUp": arrow2("vert", -1),
    "ArrowDown": arrow2("vert", 1)
  });
  function arrow2(axis, dir) {
    const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
    return function(state, dispatch, view) {
      let sel = state.selection;
      let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
      if (sel instanceof TextSelection) {
        if (!view.endOfTextblock(dirStr) || $start.depth == 0)
          return false;
        mustMove = false;
        $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
      }
      let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
      if (!$found)
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(new GapCursor($found)));
      return true;
    };
  }
  function handleClick(view, pos, event) {
    if (!view || !view.editable)
      return false;
    let $pos = view.state.doc.resolve(pos);
    if (!GapCursor.valid($pos))
      return false;
    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
      return false;
    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
    return true;
  }
  function beforeinput(view, event) {
    if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
      return false;
    let { $from } = view.state.selection;
    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
    if (!insert)
      return false;
    let frag = Fragment.empty;
    for (let i = insert.length - 1; i >= 0; i--)
      frag = Fragment.from(insert[i].createAndFill(null, frag));
    let tr3 = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
    tr3.setSelection(TextSelection.near(tr3.doc.resolve($from.pos + 1)));
    view.dispatch(tr3);
    return false;
  }
  function drawGapCursor(state) {
    if (!(state.selection instanceof GapCursor))
      return null;
    let node2 = document.createElement("div");
    node2.className = "ProseMirror-gapcursor";
    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node2, { key: "gapcursor" })]);
  }

  // node_modules/@tiptap/extension-gapcursor/dist/index.js
  var Gapcursor = Extension.create({
    name: "gapCursor",
    addProseMirrorPlugins() {
      return [
        gapCursor()
      ];
    },
    extendNodeSchema(extension2) {
      var _a3;
      const context = {
        name: extension2.name,
        options: extension2.options,
        storage: extension2.storage
      };
      return {
        allowGapCursor: (_a3 = callOrReturn(getExtensionField(extension2, "allowGapCursor", context))) !== null && _a3 !== void 0 ? _a3 : null
      };
    }
  });

  // node_modules/rope-sequence/dist/index.js
  var GOOD_LEAF_SIZE = 200;
  var RopeSequence = function RopeSequence2() {
  };
  RopeSequence.prototype.append = function append(other) {
    if (!other.length) {
      return this;
    }
    other = RopeSequence.from(other);
    return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
  };
  RopeSequence.prototype.prepend = function prepend(other) {
    if (!other.length) {
      return this;
    }
    return RopeSequence.from(other).append(this);
  };
  RopeSequence.prototype.appendInner = function appendInner(other) {
    return new Append(this, other);
  };
  RopeSequence.prototype.slice = function slice(from4, to2) {
    if (from4 === void 0) from4 = 0;
    if (to2 === void 0) to2 = this.length;
    if (from4 >= to2) {
      return RopeSequence.empty;
    }
    return this.sliceInner(Math.max(0, from4), Math.min(this.length, to2));
  };
  RopeSequence.prototype.get = function get(i) {
    if (i < 0 || i >= this.length) {
      return void 0;
    }
    return this.getInner(i);
  };
  RopeSequence.prototype.forEach = function forEach2(f, from4, to2) {
    if (from4 === void 0) from4 = 0;
    if (to2 === void 0) to2 = this.length;
    if (from4 <= to2) {
      this.forEachInner(f, from4, to2, 0);
    } else {
      this.forEachInvertedInner(f, from4, to2, 0);
    }
  };
  RopeSequence.prototype.map = function map4(f, from4, to2) {
    if (from4 === void 0) from4 = 0;
    if (to2 === void 0) to2 = this.length;
    var result = [];
    this.forEach(function(elt, i) {
      return result.push(f(elt, i));
    }, from4, to2);
    return result;
  };
  RopeSequence.from = function from(values) {
    if (values instanceof RopeSequence) {
      return values;
    }
    return values && values.length ? new Leaf(values) : RopeSequence.empty;
  };
  var Leaf = /* @__PURE__ */ function(RopeSequence3) {
    function Leaf2(values) {
      RopeSequence3.call(this);
      this.values = values;
    }
    if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
    Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
    Leaf2.prototype.constructor = Leaf2;
    var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
    Leaf2.prototype.flatten = function flatten3() {
      return this.values;
    };
    Leaf2.prototype.sliceInner = function sliceInner(from4, to2) {
      if (from4 == 0 && to2 == this.length) {
        return this;
      }
      return new Leaf2(this.values.slice(from4, to2));
    };
    Leaf2.prototype.getInner = function getInner(i) {
      return this.values[i];
    };
    Leaf2.prototype.forEachInner = function forEachInner(f, from4, to2, start) {
      for (var i = from4; i < to2; i++) {
        if (f(this.values[i], start + i) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from4, to2, start) {
      for (var i = from4 - 1; i >= to2; i--) {
        if (f(this.values[i], start + i) === false) {
          return false;
        }
      }
    };
    Leaf2.prototype.leafAppend = function leafAppend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(this.values.concat(other.flatten()));
      }
    };
    Leaf2.prototype.leafPrepend = function leafPrepend(other) {
      if (this.length + other.length <= GOOD_LEAF_SIZE) {
        return new Leaf2(other.flatten().concat(this.values));
      }
    };
    prototypeAccessors.length.get = function() {
      return this.values.length;
    };
    prototypeAccessors.depth.get = function() {
      return 0;
    };
    Object.defineProperties(Leaf2.prototype, prototypeAccessors);
    return Leaf2;
  }(RopeSequence);
  RopeSequence.empty = new Leaf([]);
  var Append = /* @__PURE__ */ function(RopeSequence3) {
    function Append2(left, right) {
      RopeSequence3.call(this);
      this.left = left;
      this.right = right;
      this.length = left.length + right.length;
      this.depth = Math.max(left.depth, right.depth) + 1;
    }
    if (RopeSequence3) Append2.__proto__ = RopeSequence3;
    Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
    Append2.prototype.constructor = Append2;
    Append2.prototype.flatten = function flatten3() {
      return this.left.flatten().concat(this.right.flatten());
    };
    Append2.prototype.getInner = function getInner(i) {
      return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
    };
    Append2.prototype.forEachInner = function forEachInner(f, from4, to2, start) {
      var leftLen = this.left.length;
      if (from4 < leftLen && this.left.forEachInner(f, from4, Math.min(to2, leftLen), start) === false) {
        return false;
      }
      if (to2 > leftLen && this.right.forEachInner(f, Math.max(from4 - leftLen, 0), Math.min(this.length, to2) - leftLen, start + leftLen) === false) {
        return false;
      }
    };
    Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from4, to2, start) {
      var leftLen = this.left.length;
      if (from4 > leftLen && this.right.forEachInvertedInner(f, from4 - leftLen, Math.max(to2, leftLen) - leftLen, start + leftLen) === false) {
        return false;
      }
      if (to2 < leftLen && this.left.forEachInvertedInner(f, Math.min(from4, leftLen), to2, start) === false) {
        return false;
      }
    };
    Append2.prototype.sliceInner = function sliceInner(from4, to2) {
      if (from4 == 0 && to2 == this.length) {
        return this;
      }
      var leftLen = this.left.length;
      if (to2 <= leftLen) {
        return this.left.slice(from4, to2);
      }
      if (from4 >= leftLen) {
        return this.right.slice(from4 - leftLen, to2 - leftLen);
      }
      return this.left.slice(from4, leftLen).append(this.right.slice(0, to2 - leftLen));
    };
    Append2.prototype.leafAppend = function leafAppend(other) {
      var inner = this.right.leafAppend(other);
      if (inner) {
        return new Append2(this.left, inner);
      }
    };
    Append2.prototype.leafPrepend = function leafPrepend(other) {
      var inner = this.left.leafPrepend(other);
      if (inner) {
        return new Append2(inner, this.right);
      }
    };
    Append2.prototype.appendInner = function appendInner2(other) {
      if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
        return new Append2(this.left, new Append2(this.right, other));
      }
      return new Append2(this, other);
    };
    return Append2;
  }(RopeSequence);
  var dist_default2 = RopeSequence;

  // node_modules/prosemirror-history/dist/index.js
  var max_empty_items = 500;
  var Branch = class _Branch {
    constructor(items, eventCount) {
      this.items = items;
      this.eventCount = eventCount;
    }
    // Pop the latest event off the branch's history and apply it
    // to a document transform.
    popEvent(state, preserveItems) {
      if (this.eventCount == 0)
        return null;
      let end = this.items.length;
      for (; ; end--) {
        let next2 = this.items.get(end - 1);
        if (next2.selection) {
          --end;
          break;
        }
      }
      let remap, mapFrom;
      if (preserveItems) {
        remap = this.remapping(end, this.items.length);
        mapFrom = remap.maps.length;
      }
      let transform2 = state.tr;
      let selection, remaining;
      let addAfter = [], addBefore = [];
      this.items.forEach((item, i) => {
        if (!item.step) {
          if (!remap) {
            remap = this.remapping(end, i + 1);
            mapFrom = remap.maps.length;
          }
          mapFrom--;
          addBefore.push(item);
          return;
        }
        if (remap) {
          addBefore.push(new Item(item.map));
          let step = item.step.map(remap.slice(mapFrom)), map9;
          if (step && transform2.maybeStep(step).doc) {
            map9 = transform2.mapping.maps[transform2.mapping.maps.length - 1];
            addAfter.push(new Item(map9, void 0, void 0, addAfter.length + addBefore.length));
          }
          mapFrom--;
          if (map9)
            remap.appendMap(map9, mapFrom);
        } else {
          transform2.maybeStep(item.step);
        }
        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new _Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
          return false;
        }
      }, this.items.length, 0);
      return { remaining, transform: transform2, selection };
    }
    // Create a new branch with the given transform added.
    addTransform(transform2, selection, histOptions, preserveItems) {
      let newItems = [], eventCount = this.eventCount;
      let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
      for (let i = 0; i < transform2.steps.length; i++) {
        let step = transform2.steps[i].invert(transform2.docs[i]);
        let item = new Item(transform2.mapping.maps[i], step, selection), merged;
        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (i)
            newItems.pop();
          else
            oldItems = oldItems.slice(0, oldItems.length - 1);
        }
        newItems.push(item);
        if (selection) {
          eventCount++;
          selection = void 0;
        }
        if (!preserveItems)
          lastItem = item;
      }
      let overflow = eventCount - histOptions.depth;
      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }
      return new _Branch(oldItems.append(newItems), eventCount);
    }
    remapping(from4, to2) {
      let maps = new Mapping();
      this.items.forEach((item, i) => {
        let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from4 ? maps.maps.length - item.mirrorOffset : void 0;
        maps.appendMap(item.map, mirrorPos);
      }, from4, to2);
      return maps;
    }
    addMaps(array) {
      if (this.eventCount == 0)
        return this;
      return new _Branch(this.items.append(array.map((map9) => new Item(map9))), this.eventCount);
    }
    // When the collab module receives remote changes, the history has
    // to know about those, so that it can adjust the steps that were
    // rebased on top of the remote changes, and include the position
    // maps for the remote changes in its array of items.
    rebased(rebasedTransform, rebasedCount) {
      if (!this.eventCount)
        return this;
      let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
      let mapping = rebasedTransform.mapping;
      let newUntil = rebasedTransform.steps.length;
      let eventCount = this.eventCount;
      this.items.forEach((item) => {
        if (item.selection)
          eventCount--;
      }, start);
      let iRebased = rebasedCount;
      this.items.forEach((item) => {
        let pos = mapping.getMirror(--iRebased);
        if (pos == null)
          return;
        newUntil = Math.min(newUntil, pos);
        let map9 = mapping.maps[pos];
        if (item.step) {
          let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection)
            eventCount++;
          rebasedItems.push(new Item(map9, step, selection));
        } else {
          rebasedItems.push(new Item(map9));
        }
      }, start);
      let newMaps = [];
      for (let i = rebasedCount; i < newUntil; i++)
        newMaps.push(new Item(mapping.maps[i]));
      let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
      let branch = new _Branch(items, eventCount);
      if (branch.emptyItemCount() > max_empty_items)
        branch = branch.compress(this.items.length - rebasedItems.length);
      return branch;
    }
    emptyItemCount() {
      let count = 0;
      this.items.forEach((item) => {
        if (!item.step)
          count++;
      });
      return count;
    }
    // Compressing a branch means rewriting it to push the air (map-only
    // items) out. During collaboration, these naturally accumulate
    // because each remote change adds one. The `upto` argument is used
    // to ensure that only the items below a given level are compressed,
    // because `rebased` relies on a clean, untouched set of items in
    // order to associate old items with rebased steps.
    compress(upto = this.items.length) {
      let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
      let items = [], events = 0;
      this.items.forEach((item, i) => {
        if (i >= upto) {
          items.push(item);
          if (item.selection)
            events++;
        } else if (item.step) {
          let step = item.step.map(remap.slice(mapFrom)), map9 = step && step.getMap();
          mapFrom--;
          if (map9)
            remap.appendMap(map9, mapFrom);
          if (step) {
            let selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection)
              events++;
            let newItem = new Item(map9.invert(), step, selection), merged, last2 = items.length - 1;
            if (merged = items.length && items[last2].merge(newItem))
              items[last2] = merged;
            else
              items.push(newItem);
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new _Branch(dist_default2.from(items.reverse()), events);
    }
  };
  Branch.empty = new Branch(dist_default2.empty, 0);
  function cutOffEvents(items, n) {
    let cutPoint;
    items.forEach((item, i) => {
      if (item.selection && n-- == 0) {
        cutPoint = i;
        return false;
      }
    });
    return items.slice(cutPoint);
  }
  var Item = class _Item {
    constructor(map9, step, selection, mirrorOffset) {
      this.map = map9;
      this.step = step;
      this.selection = selection;
      this.mirrorOffset = mirrorOffset;
    }
    merge(other) {
      if (this.step && other.step && !other.selection) {
        let step = other.step.merge(this.step);
        if (step)
          return new _Item(step.getMap().invert(), step, this.selection);
      }
    }
  };
  var HistoryState = class {
    constructor(done, undone, prevRanges, prevTime, prevComposition) {
      this.done = done;
      this.undone = undone;
      this.prevRanges = prevRanges;
      this.prevTime = prevTime;
      this.prevComposition = prevComposition;
    }
  };
  var DEPTH_OVERFLOW = 20;
  function applyTransaction(history2, state, tr3, options2) {
    let historyTr = tr3.getMeta(historyKey), rebased;
    if (historyTr)
      return historyTr.historyState;
    if (tr3.getMeta(closeHistoryKey))
      history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
    let appended = tr3.getMeta("appendedTransaction");
    if (tr3.steps.length == 0) {
      return history2;
    } else if (appended && appended.getMeta(historyKey)) {
      if (appended.getMeta(historyKey).redo)
        return new HistoryState(history2.done.addTransform(tr3, void 0, options2, mustPreserveItems(state)), history2.undone, rangesFor(tr3.mapping.maps), history2.prevTime, history2.prevComposition);
      else
        return new HistoryState(history2.done, history2.undone.addTransform(tr3, void 0, options2, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
    } else if (tr3.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
      let composition = tr3.getMeta("composition");
      let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr3.time || 0) - options2.newGroupDelay || !isAdjacentTo(tr3, history2.prevRanges));
      let prevRanges = appended ? mapRanges(history2.prevRanges, tr3.mapping) : rangesFor(tr3.mapping.maps);
      return new HistoryState(history2.done.addTransform(tr3, newGroup ? state.selection.getBookmark() : void 0, options2, mustPreserveItems(state)), Branch.empty, prevRanges, tr3.time, composition == null ? history2.prevComposition : composition);
    } else if (rebased = tr3.getMeta("rebased")) {
      return new HistoryState(history2.done.rebased(tr3, rebased), history2.undone.rebased(tr3, rebased), mapRanges(history2.prevRanges, tr3.mapping), history2.prevTime, history2.prevComposition);
    } else {
      return new HistoryState(history2.done.addMaps(tr3.mapping.maps), history2.undone.addMaps(tr3.mapping.maps), mapRanges(history2.prevRanges, tr3.mapping), history2.prevTime, history2.prevComposition);
    }
  }
  function isAdjacentTo(transform2, prevRanges) {
    if (!prevRanges)
      return false;
    if (!transform2.docChanged)
      return true;
    let adjacent = false;
    transform2.mapping.maps[0].forEach((start, end) => {
      for (let i = 0; i < prevRanges.length; i += 2)
        if (start <= prevRanges[i + 1] && end >= prevRanges[i])
          adjacent = true;
    });
    return adjacent;
  }
  function rangesFor(maps) {
    let result = [];
    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)
      maps[i].forEach((_from, _to, from4, to2) => result.push(from4, to2));
    return result;
  }
  function mapRanges(ranges, mapping) {
    if (!ranges)
      return null;
    let result = [];
    for (let i = 0; i < ranges.length; i += 2) {
      let from4 = mapping.map(ranges[i], 1), to2 = mapping.map(ranges[i + 1], -1);
      if (from4 <= to2)
        result.push(from4, to2);
    }
    return result;
  }
  function histTransaction(history2, state, redo3) {
    let preserveItems = mustPreserveItems(state);
    let histOptions = historyKey.get(state).spec.config;
    let pop = (redo3 ? history2.undone : history2.done).popEvent(state, preserveItems);
    if (!pop)
      return null;
    let selection = pop.selection.resolve(pop.transform.doc);
    let added = (redo3 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
    let newHist = new HistoryState(redo3 ? added : pop.remaining, redo3 ? pop.remaining : added, null, 0, -1);
    return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo3, historyState: newHist });
  }
  var cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
  function mustPreserveItems(state) {
    let plugins = state.plugins;
    if (cachedPreserveItemsPlugins != plugins) {
      cachedPreserveItems = false;
      cachedPreserveItemsPlugins = plugins;
      for (let i = 0; i < plugins.length; i++)
        if (plugins[i].spec.historyPreserveItems) {
          cachedPreserveItems = true;
          break;
        }
    }
    return cachedPreserveItems;
  }
  function closeHistory(tr3) {
    return tr3.setMeta(closeHistoryKey, true);
  }
  var historyKey = new PluginKey("history");
  var closeHistoryKey = new PluginKey("closeHistory");
  function history(config = {}) {
    config = {
      depth: config.depth || 100,
      newGroupDelay: config.newGroupDelay || 500
    };
    return new Plugin({
      key: historyKey,
      state: {
        init() {
          return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
        },
        apply(tr3, hist, state) {
          return applyTransaction(hist, state, tr3, config);
        }
      },
      config,
      props: {
        handleDOMEvents: {
          beforeinput(view, e) {
            let inputType = e.inputType;
            let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
            if (!command2)
              return false;
            e.preventDefault();
            return command2(view.state, view.dispatch);
          }
        }
      }
    });
  }
  function buildCommand(redo3, scroll) {
    return (state, dispatch) => {
      let hist = historyKey.getState(state);
      if (!hist || (redo3 ? hist.undone : hist.done).eventCount == 0)
        return false;
      if (dispatch) {
        let tr3 = histTransaction(hist, state, redo3);
        if (tr3)
          dispatch(scroll ? tr3.scrollIntoView() : tr3);
      }
      return true;
    };
  }
  var undo = buildCommand(false, true);
  var redo = buildCommand(true, true);
  var undoNoScroll = buildCommand(false, false);
  var redoNoScroll = buildCommand(true, false);
  function undoDepth(state) {
    let hist = historyKey.getState(state);
    return hist ? hist.done.eventCount : 0;
  }
  function redoDepth(state) {
    let hist = historyKey.getState(state);
    return hist ? hist.undone.eventCount : 0;
  }

  // node_modules/@tiptap/extension-history/dist/index.js
  var History = Extension.create({
    name: "history",
    addOptions() {
      return {
        depth: 100,
        newGroupDelay: 500
      };
    },
    addCommands() {
      return {
        undo: () => ({ state, dispatch }) => {
          return undo(state, dispatch);
        },
        redo: () => ({ state, dispatch }) => {
          return redo(state, dispatch);
        }
      };
    },
    addProseMirrorPlugins() {
      return [
        history(this.options)
      ];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-z": () => this.editor.commands.undo(),
        "Shift-Mod-z": () => this.editor.commands.redo(),
        "Mod-y": () => this.editor.commands.redo(),
        // Russian keyboard layouts
        "Mod-\u044F": () => this.editor.commands.undo(),
        "Shift-Mod-\u044F": () => this.editor.commands.redo()
      };
    }
  });

  // node_modules/linkifyjs/dist/linkify.mjs
  var encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xF6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
  var encodedUtlds = "\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2";
  var assign = (target, properties) => {
    for (const key2 in properties) {
      target[key2] = properties[key2];
    }
    return target;
  };
  var numeric = "numeric";
  var ascii = "ascii";
  var alpha = "alpha";
  var asciinumeric = "asciinumeric";
  var alphanumeric = "alphanumeric";
  var domain2 = "domain";
  var emoji = "emoji";
  var scheme = "scheme";
  var slashscheme = "slashscheme";
  var whitespace2 = "whitespace";
  function registerGroup(name, groups) {
    if (!(name in groups)) {
      groups[name] = [];
    }
    return groups[name];
  }
  function addToGroups(t2, flags, groups) {
    if (flags[numeric]) {
      flags[asciinumeric] = true;
      flags[alphanumeric] = true;
    }
    if (flags[ascii]) {
      flags[asciinumeric] = true;
      flags[alpha] = true;
    }
    if (flags[asciinumeric]) {
      flags[alphanumeric] = true;
    }
    if (flags[alpha]) {
      flags[alphanumeric] = true;
    }
    if (flags[alphanumeric]) {
      flags[domain2] = true;
    }
    if (flags[emoji]) {
      flags[domain2] = true;
    }
    for (const k in flags) {
      const group2 = registerGroup(k, groups);
      if (group2.indexOf(t2) < 0) {
        group2.push(t2);
      }
    }
  }
  function flagsForToken(t2, groups) {
    const result = {};
    for (const c in groups) {
      if (groups[c].indexOf(t2) >= 0) {
        result[c] = true;
      }
    }
    return result;
  }
  function State2(token = null) {
    this.j = {};
    this.jr = [];
    this.jd = null;
    this.t = token;
  }
  State2.groups = {};
  State2.prototype = {
    accepts() {
      return !!this.t;
    },
    /**
     * Follow an existing transition from the given input to the next state.
     * Does not mutate.
     * @param {string} input character or token type to transition on
     * @returns {?State<T>} the next state, if any
     */
    go(input2) {
      const state = this;
      const nextState = state.j[input2];
      if (nextState) {
        return nextState;
      }
      for (let i = 0; i < state.jr.length; i++) {
        const regex = state.jr[i][0];
        const nextState2 = state.jr[i][1];
        if (nextState2 && regex.test(input2)) {
          return nextState2;
        }
      }
      return state.jd;
    },
    /**
     * Whether the state has a transition for the given input. Set the second
     * argument to true to only look for an exact match (and not a default or
     * regular-expression-based transition)
     * @param {string} input
     * @param {boolean} exactOnly
     */
    has(input2, exactOnly = false) {
      return exactOnly ? input2 in this.j : !!this.go(input2);
    },
    /**
     * Short for "transition all"; create a transition from the array of items
     * in the given list to the same final resulting state.
     * @param {string | string[]} inputs Group of inputs to transition on
     * @param {Transition<T> | State<T>} [next] Transition options
     * @param {Flags} [flags] Collections flags to add token to
     * @param {Collections<T>} [groups] Master list of token groups
     */
    ta(inputs, next2, flags, groups) {
      for (let i = 0; i < inputs.length; i++) {
        this.tt(inputs[i], next2, flags, groups);
      }
    },
    /**
     * Short for "take regexp transition"; defines a transition for this state
     * when it encounters a token which matches the given regular expression
     * @param {RegExp} regexp Regular expression transition (populate first)
     * @param {T | State<T>} [next] Transition options
     * @param {Flags} [flags] Collections flags to add token to
     * @param {Collections<T>} [groups] Master list of token groups
     * @returns {State<T>} taken after the given input
     */
    tr(regexp2, next2, flags, groups) {
      groups = groups || State2.groups;
      let nextState;
      if (next2 && next2.j) {
        nextState = next2;
      } else {
        nextState = new State2(next2);
        if (flags && groups) {
          addToGroups(next2, flags, groups);
        }
      }
      this.jr.push([regexp2, nextState]);
      return nextState;
    },
    /**
     * Short for "take transitions", will take as many sequential transitions as
     * the length of the given input and returns the
     * resulting final state.
     * @param {string | string[]} input
     * @param {T | State<T>} [next] Transition options
     * @param {Flags} [flags] Collections flags to add token to
     * @param {Collections<T>} [groups] Master list of token groups
     * @returns {State<T>} taken after the given input
     */
    ts(input2, next2, flags, groups) {
      let state = this;
      const len = input2.length;
      if (!len) {
        return state;
      }
      for (let i = 0; i < len - 1; i++) {
        state = state.tt(input2[i]);
      }
      return state.tt(input2[len - 1], next2, flags, groups);
    },
    /**
     * Short for "take transition", this is a method for building/working with
     * state machines.
     *
     * If a state already exists for the given input, returns it.
     *
     * If a token is specified, that state will emit that token when reached by
     * the linkify engine.
     *
     * If no state exists, it will be initialized with some default transitions
     * that resemble existing default transitions.
     *
     * If a state is given for the second argument, that state will be
     * transitioned to on the given input regardless of what that input
     * previously did.
     *
     * Specify a token group flags to define groups that this token belongs to.
     * The token will be added to corresponding entires in the given groups
     * object.
     *
     * @param {string} input character, token type to transition on
     * @param {T | State<T>} [next] Transition options
     * @param {Flags} [flags] Collections flags to add token to
     * @param {Collections<T>} [groups] Master list of groups
     * @returns {State<T>} taken after the given input
     */
    tt(input2, next2, flags, groups) {
      groups = groups || State2.groups;
      const state = this;
      if (next2 && next2.j) {
        state.j[input2] = next2;
        return next2;
      }
      const t2 = next2;
      let nextState, templateState = state.go(input2);
      if (templateState) {
        nextState = new State2();
        assign(nextState.j, templateState.j);
        nextState.jr.push.apply(nextState.jr, templateState.jr);
        nextState.jd = templateState.jd;
        nextState.t = templateState.t;
      } else {
        nextState = new State2();
      }
      if (t2) {
        if (groups) {
          if (nextState.t && typeof nextState.t === "string") {
            const allFlags = assign(flagsForToken(nextState.t, groups), flags);
            addToGroups(t2, allFlags, groups);
          } else if (flags) {
            addToGroups(t2, flags, groups);
          }
        }
        nextState.t = t2;
      }
      state.j[input2] = nextState;
      return nextState;
    }
  };
  var ta = (state, input2, next2, flags, groups) => state.ta(input2, next2, flags, groups);
  var tr2 = (state, regexp2, next2, flags, groups) => state.tr(regexp2, next2, flags, groups);
  var ts = (state, input2, next2, flags, groups) => state.ts(input2, next2, flags, groups);
  var tt = (state, input2, next2, flags, groups) => state.tt(input2, next2, flags, groups);
  var WORD = "WORD";
  var UWORD = "UWORD";
  var ASCIINUMERICAL = "ASCIINUMERICAL";
  var ALPHANUMERICAL = "ALPHANUMERICAL";
  var LOCALHOST = "LOCALHOST";
  var TLD = "TLD";
  var UTLD = "UTLD";
  var SCHEME = "SCHEME";
  var SLASH_SCHEME = "SLASH_SCHEME";
  var NUM = "NUM";
  var WS = "WS";
  var NL = "NL";
  var OPENBRACE = "OPENBRACE";
  var CLOSEBRACE = "CLOSEBRACE";
  var OPENBRACKET = "OPENBRACKET";
  var CLOSEBRACKET = "CLOSEBRACKET";
  var OPENPAREN = "OPENPAREN";
  var CLOSEPAREN = "CLOSEPAREN";
  var OPENANGLEBRACKET = "OPENANGLEBRACKET";
  var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
  var FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
  var FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
  var LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
  var RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
  var LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
  var RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
  var FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
  var FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
  var AMPERSAND = "AMPERSAND";
  var APOSTROPHE = "APOSTROPHE";
  var ASTERISK = "ASTERISK";
  var AT = "AT";
  var BACKSLASH = "BACKSLASH";
  var BACKTICK = "BACKTICK";
  var CARET = "CARET";
  var COLON = "COLON";
  var COMMA = "COMMA";
  var DOLLAR = "DOLLAR";
  var DOT = "DOT";
  var EQUALS = "EQUALS";
  var EXCLAMATION = "EXCLAMATION";
  var HYPHEN = "HYPHEN";
  var PERCENT = "PERCENT";
  var PIPE = "PIPE";
  var PLUS = "PLUS";
  var POUND = "POUND";
  var QUERY = "QUERY";
  var QUOTE = "QUOTE";
  var FULLWIDTHMIDDLEDOT = "FULLWIDTHMIDDLEDOT";
  var SEMI = "SEMI";
  var SLASH = "SLASH";
  var TILDE = "TILDE";
  var UNDERSCORE = "UNDERSCORE";
  var EMOJI$1 = "EMOJI";
  var SYM = "SYM";
  var tk = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ALPHANUMERICAL,
    AMPERSAND,
    APOSTROPHE,
    ASCIINUMERICAL,
    ASTERISK,
    AT,
    BACKSLASH,
    BACKTICK,
    CARET,
    CLOSEANGLEBRACKET,
    CLOSEBRACE,
    CLOSEBRACKET,
    CLOSEPAREN,
    COLON,
    COMMA,
    DOLLAR,
    DOT,
    EMOJI: EMOJI$1,
    EQUALS,
    EXCLAMATION,
    FULLWIDTHGREATERTHAN,
    FULLWIDTHLEFTPAREN,
    FULLWIDTHLESSTHAN,
    FULLWIDTHMIDDLEDOT,
    FULLWIDTHRIGHTPAREN,
    HYPHEN,
    LEFTCORNERBRACKET,
    LEFTWHITECORNERBRACKET,
    LOCALHOST,
    NL,
    NUM,
    OPENANGLEBRACKET,
    OPENBRACE,
    OPENBRACKET,
    OPENPAREN,
    PERCENT,
    PIPE,
    PLUS,
    POUND,
    QUERY,
    QUOTE,
    RIGHTCORNERBRACKET,
    RIGHTWHITECORNERBRACKET,
    SCHEME,
    SEMI,
    SLASH,
    SLASH_SCHEME,
    SYM,
    TILDE,
    TLD,
    UNDERSCORE,
    UTLD,
    UWORD,
    WORD,
    WS
  });
  var ASCII_LETTER = /[a-z]/;
  var LETTER = /\p{L}/u;
  var EMOJI = /\p{Emoji}/u;
  var EMOJI_VARIATION$1 = /\ufe0f/;
  var DIGIT = /\d/;
  var SPACE = /\s/;
  var regexp = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ASCII_LETTER,
    DIGIT,
    EMOJI,
    EMOJI_VARIATION: EMOJI_VARIATION$1,
    LETTER,
    SPACE
  });
  var CR = "\r";
  var LF = "\n";
  var EMOJI_VARIATION = "\uFE0F";
  var EMOJI_JOINER = "\u200D";
  var OBJECT_REPLACEMENT = "\uFFFC";
  var tlds = null, utlds = null;
  function init$2(customSchemes = []) {
    const groups = {};
    State2.groups = groups;
    const Start = new State2();
    if (tlds == null) {
      tlds = decodeTlds(encodedTlds);
    }
    if (utlds == null) {
      utlds = decodeTlds(encodedUtlds);
    }
    tt(Start, "'", APOSTROPHE);
    tt(Start, "{", OPENBRACE);
    tt(Start, "}", CLOSEBRACE);
    tt(Start, "[", OPENBRACKET);
    tt(Start, "]", CLOSEBRACKET);
    tt(Start, "(", OPENPAREN);
    tt(Start, ")", CLOSEPAREN);
    tt(Start, "<", OPENANGLEBRACKET);
    tt(Start, ">", CLOSEANGLEBRACKET);
    tt(Start, "\uFF08", FULLWIDTHLEFTPAREN);
    tt(Start, "\uFF09", FULLWIDTHRIGHTPAREN);
    tt(Start, "\u300C", LEFTCORNERBRACKET);
    tt(Start, "\u300D", RIGHTCORNERBRACKET);
    tt(Start, "\u300E", LEFTWHITECORNERBRACKET);
    tt(Start, "\u300F", RIGHTWHITECORNERBRACKET);
    tt(Start, "\uFF1C", FULLWIDTHLESSTHAN);
    tt(Start, "\uFF1E", FULLWIDTHGREATERTHAN);
    tt(Start, "&", AMPERSAND);
    tt(Start, "*", ASTERISK);
    tt(Start, "@", AT);
    tt(Start, "`", BACKTICK);
    tt(Start, "^", CARET);
    tt(Start, ":", COLON);
    tt(Start, ",", COMMA);
    tt(Start, "$", DOLLAR);
    tt(Start, ".", DOT);
    tt(Start, "=", EQUALS);
    tt(Start, "!", EXCLAMATION);
    tt(Start, "-", HYPHEN);
    tt(Start, "%", PERCENT);
    tt(Start, "|", PIPE);
    tt(Start, "+", PLUS);
    tt(Start, "#", POUND);
    tt(Start, "?", QUERY);
    tt(Start, '"', QUOTE);
    tt(Start, "/", SLASH);
    tt(Start, ";", SEMI);
    tt(Start, "~", TILDE);
    tt(Start, "_", UNDERSCORE);
    tt(Start, "\\", BACKSLASH);
    tt(Start, "\u30FB", FULLWIDTHMIDDLEDOT);
    const Num = tr2(Start, DIGIT, NUM, {
      [numeric]: true
    });
    tr2(Num, DIGIT, Num);
    const Asciinumeric = tr2(Num, ASCII_LETTER, ASCIINUMERICAL, {
      [asciinumeric]: true
    });
    const Alphanumeric = tr2(Num, LETTER, ALPHANUMERICAL, {
      [alphanumeric]: true
    });
    const Word = tr2(Start, ASCII_LETTER, WORD, {
      [ascii]: true
    });
    tr2(Word, DIGIT, Asciinumeric);
    tr2(Word, ASCII_LETTER, Word);
    tr2(Asciinumeric, DIGIT, Asciinumeric);
    tr2(Asciinumeric, ASCII_LETTER, Asciinumeric);
    const UWord = tr2(Start, LETTER, UWORD, {
      [alpha]: true
    });
    tr2(UWord, ASCII_LETTER);
    tr2(UWord, DIGIT, Alphanumeric);
    tr2(UWord, LETTER, UWord);
    tr2(Alphanumeric, DIGIT, Alphanumeric);
    tr2(Alphanumeric, ASCII_LETTER);
    tr2(Alphanumeric, LETTER, Alphanumeric);
    const Nl2 = tt(Start, LF, NL, {
      [whitespace2]: true
    });
    const Cr2 = tt(Start, CR, WS, {
      [whitespace2]: true
    });
    const Ws2 = tr2(Start, SPACE, WS, {
      [whitespace2]: true
    });
    tt(Start, OBJECT_REPLACEMENT, Ws2);
    tt(Cr2, LF, Nl2);
    tt(Cr2, OBJECT_REPLACEMENT, Ws2);
    tr2(Cr2, SPACE, Ws2);
    tt(Ws2, CR);
    tt(Ws2, LF);
    tr2(Ws2, SPACE, Ws2);
    tt(Ws2, OBJECT_REPLACEMENT, Ws2);
    const Emoji = tr2(Start, EMOJI, EMOJI$1, {
      [emoji]: true
    });
    tt(Emoji, "#");
    tr2(Emoji, EMOJI, Emoji);
    tt(Emoji, EMOJI_VARIATION, Emoji);
    const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
    tt(EmojiJoiner, "#");
    tr2(EmojiJoiner, EMOJI, Emoji);
    const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];
    const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];
    for (let i = 0; i < tlds.length; i++) {
      fastts(Start, tlds[i], TLD, WORD, wordjr);
    }
    for (let i = 0; i < utlds.length; i++) {
      fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
    }
    addToGroups(TLD, {
      tld: true,
      ascii: true
    }, groups);
    addToGroups(UTLD, {
      utld: true,
      alpha: true
    }, groups);
    fastts(Start, "file", SCHEME, WORD, wordjr);
    fastts(Start, "mailto", SCHEME, WORD, wordjr);
    fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
    fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
    fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
    fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
    addToGroups(SCHEME, {
      scheme: true,
      ascii: true
    }, groups);
    addToGroups(SLASH_SCHEME, {
      slashscheme: true,
      ascii: true
    }, groups);
    customSchemes = customSchemes.sort((a2, b) => a2[0] > b[0] ? 1 : -1);
    for (let i = 0; i < customSchemes.length; i++) {
      const sch = customSchemes[i][0];
      const optionalSlashSlash = customSchemes[i][1];
      const flags = optionalSlashSlash ? {
        [scheme]: true
      } : {
        [slashscheme]: true
      };
      if (sch.indexOf("-") >= 0) {
        flags[domain2] = true;
      } else if (!ASCII_LETTER.test(sch)) {
        flags[numeric] = true;
      } else if (DIGIT.test(sch)) {
        flags[asciinumeric] = true;
      } else {
        flags[ascii] = true;
      }
      ts(Start, sch, sch, flags);
    }
    ts(Start, "localhost", LOCALHOST, {
      ascii: true
    });
    Start.jd = new State2(SYM);
    return {
      start: Start,
      tokens: assign({
        groups
      }, tk)
    };
  }
  function run$12(start, str) {
    const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
    const charCount = iterable.length;
    const tokens = [];
    let cursor = 0;
    let charCursor = 0;
    while (charCursor < charCount) {
      let state = start;
      let nextState = null;
      let tokenLength = 0;
      let latestAccepting = null;
      let sinceAccepts = -1;
      let charsSinceAccepts = -1;
      while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
        state = nextState;
        if (state.accepts()) {
          sinceAccepts = 0;
          charsSinceAccepts = 0;
          latestAccepting = state;
        } else if (sinceAccepts >= 0) {
          sinceAccepts += iterable[charCursor].length;
          charsSinceAccepts++;
        }
        tokenLength += iterable[charCursor].length;
        cursor += iterable[charCursor].length;
        charCursor++;
      }
      cursor -= sinceAccepts;
      charCursor -= charsSinceAccepts;
      tokenLength -= sinceAccepts;
      tokens.push({
        t: latestAccepting.t,
        // token type/name
        v: str.slice(cursor - tokenLength, cursor),
        // string value
        s: cursor - tokenLength,
        // start index
        e: cursor
        // end index (excluding)
      });
    }
    return tokens;
  }
  function stringToArray(str) {
    const result = [];
    const len = str.length;
    let index3 = 0;
    while (index3 < len) {
      let first3 = str.charCodeAt(index3);
      let second;
      let char = first3 < 55296 || first3 > 56319 || index3 + 1 === len || (second = str.charCodeAt(index3 + 1)) < 56320 || second > 57343 ? str[index3] : str.slice(index3, index3 + 2);
      result.push(char);
      index3 += char.length;
    }
    return result;
  }
  function fastts(state, input2, t2, defaultt, jr2) {
    let next2;
    const len = input2.length;
    for (let i = 0; i < len - 1; i++) {
      const char = input2[i];
      if (state.j[char]) {
        next2 = state.j[char];
      } else {
        next2 = new State2(defaultt);
        next2.jr = jr2.slice();
        state.j[char] = next2;
      }
      state = next2;
    }
    next2 = new State2(t2);
    next2.jr = jr2.slice();
    state.j[input2[len - 1]] = next2;
    return next2;
  }
  function decodeTlds(encoded) {
    const words = [];
    const stack = [];
    let i = 0;
    let digits = "0123456789";
    while (i < encoded.length) {
      let popDigitCount = 0;
      while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
        popDigitCount++;
      }
      if (popDigitCount > 0) {
        words.push(stack.join(""));
        for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
          stack.pop();
        }
        i += popDigitCount;
      } else {
        stack.push(encoded[i]);
        i++;
      }
    }
    return words;
  }
  var defaults2 = {
    defaultProtocol: "http",
    events: null,
    format: noop,
    formatHref: noop,
    nl2br: false,
    tagName: "a",
    target: null,
    rel: null,
    validate: true,
    truncate: Infinity,
    className: null,
    attributes: null,
    ignoreTags: [],
    render: null
  };
  function Options(opts, defaultRender = null) {
    let o = assign({}, defaults2);
    if (opts) {
      o = assign(o, opts instanceof Options ? opts.o : opts);
    }
    const ignoredTags = o.ignoreTags;
    const uppercaseIgnoredTags = [];
    for (let i = 0; i < ignoredTags.length; i++) {
      uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
    }
    this.o = o;
    if (defaultRender) {
      this.defaultRender = defaultRender;
    }
    this.ignoreTags = uppercaseIgnoredTags;
  }
  Options.prototype = {
    o: defaults2,
    /**
     * @type string[]
     */
    ignoreTags: [],
    /**
     * @param {IntermediateRepresentation} ir
     * @returns {any}
     */
    defaultRender(ir2) {
      return ir2;
    },
    /**
     * Returns true or false based on whether a token should be displayed as a
     * link based on the user options.
     * @param {MultiToken} token
     * @returns {boolean}
     */
    check(token) {
      return this.get("validate", token.toString(), token);
    },
    // Private methods
    /**
     * Resolve an option's value based on the value of the option and the given
     * params. If operator and token are specified and the target option is
     * callable, automatically calls the function with the given argument.
     * @template {keyof Opts} K
     * @param {K} key Name of option to use
     * @param {string} [operator] will be passed to the target option if it's a
     * function. If not specified, RAW function value gets returned
     * @param {MultiToken} [token] The token from linkify.tokenize
     * @returns {Opts[K] | any}
     */
    get(key2, operator, token) {
      const isCallable = operator != null;
      let option2 = this.o[key2];
      if (!option2) {
        return option2;
      }
      if (typeof option2 === "object") {
        option2 = token.t in option2 ? option2[token.t] : defaults2[key2];
        if (typeof option2 === "function" && isCallable) {
          option2 = option2(operator, token);
        }
      } else if (typeof option2 === "function" && isCallable) {
        option2 = option2(operator, token.t, token);
      }
      return option2;
    },
    /**
     * @template {keyof Opts} L
     * @param {L} key Name of options object to use
     * @param {string} [operator]
     * @param {MultiToken} [token]
     * @returns {Opts[L] | any}
     */
    getObj(key2, operator, token) {
      let obj = this.o[key2];
      if (typeof obj === "function" && operator != null) {
        obj = obj(operator, token.t, token);
      }
      return obj;
    },
    /**
     * Convert the given token to a rendered element that may be added to the
     * calling-interface's DOM
     * @param {MultiToken} token Token to render to an HTML element
     * @returns {any} Render result; e.g., HTML string, DOM element, React
     *   Component, etc.
     */
    render(token) {
      const ir2 = token.render(this);
      const renderFn = this.get("render", null, token) || this.defaultRender;
      return renderFn(ir2, token.t, token);
    }
  };
  function noop(val) {
    return val;
  }
  var options = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Options,
    assign,
    defaults: defaults2
  });
  function MultiToken(value, tokens) {
    this.t = "token";
    this.v = value;
    this.tk = tokens;
  }
  MultiToken.prototype = {
    isLink: false,
    /**
     * Return the string this token represents.
     * @return {string}
     */
    toString() {
      return this.v;
    },
    /**
     * What should the value for this token be in the `href` HTML attribute?
     * Returns the `.toString` value by default.
     * @param {string} [scheme]
     * @return {string}
     */
    toHref(scheme2) {
      return this.toString();
    },
    /**
     * @param {Options} options Formatting options
     * @returns {string}
     */
    toFormattedString(options2) {
      const val = this.toString();
      const truncate = options2.get("truncate", val, this);
      const formatted = options2.get("format", val, this);
      return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "\u2026" : formatted;
    },
    /**
     *
     * @param {Options} options
     * @returns {string}
     */
    toFormattedHref(options2) {
      return options2.get("formatHref", this.toHref(options2.get("defaultProtocol")), this);
    },
    /**
     * The start index of this token in the original input string
     * @returns {number}
     */
    startIndex() {
      return this.tk[0].s;
    },
    /**
     * The end index of this token in the original input string (up to this
     * index but not including it)
     * @returns {number}
     */
    endIndex() {
      return this.tk[this.tk.length - 1].e;
    },
    /**
    	Returns an object  of relevant values for this token, which includes keys
    	* type - Kind of token ('url', 'email', etc.)
    	* value - Original text
    	* href - The value that should be added to the anchor tag's href
    		attribute
    		@method toObject
    	@param {string} [protocol] `'http'` by default
    */
    toObject(protocol = defaults2.defaultProtocol) {
      return {
        type: this.t,
        value: this.toString(),
        isLink: this.isLink,
        href: this.toHref(protocol),
        start: this.startIndex(),
        end: this.endIndex()
      };
    },
    /**
     *
     * @param {Options} options Formatting option
     */
    toFormattedObject(options2) {
      return {
        type: this.t,
        value: this.toFormattedString(options2),
        isLink: this.isLink,
        href: this.toFormattedHref(options2),
        start: this.startIndex(),
        end: this.endIndex()
      };
    },
    /**
     * Whether this token should be rendered as a link according to the given options
     * @param {Options} options
     * @returns {boolean}
     */
    validate(options2) {
      return options2.get("validate", this.toString(), this);
    },
    /**
     * Return an object that represents how this link should be rendered.
     * @param {Options} options Formattinng options
     */
    render(options2) {
      const token = this;
      const href = this.toHref(options2.get("defaultProtocol"));
      const formattedHref = options2.get("formatHref", href, this);
      const tagName = options2.get("tagName", href, token);
      const content5 = this.toFormattedString(options2);
      const attributes = {};
      const className = options2.get("className", href, token);
      const target = options2.get("target", href, token);
      const rel = options2.get("rel", href, token);
      const attrs = options2.getObj("attributes", href, token);
      const eventListeners = options2.getObj("events", href, token);
      attributes.href = formattedHref;
      if (className) {
        attributes.class = className;
      }
      if (target) {
        attributes.target = target;
      }
      if (rel) {
        attributes.rel = rel;
      }
      if (attrs) {
        assign(attributes, attrs);
      }
      return {
        tagName,
        attributes,
        content: content5,
        eventListeners
      };
    }
  };
  function createTokenClass(type, props) {
    class Token extends MultiToken {
      constructor(value, tokens) {
        super(value, tokens);
        this.t = type;
      }
    }
    for (const p5 in props) {
      Token.prototype[p5] = props[p5];
    }
    Token.t = type;
    return Token;
  }
  var Email = createTokenClass("email", {
    isLink: true,
    toHref() {
      return "mailto:" + this.toString();
    }
  });
  var Text = createTokenClass("text");
  var Nl = createTokenClass("nl");
  var Url = createTokenClass("url", {
    isLink: true,
    /**
    	Lowercases relevant parts of the domain and adds the protocol if
    	required. Note that this will not escape unsafe HTML characters in the
    	URL.
    		@param {string} [scheme] default scheme (e.g., 'https')
    	@return {string} the full href
    */
    toHref(scheme2 = defaults2.defaultProtocol) {
      return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
    },
    /**
     * Check whether this URL token has a protocol
     * @return {boolean}
     */
    hasProtocol() {
      const tokens = this.tk;
      return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
    }
  });
  var multi = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Base: MultiToken,
    Email,
    MultiToken,
    Nl,
    Text,
    Url,
    createTokenClass
  });
  var makeState = (arg) => new State2(arg);
  function init$1({
    groups
  }) {
    const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
    const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
    const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
    const Start = makeState();
    const Localpart = tt(Start, TILDE);
    ta(Localpart, localpartAccepting, Localpart);
    ta(Localpart, groups.domain, Localpart);
    const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
    ta(Start, groups.domain, Domain);
    ta(Start, groups.scheme, Scheme);
    ta(Start, groups.slashscheme, SlashScheme);
    ta(Domain, localpartAccepting, Localpart);
    ta(Domain, groups.domain, Domain);
    const LocalpartAt = tt(Domain, AT);
    tt(Localpart, AT, LocalpartAt);
    tt(Scheme, AT, LocalpartAt);
    tt(SlashScheme, AT, LocalpartAt);
    const LocalpartDot = tt(Localpart, DOT);
    ta(LocalpartDot, localpartAccepting, Localpart);
    ta(LocalpartDot, groups.domain, Localpart);
    const EmailDomain = makeState();
    ta(LocalpartAt, groups.domain, EmailDomain);
    ta(EmailDomain, groups.domain, EmailDomain);
    const EmailDomainDot = tt(EmailDomain, DOT);
    ta(EmailDomainDot, groups.domain, EmailDomain);
    const Email$1 = makeState(Email);
    ta(EmailDomainDot, groups.tld, Email$1);
    ta(EmailDomainDot, groups.utld, Email$1);
    tt(LocalpartAt, LOCALHOST, Email$1);
    const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
    tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);
    ta(EmailDomainHyphen, groups.domain, EmailDomain);
    ta(Email$1, groups.domain, EmailDomain);
    tt(Email$1, DOT, EmailDomainDot);
    tt(Email$1, HYPHEN, EmailDomainHyphen);
    const EmailColon = tt(Email$1, COLON);
    ta(EmailColon, groups.numeric, Email);
    const DomainHyphen = tt(Domain, HYPHEN);
    const DomainDot = tt(Domain, DOT);
    tt(DomainHyphen, HYPHEN, DomainHyphen);
    ta(DomainHyphen, groups.domain, Domain);
    ta(DomainDot, localpartAccepting, Localpart);
    ta(DomainDot, groups.domain, Domain);
    const DomainDotTld = makeState(Url);
    ta(DomainDot, groups.tld, DomainDotTld);
    ta(DomainDot, groups.utld, DomainDotTld);
    ta(DomainDotTld, groups.domain, Domain);
    ta(DomainDotTld, localpartAccepting, Localpart);
    tt(DomainDotTld, DOT, DomainDot);
    tt(DomainDotTld, HYPHEN, DomainHyphen);
    tt(DomainDotTld, AT, LocalpartAt);
    const DomainDotTldColon = tt(DomainDotTld, COLON);
    const DomainDotTldColonPort = makeState(Url);
    ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
    const Url$1 = makeState(Url);
    const UrlNonaccept = makeState();
    ta(Url$1, qsAccepting, Url$1);
    ta(Url$1, qsNonAccepting, UrlNonaccept);
    ta(UrlNonaccept, qsAccepting, Url$1);
    ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
    tt(DomainDotTld, SLASH, Url$1);
    tt(DomainDotTldColonPort, SLASH, Url$1);
    const SchemeColon = tt(Scheme, COLON);
    const SlashSchemeColon = tt(SlashScheme, COLON);
    const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
    const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
    ta(Scheme, groups.domain, Domain);
    tt(Scheme, DOT, DomainDot);
    tt(Scheme, HYPHEN, DomainHyphen);
    ta(SlashScheme, groups.domain, Domain);
    tt(SlashScheme, DOT, DomainDot);
    tt(SlashScheme, HYPHEN, DomainHyphen);
    ta(SchemeColon, groups.domain, Url$1);
    tt(SchemeColon, SLASH, Url$1);
    tt(SchemeColon, QUERY, Url$1);
    ta(UriPrefix, groups.domain, Url$1);
    ta(UriPrefix, qsAccepting, Url$1);
    tt(UriPrefix, SLASH, Url$1);
    const bracketPairs = [
      [OPENBRACE, CLOSEBRACE],
      // {}
      [OPENBRACKET, CLOSEBRACKET],
      // []
      [OPENPAREN, CLOSEPAREN],
      // ()
      [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
      // <>
      [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
      // 
      [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
      // 
      [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
      // 
      [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
      // 
    ];
    for (let i = 0; i < bracketPairs.length; i++) {
      const [OPEN, CLOSE] = bracketPairs[i];
      const UrlOpen = tt(Url$1, OPEN);
      tt(UrlNonaccept, OPEN, UrlOpen);
      tt(UrlOpen, CLOSE, Url$1);
      const UrlOpenQ = makeState(Url);
      ta(UrlOpen, qsAccepting, UrlOpenQ);
      const UrlOpenSyms = makeState();
      ta(UrlOpen, qsNonAccepting);
      ta(UrlOpenQ, qsAccepting, UrlOpenQ);
      ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
      ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
      ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
      tt(UrlOpenQ, CLOSE, Url$1);
      tt(UrlOpenSyms, CLOSE, Url$1);
    }
    tt(Start, LOCALHOST, DomainDotTld);
    tt(Start, NL, Nl);
    return {
      start: Start,
      tokens: tk
    };
  }
  function run2(start, input2, tokens) {
    let len = tokens.length;
    let cursor = 0;
    let multis = [];
    let textTokens = [];
    while (cursor < len) {
      let state = start;
      let secondState = null;
      let nextState = null;
      let multiLength = 0;
      let latestAccepting = null;
      let sinceAccepts = -1;
      while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
        textTokens.push(tokens[cursor++]);
      }
      while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
        secondState = null;
        state = nextState;
        if (state.accepts()) {
          sinceAccepts = 0;
          latestAccepting = state;
        } else if (sinceAccepts >= 0) {
          sinceAccepts++;
        }
        cursor++;
        multiLength++;
      }
      if (sinceAccepts < 0) {
        cursor -= multiLength;
        if (cursor < len) {
          textTokens.push(tokens[cursor]);
          cursor++;
        }
      } else {
        if (textTokens.length > 0) {
          multis.push(initMultiToken(Text, input2, textTokens));
          textTokens = [];
        }
        cursor -= sinceAccepts;
        multiLength -= sinceAccepts;
        const Multi = latestAccepting.t;
        const subtokens = tokens.slice(cursor - multiLength, cursor);
        multis.push(initMultiToken(Multi, input2, subtokens));
      }
    }
    if (textTokens.length > 0) {
      multis.push(initMultiToken(Text, input2, textTokens));
    }
    return multis;
  }
  function initMultiToken(Multi, input2, tokens) {
    const startIdx = tokens[0].s;
    const endIdx = tokens[tokens.length - 1].e;
    const value = input2.slice(startIdx, endIdx);
    return new Multi(value, tokens);
  }
  var warn = typeof console !== "undefined" && console && console.warn || (() => {
  });
  var warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
  var INIT = {
    scanner: null,
    parser: null,
    tokenQueue: [],
    pluginQueue: [],
    customSchemes: [],
    initialized: false
  };
  function reset() {
    State2.groups = {};
    INIT.scanner = null;
    INIT.parser = null;
    INIT.tokenQueue = [];
    INIT.pluginQueue = [];
    INIT.customSchemes = [];
    INIT.initialized = false;
    return INIT;
  }
  function registerTokenPlugin(name, plugin) {
    if (typeof plugin !== "function") {
      throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);
    }
    for (let i = 0; i < INIT.tokenQueue.length; i++) {
      if (name === INIT.tokenQueue[i][0]) {
        warn(`linkifyjs: token plugin "${name}" already registered - will be overwritten`);
        INIT.tokenQueue[i] = [name, plugin];
        return;
      }
    }
    INIT.tokenQueue.push([name, plugin]);
    if (INIT.initialized) {
      warn(`linkifyjs: already initialized - will not register token plugin "${name}" ${warnAdvice}`);
    }
  }
  function registerPlugin(name, plugin) {
    if (typeof plugin !== "function") {
      throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);
    }
    for (let i = 0; i < INIT.pluginQueue.length; i++) {
      if (name === INIT.pluginQueue[i][0]) {
        warn(`linkifyjs: plugin "${name}" already registered - will be overwritten`);
        INIT.pluginQueue[i] = [name, plugin];
        return;
      }
    }
    INIT.pluginQueue.push([name, plugin]);
    if (INIT.initialized) {
      warn(`linkifyjs: already initialized - will not register plugin "${name}" ${warnAdvice}`);
    }
  }
  function registerCustomProtocol(scheme2, optionalSlashSlash = false) {
    if (INIT.initialized) {
      warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
    }
    if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
      throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
    }
    INIT.customSchemes.push([scheme2, optionalSlashSlash]);
  }
  function init() {
    INIT.scanner = init$2(INIT.customSchemes);
    for (let i = 0; i < INIT.tokenQueue.length; i++) {
      INIT.tokenQueue[i][1]({
        scanner: INIT.scanner
      });
    }
    INIT.parser = init$1(INIT.scanner.tokens);
    for (let i = 0; i < INIT.pluginQueue.length; i++) {
      INIT.pluginQueue[i][1]({
        scanner: INIT.scanner,
        parser: INIT.parser
      });
    }
    INIT.initialized = true;
    return INIT;
  }
  function tokenize(str) {
    if (!INIT.initialized) {
      init();
    }
    return run2(INIT.parser.start, str, run$12(INIT.scanner.start, str));
  }
  tokenize.scan = run$12;
  function find2(str, type = null, opts = null) {
    if (type && typeof type === "object") {
      if (opts) {
        throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
      }
      opts = type;
      type = null;
    }
    const options2 = new Options(opts);
    const tokens = tokenize(str);
    const filtered = [];
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (token.isLink && (!type || token.t === type) && options2.check(token)) {
        filtered.push(token.toFormattedObject(options2));
      }
    }
    return filtered;
  }
  function test(str, type = null) {
    const tokens = tokenize(str);
    return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);
  }

  // node_modules/@tiptap/extension-link/dist/index.js
  function isValidLinkStructure(tokens) {
    if (tokens.length === 1) {
      return tokens[0].isLink;
    }
    if (tokens.length === 3 && tokens[1].isLink) {
      return ["()", "[]"].includes(tokens[0].value + tokens[2].value);
    }
    return false;
  }
  function autolink2(options2) {
    return new Plugin({
      key: new PluginKey("autolink"),
      appendTransaction: (transactions, oldState, newState) => {
        const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
        const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
        if (!docChanges || preventAutolink) {
          return;
        }
        const { tr: tr3 } = newState;
        const transform2 = combineTransactionSteps(oldState.doc, [...transactions]);
        const changes = getChangedRanges(transform2);
        changes.forEach(({ newRange }) => {
          const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node2) => node2.isTextblock);
          let textBlock;
          let textBeforeWhitespace;
          if (nodesInChangedRanges.length > 1) {
            textBlock = nodesInChangedRanges[0];
            textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
          } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
            textBlock = nodesInChangedRanges[0];
            textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
          }
          if (textBlock && textBeforeWhitespace) {
            const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s2) => s2 !== "");
            if (wordsBeforeWhitespace.length <= 0) {
              return false;
            }
            const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
            const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
            if (!lastWordBeforeSpace) {
              return false;
            }
            const linksBeforeSpace = tokenize(lastWordBeforeSpace).map((t2) => t2.toObject(options2.defaultProtocol));
            if (!isValidLinkStructure(linksBeforeSpace)) {
              return false;
            }
            linksBeforeSpace.filter((link3) => link3.isLink).map((link3) => ({
              ...link3,
              from: lastWordAndBlockOffset + link3.start + 1,
              to: lastWordAndBlockOffset + link3.end + 1
            })).filter((link3) => {
              if (!newState.schema.marks.code) {
                return true;
              }
              return !newState.doc.rangeHasMark(link3.from, link3.to, newState.schema.marks.code);
            }).filter((link3) => options2.validate(link3.value)).filter((link3) => options2.shouldAutoLink(link3.value)).forEach((link3) => {
              if (getMarksBetween(link3.from, link3.to, newState.doc).some((item) => item.mark.type === options2.type)) {
                return;
              }
              tr3.addMark(link3.from, link3.to, options2.type.create({
                href: link3.href
              }));
            });
          }
        });
        if (!tr3.steps.length) {
          return;
        }
        return tr3;
      }
    });
  }
  function clickHandler(options2) {
    return new Plugin({
      key: new PluginKey("handleClickLink"),
      props: {
        handleClick: (view, pos, event) => {
          var _a3, _b;
          if (event.button !== 0) {
            return false;
          }
          if (!view.editable) {
            return false;
          }
          let a2 = event.target;
          const els = [];
          while (a2.nodeName !== "DIV") {
            els.push(a2);
            a2 = a2.parentNode;
          }
          if (!els.find((value) => value.nodeName === "A")) {
            return false;
          }
          const attrs = getAttributes(view.state, options2.type.name);
          const link3 = event.target;
          const href = (_a3 = link3 === null || link3 === void 0 ? void 0 : link3.href) !== null && _a3 !== void 0 ? _a3 : attrs.href;
          const target = (_b = link3 === null || link3 === void 0 ? void 0 : link3.target) !== null && _b !== void 0 ? _b : attrs.target;
          if (link3 && href) {
            window.open(href, target);
            return true;
          }
          return false;
        }
      }
    });
  }
  function pasteHandler(options2) {
    return new Plugin({
      key: new PluginKey("handlePasteLink"),
      props: {
        handlePaste: (view, event, slice2) => {
          const { state } = view;
          const { selection } = state;
          const { empty: empty4 } = selection;
          if (empty4) {
            return false;
          }
          let textContent = "";
          slice2.content.forEach((node2) => {
            textContent += node2.textContent;
          });
          const link3 = find2(textContent, { defaultProtocol: options2.defaultProtocol }).find((item) => item.isLink && item.value === textContent);
          if (!textContent || !link3) {
            return false;
          }
          return options2.editor.commands.setMark(options2.type, {
            href: link3.href
          });
        }
      }
    });
  }
  var pasteRegex3 = /https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z]{2,}\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;
  var ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
  function isAllowedUri(uri, protocols) {
    const allowedProtocols = [
      "http",
      "https",
      "ftp",
      "ftps",
      "mailto",
      "tel",
      "callto",
      "sms",
      "cid",
      "xmpp"
    ];
    if (protocols) {
      protocols.forEach((protocol) => {
        const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
        if (nextProtocol) {
          allowedProtocols.push(nextProtocol);
        }
      });
    }
    return !uri || uri.replace(ATTR_WHITESPACE, "").match(new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    ));
  }
  var Link = Mark2.create({
    name: "link",
    priority: 1e3,
    keepOnSplit: false,
    exitable: true,
    onCreate() {
      if (this.options.validate && !this.options.shouldAutoLink) {
        this.options.shouldAutoLink = this.options.validate;
        console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.");
      }
      this.options.protocols.forEach((protocol) => {
        if (typeof protocol === "string") {
          registerCustomProtocol(protocol);
          return;
        }
        registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
      });
    },
    onDestroy() {
      reset();
    },
    inclusive() {
      return this.options.autolink;
    },
    addOptions() {
      return {
        openOnClick: true,
        linkOnPaste: true,
        autolink: true,
        protocols: [],
        defaultProtocol: "http",
        HTMLAttributes: {
          target: "_blank",
          rel: "noopener noreferrer nofollow",
          class: null
        },
        isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),
        validate: (url) => !!url,
        shouldAutoLink: (url) => !!url
      };
    },
    addAttributes() {
      return {
        href: {
          default: null,
          parseHTML(element7) {
            return element7.getAttribute("href");
          }
        },
        target: {
          default: this.options.HTMLAttributes.target
        },
        rel: {
          default: this.options.HTMLAttributes.rel
        },
        class: {
          default: this.options.HTMLAttributes.class
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "a[href]",
          getAttrs: (dom) => {
            const href = dom.getAttribute("href");
            if (!href || !this.options.isAllowedUri(href, {
              defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
              protocols: this.options.protocols,
              defaultProtocol: this.options.defaultProtocol
            })) {
              return false;
            }
            return null;
          }
        }
      ];
    },
    renderHTML({ HTMLAttributes }) {
      if (!this.options.isAllowedUri(HTMLAttributes.href, {
        defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),
        protocols: this.options.protocols,
        defaultProtocol: this.options.defaultProtocol
      })) {
        return [
          "a",
          mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }),
          0
        ];
      }
      return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
    },
    addCommands() {
      return {
        setLink: (attributes) => ({ chain }) => {
          const { href } = attributes;
          if (!this.options.isAllowedUri(href, {
            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          })) {
            return false;
          }
          return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
        },
        toggleLink: (attributes) => ({ chain }) => {
          const { href } = attributes;
          if (!this.options.isAllowedUri(href, {
            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          })) {
            return false;
          }
          return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
        },
        unsetLink: () => ({ chain }) => {
          return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
        }
      };
    },
    addPasteRules() {
      return [
        markPasteRule({
          find: (text10) => {
            const foundLinks = [];
            if (text10) {
              const { protocols, defaultProtocol } = this.options;
              const links = find2(text10).filter((item) => item.isLink && this.options.isAllowedUri(item.value, {
                defaultValidate: (href) => !!isAllowedUri(href, protocols),
                protocols,
                defaultProtocol
              }));
              if (links.length) {
                links.forEach((link3) => foundLinks.push({
                  text: link3.value,
                  data: {
                    href: link3.href
                  },
                  index: link3.start
                }));
              }
            }
            return foundLinks;
          },
          type: this.type,
          getAttributes: (match) => {
            var _a3;
            return {
              href: (_a3 = match.data) === null || _a3 === void 0 ? void 0 : _a3.href
            };
          }
        })
      ];
    },
    addProseMirrorPlugins() {
      const plugins = [];
      const { protocols, defaultProtocol } = this.options;
      if (this.options.autolink) {
        plugins.push(autolink2({
          type: this.type,
          defaultProtocol: this.options.defaultProtocol,
          validate: (url) => this.options.isAllowedUri(url, {
            defaultValidate: (href) => !!isAllowedUri(href, protocols),
            protocols,
            defaultProtocol
          }),
          shouldAutoLink: this.options.shouldAutoLink
        }));
      }
      if (this.options.openOnClick === true) {
        plugins.push(clickHandler({
          type: this.type
        }));
      }
      if (this.options.linkOnPaste) {
        plugins.push(pasteHandler({
          editor: this.editor,
          defaultProtocol: this.options.defaultProtocol,
          type: this.type
        }));
      }
      return plugins;
    }
  });

  // node_modules/@tiptap/extension-text/dist/index.js
  var Text2 = Node3.create({
    name: "text",
    group: "inline"
  });

  // node_modules/lib0/map.js
  var create5 = () => /* @__PURE__ */ new Map();
  var copy2 = (m) => {
    const r = create5();
    m.forEach((v2, k) => {
      r.set(k, v2);
    });
    return r;
  };
  var setIfUndefined = (map9, key2, createT) => {
    let set2 = map9.get(key2);
    if (set2 === void 0) {
      map9.set(key2, set2 = createT());
    }
    return set2;
  };
  var map5 = (m, f) => {
    const res = [];
    for (const [key2, value] of m) {
      res.push(f(value, key2));
    }
    return res;
  };
  var any = (m, f) => {
    for (const [key2, value] of m) {
      if (f(value, key2)) {
        return true;
      }
    }
    return false;
  };
  var all8 = (m, f) => {
    for (const [key2, value] of m) {
      if (!f(value, key2)) {
        return false;
      }
    }
    return true;
  };

  // node_modules/lib0/set.js
  var create6 = () => /* @__PURE__ */ new Set();
  var toArray = (set2) => Array.from(set2);
  var first2 = (set2) => set2.values().next().value ?? void 0;
  var from2 = (entries) => new Set(entries);

  // node_modules/lib0/array.js
  var last = (arr) => arr[arr.length - 1];
  var create7 = () => (
    /** @type {Array<C>} */
    []
  );
  var copy3 = (a2) => (
    /** @type {Array<D>} */
    a2.slice()
  );
  var appendTo = (dest, src) => {
    for (let i = 0; i < src.length; i++) {
      dest.push(src[i]);
    }
  };
  var from3 = Array.from;
  var every = (arr, f) => {
    for (let i = 0; i < arr.length; i++) {
      if (!f(arr[i], i, arr)) {
        return false;
      }
    }
    return true;
  };
  var some = (arr, f) => {
    for (let i = 0; i < arr.length; i++) {
      if (f(arr[i], i, arr)) {
        return true;
      }
    }
    return false;
  };
  var equalFlat = (a2, b) => a2.length === b.length && every(a2, (item, index3) => item === b[index3]);
  var flatten2 = (arr) => fold(
    arr,
    /** @type {Array<ELEM>} */
    [],
    (acc, val) => acc.concat(val)
  );
  var unfold = (len, f) => {
    const array = new Array(len);
    for (let i = 0; i < len; i++) {
      array[i] = f(i, array);
    }
    return array;
  };
  var fold = (arr, seed, folder) => arr.reduce(folder, seed);
  var isArray = Array.isArray;
  var unique = (arr) => from3(from2(arr));
  var uniqueBy = (arr, mapper) => {
    const happened = create6();
    const result = [];
    for (let i = 0; i < arr.length; i++) {
      const el = arr[i];
      const mapped = mapper(el);
      if (!happened.has(mapped)) {
        happened.add(mapped);
        result.push(el);
      }
    }
    return result;
  };
  var map6 = (arr, mapper) => {
    const res = Array(arr.length);
    for (let i = 0; i < arr.length; i++) {
      res[i] = mapper(
        /** @type {any} */
        arr[i],
        i,
        /** @type {any} */
        arr
      );
    }
    return (
      /** @type {any} */
      res
    );
  };
  var bubblesortItem = (arr, i, compareFn) => {
    const n = arr[i];
    let j2 = i;
    while (j2 + 1 < arr.length && compareFn(n, arr[j2 + 1]) > 0) {
      arr[j2] = arr[j2 + 1];
      arr[++j2] = n;
    }
    if (i === j2 && j2 > 0) {
      while (j2 > 0 && compareFn(arr[j2 - 1], n) > 0) {
        arr[j2] = arr[j2 - 1];
        arr[--j2] = n;
      }
    }
    return j2;
  };

  // node_modules/lib0/observable.js
  var ObservableV2 = class {
    constructor() {
      this._observers = create5();
    }
    /**
     * @template {keyof EVENTS & string} NAME
     * @param {NAME} name
     * @param {EVENTS[NAME]} f
     */
    on(name, f) {
      setIfUndefined(
        this._observers,
        /** @type {string} */
        name,
        create6
      ).add(f);
      return f;
    }
    /**
     * @template {keyof EVENTS & string} NAME
     * @param {NAME} name
     * @param {EVENTS[NAME]} f
     */
    once(name, f) {
      const _f = (...args2) => {
        this.off(
          name,
          /** @type {any} */
          _f
        );
        f(...args2);
      };
      this.on(
        name,
        /** @type {any} */
        _f
      );
    }
    /**
     * @template {keyof EVENTS & string} NAME
     * @param {NAME} name
     * @param {EVENTS[NAME]} f
     */
    off(name, f) {
      const observers = this._observers.get(name);
      if (observers !== void 0) {
        observers.delete(f);
        if (observers.size === 0) {
          this._observers.delete(name);
        }
      }
    }
    /**
     * Emit a named event. All registered event listeners that listen to the
     * specified name will receive the event.
     *
     * @todo This should catch exceptions
     *
     * @template {keyof EVENTS & string} NAME
     * @param {NAME} name The event name.
     * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
     */
    emit(name, args2) {
      return from3((this._observers.get(name) || create5()).values()).forEach((f) => f(...args2));
    }
    destroy() {
      this._observers = create5();
    }
  };
  var Observable = class {
    constructor() {
      this._observers = create5();
    }
    /**
     * @param {N} name
     * @param {function} f
     */
    on(name, f) {
      setIfUndefined(this._observers, name, create6).add(f);
    }
    /**
     * @param {N} name
     * @param {function} f
     */
    once(name, f) {
      const _f = (...args2) => {
        this.off(name, _f);
        f(...args2);
      };
      this.on(name, _f);
    }
    /**
     * @param {N} name
     * @param {function} f
     */
    off(name, f) {
      const observers = this._observers.get(name);
      if (observers !== void 0) {
        observers.delete(f);
        if (observers.size === 0) {
          this._observers.delete(name);
        }
      }
    }
    /**
     * Emit a named event. All registered event listeners that listen to the
     * specified name will receive the event.
     *
     * @todo This should catch exceptions
     *
     * @param {N} name The event name.
     * @param {Array<any>} args The arguments that are applied to the event listener.
     */
    emit(name, args2) {
      return from3((this._observers.get(name) || create5()).values()).forEach((f) => f(...args2));
    }
    destroy() {
      this._observers = create5();
    }
  };

  // node_modules/lib0/math.js
  var floor = Math.floor;
  var ceil = Math.ceil;
  var abs = Math.abs;
  var imul = Math.imul;
  var round = Math.round;
  var log10 = Math.log10;
  var log2 = Math.log2;
  var log = Math.log;
  var sqrt = Math.sqrt;
  var add2 = (a2, b) => a2 + b;
  var min = (a2, b) => a2 < b ? a2 : b;
  var max = (a2, b) => a2 > b ? a2 : b;
  var isNaN = Number.isNaN;
  var pow = Math.pow;
  var exp10 = (exp) => Math.pow(10, exp);
  var sign = Math.sign;
  var isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;

  // node_modules/lib0/binary.js
  var BIT1 = 1;
  var BIT2 = 2;
  var BIT3 = 4;
  var BIT4 = 8;
  var BIT5 = 16;
  var BIT6 = 32;
  var BIT7 = 64;
  var BIT8 = 128;
  var BIT9 = 256;
  var BIT10 = 512;
  var BIT11 = 1024;
  var BIT12 = 2048;
  var BIT13 = 4096;
  var BIT14 = 8192;
  var BIT15 = 16384;
  var BIT16 = 32768;
  var BIT17 = 65536;
  var BIT18 = 1 << 17;
  var BIT19 = 1 << 18;
  var BIT20 = 1 << 19;
  var BIT21 = 1 << 20;
  var BIT22 = 1 << 21;
  var BIT23 = 1 << 22;
  var BIT24 = 1 << 23;
  var BIT25 = 1 << 24;
  var BIT26 = 1 << 25;
  var BIT27 = 1 << 26;
  var BIT28 = 1 << 27;
  var BIT29 = 1 << 28;
  var BIT30 = 1 << 29;
  var BIT31 = 1 << 30;
  var BIT32 = 1 << 31;
  var BITS0 = 0;
  var BITS1 = 1;
  var BITS2 = 3;
  var BITS3 = 7;
  var BITS4 = 15;
  var BITS5 = 31;
  var BITS6 = 63;
  var BITS7 = 127;
  var BITS8 = 255;
  var BITS9 = 511;
  var BITS10 = 1023;
  var BITS11 = 2047;
  var BITS12 = 4095;
  var BITS13 = 8191;
  var BITS14 = 16383;
  var BITS15 = 32767;
  var BITS16 = 65535;
  var BITS17 = BIT18 - 1;
  var BITS18 = BIT19 - 1;
  var BITS19 = BIT20 - 1;
  var BITS20 = BIT21 - 1;
  var BITS21 = BIT22 - 1;
  var BITS22 = BIT23 - 1;
  var BITS23 = BIT24 - 1;
  var BITS24 = BIT25 - 1;
  var BITS25 = BIT26 - 1;
  var BITS26 = BIT27 - 1;
  var BITS27 = BIT28 - 1;
  var BITS28 = BIT29 - 1;
  var BITS29 = BIT30 - 1;
  var BITS30 = BIT31 - 1;
  var BITS31 = 2147483647;
  var BITS32 = 4294967295;

  // node_modules/lib0/number.js
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
  var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
  var LOWEST_INT32 = 1 << 31;
  var HIGHEST_INT32 = BITS31;
  var HIGHEST_UINT32 = BITS32;
  var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
  var isNaN2 = Number.isNaN;
  var parseInt2 = Number.parseInt;
  var countBits = (n) => {
    n &= BITS32;
    let count = 0;
    while (n) {
      n &= n - 1;
      count++;
    }
    return count;
  };

  // node_modules/lib0/string.js
  var fromCharCode = String.fromCharCode;
  var fromCodePoint2 = String.fromCodePoint;
  var MAX_UTF16_CHARACTER = fromCharCode(65535);
  var toLowerCase = (s2) => s2.toLowerCase();
  var trimLeftRegex = /^\s*/g;
  var trimLeft = (s2) => s2.replace(trimLeftRegex, "");
  var fromCamelCaseRegex = /([A-Z])/g;
  var fromCamelCase = (s2, separator) => trimLeft(s2.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
  var utf8ByteLength = (str) => unescape(encodeURIComponent(str)).length;
  var _encodeUtf8Polyfill = (str) => {
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    const buf = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      buf[i] = /** @type {number} */
      encodedString.codePointAt(i);
    }
    return buf;
  };
  var utf8TextEncoder = (
    /** @type {TextEncoder} */
    typeof TextEncoder !== "undefined" ? new TextEncoder() : null
  );
  var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
  var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
  var _decodeUtf8Polyfill = (buf) => {
    let remainingLen = buf.length;
    let encodedString = "";
    let bufPos = 0;
    while (remainingLen > 0) {
      const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
      const bytes = buf.subarray(bufPos, bufPos + nextLen);
      bufPos += nextLen;
      encodedString += String.fromCodePoint.apply(
        null,
        /** @type {any} */
        bytes
      );
      remainingLen -= nextLen;
    }
    return decodeURIComponent(escape(encodedString));
  };
  var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
  if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
    utf8TextDecoder = null;
  }
  var _decodeUtf8Native = (buf) => (
    /** @type {TextDecoder} */
    utf8TextDecoder.decode(buf)
  );
  var decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill;
  var splice2 = (str, index3, remove2, insert = "") => str.slice(0, index3) + insert + str.slice(index3 + remove2);
  var repeat = (source, n) => unfold(n, () => source).join("");
  var escapeHTML = (str) => str.replace(/[&<>'"]/g, (r) => (
    /** @type {string} */
    {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "'": "&#39;",
      '"': "&quot;"
    }[r]
  ));
  var unescapeHTML = (str) => str.replace(/&amp;|&lt;|&gt;|&#39;|&quot;/g, (r) => (
    /** @type {string} */
    {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&#39;": "'",
      "&quot;": '"'
    }[r]
  ));

  // node_modules/lib0/encoding.js
  var Encoder = class {
    constructor() {
      this.cpos = 0;
      this.cbuf = new Uint8Array(100);
      this.bufs = [];
    }
  };
  var createEncoder = () => new Encoder();
  var encode2 = (f) => {
    const encoder = createEncoder();
    f(encoder);
    return toUint8Array(encoder);
  };
  var length = (encoder) => {
    let len = encoder.cpos;
    for (let i = 0; i < encoder.bufs.length; i++) {
      len += encoder.bufs[i].length;
    }
    return len;
  };
  var hasContent = (encoder) => encoder.cpos > 0 || encoder.bufs.length > 0;
  var toUint8Array = (encoder) => {
    const uint8arr = new Uint8Array(length(encoder));
    let curPos = 0;
    for (let i = 0; i < encoder.bufs.length; i++) {
      const d = encoder.bufs[i];
      uint8arr.set(d, curPos);
      curPos += d.length;
    }
    uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
    return uint8arr;
  };
  var verifyLen = (encoder, len) => {
    const bufferLen = encoder.cbuf.length;
    if (bufferLen - encoder.cpos < len) {
      encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
      encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
      encoder.cpos = 0;
    }
  };
  var write = (encoder, num) => {
    const bufferLen = encoder.cbuf.length;
    if (encoder.cpos === bufferLen) {
      encoder.bufs.push(encoder.cbuf);
      encoder.cbuf = new Uint8Array(bufferLen * 2);
      encoder.cpos = 0;
    }
    encoder.cbuf[encoder.cpos++] = num;
  };
  var set = (encoder, pos, num) => {
    let buffer = null;
    for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {
      const b = encoder.bufs[i];
      if (pos < b.length) {
        buffer = b;
      } else {
        pos -= b.length;
      }
    }
    if (buffer === null) {
      buffer = encoder.cbuf;
    }
    buffer[pos] = num;
  };
  var writeUint8 = write;
  var setUint8 = set;
  var writeUint16 = (encoder, num) => {
    write(encoder, num & BITS8);
    write(encoder, num >>> 8 & BITS8);
  };
  var setUint16 = (encoder, pos, num) => {
    set(encoder, pos, num & BITS8);
    set(encoder, pos + 1, num >>> 8 & BITS8);
  };
  var writeUint32 = (encoder, num) => {
    for (let i = 0; i < 4; i++) {
      write(encoder, num & BITS8);
      num >>>= 8;
    }
  };
  var writeUint32BigEndian = (encoder, num) => {
    for (let i = 3; i >= 0; i--) {
      write(encoder, num >>> 8 * i & BITS8);
    }
  };
  var setUint32 = (encoder, pos, num) => {
    for (let i = 0; i < 4; i++) {
      set(encoder, pos + i, num & BITS8);
      num >>>= 8;
    }
  };
  var writeVarUint = (encoder, num) => {
    while (num > BITS7) {
      write(encoder, BIT8 | BITS7 & num);
      num = floor(num / 128);
    }
    write(encoder, BITS7 & num);
  };
  var writeVarInt = (encoder, num) => {
    const isNegative = isNegativeZero(num);
    if (isNegative) {
      num = -num;
    }
    write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
    num = floor(num / 64);
    while (num > 0) {
      write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
      num = floor(num / 128);
    }
  };
  var _strBuffer = new Uint8Array(3e4);
  var _maxStrBSize = _strBuffer.length / 3;
  var _writeVarStringNative = (encoder, str) => {
    if (str.length < _maxStrBSize) {
      const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
      writeVarUint(encoder, written);
      for (let i = 0; i < written; i++) {
        write(encoder, _strBuffer[i]);
      }
    } else {
      writeVarUint8Array(encoder, encodeUtf8(str));
    }
  };
  var _writeVarStringPolyfill = (encoder, str) => {
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    writeVarUint(encoder, len);
    for (let i = 0; i < len; i++) {
      write(
        encoder,
        /** @type {number} */
        encodedString.codePointAt(i)
      );
    }
  };
  var writeVarString = utf8TextEncoder && /** @type {any} */
  utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
  var writeTerminatedString = (encoder, str) => writeTerminatedUint8Array(encoder, encodeUtf8(str));
  var writeTerminatedUint8Array = (encoder, buf) => {
    for (let i = 0; i < buf.length; i++) {
      const b = buf[i];
      if (b === 0 || b === 1) {
        write(encoder, 1);
      }
      write(encoder, buf[i]);
    }
    write(encoder, 0);
  };
  var writeBinaryEncoder = (encoder, append3) => writeUint8Array(encoder, toUint8Array(append3));
  var writeUint8Array = (encoder, uint8Array) => {
    const bufferLen = encoder.cbuf.length;
    const cpos = encoder.cpos;
    const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
    const rightCopyLen = uint8Array.length - leftCopyLen;
    encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
    encoder.cpos += leftCopyLen;
    if (rightCopyLen > 0) {
      encoder.bufs.push(encoder.cbuf);
      encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
      encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
      encoder.cpos = rightCopyLen;
    }
  };
  var writeVarUint8Array = (encoder, uint8Array) => {
    writeVarUint(encoder, uint8Array.byteLength);
    writeUint8Array(encoder, uint8Array);
  };
  var writeOnDataView = (encoder, len) => {
    verifyLen(encoder, len);
    const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
    encoder.cpos += len;
    return dview;
  };
  var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
  var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
  var writeBigInt64 = (encoder, num) => (
    /** @type {any} */
    writeOnDataView(encoder, 8).setBigInt64(0, num, false)
  );
  var writeBigUint64 = (encoder, num) => (
    /** @type {any} */
    writeOnDataView(encoder, 8).setBigUint64(0, num, false)
  );
  var floatTestBed = new DataView(new ArrayBuffer(4));
  var isFloat32 = (num) => {
    floatTestBed.setFloat32(0, num);
    return floatTestBed.getFloat32(0) === num;
  };
  var writeAny = (encoder, data) => {
    switch (typeof data) {
      case "string":
        write(encoder, 119);
        writeVarString(encoder, data);
        break;
      case "number":
        if (isInteger(data) && abs(data) <= BITS31) {
          write(encoder, 125);
          writeVarInt(encoder, data);
        } else if (isFloat32(data)) {
          write(encoder, 124);
          writeFloat32(encoder, data);
        } else {
          write(encoder, 123);
          writeFloat64(encoder, data);
        }
        break;
      case "bigint":
        write(encoder, 122);
        writeBigInt64(encoder, data);
        break;
      case "object":
        if (data === null) {
          write(encoder, 126);
        } else if (isArray(data)) {
          write(encoder, 117);
          writeVarUint(encoder, data.length);
          for (let i = 0; i < data.length; i++) {
            writeAny(encoder, data[i]);
          }
        } else if (data instanceof Uint8Array) {
          write(encoder, 116);
          writeVarUint8Array(encoder, data);
        } else {
          write(encoder, 118);
          const keys4 = Object.keys(data);
          writeVarUint(encoder, keys4.length);
          for (let i = 0; i < keys4.length; i++) {
            const key2 = keys4[i];
            writeVarString(encoder, key2);
            writeAny(encoder, data[key2]);
          }
        }
        break;
      case "boolean":
        write(encoder, data ? 120 : 121);
        break;
      default:
        write(encoder, 127);
    }
  };
  var RleEncoder = class extends Encoder {
    /**
     * @param {function(Encoder, T):void} writer
     */
    constructor(writer) {
      super();
      this.w = writer;
      this.s = null;
      this.count = 0;
    }
    /**
     * @param {T} v
     */
    write(v2) {
      if (this.s === v2) {
        this.count++;
      } else {
        if (this.count > 0) {
          writeVarUint(this, this.count - 1);
        }
        this.count = 1;
        this.w(this, v2);
        this.s = v2;
      }
    }
  };
  var IntDiffEncoder = class extends Encoder {
    /**
     * @param {number} start
     */
    constructor(start) {
      super();
      this.s = start;
    }
    /**
     * @param {number} v
     */
    write(v2) {
      writeVarInt(this, v2 - this.s);
      this.s = v2;
    }
  };
  var RleIntDiffEncoder = class extends Encoder {
    /**
     * @param {number} start
     */
    constructor(start) {
      super();
      this.s = start;
      this.count = 0;
    }
    /**
     * @param {number} v
     */
    write(v2) {
      if (this.s === v2 && this.count > 0) {
        this.count++;
      } else {
        if (this.count > 0) {
          writeVarUint(this, this.count - 1);
        }
        this.count = 1;
        writeVarInt(this, v2 - this.s);
        this.s = v2;
      }
    }
  };
  var flushUintOptRleEncoder = (encoder) => {
    if (encoder.count > 0) {
      writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
      if (encoder.count > 1) {
        writeVarUint(encoder.encoder, encoder.count - 2);
      }
    }
  };
  var UintOptRleEncoder = class {
    constructor() {
      this.encoder = new Encoder();
      this.s = 0;
      this.count = 0;
    }
    /**
     * @param {number} v
     */
    write(v2) {
      if (this.s === v2) {
        this.count++;
      } else {
        flushUintOptRleEncoder(this);
        this.count = 1;
        this.s = v2;
      }
    }
    /**
     * Flush the encoded state and transform this to a Uint8Array.
     *
     * Note that this should only be called once.
     */
    toUint8Array() {
      flushUintOptRleEncoder(this);
      return toUint8Array(this.encoder);
    }
  };
  var IncUintOptRleEncoder = class {
    constructor() {
      this.encoder = new Encoder();
      this.s = 0;
      this.count = 0;
    }
    /**
     * @param {number} v
     */
    write(v2) {
      if (this.s + this.count === v2) {
        this.count++;
      } else {
        flushUintOptRleEncoder(this);
        this.count = 1;
        this.s = v2;
      }
    }
    /**
     * Flush the encoded state and transform this to a Uint8Array.
     *
     * Note that this should only be called once.
     */
    toUint8Array() {
      flushUintOptRleEncoder(this);
      return toUint8Array(this.encoder);
    }
  };
  var flushIntDiffOptRleEncoder = (encoder) => {
    if (encoder.count > 0) {
      const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
      writeVarInt(encoder.encoder, encodedDiff);
      if (encoder.count > 1) {
        writeVarUint(encoder.encoder, encoder.count - 2);
      }
    }
  };
  var IntDiffOptRleEncoder = class {
    constructor() {
      this.encoder = new Encoder();
      this.s = 0;
      this.count = 0;
      this.diff = 0;
    }
    /**
     * @param {number} v
     */
    write(v2) {
      if (this.diff === v2 - this.s) {
        this.s = v2;
        this.count++;
      } else {
        flushIntDiffOptRleEncoder(this);
        this.count = 1;
        this.diff = v2 - this.s;
        this.s = v2;
      }
    }
    /**
     * Flush the encoded state and transform this to a Uint8Array.
     *
     * Note that this should only be called once.
     */
    toUint8Array() {
      flushIntDiffOptRleEncoder(this);
      return toUint8Array(this.encoder);
    }
  };
  var StringEncoder = class {
    constructor() {
      this.sarr = [];
      this.s = "";
      this.lensE = new UintOptRleEncoder();
    }
    /**
     * @param {string} string
     */
    write(string3) {
      this.s += string3;
      if (this.s.length > 19) {
        this.sarr.push(this.s);
        this.s = "";
      }
      this.lensE.write(string3.length);
    }
    toUint8Array() {
      const encoder = new Encoder();
      this.sarr.push(this.s);
      this.s = "";
      writeVarString(encoder, this.sarr.join(""));
      writeUint8Array(encoder, this.lensE.toUint8Array());
      return toUint8Array(encoder);
    }
  };

  // node_modules/lib0/error.js
  var create8 = (s2) => new Error(s2);
  var methodUnimplemented = () => {
    throw create8("Method unimplemented");
  };
  var unexpectedCase = () => {
    throw create8("Unexpected case");
  };

  // node_modules/lib0/decoding.js
  var errorUnexpectedEndOfArray = create8("Unexpected end of array");
  var errorIntegerOutOfRange = create8("Integer out of Range");
  var Decoder = class {
    /**
     * @param {Uint8Array} uint8Array Binary data to decode
     */
    constructor(uint8Array) {
      this.arr = uint8Array;
      this.pos = 0;
    }
  };
  var createDecoder = (uint8Array) => new Decoder(uint8Array);
  var hasContent2 = (decoder) => decoder.pos !== decoder.arr.length;
  var clone = (decoder, newPos = decoder.pos) => {
    const _decoder = createDecoder(decoder.arr);
    _decoder.pos = newPos;
    return _decoder;
  };
  var readUint8Array = (decoder, len) => {
    const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
    decoder.pos += len;
    return view;
  };
  var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
  var readTailAsUint8Array = (decoder) => readUint8Array(decoder, decoder.arr.length - decoder.pos);
  var skip8 = (decoder) => decoder.pos++;
  var readUint8 = (decoder) => decoder.arr[decoder.pos++];
  var readUint16 = (decoder) => {
    const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
    decoder.pos += 2;
    return uint;
  };
  var readUint32 = (decoder) => {
    const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
    decoder.pos += 4;
    return uint;
  };
  var readUint32BigEndian = (decoder) => {
    const uint = decoder.arr[decoder.pos + 3] + (decoder.arr[decoder.pos + 2] << 8) + (decoder.arr[decoder.pos + 1] << 16) + (decoder.arr[decoder.pos] << 24) >>> 0;
    decoder.pos += 4;
    return uint;
  };
  var peekUint8 = (decoder) => decoder.arr[decoder.pos];
  var peekUint16 = (decoder) => decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
  var peekUint32 = (decoder) => decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
  var readVarUint = (decoder) => {
    let num = 0;
    let mult = 1;
    const len = decoder.arr.length;
    while (decoder.pos < len) {
      const r = decoder.arr[decoder.pos++];
      num = num + (r & BITS7) * mult;
      mult *= 128;
      if (r < BIT8) {
        return num;
      }
      if (num > MAX_SAFE_INTEGER) {
        throw errorIntegerOutOfRange;
      }
    }
    throw errorUnexpectedEndOfArray;
  };
  var readVarInt = (decoder) => {
    let r = decoder.arr[decoder.pos++];
    let num = r & BITS6;
    let mult = 64;
    const sign2 = (r & BIT7) > 0 ? -1 : 1;
    if ((r & BIT8) === 0) {
      return sign2 * num;
    }
    const len = decoder.arr.length;
    while (decoder.pos < len) {
      r = decoder.arr[decoder.pos++];
      num = num + (r & BITS7) * mult;
      mult *= 128;
      if (r < BIT8) {
        return sign2 * num;
      }
      if (num > MAX_SAFE_INTEGER) {
        throw errorIntegerOutOfRange;
      }
    }
    throw errorUnexpectedEndOfArray;
  };
  var peekVarUint = (decoder) => {
    const pos = decoder.pos;
    const s2 = readVarUint(decoder);
    decoder.pos = pos;
    return s2;
  };
  var peekVarInt = (decoder) => {
    const pos = decoder.pos;
    const s2 = readVarInt(decoder);
    decoder.pos = pos;
    return s2;
  };
  var _readVarStringPolyfill = (decoder) => {
    let remainingLen = readVarUint(decoder);
    if (remainingLen === 0) {
      return "";
    } else {
      let encodedString = String.fromCodePoint(readUint8(decoder));
      if (--remainingLen < 100) {
        while (remainingLen--) {
          encodedString += String.fromCodePoint(readUint8(decoder));
        }
      } else {
        while (remainingLen > 0) {
          const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
          const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
          decoder.pos += nextLen;
          encodedString += String.fromCodePoint.apply(
            null,
            /** @type {any} */
            bytes
          );
          remainingLen -= nextLen;
        }
      }
      return decodeURIComponent(escape(encodedString));
    }
  };
  var _readVarStringNative = (decoder) => (
    /** @type any */
    utf8TextDecoder.decode(readVarUint8Array(decoder))
  );
  var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
  var readTerminatedUint8Array = (decoder) => {
    const encoder = createEncoder();
    let b;
    while (true) {
      b = readUint8(decoder);
      if (b === 0) {
        return toUint8Array(encoder);
      }
      if (b === 1) {
        b = readUint8(decoder);
      }
      write(encoder, b);
    }
  };
  var readTerminatedString = (decoder) => decodeUtf8(readTerminatedUint8Array(decoder));
  var peekVarString = (decoder) => {
    const pos = decoder.pos;
    const s2 = readVarString(decoder);
    decoder.pos = pos;
    return s2;
  };
  var readFromDataView = (decoder, len) => {
    const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
    decoder.pos += len;
    return dv;
  };
  var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
  var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
  var readBigInt64 = (decoder) => (
    /** @type {any} */
    readFromDataView(decoder, 8).getBigInt64(0, false)
  );
  var readBigUint64 = (decoder) => (
    /** @type {any} */
    readFromDataView(decoder, 8).getBigUint64(0, false)
  );
  var readAnyLookupTable = [
    (decoder) => void 0,
    // CASE 127: undefined
    (decoder) => null,
    // CASE 126: null
    readVarInt,
    // CASE 125: integer
    readFloat32,
    // CASE 124: float32
    readFloat64,
    // CASE 123: float64
    readBigInt64,
    // CASE 122: bigint
    (decoder) => false,
    // CASE 121: boolean (false)
    (decoder) => true,
    // CASE 120: boolean (true)
    readVarString,
    // CASE 119: string
    (decoder) => {
      const len = readVarUint(decoder);
      const obj = {};
      for (let i = 0; i < len; i++) {
        const key2 = readVarString(decoder);
        obj[key2] = readAny(decoder);
      }
      return obj;
    },
    (decoder) => {
      const len = readVarUint(decoder);
      const arr = [];
      for (let i = 0; i < len; i++) {
        arr.push(readAny(decoder));
      }
      return arr;
    },
    readVarUint8Array
    // CASE 116: Uint8Array
  ];
  var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
  var RleDecoder = class extends Decoder {
    /**
     * @param {Uint8Array} uint8Array
     * @param {function(Decoder):T} reader
     */
    constructor(uint8Array, reader) {
      super(uint8Array);
      this.reader = reader;
      this.s = null;
      this.count = 0;
    }
    read() {
      if (this.count === 0) {
        this.s = this.reader(this);
        if (hasContent2(this)) {
          this.count = readVarUint(this) + 1;
        } else {
          this.count = -1;
        }
      }
      this.count--;
      return (
        /** @type {T} */
        this.s
      );
    }
  };
  var IntDiffDecoder = class extends Decoder {
    /**
     * @param {Uint8Array} uint8Array
     * @param {number} start
     */
    constructor(uint8Array, start) {
      super(uint8Array);
      this.s = start;
    }
    /**
     * @return {number}
     */
    read() {
      this.s += readVarInt(this);
      return this.s;
    }
  };
  var RleIntDiffDecoder = class extends Decoder {
    /**
     * @param {Uint8Array} uint8Array
     * @param {number} start
     */
    constructor(uint8Array, start) {
      super(uint8Array);
      this.s = start;
      this.count = 0;
    }
    /**
     * @return {number}
     */
    read() {
      if (this.count === 0) {
        this.s += readVarInt(this);
        if (hasContent2(this)) {
          this.count = readVarUint(this) + 1;
        } else {
          this.count = -1;
        }
      }
      this.count--;
      return (
        /** @type {number} */
        this.s
      );
    }
  };
  var UintOptRleDecoder = class extends Decoder {
    /**
     * @param {Uint8Array} uint8Array
     */
    constructor(uint8Array) {
      super(uint8Array);
      this.s = 0;
      this.count = 0;
    }
    read() {
      if (this.count === 0) {
        this.s = readVarInt(this);
        const isNegative = isNegativeZero(this.s);
        this.count = 1;
        if (isNegative) {
          this.s = -this.s;
          this.count = readVarUint(this) + 2;
        }
      }
      this.count--;
      return (
        /** @type {number} */
        this.s
      );
    }
  };
  var IncUintOptRleDecoder = class extends Decoder {
    /**
     * @param {Uint8Array} uint8Array
     */
    constructor(uint8Array) {
      super(uint8Array);
      this.s = 0;
      this.count = 0;
    }
    read() {
      if (this.count === 0) {
        this.s = readVarInt(this);
        const isNegative = isNegativeZero(this.s);
        this.count = 1;
        if (isNegative) {
          this.s = -this.s;
          this.count = readVarUint(this) + 2;
        }
      }
      this.count--;
      return (
        /** @type {number} */
        this.s++
      );
    }
  };
  var IntDiffOptRleDecoder = class extends Decoder {
    /**
     * @param {Uint8Array} uint8Array
     */
    constructor(uint8Array) {
      super(uint8Array);
      this.s = 0;
      this.count = 0;
      this.diff = 0;
    }
    /**
     * @return {number}
     */
    read() {
      if (this.count === 0) {
        const diff = readVarInt(this);
        const hasCount = diff & 1;
        this.diff = floor(diff / 2);
        this.count = 1;
        if (hasCount) {
          this.count = readVarUint(this) + 2;
        }
      }
      this.s += this.diff;
      this.count--;
      return this.s;
    }
  };
  var StringDecoder = class {
    /**
     * @param {Uint8Array} uint8Array
     */
    constructor(uint8Array) {
      this.decoder = new UintOptRleDecoder(uint8Array);
      this.str = readVarString(this.decoder);
      this.spos = 0;
    }
    /**
     * @return {string}
     */
    read() {
      const end = this.spos + this.decoder.read();
      const res = this.str.slice(this.spos, end);
      this.spos = end;
      return res;
    }
  };

  // node_modules/lib0/webcrypto.js
  var subtle = crypto.subtle;
  var getRandomValues2 = crypto.getRandomValues.bind(crypto);

  // node_modules/lib0/random.js
  var rand = Math.random;
  var uint32 = () => getRandomValues2(new Uint32Array(1))[0];
  var uint53 = () => {
    const arr = getRandomValues2(new Uint32Array(8));
    return (arr[0] & BITS21) * (BITS32 + 1) + (arr[1] >>> 0);
  };
  var oneOf = (arr) => arr[floor(rand() * arr.length)];
  var uuidv4Template = "10000000-1000-4000-8000" + -1e11;
  var uuidv4 = () => uuidv4Template.replace(
    /[018]/g,
    /** @param {number} c */
    (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
  );

  // node_modules/lib0/metric.js
  var yotta = 1e24;
  var zetta = 1e21;
  var exa = 1e18;
  var peta = 1e15;
  var tera = 1e12;
  var giga = 1e9;
  var mega = 1e6;
  var kilo = 1e3;
  var hecto = 100;
  var deca = 10;
  var deci = 0.1;
  var centi = 0.01;
  var milli = 1e-3;
  var micro = 1e-6;
  var nano = 1e-9;
  var pico = 1e-12;
  var femto = 1e-15;
  var atto = 1e-18;
  var zepto = 1e-21;
  var yocto = 1e-24;
  var prefixUp = ["", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  var prefixDown = ["", "m", "\u03BC", "n", "p", "f", "a", "z", "y"];
  var prefix2 = (n, baseMultiplier = 0) => {
    const nPow = n === 0 ? 0 : log10(n);
    let mult = 0;
    while (nPow < mult * 3 && baseMultiplier > -8) {
      baseMultiplier--;
      mult--;
    }
    while (nPow >= 3 + mult * 3 && baseMultiplier < 8) {
      baseMultiplier++;
      mult++;
    }
    const prefix3 = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier];
    return {
      n: round((mult > 0 ? n / exp10(mult * 3) : n * exp10(mult * -3)) * 1e12) / 1e12,
      prefix: prefix3
    };
  };

  // node_modules/lib0/time.js
  var getDate = () => /* @__PURE__ */ new Date();
  var getUnixTime = Date.now;
  var humanizeDuration = (d) => {
    if (d < 6e4) {
      const p5 = prefix2(d, -1);
      return round(p5.n * 100) / 100 + p5.prefix + "s";
    }
    d = floor(d / 1e3);
    const seconds = d % 60;
    const minutes = floor(d / 60) % 60;
    const hours = floor(d / 3600) % 24;
    const days = floor(d / 86400);
    if (days > 0) {
      return days + "d" + (hours > 0 || minutes > 30 ? " " + (minutes > 30 ? hours + 1 : hours) + "h" : "");
    }
    if (hours > 0) {
      return hours + "h" + (minutes > 0 || seconds > 30 ? " " + (seconds > 30 ? minutes + 1 : minutes) + "min" : "");
    }
    return minutes + "min" + (seconds > 0 ? " " + seconds + "s" : "");
  };

  // node_modules/lib0/promise.js
  var create9 = (f) => (
    /** @type {Promise<T>} */
    new Promise(f)
  );
  var createEmpty = (f) => new Promise(f);
  var all9 = Promise.all.bind(Promise);
  var reject = (reason) => Promise.reject(reason);
  var resolve2 = (res) => Promise.resolve(res);
  var resolveWith = (res) => Promise.resolve(res);
  var until = (timeout2, check, intervalResolution = 10) => create9((resolve3, reject2) => {
    const startTime = getUnixTime();
    const hasTimeout = timeout2 > 0;
    const untilInterval = () => {
      if (check()) {
        clearInterval(intervalHandle);
        resolve3();
      } else if (hasTimeout) {
        if (getUnixTime() - startTime > timeout2) {
          clearInterval(intervalHandle);
          reject2(new Error("Timeout"));
        }
      }
    };
    const intervalHandle = setInterval(untilInterval, intervalResolution);
  });
  var untilAsync = async (check, timeout2 = 0, intervalResolution = 10) => {
    const startTime = getUnixTime();
    const noTimeout = timeout2 <= 0;
    while (noTimeout || getUnixTime() - startTime <= timeout2) {
      if (await check()) return;
      await wait(intervalResolution);
    }
    throw new Error("Timeout");
  };
  var wait = (timeout2) => create9((resolve3, _reject) => setTimeout(resolve3, timeout2));
  var isPromise = (p5) => p5 instanceof Promise || p5 && p5.then && p5.catch && p5.finally;

  // node_modules/lib0/conditions.js
  var undefinedToNull = (v2) => v2 === void 0 ? null : v2;

  // node_modules/lib0/storage.js
  var VarStoragePolyfill = class {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    /**
     * @param {string} key
     * @param {any} newValue
     */
    setItem(key2, newValue) {
      this.map.set(key2, newValue);
    }
    /**
     * @param {string} key
     */
    getItem(key2) {
      return this.map.get(key2);
    }
  };
  var _localStorage = new VarStoragePolyfill();
  var usePolyfill = true;
  try {
    if (typeof localStorage !== "undefined" && localStorage) {
      _localStorage = localStorage;
      usePolyfill = false;
    }
  } catch (e) {
  }
  var varStorage = _localStorage;
  var onChange = (eventHandler) => usePolyfill || addEventListener(
    "storage",
    /** @type {any} */
    eventHandler
  );
  var offChange = (eventHandler) => usePolyfill || removeEventListener(
    "storage",
    /** @type {any} */
    eventHandler
  );

  // node_modules/lib0/object.js
  var create10 = () => /* @__PURE__ */ Object.create(null);
  var assign2 = Object.assign;
  var keys3 = Object.keys;
  var forEach3 = (obj, f) => {
    for (const key2 in obj) {
      f(obj[key2], key2);
    }
  };
  var map7 = (obj, f) => {
    const results = [];
    for (const key2 in obj) {
      results.push(f(obj[key2], key2));
    }
    return results;
  };
  var length2 = (obj) => keys3(obj).length;
  var size = (obj) => keys3(obj).length;
  var some2 = (obj, f) => {
    for (const key2 in obj) {
      if (f(obj[key2], key2)) {
        return true;
      }
    }
    return false;
  };
  var isEmpty2 = (obj) => {
    for (const _k in obj) {
      return false;
    }
    return true;
  };
  var every2 = (obj, f) => {
    for (const key2 in obj) {
      if (!f(obj[key2], key2)) {
        return false;
      }
    }
    return true;
  };
  var hasProperty2 = (obj, key2) => Object.prototype.hasOwnProperty.call(obj, key2);
  var equalFlat2 = (a2, b) => a2 === b || size(a2) === size(b) && every2(a2, (val, key2) => (val !== void 0 || hasProperty2(b, key2)) && b[key2] === val);
  var freeze = Object.freeze;
  var deepFreeze = (o) => {
    for (const key2 in o) {
      const c = o[key2];
      if (typeof c === "object" || typeof c === "function") {
        deepFreeze(o[key2]);
      }
    }
    return freeze(o);
  };

  // node_modules/lib0/traits.js
  var EqualityTraitSymbol = Symbol("Equality");

  // node_modules/lib0/function.js
  var callAll = (fs2, args2, i = 0) => {
    try {
      for (; i < fs2.length; i++) {
        fs2[i](...args2);
      }
    } finally {
      if (i < fs2.length) {
        callAll(fs2, args2, i + 1);
      }
    }
  };
  var nop = () => {
  };
  var apply2 = (f) => f();
  var id = (a2) => a2;
  var equalityStrict = (a2, b) => a2 === b;
  var equalityFlat = (a2, b) => a2 === b || a2 != null && b != null && a2.constructor === b.constructor && (isArray(a2) && equalFlat(
    a2,
    /** @type {Array<T>} */
    b
  ) || typeof a2 === "object" && equalFlat2(a2, b));
  var equalityDeep = (a2, b) => {
    if (a2 === b) {
      return true;
    }
    if (a2 == null || b == null || a2.constructor !== b.constructor) {
      return false;
    }
    if (a2[EqualityTraitSymbol] != null) {
      return a2[EqualityTraitSymbol](b);
    }
    switch (a2.constructor) {
      case ArrayBuffer:
        a2 = new Uint8Array(a2);
        b = new Uint8Array(b);
      // eslint-disable-next-line no-fallthrough
      case Uint8Array: {
        if (a2.byteLength !== b.byteLength) {
          return false;
        }
        for (let i = 0; i < a2.length; i++) {
          if (a2[i] !== b[i]) {
            return false;
          }
        }
        break;
      }
      case Set: {
        if (a2.size !== b.size) {
          return false;
        }
        for (const value of a2) {
          if (!b.has(value)) {
            return false;
          }
        }
        break;
      }
      case Map: {
        if (a2.size !== b.size) {
          return false;
        }
        for (const key2 of a2.keys()) {
          if (!b.has(key2) || !equalityDeep(a2.get(key2), b.get(key2))) {
            return false;
          }
        }
        break;
      }
      case Object:
        if (length2(a2) !== length2(b)) {
          return false;
        }
        for (const key2 in a2) {
          if (!hasProperty2(a2, key2) || !equalityDeep(a2[key2], b[key2])) {
            return false;
          }
        }
        break;
      case Array:
        if (a2.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a2.length; i++) {
          if (!equalityDeep(a2[i], b[i])) {
            return false;
          }
        }
        break;
      default:
        return false;
    }
    return true;
  };
  var isOneOf = (value, options2) => options2.includes(value);
  var isArray2 = isArray;
  var isString2 = (s2) => s2 && s2.constructor === String;
  var isNumber3 = (n) => n != null && n.constructor === Number;
  var is2 = (n, T2) => n && n.constructor === T2;
  var isTemplate = (T2) => (
    /**
     * @param {any} n
     * @return {n is InstanceType<TYPE>}
     **/
    (n) => n && n.constructor === T2
  );

  // node_modules/lib0/environment.js
  var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
  var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
  var params;
  var args = [];
  var computeParams = () => {
    if (params === void 0) {
      if (isNode) {
        params = create5();
        const pargs = process.argv;
        let currParamName = null;
        for (let i = 0; i < pargs.length; i++) {
          const parg = pargs[i];
          if (parg[0] === "-") {
            if (currParamName !== null) {
              params.set(currParamName, "");
            }
            currParamName = parg;
          } else {
            if (currParamName !== null) {
              params.set(currParamName, parg);
              currParamName = null;
            } else {
              args.push(parg);
            }
          }
        }
        if (currParamName !== null) {
          params.set(currParamName, "");
        }
      } else if (typeof location === "object") {
        params = create5();
        (location.search || "?").slice(1).split("&").forEach((kv) => {
          if (kv.length !== 0) {
            const [key2, value] = kv.split("=");
            params.set(`--${fromCamelCase(key2, "-")}`, value);
            params.set(`-${fromCamelCase(key2, "-")}`, value);
          }
        });
      } else {
        params = create5();
      }
    }
    return params;
  };
  var hasParam = (name) => computeParams().has(name);
  var getParam = (name, defaultVal) => computeParams().get(name) || defaultVal;
  var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
  var getConf = (name) => computeParams().get("--" + name) || getVariable(name);
  var ensureConf = (name) => {
    const c = getConf(name);
    if (c == null) throw new Error(`Expected configuration "${name.toUpperCase().replaceAll("-", "_")}"`);
    return c;
  };
  var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
  var production = hasConf("production");
  var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
  var supportsColor = forceColor || !hasParam("--no-colors") && // @todo deprecate --no-colors
  !hasConf("no-color") && (!isNode || process.stdout.isTTY) && (!isNode || hasParam("--color") || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

  // node_modules/lib0/buffer.js
  var createUint8ArrayFromLen = (len) => new Uint8Array(len);
  var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length3) => new Uint8Array(buffer, byteOffset, length3);
  var createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
  var toBase64Browser = (bytes) => {
    let s2 = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      s2 += fromCharCode(bytes[i]);
    }
    return btoa(s2);
  };
  var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
  var fromBase64Browser = (s2) => {
    const a2 = atob(s2);
    const bytes = createUint8ArrayFromLen(a2.length);
    for (let i = 0; i < a2.length; i++) {
      bytes[i] = a2.charCodeAt(i);
    }
    return bytes;
  };
  var fromBase64Node = (s2) => {
    const buf = Buffer.from(s2, "base64");
    return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength);
  };
  var toBase64 = isBrowser ? toBase64Browser : toBase64Node;
  var fromBase64 = isBrowser ? fromBase64Browser : fromBase64Node;
  var toBase64UrlEncoded = (buf) => toBase64(buf).replaceAll("+", "-").replaceAll("/", "_").replaceAll("=", "");
  var fromBase64UrlEncoded = (base64) => fromBase64(base64.replaceAll("-", "+").replaceAll("_", "/"));
  var toHexString = (buf) => map6(buf, (b) => b.toString(16).padStart(2, "0")).join("");
  var fromHexString = (hex) => {
    const hlen = hex.length;
    const buf = new Uint8Array(ceil(hlen / 2));
    for (let i = 0; i < hlen; i += 2) {
      buf[buf.length - i / 2 - 1] = Number.parseInt(hex.slice(hlen - i - 2, hlen - i), 16);
    }
    return buf;
  };
  var copyUint8Array = (uint8Array) => {
    const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
    newBuf.set(uint8Array);
    return newBuf;
  };
  var encodeAny = (data) => encode2((encoder) => writeAny(encoder, data));
  var decodeAny = (buf) => readAny(createDecoder(buf));
  var shiftNBitsLeft = (bs2, N2) => {
    if (N2 === 0) return bs2;
    bs2 = new Uint8Array(bs2);
    bs2[0] <<= N2;
    for (let i = 1; i < bs2.length; i++) {
      bs2[i - 1] |= bs2[i] >>> 8 - N2;
      bs2[i] <<= N2;
    }
    return bs2;
  };

  // node_modules/lib0/pair.js
  var Pair = class {
    /**
     * @param {L} left
     * @param {R} right
     */
    constructor(left, right) {
      this.left = left;
      this.right = right;
    }
  };
  var create11 = (left, right) => new Pair(left, right);
  var createReversed = (right, left) => new Pair(left, right);
  var forEach4 = (arr, f) => arr.forEach((p5) => f(p5.left, p5.right));
  var map8 = (arr, f) => arr.map((p5) => f(p5.left, p5.right));

  // node_modules/lib0/dom.js
  var doc3 = (
    /** @type {Document} */
    typeof document !== "undefined" ? document : {}
  );
  var createElement = (name) => doc3.createElement(name);
  var createDocumentFragment = () => doc3.createDocumentFragment();
  var createTextNode = (text10) => doc3.createTextNode(text10);
  var domParser = (
    /** @type {DOMParser} */
    typeof DOMParser !== "undefined" ? new DOMParser() : null
  );
  var emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts));
  var setAttributes = (el, attrs) => {
    forEach4(attrs, (key2, value) => {
      if (value === false) {
        el.removeAttribute(key2);
      } else if (value === true) {
        el.setAttribute(key2, "");
      } else {
        el.setAttribute(key2, value);
      }
    });
    return el;
  };
  var setAttributesMap = (el, attrs) => {
    attrs.forEach((value, key2) => {
      el.setAttribute(key2, value);
    });
    return el;
  };
  var fragment = (children) => {
    const fragment2 = createDocumentFragment();
    for (let i = 0; i < children.length; i++) {
      appendChild(fragment2, children[i]);
    }
    return fragment2;
  };
  var append2 = (parent, nodes) => {
    appendChild(parent, fragment(nodes));
    return parent;
  };
  var remove = (el) => el.remove();
  var addEventListener2 = (el, name, f) => el.addEventListener(name, f);
  var removeEventListener2 = (el, name, f) => el.removeEventListener(name, f);
  var addEventListeners = (node2, listeners) => {
    forEach4(listeners, (name, f) => addEventListener2(node2, name, f));
    return node2;
  };
  var removeEventListeners = (node2, listeners) => {
    forEach4(listeners, (name, f) => removeEventListener2(node2, name, f));
    return node2;
  };
  var element6 = (name, attrs = [], children = []) => append2(setAttributes(createElement(name), attrs), children);
  var canvas = (width, height) => {
    const c = (
      /** @type {HTMLCanvasElement} */
      createElement("canvas")
    );
    c.height = height;
    c.width = width;
    return c;
  };
  var text9 = createTextNode;
  var pairToStyleString = (pair) => `${pair.left}:${pair.right};`;
  var pairsToStyleString = (pairs) => pairs.map(pairToStyleString).join("");
  var mapToStyleString = (m) => map5(m, (value, key2) => `${key2}:${value};`).join("");
  var querySelector = (el, query) => el.querySelector(query);
  var querySelectorAll = (el, query) => el.querySelectorAll(query);
  var getElementById = (id2) => (
    /** @type {HTMLElement} */
    doc3.getElementById(id2)
  );
  var _parse = (html7) => domParser.parseFromString(`<html><body>${html7}</body></html>`, "text/html").body;
  var parseFragment2 = (html7) => fragment(
    /** @type {any} */
    _parse(html7).childNodes
  );
  var parseElement = (html7) => (
    /** @type HTMLElement */
    _parse(html7).firstElementChild
  );
  var replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl);
  var insertBefore = (parent, el, ref) => parent.insertBefore(el, ref);
  var appendChild = (parent, child) => parent.appendChild(child);
  var ELEMENT_NODE = doc3.ELEMENT_NODE;
  var TEXT_NODE = doc3.TEXT_NODE;
  var CDATA_SECTION_NODE = doc3.CDATA_SECTION_NODE;
  var COMMENT_NODE = doc3.COMMENT_NODE;
  var DOCUMENT_NODE = doc3.DOCUMENT_NODE;
  var DOCUMENT_TYPE_NODE = doc3.DOCUMENT_TYPE_NODE;
  var DOCUMENT_FRAGMENT_NODE = doc3.DOCUMENT_FRAGMENT_NODE;
  var checkNodeType = (node2, type) => node2.nodeType === type;
  var isParentOf = (parent, child) => {
    let p5 = child.parentNode;
    while (p5 && p5 !== parent) {
      p5 = p5.parentNode;
    }
    return p5 === parent;
  };

  // node_modules/lib0/json.js
  var stringify4 = JSON.stringify;
  var parse5 = JSON.parse;

  // node_modules/lib0/eventloop.js
  var queue = [];
  var _runQueue = () => {
    for (let i = 0; i < queue.length; i++) {
      queue[i]();
    }
    queue = [];
  };
  var enqueue = (f) => {
    queue.push(f);
    if (queue.length === 1) {
      setTimeout(_runQueue, 0);
    }
  };
  var createTimeoutClass = (clearFunction) => class TT {
    /**
     * @param {number} timeoutId
     */
    constructor(timeoutId) {
      this._ = timeoutId;
    }
    destroy() {
      clearFunction(this._);
    }
  };
  var Timeout = createTimeoutClass(clearTimeout);
  var timeout = (timeout2, callback) => new Timeout(setTimeout(callback, timeout2));
  var Interval = createTimeoutClass(clearInterval);
  var interval = (timeout2, callback) => new Interval(setInterval(callback, timeout2));
  var Animation = createTimeoutClass((arg) => typeof requestAnimationFrame !== "undefined" && cancelAnimationFrame(arg));
  var animationFrame = (cb) => typeof requestAnimationFrame === "undefined" ? timeout(0, cb) : new Animation(requestAnimationFrame(cb));
  var Idle = createTimeoutClass((arg) => typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(arg));
  var idleCallback = (cb) => typeof requestIdleCallback !== "undefined" ? new Idle(requestIdleCallback(cb)) : timeout(1e3, cb);
  var createDebouncer = (timeout2, triggerAfter = -1) => {
    let timer = -1;
    let lastCall = null;
    return (cb) => {
      clearTimeout(timer);
      if (cb) {
        if (triggerAfter >= 0) {
          const now = getUnixTime();
          if (lastCall === null) lastCall = now;
          if (now - lastCall > triggerAfter) {
            lastCall = null;
            timer = /** @type {any} */
            setTimeout(cb, 0);
            return;
          }
        }
        timer = /** @type {any} */
        setTimeout(() => {
          lastCall = null;
          cb();
        }, timeout2);
      } else {
        lastCall = null;
      }
    };
  };

  // node_modules/lib0/symbol.js
  var create12 = Symbol;
  var isSymbol = (s2) => typeof s2 === "symbol";

  // node_modules/lib0/logging.common.js
  var BOLD = create12();
  var UNBOLD = create12();
  var BLUE = create12();
  var GREY = create12();
  var GREEN = create12();
  var RED = create12();
  var PURPLE = create12();
  var ORANGE = create12();
  var UNCOLOR = create12();
  var computeNoColorLoggingArgs = (args2) => {
    if (args2.length === 1 && args2[0]?.constructor === Function) {
      args2 = /** @type {Array<string|Symbol|Object|number>} */
      /** @type {[function]} */
      args2[0]();
    }
    const strBuilder = [];
    const logArgs = [];
    let i = 0;
    for (; i < args2.length; i++) {
      const arg = args2[i];
      if (arg === void 0) {
        break;
      } else if (arg.constructor === String || arg.constructor === Number) {
        strBuilder.push(arg);
      } else if (arg.constructor === Object) {
        break;
      }
    }
    if (i > 0) {
      logArgs.push(strBuilder.join(""));
    }
    for (; i < args2.length; i++) {
      const arg = args2[i];
      if (!(arg instanceof Symbol)) {
        logArgs.push(arg);
      }
    }
    return logArgs;
  };
  var loggingColors = [GREEN, PURPLE, ORANGE, BLUE];
  var nextColor = 0;
  var lastLoggingTime = getUnixTime();
  var createModuleLogger = (_print, moduleName) => {
    const color2 = loggingColors[nextColor];
    const debugRegexVar = getVariable("log");
    const doLogging = debugRegexVar !== null && (debugRegexVar === "*" || debugRegexVar === "true" || new RegExp(debugRegexVar, "gi").test(moduleName));
    nextColor = (nextColor + 1) % loggingColors.length;
    moduleName += ": ";
    return !doLogging ? nop : (...args2) => {
      if (args2.length === 1 && args2[0]?.constructor === Function) {
        args2 = args2[0]();
      }
      const timeNow = getUnixTime();
      const timeDiff = timeNow - lastLoggingTime;
      lastLoggingTime = timeNow;
      _print(
        color2,
        moduleName,
        UNCOLOR,
        ...args2.map((arg) => {
          if (arg != null && arg.constructor === Uint8Array) {
            arg = Array.from(arg);
          }
          const t2 = typeof arg;
          switch (t2) {
            case "string":
            case "symbol":
              return arg;
            default: {
              return stringify4(arg);
            }
          }
        }),
        color2,
        " +" + timeDiff + "ms"
      );
    };
  };

  // node_modules/lib0/logging.js
  var _browserStyleMap = {
    [BOLD]: create11("font-weight", "bold"),
    [UNBOLD]: create11("font-weight", "normal"),
    [BLUE]: create11("color", "blue"),
    [GREEN]: create11("color", "green"),
    [GREY]: create11("color", "grey"),
    [RED]: create11("color", "red"),
    [PURPLE]: create11("color", "purple"),
    [ORANGE]: create11("color", "orange"),
    // not well supported in chrome when debugging node with inspector - TODO: deprecate
    [UNCOLOR]: create11("color", "black")
  };
  var computeBrowserLoggingArgs = (args2) => {
    if (args2.length === 1 && args2[0]?.constructor === Function) {
      args2 = /** @type {Array<string|Symbol|Object|number>} */
      /** @type {[function]} */
      args2[0]();
    }
    const strBuilder = [];
    const styles = [];
    const currentStyle = create5();
    let logArgs = [];
    let i = 0;
    for (; i < args2.length; i++) {
      const arg = args2[i];
      const style3 = _browserStyleMap[arg];
      if (style3 !== void 0) {
        currentStyle.set(style3.left, style3.right);
      } else {
        if (arg === void 0) {
          break;
        }
        if (arg.constructor === String || arg.constructor === Number) {
          const style4 = mapToStyleString(currentStyle);
          if (i > 0 || style4.length > 0) {
            strBuilder.push("%c" + arg);
            styles.push(style4);
          } else {
            strBuilder.push(arg);
          }
        } else {
          break;
        }
      }
    }
    if (i > 0) {
      logArgs = styles;
      logArgs.unshift(strBuilder.join(""));
    }
    for (; i < args2.length; i++) {
      const arg = args2[i];
      if (!(arg instanceof Symbol)) {
        logArgs.push(arg);
      }
    }
    return logArgs;
  };
  var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
  var print = (...args2) => {
    console.log(...computeLoggingArgs(args2));
    vconsoles.forEach((vc) => vc.print(args2));
  };
  var warn2 = (...args2) => {
    console.warn(...computeLoggingArgs(args2));
    args2.unshift(ORANGE);
    vconsoles.forEach((vc) => vc.print(args2));
  };
  var printError = (err) => {
    console.error(err);
    vconsoles.forEach((vc) => vc.printError(err));
  };
  var printImg = (url, height) => {
    if (isBrowser) {
      console.log(
        "%c                      ",
        `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`
      );
    }
    vconsoles.forEach((vc) => vc.printImg(url, height));
  };
  var printImgBase64 = (base64, height) => printImg(`data:image/gif;base64,${base64}`, height);
  var group = (...args2) => {
    console.group(...computeLoggingArgs(args2));
    vconsoles.forEach((vc) => vc.group(args2));
  };
  var groupCollapsed = (...args2) => {
    console.groupCollapsed(...computeLoggingArgs(args2));
    vconsoles.forEach((vc) => vc.groupCollapsed(args2));
  };
  var groupEnd = () => {
    console.groupEnd();
    vconsoles.forEach((vc) => vc.groupEnd());
  };
  var printDom = (createNode) => vconsoles.forEach((vc) => vc.printDom(createNode()));
  var printCanvas = (canvas2, height) => printImg(canvas2.toDataURL(), height);
  var vconsoles = create6();
  var _computeLineSpans = (args2) => {
    const spans = [];
    const currentStyle = /* @__PURE__ */ new Map();
    let i = 0;
    for (; i < args2.length; i++) {
      let arg = args2[i];
      const style3 = _browserStyleMap[arg];
      if (style3 !== void 0) {
        currentStyle.set(style3.left, style3.right);
      } else {
        if (arg === void 0) {
          arg = "undefined ";
        }
        if (arg.constructor === String || arg.constructor === Number) {
          const span = element6("span", [
            create11("style", mapToStyleString(currentStyle))
          ], [text9(arg.toString())]);
          if (span.innerHTML === "") {
            span.innerHTML = "&nbsp;";
          }
          spans.push(span);
        } else {
          break;
        }
      }
    }
    for (; i < args2.length; i++) {
      let content5 = args2[i];
      if (!(content5 instanceof Symbol)) {
        if (content5.constructor !== String && content5.constructor !== Number) {
          content5 = " " + stringify4(content5) + " ";
        }
        spans.push(
          element6("span", [], [text9(
            /** @type {string} */
            content5
          )])
        );
      }
    }
    return spans;
  };
  var lineStyle = "font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;";
  var VConsole = class {
    /**
     * @param {Element} dom
     */
    constructor(dom) {
      this.dom = dom;
      this.ccontainer = this.dom;
      this.depth = 0;
      vconsoles.add(this);
    }
    /**
     * @param {Array<string|Symbol|Object|number>} args
     * @param {boolean} collapsed
     */
    group(args2, collapsed = false) {
      enqueue(() => {
        const triangleDown = element6("span", [
          create11("hidden", collapsed),
          create11("style", "color:grey;font-size:120%;")
        ], [text9("\u25BC")]);
        const triangleRight = element6("span", [
          create11("hidden", !collapsed),
          create11("style", "color:grey;font-size:125%;")
        ], [text9("\u25B6")]);
        const content5 = element6(
          "div",
          [create11(
            "style",
            `${lineStyle};padding-left:${this.depth * 10}px`
          )],
          [triangleDown, triangleRight, text9(" ")].concat(
            _computeLineSpans(args2)
          )
        );
        const nextContainer = element6("div", [
          create11("hidden", collapsed)
        ]);
        const nextLine = element6("div", [], [content5, nextContainer]);
        append2(this.ccontainer, [nextLine]);
        this.ccontainer = nextContainer;
        this.depth++;
        addEventListener2(content5, "click", (_event) => {
          nextContainer.toggleAttribute("hidden");
          triangleDown.toggleAttribute("hidden");
          triangleRight.toggleAttribute("hidden");
        });
      });
    }
    /**
     * @param {Array<string|Symbol|Object|number>} args
     */
    groupCollapsed(args2) {
      this.group(args2, true);
    }
    groupEnd() {
      enqueue(() => {
        if (this.depth > 0) {
          this.depth--;
          this.ccontainer = this.ccontainer.parentElement.parentElement;
        }
      });
    }
    /**
     * @param {Array<string|Symbol|Object|number>} args
     */
    print(args2) {
      enqueue(() => {
        append2(this.ccontainer, [
          element6("div", [
            create11(
              "style",
              `${lineStyle};padding-left:${this.depth * 10}px`
            )
          ], _computeLineSpans(args2))
        ]);
      });
    }
    /**
     * @param {Error} err
     */
    printError(err) {
      this.print([RED, BOLD, err.toString()]);
    }
    /**
     * @param {string} url
     * @param {number} height
     */
    printImg(url, height) {
      enqueue(() => {
        append2(this.ccontainer, [
          element6("img", [
            create11("src", url),
            create11("height", `${round(height * 1.5)}px`)
          ])
        ]);
      });
    }
    /**
     * @param {Node} node
     */
    printDom(node2) {
      enqueue(() => {
        append2(this.ccontainer, [node2]);
      });
    }
    destroy() {
      enqueue(() => {
        vconsoles.delete(this);
      });
    }
  };
  var createVConsole = (dom) => new VConsole(dom);
  var createModuleLogger2 = (moduleName) => createModuleLogger(print, moduleName);

  // node_modules/lib0/iterator.js
  var mapIterator = (iterator, f) => ({
    [Symbol.iterator]() {
      return this;
    },
    // @ts-ignore
    next() {
      const r = iterator.next();
      return { value: r.done ? void 0 : f(r.value), done: r.done };
    }
  });
  var createIterator = (next2) => ({
    /**
     * @return {IterableIterator<T>}
     */
    [Symbol.iterator]() {
      return this;
    },
    // @ts-ignore
    next: next2
  });
  var iteratorFilter = (iterator, filter) => createIterator(() => {
    let res;
    do {
      res = iterator.next();
    } while (!res.done && !filter(res.value));
    return res;
  });
  var iteratorMap = (iterator, fmap) => createIterator(() => {
    const { done, value } = iterator.next();
    return { done, value: done ? void 0 : fmap(value) };
  });

  // node_modules/yjs/dist/yjs.mjs
  var AbstractConnector = class extends ObservableV2 {
    /**
     * @param {Doc} ydoc
     * @param {any} awareness
     */
    constructor(ydoc, awareness) {
      super();
      this.doc = ydoc;
      this.awareness = awareness;
    }
  };
  var DeleteItem = class {
    /**
     * @param {number} clock
     * @param {number} len
     */
    constructor(clock, len) {
      this.clock = clock;
      this.len = len;
    }
  };
  var DeleteSet = class {
    constructor() {
      this.clients = /* @__PURE__ */ new Map();
    }
  };
  var iterateDeletedStructs = (transaction, ds2, f) => ds2.clients.forEach((deletes, clientid) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      transaction.doc.store.clients.get(clientid)
    );
    if (structs != null) {
      const lastStruct = structs[structs.length - 1];
      const clockState = lastStruct.id.clock + lastStruct.length;
      for (let i = 0, del3 = deletes[i]; i < deletes.length && del3.clock < clockState; del3 = deletes[++i]) {
        iterateStructs(transaction, structs, del3.clock, del3.len, f);
      }
    }
  });
  var findIndexDS = (dis, clock) => {
    let left = 0;
    let right = dis.length - 1;
    while (left <= right) {
      const midindex = floor((left + right) / 2);
      const mid = dis[midindex];
      const midclock = mid.clock;
      if (midclock <= clock) {
        if (clock < midclock + mid.len) {
          return midindex;
        }
        left = midindex + 1;
      } else {
        right = midindex - 1;
      }
    }
    return null;
  };
  var isDeleted = (ds2, id2) => {
    const dis = ds2.clients.get(id2.client);
    return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
  };
  var sortAndMergeDeleteSet = (ds2) => {
    ds2.clients.forEach((dels) => {
      dels.sort((a2, b) => a2.clock - b.clock);
      let i, j2;
      for (i = 1, j2 = 1; i < dels.length; i++) {
        const left = dels[j2 - 1];
        const right = dels[i];
        if (left.clock + left.len >= right.clock) {
          left.len = max(left.len, right.clock + right.len - left.clock);
        } else {
          if (j2 < i) {
            dels[j2] = right;
          }
          j2++;
        }
      }
      dels.length = j2;
    });
  };
  var mergeDeleteSets = (dss) => {
    const merged = new DeleteSet();
    for (let dssI = 0; dssI < dss.length; dssI++) {
      dss[dssI].clients.forEach((delsLeft, client) => {
        if (!merged.clients.has(client)) {
          const dels = delsLeft.slice();
          for (let i = dssI + 1; i < dss.length; i++) {
            appendTo(dels, dss[i].clients.get(client) || []);
          }
          merged.clients.set(client, dels);
        }
      });
    }
    sortAndMergeDeleteSet(merged);
    return merged;
  };
  var addToDeleteSet = (ds2, client, clock, length3) => {
    setIfUndefined(ds2.clients, client, () => (
      /** @type {Array<DeleteItem>} */
      []
    )).push(new DeleteItem(clock, length3));
  };
  var createDeleteSet = () => new DeleteSet();
  var createDeleteSetFromStructStore = (ss2) => {
    const ds2 = createDeleteSet();
    ss2.clients.forEach((structs, client) => {
      const dsitems = [];
      for (let i = 0; i < structs.length; i++) {
        const struct = structs[i];
        if (struct.deleted) {
          const clock = struct.id.clock;
          let len = struct.length;
          if (i + 1 < structs.length) {
            for (let next2 = structs[i + 1]; i + 1 < structs.length && next2.deleted; next2 = structs[++i + 1]) {
              len += next2.length;
            }
          }
          dsitems.push(new DeleteItem(clock, len));
        }
      }
      if (dsitems.length > 0) {
        ds2.clients.set(client, dsitems);
      }
    });
    return ds2;
  };
  var writeDeleteSet = (encoder, ds2) => {
    writeVarUint(encoder.restEncoder, ds2.clients.size);
    from3(ds2.clients.entries()).sort((a2, b) => b[0] - a2[0]).forEach(([client, dsitems]) => {
      encoder.resetDsCurVal();
      writeVarUint(encoder.restEncoder, client);
      const len = dsitems.length;
      writeVarUint(encoder.restEncoder, len);
      for (let i = 0; i < len; i++) {
        const item = dsitems[i];
        encoder.writeDsClock(item.clock);
        encoder.writeDsLen(item.len);
      }
    });
  };
  var readDeleteSet = (decoder) => {
    const ds2 = new DeleteSet();
    const numClients = readVarUint(decoder.restDecoder);
    for (let i = 0; i < numClients; i++) {
      decoder.resetDsCurVal();
      const client = readVarUint(decoder.restDecoder);
      const numberOfDeletes = readVarUint(decoder.restDecoder);
      if (numberOfDeletes > 0) {
        const dsField = setIfUndefined(ds2.clients, client, () => (
          /** @type {Array<DeleteItem>} */
          []
        ));
        for (let i2 = 0; i2 < numberOfDeletes; i2++) {
          dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
        }
      }
    }
    return ds2;
  };
  var readAndApplyDeleteSet = (decoder, transaction, store) => {
    const unappliedDS = new DeleteSet();
    const numClients = readVarUint(decoder.restDecoder);
    for (let i = 0; i < numClients; i++) {
      decoder.resetDsCurVal();
      const client = readVarUint(decoder.restDecoder);
      const numberOfDeletes = readVarUint(decoder.restDecoder);
      const structs = store.clients.get(client) || [];
      const state = getState(store, client);
      for (let i2 = 0; i2 < numberOfDeletes; i2++) {
        const clock = decoder.readDsClock();
        const clockEnd = clock + decoder.readDsLen();
        if (clock < state) {
          if (state < clockEnd) {
            addToDeleteSet(unappliedDS, client, state, clockEnd - state);
          }
          let index3 = findIndexSS(structs, clock);
          let struct = structs[index3];
          if (!struct.deleted && struct.id.clock < clock) {
            structs.splice(index3 + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
            index3++;
          }
          while (index3 < structs.length) {
            struct = structs[index3++];
            if (struct.id.clock < clockEnd) {
              if (!struct.deleted) {
                if (clockEnd < struct.id.clock + struct.length) {
                  structs.splice(index3, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
                }
                struct.delete(transaction);
              }
            } else {
              break;
            }
          }
        } else {
          addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
        }
      }
    }
    if (unappliedDS.clients.size > 0) {
      const ds2 = new UpdateEncoderV2();
      writeVarUint(ds2.restEncoder, 0);
      writeDeleteSet(ds2, unappliedDS);
      return ds2.toUint8Array();
    }
    return null;
  };
  var equalDeleteSets = (ds1, ds2) => {
    if (ds1.clients.size !== ds2.clients.size) return false;
    for (const [client, deleteItems1] of ds1.clients.entries()) {
      const deleteItems2 = (
        /** @type {Array<import('../internals.js').DeleteItem>} */
        ds2.clients.get(client)
      );
      if (deleteItems2 === void 0 || deleteItems1.length !== deleteItems2.length) return false;
      for (let i = 0; i < deleteItems1.length; i++) {
        const di1 = deleteItems1[i];
        const di2 = deleteItems2[i];
        if (di1.clock !== di2.clock || di1.len !== di2.len) {
          return false;
        }
      }
    }
    return true;
  };
  var generateNewClientId = uint32;
  var Doc = class _Doc extends ObservableV2 {
    /**
     * @param {DocOpts} opts configuration
     */
    constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta: meta2 = null, autoLoad = false, shouldLoad = true } = {}) {
      super();
      this.gc = gc;
      this.gcFilter = gcFilter;
      this.clientID = generateNewClientId();
      this.guid = guid;
      this.collectionid = collectionid;
      this.share = /* @__PURE__ */ new Map();
      this.store = new StructStore();
      this._transaction = null;
      this._transactionCleanups = [];
      this.subdocs = /* @__PURE__ */ new Set();
      this._item = null;
      this.shouldLoad = shouldLoad;
      this.autoLoad = autoLoad;
      this.meta = meta2;
      this.isLoaded = false;
      this.isSynced = false;
      this.isDestroyed = false;
      this.whenLoaded = create9((resolve3) => {
        this.on("load", () => {
          this.isLoaded = true;
          resolve3(this);
        });
      });
      const provideSyncedPromise = () => create9((resolve3) => {
        const eventHandler = (isSynced) => {
          if (isSynced === void 0 || isSynced === true) {
            this.off("sync", eventHandler);
            resolve3();
          }
        };
        this.on("sync", eventHandler);
      });
      this.on("sync", (isSynced) => {
        if (isSynced === false && this.isSynced) {
          this.whenSynced = provideSyncedPromise();
        }
        this.isSynced = isSynced === void 0 || isSynced === true;
        if (this.isSynced && !this.isLoaded) {
          this.emit("load", [this]);
        }
      });
      this.whenSynced = provideSyncedPromise();
    }
    /**
     * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
     *
     * `load()` might be used in the future to request any provider to load the most current data.
     *
     * It is safe to call `load()` multiple times.
     */
    load() {
      const item = this._item;
      if (item !== null && !this.shouldLoad) {
        transact(
          /** @type {any} */
          item.parent.doc,
          (transaction) => {
            transaction.subdocsLoaded.add(this);
          },
          null,
          true
        );
      }
      this.shouldLoad = true;
    }
    getSubdocs() {
      return this.subdocs;
    }
    getSubdocGuids() {
      return new Set(from3(this.subdocs).map((doc4) => doc4.guid));
    }
    /**
     * Changes that happen inside of a transaction are bundled. This means that
     * the observer fires _after_ the transaction is finished and that all changes
     * that happened inside of the transaction are sent as one message to the
     * other peers.
     *
     * @template T
     * @param {function(Transaction):T} f The function that should be executed as a transaction
     * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
     * @return T
     *
     * @public
     */
    transact(f, origin = null) {
      return transact(this, f, origin);
    }
    /**
     * Define a shared data type.
     *
     * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
     * and do not overwrite each other. I.e.
     * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
     *
     * After this method is called, the type is also available on `ydoc.share.get(name)`.
     *
     * *Best Practices:*
     * Define all types right after the Y.Doc instance is created and store them in a separate object.
     * Also use the typed methods `getText(name)`, `getArray(name)`, ..
     *
     * @template {typeof AbstractType<any>} Type
     * @example
     *   const ydoc = new Y.Doc(..)
     *   const appState = {
     *     document: ydoc.getText('document')
     *     comments: ydoc.getArray('comments')
     *   }
     *
     * @param {string} name
     * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
     * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
     *
     * @public
     */
    get(name, TypeConstructor = (
      /** @type {any} */
      AbstractType
    )) {
      const type = setIfUndefined(this.share, name, () => {
        const t2 = new TypeConstructor();
        t2._integrate(this, null);
        return t2;
      });
      const Constr = type.constructor;
      if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
        if (Constr === AbstractType) {
          const t2 = new TypeConstructor();
          t2._map = type._map;
          type._map.forEach(
            /** @param {Item?} n */
            (n) => {
              for (; n !== null; n = n.left) {
                n.parent = t2;
              }
            }
          );
          t2._start = type._start;
          for (let n = t2._start; n !== null; n = n.right) {
            n.parent = t2;
          }
          t2._length = type._length;
          this.share.set(name, t2);
          t2._integrate(this, null);
          return (
            /** @type {InstanceType<Type>} */
            t2
          );
        } else {
          throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
        }
      }
      return (
        /** @type {InstanceType<Type>} */
        type
      );
    }
    /**
     * @template T
     * @param {string} [name]
     * @return {YArray<T>}
     *
     * @public
     */
    getArray(name = "") {
      return (
        /** @type {YArray<T>} */
        this.get(name, YArray)
      );
    }
    /**
     * @param {string} [name]
     * @return {YText}
     *
     * @public
     */
    getText(name = "") {
      return this.get(name, YText);
    }
    /**
     * @template T
     * @param {string} [name]
     * @return {YMap<T>}
     *
     * @public
     */
    getMap(name = "") {
      return (
        /** @type {YMap<T>} */
        this.get(name, YMap)
      );
    }
    /**
     * @param {string} [name]
     * @return {YXmlElement}
     *
     * @public
     */
    getXmlElement(name = "") {
      return (
        /** @type {YXmlElement<{[key:string]:string}>} */
        this.get(name, YXmlElement)
      );
    }
    /**
     * @param {string} [name]
     * @return {YXmlFragment}
     *
     * @public
     */
    getXmlFragment(name = "") {
      return this.get(name, YXmlFragment);
    }
    /**
     * Converts the entire document into a js object, recursively traversing each yjs type
     * Doesn't log types that have not been defined (using ydoc.getType(..)).
     *
     * @deprecated Do not use this method and rather call toJSON directly on the shared types.
     *
     * @return {Object<string, any>}
     */
    toJSON() {
      const doc4 = {};
      this.share.forEach((value, key2) => {
        doc4[key2] = value.toJSON();
      });
      return doc4;
    }
    /**
     * Emit `destroy` event and unregister all event handlers.
     */
    destroy() {
      this.isDestroyed = true;
      from3(this.subdocs).forEach((subdoc) => subdoc.destroy());
      const item = this._item;
      if (item !== null) {
        this._item = null;
        const content5 = (
          /** @type {ContentDoc} */
          item.content
        );
        content5.doc = new _Doc({ guid: this.guid, ...content5.opts, shouldLoad: false });
        content5.doc._item = item;
        transact(
          /** @type {any} */
          item.parent.doc,
          (transaction) => {
            const doc4 = content5.doc;
            if (!item.deleted) {
              transaction.subdocsAdded.add(doc4);
            }
            transaction.subdocsRemoved.add(this);
          },
          null,
          true
        );
      }
      this.emit("destroyed", [true]);
      this.emit("destroy", [this]);
      super.destroy();
    }
  };
  var DSDecoderV1 = class {
    /**
     * @param {decoding.Decoder} decoder
     */
    constructor(decoder) {
      this.restDecoder = decoder;
    }
    resetDsCurVal() {
    }
    /**
     * @return {number}
     */
    readDsClock() {
      return readVarUint(this.restDecoder);
    }
    /**
     * @return {number}
     */
    readDsLen() {
      return readVarUint(this.restDecoder);
    }
  };
  var UpdateDecoderV1 = class extends DSDecoderV1 {
    /**
     * @return {ID}
     */
    readLeftID() {
      return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
    }
    /**
     * @return {ID}
     */
    readRightID() {
      return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
    }
    /**
     * Read the next client id.
     * Use this in favor of readID whenever possible to reduce the number of objects created.
     */
    readClient() {
      return readVarUint(this.restDecoder);
    }
    /**
     * @return {number} info An unsigned 8-bit integer
     */
    readInfo() {
      return readUint8(this.restDecoder);
    }
    /**
     * @return {string}
     */
    readString() {
      return readVarString(this.restDecoder);
    }
    /**
     * @return {boolean} isKey
     */
    readParentInfo() {
      return readVarUint(this.restDecoder) === 1;
    }
    /**
     * @return {number} info An unsigned 8-bit integer
     */
    readTypeRef() {
      return readVarUint(this.restDecoder);
    }
    /**
     * Write len of a struct - well suited for Opt RLE encoder.
     *
     * @return {number} len
     */
    readLen() {
      return readVarUint(this.restDecoder);
    }
    /**
     * @return {any}
     */
    readAny() {
      return readAny(this.restDecoder);
    }
    /**
     * @return {Uint8Array}
     */
    readBuf() {
      return copyUint8Array(readVarUint8Array(this.restDecoder));
    }
    /**
     * Legacy implementation uses JSON parse. We use any-decoding in v2.
     *
     * @return {any}
     */
    readJSON() {
      return JSON.parse(readVarString(this.restDecoder));
    }
    /**
     * @return {string}
     */
    readKey() {
      return readVarString(this.restDecoder);
    }
  };
  var DSDecoderV2 = class {
    /**
     * @param {decoding.Decoder} decoder
     */
    constructor(decoder) {
      this.dsCurrVal = 0;
      this.restDecoder = decoder;
    }
    resetDsCurVal() {
      this.dsCurrVal = 0;
    }
    /**
     * @return {number}
     */
    readDsClock() {
      this.dsCurrVal += readVarUint(this.restDecoder);
      return this.dsCurrVal;
    }
    /**
     * @return {number}
     */
    readDsLen() {
      const diff = readVarUint(this.restDecoder) + 1;
      this.dsCurrVal += diff;
      return diff;
    }
  };
  var UpdateDecoderV2 = class extends DSDecoderV2 {
    /**
     * @param {decoding.Decoder} decoder
     */
    constructor(decoder) {
      super(decoder);
      this.keys = [];
      readVarUint(decoder);
      this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
      this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
      this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
      this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
      this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
      this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
      this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
      this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
      this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    }
    /**
     * @return {ID}
     */
    readLeftID() {
      return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
    }
    /**
     * @return {ID}
     */
    readRightID() {
      return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
    }
    /**
     * Read the next client id.
     * Use this in favor of readID whenever possible to reduce the number of objects created.
     */
    readClient() {
      return this.clientDecoder.read();
    }
    /**
     * @return {number} info An unsigned 8-bit integer
     */
    readInfo() {
      return (
        /** @type {number} */
        this.infoDecoder.read()
      );
    }
    /**
     * @return {string}
     */
    readString() {
      return this.stringDecoder.read();
    }
    /**
     * @return {boolean}
     */
    readParentInfo() {
      return this.parentInfoDecoder.read() === 1;
    }
    /**
     * @return {number} An unsigned 8-bit integer
     */
    readTypeRef() {
      return this.typeRefDecoder.read();
    }
    /**
     * Write len of a struct - well suited for Opt RLE encoder.
     *
     * @return {number}
     */
    readLen() {
      return this.lenDecoder.read();
    }
    /**
     * @return {any}
     */
    readAny() {
      return readAny(this.restDecoder);
    }
    /**
     * @return {Uint8Array}
     */
    readBuf() {
      return readVarUint8Array(this.restDecoder);
    }
    /**
     * This is mainly here for legacy purposes.
     *
     * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
     *
     * @return {any}
     */
    readJSON() {
      return readAny(this.restDecoder);
    }
    /**
     * @return {string}
     */
    readKey() {
      const keyClock = this.keyClockDecoder.read();
      if (keyClock < this.keys.length) {
        return this.keys[keyClock];
      } else {
        const key2 = this.stringDecoder.read();
        this.keys.push(key2);
        return key2;
      }
    }
  };
  var DSEncoderV1 = class {
    constructor() {
      this.restEncoder = createEncoder();
    }
    toUint8Array() {
      return toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
    }
    /**
     * @param {number} clock
     */
    writeDsClock(clock) {
      writeVarUint(this.restEncoder, clock);
    }
    /**
     * @param {number} len
     */
    writeDsLen(len) {
      writeVarUint(this.restEncoder, len);
    }
  };
  var UpdateEncoderV1 = class extends DSEncoderV1 {
    /**
     * @param {ID} id
     */
    writeLeftID(id2) {
      writeVarUint(this.restEncoder, id2.client);
      writeVarUint(this.restEncoder, id2.clock);
    }
    /**
     * @param {ID} id
     */
    writeRightID(id2) {
      writeVarUint(this.restEncoder, id2.client);
      writeVarUint(this.restEncoder, id2.clock);
    }
    /**
     * Use writeClient and writeClock instead of writeID if possible.
     * @param {number} client
     */
    writeClient(client) {
      writeVarUint(this.restEncoder, client);
    }
    /**
     * @param {number} info An unsigned 8-bit integer
     */
    writeInfo(info) {
      writeUint8(this.restEncoder, info);
    }
    /**
     * @param {string} s
     */
    writeString(s2) {
      writeVarString(this.restEncoder, s2);
    }
    /**
     * @param {boolean} isYKey
     */
    writeParentInfo(isYKey) {
      writeVarUint(this.restEncoder, isYKey ? 1 : 0);
    }
    /**
     * @param {number} info An unsigned 8-bit integer
     */
    writeTypeRef(info) {
      writeVarUint(this.restEncoder, info);
    }
    /**
     * Write len of a struct - well suited for Opt RLE encoder.
     *
     * @param {number} len
     */
    writeLen(len) {
      writeVarUint(this.restEncoder, len);
    }
    /**
     * @param {any} any
     */
    writeAny(any2) {
      writeAny(this.restEncoder, any2);
    }
    /**
     * @param {Uint8Array} buf
     */
    writeBuf(buf) {
      writeVarUint8Array(this.restEncoder, buf);
    }
    /**
     * @param {any} embed
     */
    writeJSON(embed) {
      writeVarString(this.restEncoder, JSON.stringify(embed));
    }
    /**
     * @param {string} key
     */
    writeKey(key2) {
      writeVarString(this.restEncoder, key2);
    }
  };
  var DSEncoderV2 = class {
    constructor() {
      this.restEncoder = createEncoder();
      this.dsCurrVal = 0;
    }
    toUint8Array() {
      return toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
      this.dsCurrVal = 0;
    }
    /**
     * @param {number} clock
     */
    writeDsClock(clock) {
      const diff = clock - this.dsCurrVal;
      this.dsCurrVal = clock;
      writeVarUint(this.restEncoder, diff);
    }
    /**
     * @param {number} len
     */
    writeDsLen(len) {
      if (len === 0) {
        unexpectedCase();
      }
      writeVarUint(this.restEncoder, len - 1);
      this.dsCurrVal += len;
    }
  };
  var UpdateEncoderV2 = class extends DSEncoderV2 {
    constructor() {
      super();
      this.keyMap = /* @__PURE__ */ new Map();
      this.keyClock = 0;
      this.keyClockEncoder = new IntDiffOptRleEncoder();
      this.clientEncoder = new UintOptRleEncoder();
      this.leftClockEncoder = new IntDiffOptRleEncoder();
      this.rightClockEncoder = new IntDiffOptRleEncoder();
      this.infoEncoder = new RleEncoder(writeUint8);
      this.stringEncoder = new StringEncoder();
      this.parentInfoEncoder = new RleEncoder(writeUint8);
      this.typeRefEncoder = new UintOptRleEncoder();
      this.lenEncoder = new UintOptRleEncoder();
    }
    toUint8Array() {
      const encoder = createEncoder();
      writeVarUint(encoder, 0);
      writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
      writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
      writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
      writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
      writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
      writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
      writeUint8Array(encoder, toUint8Array(this.restEncoder));
      return toUint8Array(encoder);
    }
    /**
     * @param {ID} id
     */
    writeLeftID(id2) {
      this.clientEncoder.write(id2.client);
      this.leftClockEncoder.write(id2.clock);
    }
    /**
     * @param {ID} id
     */
    writeRightID(id2) {
      this.clientEncoder.write(id2.client);
      this.rightClockEncoder.write(id2.clock);
    }
    /**
     * @param {number} client
     */
    writeClient(client) {
      this.clientEncoder.write(client);
    }
    /**
     * @param {number} info An unsigned 8-bit integer
     */
    writeInfo(info) {
      this.infoEncoder.write(info);
    }
    /**
     * @param {string} s
     */
    writeString(s2) {
      this.stringEncoder.write(s2);
    }
    /**
     * @param {boolean} isYKey
     */
    writeParentInfo(isYKey) {
      this.parentInfoEncoder.write(isYKey ? 1 : 0);
    }
    /**
     * @param {number} info An unsigned 8-bit integer
     */
    writeTypeRef(info) {
      this.typeRefEncoder.write(info);
    }
    /**
     * Write len of a struct - well suited for Opt RLE encoder.
     *
     * @param {number} len
     */
    writeLen(len) {
      this.lenEncoder.write(len);
    }
    /**
     * @param {any} any
     */
    writeAny(any2) {
      writeAny(this.restEncoder, any2);
    }
    /**
     * @param {Uint8Array} buf
     */
    writeBuf(buf) {
      writeVarUint8Array(this.restEncoder, buf);
    }
    /**
     * This is mainly here for legacy purposes.
     *
     * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
     *
     * @param {any} embed
     */
    writeJSON(embed) {
      writeAny(this.restEncoder, embed);
    }
    /**
     * Property keys are often reused. For example, in y-prosemirror the key `bold` might
     * occur very often. For a 3d application, the key `position` might occur very often.
     *
     * We cache these keys in a Map and refer to them via a unique number.
     *
     * @param {string} key
     */
    writeKey(key2) {
      const clock = this.keyMap.get(key2);
      if (clock === void 0) {
        this.keyClockEncoder.write(this.keyClock++);
        this.stringEncoder.write(key2);
      } else {
        this.keyClockEncoder.write(clock);
      }
    }
  };
  var writeStructs = (encoder, structs, client, clock) => {
    clock = max(clock, structs[0].id.clock);
    const startNewStructs = findIndexSS(structs, clock);
    writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
    encoder.writeClient(client);
    writeVarUint(encoder.restEncoder, clock);
    const firstStruct = structs[startNewStructs];
    firstStruct.write(encoder, clock - firstStruct.id.clock);
    for (let i = startNewStructs + 1; i < structs.length; i++) {
      structs[i].write(encoder, 0);
    }
  };
  var writeClientsStructs = (encoder, store, _sm) => {
    const sm = /* @__PURE__ */ new Map();
    _sm.forEach((clock, client) => {
      if (getState(store, client) > clock) {
        sm.set(client, clock);
      }
    });
    getStateVector(store).forEach((_clock, client) => {
      if (!_sm.has(client)) {
        sm.set(client, 0);
      }
    });
    writeVarUint(encoder.restEncoder, sm.size);
    from3(sm.entries()).sort((a2, b) => b[0] - a2[0]).forEach(([client, clock]) => {
      writeStructs(
        encoder,
        /** @type {Array<GC|Item>} */
        store.clients.get(client),
        client,
        clock
      );
    });
  };
  var readClientsStructRefs = (decoder, doc4) => {
    const clientRefs = create5();
    const numOfStateUpdates = readVarUint(decoder.restDecoder);
    for (let i = 0; i < numOfStateUpdates; i++) {
      const numberOfStructs = readVarUint(decoder.restDecoder);
      const refs = new Array(numberOfStructs);
      const client = decoder.readClient();
      let clock = readVarUint(decoder.restDecoder);
      clientRefs.set(client, { i: 0, refs });
      for (let i2 = 0; i2 < numberOfStructs; i2++) {
        const info = decoder.readInfo();
        switch (BITS5 & info) {
          case 0: {
            const len = decoder.readLen();
            refs[i2] = new GC(createID(client, clock), len);
            clock += len;
            break;
          }
          case 10: {
            const len = readVarUint(decoder.restDecoder);
            refs[i2] = new Skip(createID(client, clock), len);
            clock += len;
            break;
          }
          default: {
            const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
            const struct = new Item2(
              createID(client, clock),
              null,
              // left
              (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
              // origin
              null,
              // right
              (info & BIT7) === BIT7 ? decoder.readRightID() : null,
              // right origin
              cantCopyParentInfo ? decoder.readParentInfo() ? doc4.get(decoder.readString()) : decoder.readLeftID() : null,
              // parent
              cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
              // parentSub
              readItemContent(decoder, info)
              // item content
            );
            refs[i2] = struct;
            clock += struct.length;
          }
        }
      }
    }
    return clientRefs;
  };
  var integrateStructs = (transaction, store, clientsStructRefs) => {
    const stack = [];
    let clientsStructRefsIds = from3(clientsStructRefs.keys()).sort((a2, b) => a2 - b);
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    const getNextStructTarget = () => {
      if (clientsStructRefsIds.length === 0) {
        return null;
      }
      let nextStructsTarget = (
        /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
      );
      while (nextStructsTarget.refs.length === nextStructsTarget.i) {
        clientsStructRefsIds.pop();
        if (clientsStructRefsIds.length > 0) {
          nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
          clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
        } else {
          return null;
        }
      }
      return nextStructsTarget;
    };
    let curStructsTarget = getNextStructTarget();
    if (curStructsTarget === null) {
      return null;
    }
    const restStructs = new StructStore();
    const missingSV = /* @__PURE__ */ new Map();
    const updateMissingSv = (client, clock) => {
      const mclock = missingSV.get(client);
      if (mclock == null || mclock > clock) {
        missingSV.set(client, clock);
      }
    };
    let stackHead = (
      /** @type {any} */
      curStructsTarget.refs[
        /** @type {any} */
        curStructsTarget.i++
      ]
    );
    const state = /* @__PURE__ */ new Map();
    const addStackToRestSS = () => {
      for (const item of stack) {
        const client = item.id.client;
        const inapplicableItems = clientsStructRefs.get(client);
        if (inapplicableItems) {
          inapplicableItems.i--;
          restStructs.clients.set(client, inapplicableItems.refs.slice(inapplicableItems.i));
          clientsStructRefs.delete(client);
          inapplicableItems.i = 0;
          inapplicableItems.refs = [];
        } else {
          restStructs.clients.set(client, [item]);
        }
        clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);
      }
      stack.length = 0;
    };
    while (true) {
      if (stackHead.constructor !== Skip) {
        const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
        const offset = localClock - stackHead.id.clock;
        if (offset < 0) {
          stack.push(stackHead);
          updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
          addStackToRestSS();
        } else {
          const missing = stackHead.getMissing(transaction, store);
          if (missing !== null) {
            stack.push(stackHead);
            const structRefs = clientsStructRefs.get(
              /** @type {number} */
              missing
            ) || { refs: [], i: 0 };
            if (structRefs.refs.length === structRefs.i) {
              updateMissingSv(
                /** @type {number} */
                missing,
                getState(store, missing)
              );
              addStackToRestSS();
            } else {
              stackHead = structRefs.refs[structRefs.i++];
              continue;
            }
          } else if (offset === 0 || offset < stackHead.length) {
            stackHead.integrate(transaction, offset);
            state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
          }
        }
      }
      if (stack.length > 0) {
        stackHead = /** @type {GC|Item} */
        stack.pop();
      } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      } else {
        curStructsTarget = getNextStructTarget();
        if (curStructsTarget === null) {
          break;
        } else {
          stackHead = /** @type {GC|Item} */
          curStructsTarget.refs[curStructsTarget.i++];
        }
      }
    }
    if (restStructs.clients.size > 0) {
      const encoder = new UpdateEncoderV2();
      writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
      writeVarUint(encoder.restEncoder, 0);
      return { missing: missingSV, update: encoder.toUint8Array() };
    }
    return null;
  };
  var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
  var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
    transaction.local = false;
    let retry = false;
    const doc4 = transaction.doc;
    const store = doc4.store;
    const ss2 = readClientsStructRefs(structDecoder, doc4);
    const restStructs = integrateStructs(transaction, store, ss2);
    const pending = store.pendingStructs;
    if (pending) {
      for (const [client, clock] of pending.missing) {
        if (clock < getState(store, client)) {
          retry = true;
          break;
        }
      }
      if (restStructs) {
        for (const [client, clock] of restStructs.missing) {
          const mclock = pending.missing.get(client);
          if (mclock == null || mclock > clock) {
            pending.missing.set(client, clock);
          }
        }
        pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
      }
    } else {
      store.pendingStructs = restStructs;
    }
    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
    if (store.pendingDs) {
      const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
      readVarUint(pendingDSUpdate.restDecoder);
      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
      if (dsRest && dsRest2) {
        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
      } else {
        store.pendingDs = dsRest || dsRest2;
      }
    } else {
      store.pendingDs = dsRest;
    }
    if (retry) {
      const update = (
        /** @type {{update: Uint8Array}} */
        store.pendingStructs.update
      );
      store.pendingStructs = null;
      applyUpdateV2(transaction.doc, update);
    }
  }, transactionOrigin, false);
  var readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));
  var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
    const decoder = createDecoder(update);
    readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
  };
  var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
  var writeStateAsUpdate = (encoder, doc4, targetStateVector = /* @__PURE__ */ new Map()) => {
    writeClientsStructs(encoder, doc4.store, targetStateVector);
    writeDeleteSet(encoder, createDeleteSetFromStructStore(doc4.store));
  };
  var encodeStateAsUpdateV2 = (doc4, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
    const targetStateVector = decodeStateVector(encodedTargetStateVector);
    writeStateAsUpdate(encoder, doc4, targetStateVector);
    const updates = [encoder.toUint8Array()];
    if (doc4.store.pendingDs) {
      updates.push(doc4.store.pendingDs);
    }
    if (doc4.store.pendingStructs) {
      updates.push(diffUpdateV2(doc4.store.pendingStructs.update, encodedTargetStateVector));
    }
    if (updates.length > 1) {
      if (encoder.constructor === UpdateEncoderV1) {
        return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));
      } else if (encoder.constructor === UpdateEncoderV2) {
        return mergeUpdatesV2(updates);
      }
    }
    return updates[0];
  };
  var encodeStateAsUpdate = (doc4, encodedTargetStateVector) => encodeStateAsUpdateV2(doc4, encodedTargetStateVector, new UpdateEncoderV1());
  var readStateVector = (decoder) => {
    const ss2 = /* @__PURE__ */ new Map();
    const ssLength = readVarUint(decoder.restDecoder);
    for (let i = 0; i < ssLength; i++) {
      const client = readVarUint(decoder.restDecoder);
      const clock = readVarUint(decoder.restDecoder);
      ss2.set(client, clock);
    }
    return ss2;
  };
  var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
  var writeStateVector = (encoder, sv) => {
    writeVarUint(encoder.restEncoder, sv.size);
    from3(sv.entries()).sort((a2, b) => b[0] - a2[0]).forEach(([client, clock]) => {
      writeVarUint(encoder.restEncoder, client);
      writeVarUint(encoder.restEncoder, clock);
    });
    return encoder;
  };
  var writeDocumentStateVector = (encoder, doc4) => writeStateVector(encoder, getStateVector(doc4.store));
  var encodeStateVectorV2 = (doc4, encoder = new DSEncoderV2()) => {
    if (doc4 instanceof Map) {
      writeStateVector(encoder, doc4);
    } else {
      writeDocumentStateVector(encoder, doc4);
    }
    return encoder.toUint8Array();
  };
  var encodeStateVector = (doc4) => encodeStateVectorV2(doc4, new DSEncoderV1());
  var EventHandler = class {
    constructor() {
      this.l = [];
    }
  };
  var createEventHandler = () => new EventHandler();
  var addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);
  var removeEventHandlerListener = (eventHandler, f) => {
    const l = eventHandler.l;
    const len = l.length;
    eventHandler.l = l.filter((g) => f !== g);
    if (len === eventHandler.l.length) {
      console.error("[yjs] Tried to remove event handler that doesn't exist.");
    }
  };
  var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
  var ID = class {
    /**
     * @param {number} client client id
     * @param {number} clock unique per client id, continuous number
     */
    constructor(client, clock) {
      this.client = client;
      this.clock = clock;
    }
  };
  var compareIDs = (a2, b) => a2 === b || a2 !== null && b !== null && a2.client === b.client && a2.clock === b.clock;
  var createID = (client, clock) => new ID(client, clock);
  var writeID = (encoder, id2) => {
    writeVarUint(encoder, id2.client);
    writeVarUint(encoder, id2.clock);
  };
  var readID = (decoder) => createID(readVarUint(decoder), readVarUint(decoder));
  var findRootTypeKey = (type) => {
    for (const [key2, value] of type.doc.share.entries()) {
      if (value === type) {
        return key2;
      }
    }
    throw unexpectedCase();
  };
  var isParentOf2 = (parent, child) => {
    while (child !== null) {
      if (child.parent === parent) {
        return true;
      }
      child = /** @type {AbstractType<any>} */
      child.parent._item;
    }
    return false;
  };
  var logType = (type) => {
    const res = [];
    let n = type._start;
    while (n) {
      res.push(n);
      n = n.right;
    }
    console.log("Children: ", res);
    console.log("Children content: ", res.filter((m) => !m.deleted).map((m) => m.content));
  };
  var PermanentUserData = class {
    /**
     * @param {Doc} doc
     * @param {YMap<any>} [storeType]
     */
    constructor(doc4, storeType = doc4.getMap("users")) {
      const dss = /* @__PURE__ */ new Map();
      this.yusers = storeType;
      this.doc = doc4;
      this.clients = /* @__PURE__ */ new Map();
      this.dss = dss;
      const initUser = (user, userDescription) => {
        const ds2 = user.get("ds");
        const ids = user.get("ids");
        const addClientId = (
          /** @param {number} clientid */
          (clientid) => this.clients.set(clientid, userDescription)
        );
        ds2.observe(
          /** @param {YArrayEvent<any>} event */
          (event) => {
            event.changes.added.forEach((item) => {
              item.content.getContent().forEach((encodedDs) => {
                if (encodedDs instanceof Uint8Array) {
                  this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(createDecoder(encodedDs)))]));
                }
              });
            });
          }
        );
        this.dss.set(userDescription, mergeDeleteSets(ds2.map((encodedDs) => readDeleteSet(new DSDecoderV1(createDecoder(encodedDs))))));
        ids.observe(
          /** @param {YArrayEvent<any>} event */
          (event) => event.changes.added.forEach((item) => item.content.getContent().forEach(addClientId))
        );
        ids.forEach(addClientId);
      };
      storeType.observe((event) => {
        event.keysChanged.forEach(
          (userDescription) => initUser(storeType.get(userDescription), userDescription)
        );
      });
      storeType.forEach(initUser);
    }
    /**
     * @param {Doc} doc
     * @param {number} clientid
     * @param {string} userDescription
     * @param {Object} conf
     * @param {function(Transaction, DeleteSet):boolean} [conf.filter]
     */
    setUserMapping(doc4, clientid, userDescription, { filter = () => true } = {}) {
      const users = this.yusers;
      let user = users.get(userDescription);
      if (!user) {
        user = new YMap();
        user.set("ids", new YArray());
        user.set("ds", new YArray());
        users.set(userDescription, user);
      }
      user.get("ids").push([clientid]);
      users.observe((_event) => {
        setTimeout(() => {
          const userOverwrite = users.get(userDescription);
          if (userOverwrite !== user) {
            user = userOverwrite;
            this.clients.forEach((_userDescription, clientid2) => {
              if (userDescription === _userDescription) {
                user.get("ids").push([clientid2]);
              }
            });
            const encoder = new DSEncoderV1();
            const ds2 = this.dss.get(userDescription);
            if (ds2) {
              writeDeleteSet(encoder, ds2);
              user.get("ds").push([encoder.toUint8Array()]);
            }
          }
        }, 0);
      });
      doc4.on(
        "afterTransaction",
        /** @param {Transaction} transaction */
        (transaction) => {
          setTimeout(() => {
            const yds = user.get("ds");
            const ds2 = transaction.deleteSet;
            if (transaction.local && ds2.clients.size > 0 && filter(transaction, ds2)) {
              const encoder = new DSEncoderV1();
              writeDeleteSet(encoder, ds2);
              yds.push([encoder.toUint8Array()]);
            }
          });
        }
      );
    }
    /**
     * @param {number} clientid
     * @return {any}
     */
    getUserByClientId(clientid) {
      return this.clients.get(clientid) || null;
    }
    /**
     * @param {ID} id
     * @return {string | null}
     */
    getUserByDeletedId(id2) {
      for (const [userDescription, ds2] of this.dss.entries()) {
        if (isDeleted(ds2, id2)) {
          return userDescription;
        }
      }
      return null;
    }
  };
  var RelativePosition = class {
    /**
     * @param {ID|null} type
     * @param {string|null} tname
     * @param {ID|null} item
     * @param {number} assoc
     */
    constructor(type, tname, item, assoc = 0) {
      this.type = type;
      this.tname = tname;
      this.item = item;
      this.assoc = assoc;
    }
  };
  var relativePositionToJSON = (rpos) => {
    const json = {};
    if (rpos.type) {
      json.type = rpos.type;
    }
    if (rpos.tname) {
      json.tname = rpos.tname;
    }
    if (rpos.item) {
      json.item = rpos.item;
    }
    if (rpos.assoc != null) {
      json.assoc = rpos.assoc;
    }
    return json;
  };
  var createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname ?? null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
  var AbsolutePosition = class {
    /**
     * @param {AbstractType<any>} type
     * @param {number} index
     * @param {number} [assoc]
     */
    constructor(type, index3, assoc = 0) {
      this.type = type;
      this.index = index3;
      this.assoc = assoc;
    }
  };
  var createAbsolutePosition = (type, index3, assoc = 0) => new AbsolutePosition(type, index3, assoc);
  var createRelativePosition = (type, item, assoc) => {
    let typeid = null;
    let tname = null;
    if (type._item === null) {
      tname = findRootTypeKey(type);
    } else {
      typeid = createID(type._item.id.client, type._item.id.clock);
    }
    return new RelativePosition(typeid, tname, item, assoc);
  };
  var createRelativePositionFromTypeIndex = (type, index3, assoc = 0) => {
    let t2 = type._start;
    if (assoc < 0) {
      if (index3 === 0) {
        return createRelativePosition(type, null, assoc);
      }
      index3--;
    }
    while (t2 !== null) {
      if (!t2.deleted && t2.countable) {
        if (t2.length > index3) {
          return createRelativePosition(type, createID(t2.id.client, t2.id.clock + index3), assoc);
        }
        index3 -= t2.length;
      }
      if (t2.right === null && assoc < 0) {
        return createRelativePosition(type, t2.lastId, assoc);
      }
      t2 = t2.right;
    }
    return createRelativePosition(type, null, assoc);
  };
  var writeRelativePosition = (encoder, rpos) => {
    const { type, tname, item, assoc } = rpos;
    if (item !== null) {
      writeVarUint(encoder, 0);
      writeID(encoder, item);
    } else if (tname !== null) {
      writeUint8(encoder, 1);
      writeVarString(encoder, tname);
    } else if (type !== null) {
      writeUint8(encoder, 2);
      writeID(encoder, type);
    } else {
      throw unexpectedCase();
    }
    writeVarInt(encoder, assoc);
    return encoder;
  };
  var encodeRelativePosition = (rpos) => {
    const encoder = createEncoder();
    writeRelativePosition(encoder, rpos);
    return toUint8Array(encoder);
  };
  var readRelativePosition = (decoder) => {
    let type = null;
    let tname = null;
    let itemID = null;
    switch (readVarUint(decoder)) {
      case 0:
        itemID = readID(decoder);
        break;
      case 1:
        tname = readVarString(decoder);
        break;
      case 2: {
        type = readID(decoder);
      }
    }
    const assoc = hasContent2(decoder) ? readVarInt(decoder) : 0;
    return new RelativePosition(type, tname, itemID, assoc);
  };
  var decodeRelativePosition = (uint8Array) => readRelativePosition(createDecoder(uint8Array));
  var getItemWithOffset = (store, id2) => {
    const item = getItem(store, id2);
    const diff = id2.clock - item.id.clock;
    return {
      item,
      diff
    };
  };
  var createAbsolutePositionFromRelativePosition = (rpos, doc4, followUndoneDeletions = true) => {
    const store = doc4.store;
    const rightID = rpos.item;
    const typeID = rpos.type;
    const tname = rpos.tname;
    const assoc = rpos.assoc;
    let type = null;
    let index3 = 0;
    if (rightID !== null) {
      if (getState(store, rightID.client) <= rightID.clock) {
        return null;
      }
      const res = followUndoneDeletions ? followRedone(store, rightID) : getItemWithOffset(store, rightID);
      const right = res.item;
      if (!(right instanceof Item2)) {
        return null;
      }
      type = /** @type {AbstractType<any>} */
      right.parent;
      if (type._item === null || !type._item.deleted) {
        index3 = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
        let n = right.left;
        while (n !== null) {
          if (!n.deleted && n.countable) {
            index3 += n.length;
          }
          n = n.left;
        }
      }
    } else {
      if (tname !== null) {
        type = doc4.get(tname);
      } else if (typeID !== null) {
        if (getState(store, typeID.client) <= typeID.clock) {
          return null;
        }
        const { item } = followUndoneDeletions ? followRedone(store, typeID) : { item: getItem(store, typeID) };
        if (item instanceof Item2 && item.content instanceof ContentType) {
          type = item.content.type;
        } else {
          return null;
        }
      } else {
        throw unexpectedCase();
      }
      if (assoc >= 0) {
        index3 = type._length;
      } else {
        index3 = 0;
      }
    }
    return createAbsolutePosition(type, index3, rpos.assoc);
  };
  var compareRelativePositions = (a2, b) => a2 === b || a2 !== null && b !== null && a2.tname === b.tname && compareIDs(a2.item, b.item) && compareIDs(a2.type, b.type) && a2.assoc === b.assoc;
  var Snapshot = class {
    /**
     * @param {DeleteSet} ds
     * @param {Map<number,number>} sv state map
     */
    constructor(ds2, sv) {
      this.ds = ds2;
      this.sv = sv;
    }
  };
  var equalSnapshots = (snap1, snap2) => {
    const ds1 = snap1.ds.clients;
    const ds2 = snap2.ds.clients;
    const sv1 = snap1.sv;
    const sv2 = snap2.sv;
    if (sv1.size !== sv2.size || ds1.size !== ds2.size) {
      return false;
    }
    for (const [key2, value] of sv1.entries()) {
      if (sv2.get(key2) !== value) {
        return false;
      }
    }
    for (const [client, dsitems1] of ds1.entries()) {
      const dsitems2 = ds2.get(client) || [];
      if (dsitems1.length !== dsitems2.length) {
        return false;
      }
      for (let i = 0; i < dsitems1.length; i++) {
        const dsitem1 = dsitems1[i];
        const dsitem2 = dsitems2[i];
        if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {
          return false;
        }
      }
    }
    return true;
  };
  var encodeSnapshotV2 = (snapshot2, encoder = new DSEncoderV2()) => {
    writeDeleteSet(encoder, snapshot2.ds);
    writeStateVector(encoder, snapshot2.sv);
    return encoder.toUint8Array();
  };
  var encodeSnapshot = (snapshot2) => encodeSnapshotV2(snapshot2, new DSEncoderV1());
  var decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(createDecoder(buf))) => {
    return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));
  };
  var decodeSnapshot = (buf) => decodeSnapshotV2(buf, new DSDecoderV1(createDecoder(buf)));
  var createSnapshot = (ds2, sm) => new Snapshot(ds2, sm);
  var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
  var snapshot = (doc4) => createSnapshot(createDeleteSetFromStructStore(doc4.store), getStateVector(doc4.store));
  var isVisible = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && (snapshot2.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot2.ds, item.id);
  var splitSnapshotAffectedStructs = (transaction, snapshot2) => {
    const meta2 = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create6);
    const store = transaction.doc.store;
    if (!meta2.has(snapshot2)) {
      snapshot2.sv.forEach((clock, client) => {
        if (clock < getState(store, client)) {
          getItemCleanStart(transaction, createID(client, clock));
        }
      });
      iterateDeletedStructs(transaction, snapshot2.ds, (_item) => {
      });
      meta2.add(snapshot2);
    }
  };
  var createDocFromSnapshot = (originDoc, snapshot2, newDoc = new Doc()) => {
    if (originDoc.gc) {
      throw new Error("Garbage-collection must be disabled in `originDoc`!");
    }
    const { sv, ds: ds2 } = snapshot2;
    const encoder = new UpdateEncoderV2();
    originDoc.transact((transaction) => {
      let size2 = 0;
      sv.forEach((clock) => {
        if (clock > 0) {
          size2++;
        }
      });
      writeVarUint(encoder.restEncoder, size2);
      for (const [client, clock] of sv) {
        if (clock === 0) {
          continue;
        }
        if (clock < getState(originDoc.store, client)) {
          getItemCleanStart(transaction, createID(client, clock));
        }
        const structs = originDoc.store.clients.get(client) || [];
        const lastStructIndex = findIndexSS(structs, clock - 1);
        writeVarUint(encoder.restEncoder, lastStructIndex + 1);
        encoder.writeClient(client);
        writeVarUint(encoder.restEncoder, 0);
        for (let i = 0; i <= lastStructIndex; i++) {
          structs[i].write(encoder, 0);
        }
      }
      writeDeleteSet(encoder, ds2);
    });
    applyUpdateV2(newDoc, encoder.toUint8Array(), "snapshot");
    return newDoc;
  };
  var snapshotContainsUpdateV2 = (snapshot2, update, YDecoder = UpdateDecoderV2) => {
    const updateDecoder = new YDecoder(createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
      if ((snapshot2.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {
        return false;
      }
    }
    const mergedDS = mergeDeleteSets([snapshot2.ds, readDeleteSet(updateDecoder)]);
    return equalDeleteSets(snapshot2.ds, mergedDS);
  };
  var snapshotContainsUpdate = (snapshot2, update) => snapshotContainsUpdateV2(snapshot2, update, UpdateDecoderV1);
  var StructStore = class {
    constructor() {
      this.clients = /* @__PURE__ */ new Map();
      this.pendingStructs = null;
      this.pendingDs = null;
    }
  };
  var getStateVector = (store) => {
    const sm = /* @__PURE__ */ new Map();
    store.clients.forEach((structs, client) => {
      const struct = structs[structs.length - 1];
      sm.set(client, struct.id.clock + struct.length);
    });
    return sm;
  };
  var getState = (store, client) => {
    const structs = store.clients.get(client);
    if (structs === void 0) {
      return 0;
    }
    const lastStruct = structs[structs.length - 1];
    return lastStruct.id.clock + lastStruct.length;
  };
  var addStruct = (store, struct) => {
    let structs = store.clients.get(struct.id.client);
    if (structs === void 0) {
      structs = [];
      store.clients.set(struct.id.client, structs);
    } else {
      const lastStruct = structs[structs.length - 1];
      if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
        throw unexpectedCase();
      }
    }
    structs.push(struct);
  };
  var findIndexSS = (structs, clock) => {
    let left = 0;
    let right = structs.length - 1;
    let mid = structs[right];
    let midclock = mid.id.clock;
    if (midclock === clock) {
      return right;
    }
    let midindex = floor(clock / (midclock + mid.length - 1) * right);
    while (left <= right) {
      mid = structs[midindex];
      midclock = mid.id.clock;
      if (midclock <= clock) {
        if (clock < midclock + mid.length) {
          return midindex;
        }
        left = midindex + 1;
      } else {
        right = midindex - 1;
      }
      midindex = floor((left + right) / 2);
    }
    throw unexpectedCase();
  };
  var find3 = (store, id2) => {
    const structs = store.clients.get(id2.client);
    return structs[findIndexSS(structs, id2.clock)];
  };
  var getItem = (
    /** @type {function(StructStore,ID):Item} */
    find3
  );
  var findIndexCleanStart = (transaction, structs, clock) => {
    const index3 = findIndexSS(structs, clock);
    const struct = structs[index3];
    if (struct.id.clock < clock && struct instanceof Item2) {
      structs.splice(index3 + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
      return index3 + 1;
    }
    return index3;
  };
  var getItemCleanStart = (transaction, id2) => {
    const structs = (
      /** @type {Array<Item>} */
      transaction.doc.store.clients.get(id2.client)
    );
    return structs[findIndexCleanStart(transaction, structs, id2.clock)];
  };
  var getItemCleanEnd = (transaction, store, id2) => {
    const structs = store.clients.get(id2.client);
    const index3 = findIndexSS(structs, id2.clock);
    const struct = structs[index3];
    if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
      structs.splice(index3 + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
    }
    return struct;
  };
  var replaceStruct = (store, struct, newStruct) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(struct.id.client)
    );
    structs[findIndexSS(structs, struct.id.clock)] = newStruct;
  };
  var iterateStructs = (transaction, structs, clockStart, len, f) => {
    if (len === 0) {
      return;
    }
    const clockEnd = clockStart + len;
    let index3 = findIndexCleanStart(transaction, structs, clockStart);
    let struct;
    do {
      struct = structs[index3++];
      if (clockEnd < struct.id.clock + struct.length) {
        findIndexCleanStart(transaction, structs, clockEnd);
      }
      f(struct);
    } while (index3 < structs.length && structs[index3].id.clock < clockEnd);
  };
  var Transaction2 = class {
    /**
     * @param {Doc} doc
     * @param {any} origin
     * @param {boolean} local
     */
    constructor(doc4, origin, local) {
      this.doc = doc4;
      this.deleteSet = new DeleteSet();
      this.beforeState = getStateVector(doc4.store);
      this.afterState = /* @__PURE__ */ new Map();
      this.changed = /* @__PURE__ */ new Map();
      this.changedParentTypes = /* @__PURE__ */ new Map();
      this._mergeStructs = [];
      this.origin = origin;
      this.meta = /* @__PURE__ */ new Map();
      this.local = local;
      this.subdocsAdded = /* @__PURE__ */ new Set();
      this.subdocsRemoved = /* @__PURE__ */ new Set();
      this.subdocsLoaded = /* @__PURE__ */ new Set();
      this._needFormattingCleanup = false;
    }
  };
  var writeUpdateMessageFromTransaction = (encoder, transaction) => {
    if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
      return false;
    }
    sortAndMergeDeleteSet(transaction.deleteSet);
    writeStructsFromTransaction(encoder, transaction);
    writeDeleteSet(encoder, transaction.deleteSet);
    return true;
  };
  var addChangedTypeToTransaction = (transaction, type, parentSub) => {
    const item = type._item;
    if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
      setIfUndefined(transaction.changed, type, create6).add(parentSub);
    }
  };
  var tryToMergeWithLefts = (structs, pos) => {
    let right = structs[pos];
    let left = structs[pos - 1];
    let i = pos;
    for (; i > 0; right = left, left = structs[--i - 1]) {
      if (left.deleted === right.deleted && left.constructor === right.constructor) {
        if (left.mergeWith(right)) {
          if (right instanceof Item2 && right.parentSub !== null && /** @type {AbstractType<any>} */
          right.parent._map.get(right.parentSub) === right) {
            right.parent._map.set(
              right.parentSub,
              /** @type {Item} */
              left
            );
          }
          continue;
        }
      }
      break;
    }
    const merged = pos - i;
    if (merged) {
      structs.splice(pos + 1 - merged, merged);
    }
    return merged;
  };
  var tryGcDeleteSet = (ds2, store, gcFilter) => {
    for (const [client, deleteItems] of ds2.clients.entries()) {
      const structs = (
        /** @type {Array<GC|Item>} */
        store.clients.get(client)
      );
      for (let di2 = deleteItems.length - 1; di2 >= 0; di2--) {
        const deleteItem = deleteItems[di2];
        const endDeleteItemClock = deleteItem.clock + deleteItem.len;
        for (let si2 = findIndexSS(structs, deleteItem.clock), struct = structs[si2]; si2 < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si2]) {
          const struct2 = structs[si2];
          if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
            break;
          }
          if (struct2 instanceof Item2 && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
            struct2.gc(store, false);
          }
        }
      }
    }
  };
  var tryMergeDeleteSet = (ds2, store) => {
    ds2.clients.forEach((deleteItems, client) => {
      const structs = (
        /** @type {Array<GC|Item>} */
        store.clients.get(client)
      );
      for (let di2 = deleteItems.length - 1; di2 >= 0; di2--) {
        const deleteItem = deleteItems[di2];
        const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
        for (let si2 = mostRightIndexToCheck, struct = structs[si2]; si2 > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si2]) {
          si2 -= 1 + tryToMergeWithLefts(structs, si2);
        }
      }
    });
  };
  var tryGc = (ds2, store, gcFilter) => {
    tryGcDeleteSet(ds2, store, gcFilter);
    tryMergeDeleteSet(ds2, store);
  };
  var cleanupTransactions = (transactionCleanups, i) => {
    if (i < transactionCleanups.length) {
      const transaction = transactionCleanups[i];
      const doc4 = transaction.doc;
      const store = doc4.store;
      const ds2 = transaction.deleteSet;
      const mergeStructs = transaction._mergeStructs;
      try {
        sortAndMergeDeleteSet(ds2);
        transaction.afterState = getStateVector(transaction.doc.store);
        doc4.emit("beforeObserverCalls", [transaction, doc4]);
        const fs2 = [];
        transaction.changed.forEach(
          (subs, itemtype) => fs2.push(() => {
            if (itemtype._item === null || !itemtype._item.deleted) {
              itemtype._callObserver(transaction, subs);
            }
          })
        );
        fs2.push(() => {
          transaction.changedParentTypes.forEach((events, type) => {
            if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
              events = events.filter(
                (event) => event.target._item === null || !event.target._item.deleted
              );
              events.forEach((event) => {
                event.currentTarget = type;
                event._path = null;
              });
              events.sort((event1, event2) => event1.path.length - event2.path.length);
              callEventHandlerListeners(type._dEH, events, transaction);
            }
          });
        });
        fs2.push(() => doc4.emit("afterTransaction", [transaction, doc4]));
        callAll(fs2, []);
        if (transaction._needFormattingCleanup) {
          cleanupYTextAfterTransaction(transaction);
        }
      } finally {
        if (doc4.gc) {
          tryGcDeleteSet(ds2, store, doc4.gcFilter);
        }
        tryMergeDeleteSet(ds2, store);
        transaction.afterState.forEach((clock, client) => {
          const beforeClock = transaction.beforeState.get(client) || 0;
          if (beforeClock !== clock) {
            const structs = (
              /** @type {Array<GC|Item>} */
              store.clients.get(client)
            );
            const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
            for (let i2 = structs.length - 1; i2 >= firstChangePos; ) {
              i2 -= 1 + tryToMergeWithLefts(structs, i2);
            }
          }
        });
        for (let i2 = mergeStructs.length - 1; i2 >= 0; i2--) {
          const { client, clock } = mergeStructs[i2].id;
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const replacedStructPos = findIndexSS(structs, clock);
          if (replacedStructPos + 1 < structs.length) {
            if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
              continue;
            }
          }
          if (replacedStructPos > 0) {
            tryToMergeWithLefts(structs, replacedStructPos);
          }
        }
        if (!transaction.local && transaction.afterState.get(doc4.clientID) !== transaction.beforeState.get(doc4.clientID)) {
          print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
          doc4.clientID = generateNewClientId();
        }
        doc4.emit("afterTransactionCleanup", [transaction, doc4]);
        if (doc4._observers.has("update")) {
          const encoder = new UpdateEncoderV1();
          const hasContent3 = writeUpdateMessageFromTransaction(encoder, transaction);
          if (hasContent3) {
            doc4.emit("update", [encoder.toUint8Array(), transaction.origin, doc4, transaction]);
          }
        }
        if (doc4._observers.has("updateV2")) {
          const encoder = new UpdateEncoderV2();
          const hasContent3 = writeUpdateMessageFromTransaction(encoder, transaction);
          if (hasContent3) {
            doc4.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc4, transaction]);
          }
        }
        const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
        if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
          subdocsAdded.forEach((subdoc) => {
            subdoc.clientID = doc4.clientID;
            if (subdoc.collectionid == null) {
              subdoc.collectionid = doc4.collectionid;
            }
            doc4.subdocs.add(subdoc);
          });
          subdocsRemoved.forEach((subdoc) => doc4.subdocs.delete(subdoc));
          doc4.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc4, transaction]);
          subdocsRemoved.forEach((subdoc) => subdoc.destroy());
        }
        if (transactionCleanups.length <= i + 1) {
          doc4._transactionCleanups = [];
          doc4.emit("afterAllTransactions", [doc4, transactionCleanups]);
        } else {
          cleanupTransactions(transactionCleanups, i + 1);
        }
      }
    }
  };
  var transact = (doc4, f, origin = null, local = true) => {
    const transactionCleanups = doc4._transactionCleanups;
    let initialCall = false;
    let result = null;
    if (doc4._transaction === null) {
      initialCall = true;
      doc4._transaction = new Transaction2(doc4, origin, local);
      transactionCleanups.push(doc4._transaction);
      if (transactionCleanups.length === 1) {
        doc4.emit("beforeAllTransactions", [doc4]);
      }
      doc4.emit("beforeTransaction", [doc4._transaction, doc4]);
    }
    try {
      result = f(doc4._transaction);
    } finally {
      if (initialCall) {
        const finishCleanup = doc4._transaction === transactionCleanups[0];
        doc4._transaction = null;
        if (finishCleanup) {
          cleanupTransactions(transactionCleanups, 0);
        }
      }
    }
    return result;
  };
  var StackItem = class {
    /**
     * @param {DeleteSet} deletions
     * @param {DeleteSet} insertions
     */
    constructor(deletions, insertions) {
      this.insertions = insertions;
      this.deletions = deletions;
      this.meta = /* @__PURE__ */ new Map();
    }
  };
  var clearUndoManagerStackItem = (tr3, um, stackItem) => {
    iterateDeletedStructs(tr3, stackItem.deletions, (item) => {
      if (item instanceof Item2 && um.scope.some((type) => type === tr3.doc || isParentOf2(
        /** @type {AbstractType<any>} */
        type,
        item
      ))) {
        keepItem(item, false);
      }
    });
  };
  var popStackItem = (undoManager, stack, eventType) => {
    let _tr = null;
    const doc4 = undoManager.doc;
    const scope = undoManager.scope;
    transact(doc4, (transaction) => {
      while (stack.length > 0 && undoManager.currStackItem === null) {
        const store = doc4.store;
        const stackItem = (
          /** @type {StackItem} */
          stack.pop()
        );
        const itemsToRedo = /* @__PURE__ */ new Set();
        const itemsToDelete = [];
        let performedChange = false;
        iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {
          if (struct instanceof Item2) {
            if (struct.redone !== null) {
              let { item, diff } = followRedone(store, struct.id);
              if (diff > 0) {
                item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
              }
              struct = item;
            }
            if (!struct.deleted && scope.some((type) => type === transaction.doc || isParentOf2(
              /** @type {AbstractType<any>} */
              type,
              /** @type {Item} */
              struct
            ))) {
              itemsToDelete.push(struct);
            }
          }
        });
        iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {
          if (struct instanceof Item2 && scope.some((type) => type === transaction.doc || isParentOf2(
            /** @type {AbstractType<any>} */
            type,
            struct
          )) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
          !isDeleted(stackItem.insertions, struct.id)) {
            itemsToRedo.add(struct);
          }
        });
        itemsToRedo.forEach((struct) => {
          performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
        });
        for (let i = itemsToDelete.length - 1; i >= 0; i--) {
          const item = itemsToDelete[i];
          if (undoManager.deleteFilter(item)) {
            item.delete(transaction);
            performedChange = true;
          }
        }
        undoManager.currStackItem = performedChange ? stackItem : null;
      }
      transaction.changed.forEach((subProps, type) => {
        if (subProps.has(null) && type._searchMarker) {
          type._searchMarker.length = 0;
        }
      });
      _tr = transaction;
    }, undoManager);
    const res = undoManager.currStackItem;
    if (res != null) {
      const changedParentTypes = _tr.changedParentTypes;
      undoManager.emit("stack-item-popped", [{ stackItem: res, type: eventType, changedParentTypes, origin: undoManager }, undoManager]);
      undoManager.currStackItem = null;
    }
    return res;
  };
  var UndoManager = class extends ObservableV2 {
    /**
     * @param {Doc|AbstractType<any>|Array<AbstractType<any>>} typeScope Limits the scope of the UndoManager. If this is set to a ydoc instance, all changes on that ydoc will be undone. If set to a specific type, only changes on that type or its children will be undone. Also accepts an array of types.
     * @param {UndoManagerOptions} options
     */
    constructor(typeScope, {
      captureTimeout = 500,
      captureTransaction = (_tr) => true,
      deleteFilter = () => true,
      trackedOrigins = /* @__PURE__ */ new Set([null]),
      ignoreRemoteMapChanges = false,
      doc: doc4 = (
        /** @type {Doc} */
        isArray(typeScope) ? typeScope[0].doc : typeScope instanceof Doc ? typeScope : typeScope.doc
      )
    } = {}) {
      super();
      this.scope = [];
      this.doc = doc4;
      this.addToScope(typeScope);
      this.deleteFilter = deleteFilter;
      trackedOrigins.add(this);
      this.trackedOrigins = trackedOrigins;
      this.captureTransaction = captureTransaction;
      this.undoStack = [];
      this.redoStack = [];
      this.undoing = false;
      this.redoing = false;
      this.currStackItem = null;
      this.lastChange = 0;
      this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
      this.captureTimeout = captureTimeout;
      this.afterTransactionHandler = (transaction) => {
        if (!this.captureTransaction(transaction) || !this.scope.some((type) => transaction.changedParentTypes.has(
          /** @type {AbstractType<any>} */
          type
        ) || type === this.doc) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
          return;
        }
        const undoing = this.undoing;
        const redoing = this.redoing;
        const stack = undoing ? this.redoStack : this.undoStack;
        if (undoing) {
          this.stopCapturing();
        } else if (!redoing) {
          this.clear(false, true);
        }
        const insertions = new DeleteSet();
        transaction.afterState.forEach((endClock, client) => {
          const startClock = transaction.beforeState.get(client) || 0;
          const len = endClock - startClock;
          if (len > 0) {
            addToDeleteSet(insertions, client, startClock, len);
          }
        });
        const now = getUnixTime();
        let didAdd = false;
        if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
          const lastOp = stack[stack.length - 1];
          lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
          lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
        } else {
          stack.push(new StackItem(transaction.deleteSet, insertions));
          didAdd = true;
        }
        if (!undoing && !redoing) {
          this.lastChange = now;
        }
        iterateDeletedStructs(
          transaction,
          transaction.deleteSet,
          /** @param {Item|GC} item */
          (item) => {
            if (item instanceof Item2 && this.scope.some((type) => type === transaction.doc || isParentOf2(
              /** @type {AbstractType<any>} */
              type,
              item
            ))) {
              keepItem(item, true);
            }
          }
        );
        const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction.changedParentTypes }, this];
        if (didAdd) {
          this.emit("stack-item-added", changeEvent);
        } else {
          this.emit("stack-item-updated", changeEvent);
        }
      };
      this.doc.on("afterTransaction", this.afterTransactionHandler);
      this.doc.on("destroy", () => {
        this.destroy();
      });
    }
    /**
     * Extend the scope.
     *
     * @param {Array<AbstractType<any> | Doc> | AbstractType<any> | Doc} ytypes
     */
    addToScope(ytypes) {
      const tmpSet = new Set(this.scope);
      ytypes = isArray(ytypes) ? ytypes : [ytypes];
      ytypes.forEach((ytype) => {
        if (!tmpSet.has(ytype)) {
          tmpSet.add(ytype);
          if (ytype instanceof AbstractType ? ytype.doc !== this.doc : ytype !== this.doc) warn2("[yjs#509] Not same Y.Doc");
          this.scope.push(ytype);
        }
      });
    }
    /**
     * @param {any} origin
     */
    addTrackedOrigin(origin) {
      this.trackedOrigins.add(origin);
    }
    /**
     * @param {any} origin
     */
    removeTrackedOrigin(origin) {
      this.trackedOrigins.delete(origin);
    }
    clear(clearUndoStack = true, clearRedoStack = true) {
      if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
        this.doc.transact((tr3) => {
          if (clearUndoStack) {
            this.undoStack.forEach((item) => clearUndoManagerStackItem(tr3, this, item));
            this.undoStack = [];
          }
          if (clearRedoStack) {
            this.redoStack.forEach((item) => clearUndoManagerStackItem(tr3, this, item));
            this.redoStack = [];
          }
          this.emit("stack-cleared", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
        });
      }
    }
    /**
     * UndoManager merges Undo-StackItem if they are created within time-gap
     * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
     * StackItem won't be merged.
     *
     *
     * @example
     *     // without stopCapturing
     *     ytext.insert(0, 'a')
     *     ytext.insert(1, 'b')
     *     um.undo()
     *     ytext.toString() // => '' (note that 'ab' was removed)
     *     // with stopCapturing
     *     ytext.insert(0, 'a')
     *     um.stopCapturing()
     *     ytext.insert(0, 'b')
     *     um.undo()
     *     ytext.toString() // => 'a' (note that only 'b' was removed)
     *
     */
    stopCapturing() {
      this.lastChange = 0;
    }
    /**
     * Undo last changes on type.
     *
     * @return {StackItem?} Returns StackItem if a change was applied
     */
    undo() {
      this.undoing = true;
      let res;
      try {
        res = popStackItem(this, this.undoStack, "undo");
      } finally {
        this.undoing = false;
      }
      return res;
    }
    /**
     * Redo last undo operation.
     *
     * @return {StackItem?} Returns StackItem if a change was applied
     */
    redo() {
      this.redoing = true;
      let res;
      try {
        res = popStackItem(this, this.redoStack, "redo");
      } finally {
        this.redoing = false;
      }
      return res;
    }
    /**
     * Are undo steps available?
     *
     * @return {boolean} `true` if undo is possible
     */
    canUndo() {
      return this.undoStack.length > 0;
    }
    /**
     * Are redo steps available?
     *
     * @return {boolean} `true` if redo is possible
     */
    canRedo() {
      return this.redoStack.length > 0;
    }
    destroy() {
      this.trackedOrigins.delete(this);
      this.doc.off("afterTransaction", this.afterTransactionHandler);
      super.destroy();
    }
  };
  function* lazyStructReaderGenerator(decoder) {
    const numOfStateUpdates = readVarUint(decoder.restDecoder);
    for (let i = 0; i < numOfStateUpdates; i++) {
      const numberOfStructs = readVarUint(decoder.restDecoder);
      const client = decoder.readClient();
      let clock = readVarUint(decoder.restDecoder);
      for (let i2 = 0; i2 < numberOfStructs; i2++) {
        const info = decoder.readInfo();
        if (info === 10) {
          const len = readVarUint(decoder.restDecoder);
          yield new Skip(createID(client, clock), len);
          clock += len;
        } else if ((BITS5 & info) !== 0) {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item2(
            createID(client, clock),
            null,
            // left
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            // @ts-ignore Force writing a string here.
            cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          yield struct;
          clock += struct.length;
        } else {
          const len = decoder.readLen();
          yield new GC(createID(client, clock), len);
          clock += len;
        }
      }
    }
  }
  var LazyStructReader = class {
    /**
     * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
     * @param {boolean} filterSkips
     */
    constructor(decoder, filterSkips) {
      this.gen = lazyStructReaderGenerator(decoder);
      this.curr = null;
      this.done = false;
      this.filterSkips = filterSkips;
      this.next();
    }
    /**
     * @return {Item | GC | Skip |null}
     */
    next() {
      do {
        this.curr = this.gen.next().value || null;
      } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
      return this.curr;
    }
  };
  var logUpdate = (update) => logUpdateV2(update, UpdateDecoderV1);
  var logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {
    const structs = [];
    const updateDecoder = new YDecoder(createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
      structs.push(curr);
    }
    print("Structs: ", structs);
    const ds2 = readDeleteSet(updateDecoder);
    print("DeleteSet: ", ds2);
  };
  var decodeUpdate = (update) => decodeUpdateV2(update, UpdateDecoderV1);
  var decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {
    const structs = [];
    const updateDecoder = new YDecoder(createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
      structs.push(curr);
    }
    return {
      structs,
      ds: readDeleteSet(updateDecoder)
    };
  };
  var LazyStructWriter = class {
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     */
    constructor(encoder) {
      this.currClient = 0;
      this.startClock = 0;
      this.written = 0;
      this.encoder = encoder;
      this.clientStructs = [];
    }
  };
  var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
  var encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {
    const encoder = new YEncoder();
    const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);
    let curr = updateDecoder.curr;
    if (curr !== null) {
      let size2 = 0;
      let currClient = curr.id.client;
      let stopCounting = curr.id.clock !== 0;
      let currClock = stopCounting ? 0 : curr.id.clock + curr.length;
      for (; curr !== null; curr = updateDecoder.next()) {
        if (currClient !== curr.id.client) {
          if (currClock !== 0) {
            size2++;
            writeVarUint(encoder.restEncoder, currClient);
            writeVarUint(encoder.restEncoder, currClock);
          }
          currClient = curr.id.client;
          currClock = 0;
          stopCounting = curr.id.clock !== 0;
        }
        if (curr.constructor === Skip) {
          stopCounting = true;
        }
        if (!stopCounting) {
          currClock = curr.id.clock + curr.length;
        }
      }
      if (currClock !== 0) {
        size2++;
        writeVarUint(encoder.restEncoder, currClient);
        writeVarUint(encoder.restEncoder, currClock);
      }
      const enc = createEncoder();
      writeVarUint(enc, size2);
      writeBinaryEncoder(enc, encoder.restEncoder);
      encoder.restEncoder = enc;
      return encoder.toUint8Array();
    } else {
      writeVarUint(encoder.restEncoder, 0);
      return encoder.toUint8Array();
    }
  };
  var encodeStateVectorFromUpdate = (update) => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);
  var parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {
    const from4 = /* @__PURE__ */ new Map();
    const to2 = /* @__PURE__ */ new Map();
    const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);
    let curr = updateDecoder.curr;
    if (curr !== null) {
      let currClient = curr.id.client;
      let currClock = curr.id.clock;
      from4.set(currClient, currClock);
      for (; curr !== null; curr = updateDecoder.next()) {
        if (currClient !== curr.id.client) {
          to2.set(currClient, currClock);
          from4.set(curr.id.client, curr.id.clock);
          currClient = curr.id.client;
        }
        currClock = curr.id.clock + curr.length;
      }
      to2.set(currClient, currClock);
    }
    return { from: from4, to: to2 };
  };
  var parseUpdateMeta = (update) => parseUpdateMetaV2(update, UpdateDecoderV1);
  var sliceStruct = (left, diff) => {
    if (left.constructor === GC) {
      const { client, clock } = left.id;
      return new GC(createID(client, clock + diff), left.length - diff);
    } else if (left.constructor === Skip) {
      const { client, clock } = left.id;
      return new Skip(createID(client, clock + diff), left.length - diff);
    } else {
      const leftItem = (
        /** @type {Item} */
        left
      );
      const { client, clock } = leftItem.id;
      return new Item2(
        createID(client, clock + diff),
        null,
        createID(client, clock + diff - 1),
        null,
        leftItem.rightOrigin,
        leftItem.parent,
        leftItem.parentSub,
        leftItem.content.splice(diff)
      );
    }
  };
  var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
    if (updates.length === 1) {
      return updates[0];
    }
    const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
    let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
    let currWrite = null;
    const updateEncoder = new YEncoder();
    const lazyStructEncoder = new LazyStructWriter(updateEncoder);
    while (true) {
      lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
      lazyStructDecoders.sort(
        /** @type {function(any,any):number} */
        (dec1, dec2) => {
          if (dec1.curr.id.client === dec2.curr.id.client) {
            const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
            if (clockDiff === 0) {
              return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
            } else {
              return clockDiff;
            }
          } else {
            return dec2.curr.id.client - dec1.curr.id.client;
          }
        }
      );
      if (lazyStructDecoders.length === 0) {
        break;
      }
      const currDecoder = lazyStructDecoders[0];
      const firstClient = (
        /** @type {Item | GC} */
        currDecoder.curr.id.client
      );
      if (currWrite !== null) {
        let curr = (
          /** @type {Item | GC | null} */
          currDecoder.curr
        );
        let iterated = false;
        while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
          curr = currDecoder.next();
          iterated = true;
        }
        if (curr === null || // current decoder is empty
        curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
        iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
          continue;
        }
        if (firstClient !== currWrite.struct.id.client) {
          writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
          currWrite = { struct: curr, offset: 0 };
          currDecoder.next();
        } else {
          if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
            } else {
              writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
              const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
              const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
              currWrite = { struct, offset: 0 };
            }
          } else {
            const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
            if (diff > 0) {
              if (currWrite.struct.constructor === Skip) {
                currWrite.struct.length -= diff;
              } else {
                curr = sliceStruct(curr, diff);
              }
            }
            if (!currWrite.struct.mergeWith(
              /** @type {any} */
              curr
            )) {
              writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
              currWrite = { struct: curr, offset: 0 };
              currDecoder.next();
            }
          }
        }
      } else {
        currWrite = { struct: (
          /** @type {Item | GC} */
          currDecoder.curr
        ), offset: 0 };
        currDecoder.next();
      }
      for (let next2 = currDecoder.curr; next2 !== null && next2.id.client === firstClient && next2.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next2.constructor !== Skip; next2 = currDecoder.next()) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: next2, offset: 0 };
      }
    }
    if (currWrite !== null) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = null;
    }
    finishLazyStructWriting(lazyStructEncoder);
    const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
    const ds2 = mergeDeleteSets(dss);
    writeDeleteSet(updateEncoder, ds2);
    return updateEncoder.toUint8Array();
  };
  var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
    const state = decodeStateVector(sv);
    const encoder = new YEncoder();
    const lazyStructWriter = new LazyStructWriter(encoder);
    const decoder = new YDecoder(createDecoder(update));
    const reader = new LazyStructReader(decoder, false);
    while (reader.curr) {
      const curr = reader.curr;
      const currClient = curr.id.client;
      const svClock = state.get(currClient) || 0;
      if (reader.curr.constructor === Skip) {
        reader.next();
        continue;
      }
      if (curr.id.clock + curr.length > svClock) {
        writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
        reader.next();
        while (reader.curr && reader.curr.id.client === currClient) {
          writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
          reader.next();
        }
      } else {
        while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
          reader.next();
        }
      }
    }
    finishLazyStructWriting(lazyStructWriter);
    const ds2 = readDeleteSet(decoder);
    writeDeleteSet(encoder, ds2);
    return encoder.toUint8Array();
  };
  var diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);
  var flushLazyStructWriter = (lazyWriter) => {
    if (lazyWriter.written > 0) {
      lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
      lazyWriter.encoder.restEncoder = createEncoder();
      lazyWriter.written = 0;
    }
  };
  var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
    if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
      flushLazyStructWriter(lazyWriter);
    }
    if (lazyWriter.written === 0) {
      lazyWriter.currClient = struct.id.client;
      lazyWriter.encoder.writeClient(struct.id.client);
      writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
    }
    struct.write(lazyWriter.encoder, offset);
    lazyWriter.written++;
  };
  var finishLazyStructWriting = (lazyWriter) => {
    flushLazyStructWriter(lazyWriter);
    const restEncoder = lazyWriter.encoder.restEncoder;
    writeVarUint(restEncoder, lazyWriter.clientStructs.length);
    for (let i = 0; i < lazyWriter.clientStructs.length; i++) {
      const partStructs = lazyWriter.clientStructs[i];
      writeVarUint(restEncoder, partStructs.written);
      writeUint8Array(restEncoder, partStructs.restEncoder);
    }
  };
  var convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {
    const updateDecoder = new YDecoder(createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    const updateEncoder = new YEncoder();
    const lazyWriter = new LazyStructWriter(updateEncoder);
    for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
      writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
    }
    finishLazyStructWriting(lazyWriter);
    const ds2 = readDeleteSet(updateDecoder);
    writeDeleteSet(updateEncoder, ds2);
    return updateEncoder.toUint8Array();
  };
  var createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) => {
    let i = 0;
    const mapKeyCache = create5();
    const nodeNameCache = create5();
    const formattingKeyCache = create5();
    const formattingValueCache = create5();
    formattingValueCache.set(null, null);
    return (block) => {
      switch (block.constructor) {
        case GC:
        case Skip:
          return block;
        case Item2: {
          const item = (
            /** @type {Item} */
            block
          );
          const content5 = item.content;
          switch (content5.constructor) {
            case ContentDeleted:
              break;
            case ContentType: {
              if (yxml) {
                const type = (
                  /** @type {ContentType} */
                  content5.type
                );
                if (type instanceof YXmlElement) {
                  type.nodeName = setIfUndefined(nodeNameCache, type.nodeName, () => "node-" + i);
                }
                if (type instanceof YXmlHook) {
                  type.hookName = setIfUndefined(nodeNameCache, type.hookName, () => "hook-" + i);
                }
              }
              break;
            }
            case ContentAny: {
              const c = (
                /** @type {ContentAny} */
                content5
              );
              c.arr = c.arr.map(() => i);
              break;
            }
            case ContentBinary: {
              const c = (
                /** @type {ContentBinary} */
                content5
              );
              c.content = new Uint8Array([i]);
              break;
            }
            case ContentDoc: {
              const c = (
                /** @type {ContentDoc} */
                content5
              );
              if (subdocs) {
                c.opts = {};
                c.doc.guid = i + "";
              }
              break;
            }
            case ContentEmbed: {
              const c = (
                /** @type {ContentEmbed} */
                content5
              );
              c.embed = {};
              break;
            }
            case ContentFormat: {
              const c = (
                /** @type {ContentFormat} */
                content5
              );
              if (formatting) {
                c.key = setIfUndefined(formattingKeyCache, c.key, () => i + "");
                c.value = setIfUndefined(formattingValueCache, c.value, () => ({ i }));
              }
              break;
            }
            case ContentJSON: {
              const c = (
                /** @type {ContentJSON} */
                content5
              );
              c.arr = c.arr.map(() => i);
              break;
            }
            case ContentString: {
              const c = (
                /** @type {ContentString} */
                content5
              );
              c.str = repeat(i % 10 + "", c.str.length);
              break;
            }
            default:
              unexpectedCase();
          }
          if (item.parentSub) {
            item.parentSub = setIfUndefined(mapKeyCache, item.parentSub, () => i + "");
          }
          i++;
          return block;
        }
        default:
          unexpectedCase();
      }
    };
  };
  var obfuscateUpdate = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);
  var obfuscateUpdateV2 = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);
  var convertUpdateFormatV1ToV2 = (update) => convertUpdateFormat(update, id, UpdateDecoderV1, UpdateEncoderV2);
  var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);
  var errorComputeChanges = "You must not compute changes after the event-handler fired.";
  var YEvent = class {
    /**
     * @param {T} target The changed type.
     * @param {Transaction} transaction
     */
    constructor(target, transaction) {
      this.target = target;
      this.currentTarget = target;
      this.transaction = transaction;
      this._changes = null;
      this._keys = null;
      this._delta = null;
      this._path = null;
    }
    /**
     * Computes the path from `y` to the changed type.
     *
     * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
     *
     * The following property holds:
     * @example
     *   let type = y
     *   event.path.forEach(dir => {
     *     type = type.get(dir)
     *   })
     *   type === event.target // => true
     */
    get path() {
      return this._path || (this._path = getPathTo(this.currentTarget, this.target));
    }
    /**
     * Check if a struct is deleted by this event.
     *
     * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
     *
     * @param {AbstractStruct} struct
     * @return {boolean}
     */
    deletes(struct) {
      return isDeleted(this.transaction.deleteSet, struct.id);
    }
    /**
     * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
     */
    get keys() {
      if (this._keys === null) {
        if (this.transaction.doc._transactionCleanups.length === 0) {
          throw create8(errorComputeChanges);
        }
        const keys4 = /* @__PURE__ */ new Map();
        const target = this.target;
        const changed = (
          /** @type Set<string|null> */
          this.transaction.changed.get(target)
        );
        changed.forEach((key2) => {
          if (key2 !== null) {
            const item = (
              /** @type {Item} */
              target._map.get(key2)
            );
            let action;
            let oldValue;
            if (this.adds(item)) {
              let prev = item.left;
              while (prev !== null && this.adds(prev)) {
                prev = prev.left;
              }
              if (this.deletes(item)) {
                if (prev !== null && this.deletes(prev)) {
                  action = "delete";
                  oldValue = last(prev.content.getContent());
                } else {
                  return;
                }
              } else {
                if (prev !== null && this.deletes(prev)) {
                  action = "update";
                  oldValue = last(prev.content.getContent());
                } else {
                  action = "add";
                  oldValue = void 0;
                }
              }
            } else {
              if (this.deletes(item)) {
                action = "delete";
                oldValue = last(
                  /** @type {Item} */
                  item.content.getContent()
                );
              } else {
                return;
              }
            }
            keys4.set(key2, { action, oldValue });
          }
        });
        this._keys = keys4;
      }
      return this._keys;
    }
    /**
     * This is a computed property. Note that this can only be safely computed during the
     * event call. Computing this property after other changes happened might result in
     * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
     * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
     *
     * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
     */
    get delta() {
      return this.changes.delta;
    }
    /**
     * Check if a struct is added by this event.
     *
     * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
     *
     * @param {AbstractStruct} struct
     * @return {boolean}
     */
    adds(struct) {
      return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
    }
    /**
     * This is a computed property. Note that this can only be safely computed during the
     * event call. Computing this property after other changes happened might result in
     * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
     * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
     *
     * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
     */
    get changes() {
      let changes = this._changes;
      if (changes === null) {
        if (this.transaction.doc._transactionCleanups.length === 0) {
          throw create8(errorComputeChanges);
        }
        const target = this.target;
        const added = create6();
        const deleted = create6();
        const delta = [];
        changes = {
          added,
          deleted,
          delta,
          keys: this.keys
        };
        const changed = (
          /** @type Set<string|null> */
          this.transaction.changed.get(target)
        );
        if (changed.has(null)) {
          let lastOp = null;
          const packOp = () => {
            if (lastOp) {
              delta.push(lastOp);
            }
          };
          for (let item = target._start; item !== null; item = item.right) {
            if (item.deleted) {
              if (this.deletes(item) && !this.adds(item)) {
                if (lastOp === null || lastOp.delete === void 0) {
                  packOp();
                  lastOp = { delete: 0 };
                }
                lastOp.delete += item.length;
                deleted.add(item);
              }
            } else {
              if (this.adds(item)) {
                if (lastOp === null || lastOp.insert === void 0) {
                  packOp();
                  lastOp = { insert: [] };
                }
                lastOp.insert = lastOp.insert.concat(item.content.getContent());
                added.add(item);
              } else {
                if (lastOp === null || lastOp.retain === void 0) {
                  packOp();
                  lastOp = { retain: 0 };
                }
                lastOp.retain += item.length;
              }
            }
          }
          if (lastOp !== null && lastOp.retain === void 0) {
            packOp();
          }
        }
        this._changes = changes;
      }
      return (
        /** @type {any} */
        changes
      );
    }
  };
  var getPathTo = (parent, child) => {
    const path2 = [];
    while (child._item !== null && child !== parent) {
      if (child._item.parentSub !== null) {
        path2.unshift(child._item.parentSub);
      } else {
        let i = 0;
        let c = (
          /** @type {AbstractType<any>} */
          child._item.parent._start
        );
        while (c !== child._item && c !== null) {
          if (!c.deleted && c.countable) {
            i += c.length;
          }
          c = c.right;
        }
        path2.unshift(i);
      }
      child = /** @type {AbstractType<any>} */
      child._item.parent;
    }
    return path2;
  };
  var warnPrematureAccess = () => {
    warn2("Invalid access: Add Yjs type to a document before reading data.");
  };
  var maxSearchMarker = 80;
  var globalSearchMarkerTimestamp = 0;
  var ArraySearchMarker = class {
    /**
     * @param {Item} p
     * @param {number} index
     */
    constructor(p5, index3) {
      p5.marker = true;
      this.p = p5;
      this.index = index3;
      this.timestamp = globalSearchMarkerTimestamp++;
    }
  };
  var refreshMarkerTimestamp = (marker) => {
    marker.timestamp = globalSearchMarkerTimestamp++;
  };
  var overwriteMarker = (marker, p5, index3) => {
    marker.p.marker = false;
    marker.p = p5;
    p5.marker = true;
    marker.index = index3;
    marker.timestamp = globalSearchMarkerTimestamp++;
  };
  var markPosition = (searchMarker, p5, index3) => {
    if (searchMarker.length >= maxSearchMarker) {
      const marker = searchMarker.reduce((a2, b) => a2.timestamp < b.timestamp ? a2 : b);
      overwriteMarker(marker, p5, index3);
      return marker;
    } else {
      const pm = new ArraySearchMarker(p5, index3);
      searchMarker.push(pm);
      return pm;
    }
  };
  var findMarker = (yarray, index3) => {
    if (yarray._start === null || index3 === 0 || yarray._searchMarker === null) {
      return null;
    }
    const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a2, b) => abs(index3 - a2.index) < abs(index3 - b.index) ? a2 : b);
    let p5 = yarray._start;
    let pindex = 0;
    if (marker !== null) {
      p5 = marker.p;
      pindex = marker.index;
      refreshMarkerTimestamp(marker);
    }
    while (p5.right !== null && pindex < index3) {
      if (!p5.deleted && p5.countable) {
        if (index3 < pindex + p5.length) {
          break;
        }
        pindex += p5.length;
      }
      p5 = p5.right;
    }
    while (p5.left !== null && pindex > index3) {
      p5 = p5.left;
      if (!p5.deleted && p5.countable) {
        pindex -= p5.length;
      }
    }
    while (p5.left !== null && p5.left.id.client === p5.id.client && p5.left.id.clock + p5.left.length === p5.id.clock) {
      p5 = p5.left;
      if (!p5.deleted && p5.countable) {
        pindex -= p5.length;
      }
    }
    if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
    p5.parent.length / maxSearchMarker) {
      overwriteMarker(marker, p5, pindex);
      return marker;
    } else {
      return markPosition(yarray._searchMarker, p5, pindex);
    }
  };
  var updateMarkerChanges = (searchMarker, index3, len) => {
    for (let i = searchMarker.length - 1; i >= 0; i--) {
      const m = searchMarker[i];
      if (len > 0) {
        let p5 = m.p;
        p5.marker = false;
        while (p5 && (p5.deleted || !p5.countable)) {
          p5 = p5.left;
          if (p5 && !p5.deleted && p5.countable) {
            m.index -= p5.length;
          }
        }
        if (p5 === null || p5.marker === true) {
          searchMarker.splice(i, 1);
          continue;
        }
        m.p = p5;
        p5.marker = true;
      }
      if (index3 < m.index || len > 0 && index3 === m.index) {
        m.index = max(index3, m.index + len);
      }
    }
  };
  var getTypeChildren = (t2) => {
    t2.doc ?? warnPrematureAccess();
    let s2 = t2._start;
    const arr = [];
    while (s2) {
      arr.push(s2);
      s2 = s2.right;
    }
    return arr;
  };
  var callTypeObservers = (type, transaction, event) => {
    const changedType = type;
    const changedParentTypes = transaction.changedParentTypes;
    while (true) {
      setIfUndefined(changedParentTypes, type, () => []).push(event);
      if (type._item === null) {
        break;
      }
      type = /** @type {AbstractType<any>} */
      type._item.parent;
    }
    callEventHandlerListeners(changedType._eH, event, transaction);
  };
  var AbstractType = class {
    constructor() {
      this._item = null;
      this._map = /* @__PURE__ */ new Map();
      this._start = null;
      this.doc = null;
      this._length = 0;
      this._eH = createEventHandler();
      this._dEH = createEventHandler();
      this._searchMarker = null;
    }
    /**
     * @return {AbstractType<any>|null}
     */
    get parent() {
      return this._item ? (
        /** @type {AbstractType<any>} */
        this._item.parent
      ) : null;
    }
    /**
     * Integrate this type into the Yjs instance.
     *
     * * Save this struct in the os
     * * This type is sent to other client
     * * Observer functions are fired
     *
     * @param {Doc} y The Yjs instance
     * @param {Item|null} item
     */
    _integrate(y, item) {
      this.doc = y;
      this._item = item;
    }
    /**
     * @return {AbstractType<EventType>}
     */
    _copy() {
      throw methodUnimplemented();
    }
    /**
     * Makes a copy of this data type that can be included somewhere else.
     *
     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
     *
     * @return {AbstractType<EventType>}
     */
    clone() {
      throw methodUnimplemented();
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
     */
    _write(_encoder) {
    }
    /**
     * The first non-deleted item
     */
    get _first() {
      let n = this._start;
      while (n !== null && n.deleted) {
        n = n.right;
      }
      return n;
    }
    /**
     * Creates YEvent and calls all type observers.
     * Must be implemented by each type.
     *
     * @param {Transaction} transaction
     * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
     */
    _callObserver(transaction, _parentSubs) {
      if (!transaction.local && this._searchMarker) {
        this._searchMarker.length = 0;
      }
    }
    /**
     * Observe all events that are created on this type.
     *
     * @param {function(EventType, Transaction):void} f Observer function
     */
    observe(f) {
      addEventHandlerListener(this._eH, f);
    }
    /**
     * Observe all events that are created by this type and its children.
     *
     * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
     */
    observeDeep(f) {
      addEventHandlerListener(this._dEH, f);
    }
    /**
     * Unregister an observer function.
     *
     * @param {function(EventType,Transaction):void} f Observer function
     */
    unobserve(f) {
      removeEventHandlerListener(this._eH, f);
    }
    /**
     * Unregister an observer function.
     *
     * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
     */
    unobserveDeep(f) {
      removeEventHandlerListener(this._dEH, f);
    }
    /**
     * @abstract
     * @return {any}
     */
    toJSON() {
    }
  };
  var typeListSlice = (type, start, end) => {
    type.doc ?? warnPrematureAccess();
    if (start < 0) {
      start = type._length + start;
    }
    if (end < 0) {
      end = type._length + end;
    }
    let len = end - start;
    const cs2 = [];
    let n = type._start;
    while (n !== null && len > 0) {
      if (n.countable && !n.deleted) {
        const c = n.content.getContent();
        if (c.length <= start) {
          start -= c.length;
        } else {
          for (let i = start; i < c.length && len > 0; i++) {
            cs2.push(c[i]);
            len--;
          }
          start = 0;
        }
      }
      n = n.right;
    }
    return cs2;
  };
  var typeListToArray = (type) => {
    type.doc ?? warnPrematureAccess();
    const cs2 = [];
    let n = type._start;
    while (n !== null) {
      if (n.countable && !n.deleted) {
        const c = n.content.getContent();
        for (let i = 0; i < c.length; i++) {
          cs2.push(c[i]);
        }
      }
      n = n.right;
    }
    return cs2;
  };
  var typeListToArraySnapshot = (type, snapshot2) => {
    const cs2 = [];
    let n = type._start;
    while (n !== null) {
      if (n.countable && isVisible(n, snapshot2)) {
        const c = n.content.getContent();
        for (let i = 0; i < c.length; i++) {
          cs2.push(c[i]);
        }
      }
      n = n.right;
    }
    return cs2;
  };
  var typeListForEach = (type, f) => {
    let index3 = 0;
    let n = type._start;
    type.doc ?? warnPrematureAccess();
    while (n !== null) {
      if (n.countable && !n.deleted) {
        const c = n.content.getContent();
        for (let i = 0; i < c.length; i++) {
          f(c[i], index3++, type);
        }
      }
      n = n.right;
    }
  };
  var typeListMap = (type, f) => {
    const result = [];
    typeListForEach(type, (c, i) => {
      result.push(f(c, i, type));
    });
    return result;
  };
  var typeListCreateIterator = (type) => {
    let n = type._start;
    let currentContent = null;
    let currentContentIndex = 0;
    return {
      [Symbol.iterator]() {
        return this;
      },
      next: () => {
        if (currentContent === null) {
          while (n !== null && n.deleted) {
            n = n.right;
          }
          if (n === null) {
            return {
              done: true,
              value: void 0
            };
          }
          currentContent = n.content.getContent();
          currentContentIndex = 0;
          n = n.right;
        }
        const value = currentContent[currentContentIndex++];
        if (currentContent.length <= currentContentIndex) {
          currentContent = null;
        }
        return {
          done: false,
          value
        };
      }
    };
  };
  var typeListGet = (type, index3) => {
    type.doc ?? warnPrematureAccess();
    const marker = findMarker(type, index3);
    let n = type._start;
    if (marker !== null) {
      n = marker.p;
      index3 -= marker.index;
    }
    for (; n !== null; n = n.right) {
      if (!n.deleted && n.countable) {
        if (index3 < n.length) {
          return n.content.getContent()[index3];
        }
        index3 -= n.length;
      }
    }
  };
  var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content5) => {
    let left = referenceItem;
    const doc4 = transaction.doc;
    const ownClientId = doc4.clientID;
    const store = doc4.store;
    const right = referenceItem === null ? parent._start : referenceItem.right;
    let jsonContent = [];
    const packJsonContent = () => {
      if (jsonContent.length > 0) {
        left = new Item2(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
        left.integrate(transaction, 0);
        jsonContent = [];
      }
    };
    content5.forEach((c) => {
      if (c === null) {
        jsonContent.push(c);
      } else {
        switch (c.constructor) {
          case Number:
          case Object:
          case Boolean:
          case Array:
          case String:
            jsonContent.push(c);
            break;
          default:
            packJsonContent();
            switch (c.constructor) {
              case Uint8Array:
              case ArrayBuffer:
                left = new Item2(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                  /** @type {Uint8Array} */
                  c
                )));
                left.integrate(transaction, 0);
                break;
              case Doc:
                left = new Item2(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                  /** @type {Doc} */
                  c
                ));
                left.integrate(transaction, 0);
                break;
              default:
                if (c instanceof AbstractType) {
                  left = new Item2(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                  left.integrate(transaction, 0);
                } else {
                  throw new Error("Unexpected content type in insert operation");
                }
            }
        }
      }
    });
    packJsonContent();
  };
  var lengthExceeded = () => create8("Length exceeded!");
  var typeListInsertGenerics = (transaction, parent, index3, content5) => {
    if (index3 > parent._length) {
      throw lengthExceeded();
    }
    if (index3 === 0) {
      if (parent._searchMarker) {
        updateMarkerChanges(parent._searchMarker, index3, content5.length);
      }
      return typeListInsertGenericsAfter(transaction, parent, null, content5);
    }
    const startIndex = index3;
    const marker = findMarker(parent, index3);
    let n = parent._start;
    if (marker !== null) {
      n = marker.p;
      index3 -= marker.index;
      if (index3 === 0) {
        n = n.prev;
        index3 += n && n.countable && !n.deleted ? n.length : 0;
      }
    }
    for (; n !== null; n = n.right) {
      if (!n.deleted && n.countable) {
        if (index3 <= n.length) {
          if (index3 < n.length) {
            getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index3));
          }
          break;
        }
        index3 -= n.length;
      }
    }
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, startIndex, content5.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, n, content5);
  };
  var typeListPushGenerics = (transaction, parent, content5) => {
    const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
    let n = marker.p;
    if (n) {
      while (n.right) {
        n = n.right;
      }
    }
    return typeListInsertGenericsAfter(transaction, parent, n, content5);
  };
  var typeListDelete = (transaction, parent, index3, length3) => {
    if (length3 === 0) {
      return;
    }
    const startIndex = index3;
    const startLength = length3;
    const marker = findMarker(parent, index3);
    let n = parent._start;
    if (marker !== null) {
      n = marker.p;
      index3 -= marker.index;
    }
    for (; n !== null && index3 > 0; n = n.right) {
      if (!n.deleted && n.countable) {
        if (index3 < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index3));
        }
        index3 -= n.length;
      }
    }
    while (length3 > 0 && n !== null) {
      if (!n.deleted) {
        if (length3 < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length3));
        }
        n.delete(transaction);
        length3 -= n.length;
      }
      n = n.right;
    }
    if (length3 > 0) {
      throw lengthExceeded();
    }
    if (parent._searchMarker) {
      updateMarkerChanges(
        parent._searchMarker,
        startIndex,
        -startLength + length3
        /* in case we remove the above exception */
      );
    }
  };
  var typeMapDelete = (transaction, parent, key2) => {
    const c = parent._map.get(key2);
    if (c !== void 0) {
      c.delete(transaction);
    }
  };
  var typeMapSet = (transaction, parent, key2, value) => {
    const left = parent._map.get(key2) || null;
    const doc4 = transaction.doc;
    const ownClientId = doc4.clientID;
    let content5;
    if (value == null) {
      content5 = new ContentAny([value]);
    } else {
      switch (value.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
        case Date:
        case BigInt:
          content5 = new ContentAny([value]);
          break;
        case Uint8Array:
          content5 = new ContentBinary(
            /** @type {Uint8Array} */
            value
          );
          break;
        case Doc:
          content5 = new ContentDoc(
            /** @type {Doc} */
            value
          );
          break;
        default:
          if (value instanceof AbstractType) {
            content5 = new ContentType(value);
          } else {
            throw new Error("Unexpected content type");
          }
      }
    }
    new Item2(createID(ownClientId, getState(doc4.store, ownClientId)), left, left && left.lastId, null, null, parent, key2, content5).integrate(transaction, 0);
  };
  var typeMapGet = (parent, key2) => {
    parent.doc ?? warnPrematureAccess();
    const val = parent._map.get(key2);
    return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
  };
  var typeMapGetAll = (parent) => {
    const res = {};
    parent.doc ?? warnPrematureAccess();
    parent._map.forEach((value, key2) => {
      if (!value.deleted) {
        res[key2] = value.content.getContent()[value.length - 1];
      }
    });
    return res;
  };
  var typeMapHas = (parent, key2) => {
    parent.doc ?? warnPrematureAccess();
    const val = parent._map.get(key2);
    return val !== void 0 && !val.deleted;
  };
  var typeMapGetSnapshot = (parent, key2, snapshot2) => {
    let v2 = parent._map.get(key2) || null;
    while (v2 !== null && (!snapshot2.sv.has(v2.id.client) || v2.id.clock >= (snapshot2.sv.get(v2.id.client) || 0))) {
      v2 = v2.left;
    }
    return v2 !== null && isVisible(v2, snapshot2) ? v2.content.getContent()[v2.length - 1] : void 0;
  };
  var typeMapGetAllSnapshot = (parent, snapshot2) => {
    const res = {};
    parent._map.forEach((value, key2) => {
      let v2 = value;
      while (v2 !== null && (!snapshot2.sv.has(v2.id.client) || v2.id.clock >= (snapshot2.sv.get(v2.id.client) || 0))) {
        v2 = v2.left;
      }
      if (v2 !== null && isVisible(v2, snapshot2)) {
        res[key2] = v2.content.getContent()[v2.length - 1];
      }
    });
    return res;
  };
  var createMapIterator = (type) => {
    type.doc ?? warnPrematureAccess();
    return iteratorFilter(
      type._map.entries(),
      /** @param {any} entry */
      (entry) => !entry[1].deleted
    );
  };
  var YArrayEvent = class extends YEvent {
  };
  var YArray = class _YArray extends AbstractType {
    constructor() {
      super();
      this._prelimContent = [];
      this._searchMarker = [];
    }
    /**
     * Construct a new YArray containing the specified items.
     * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
     * @param {Array<T>} items
     * @return {YArray<T>}
     */
    static from(items) {
      const a2 = new _YArray();
      a2.push(items);
      return a2;
    }
    /**
     * Integrate this type into the Yjs instance.
     *
     * * Save this struct in the os
     * * This type is sent to other client
     * * Observer functions are fired
     *
     * @param {Doc} y The Yjs instance
     * @param {Item} item
     */
    _integrate(y, item) {
      super._integrate(y, item);
      this.insert(
        0,
        /** @type {Array<any>} */
        this._prelimContent
      );
      this._prelimContent = null;
    }
    /**
     * @return {YArray<T>}
     */
    _copy() {
      return new _YArray();
    }
    /**
     * Makes a copy of this data type that can be included somewhere else.
     *
     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
     *
     * @return {YArray<T>}
     */
    clone() {
      const arr = new _YArray();
      arr.insert(0, this.toArray().map(
        (el) => el instanceof AbstractType ? (
          /** @type {typeof el} */
          el.clone()
        ) : el
      ));
      return arr;
    }
    get length() {
      this.doc ?? warnPrematureAccess();
      return this._length;
    }
    /**
     * Creates YArrayEvent and calls observers.
     *
     * @param {Transaction} transaction
     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
     */
    _callObserver(transaction, parentSubs) {
      super._callObserver(transaction, parentSubs);
      callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
    }
    /**
     * Inserts new content at an index.
     *
     * Important: This function expects an array of content. Not just a content
     * object. The reason for this "weirdness" is that inserting several elements
     * is very efficient when it is done as a single operation.
     *
     * @example
     *  // Insert character 'a' at position 0
     *  yarray.insert(0, ['a'])
     *  // Insert numbers 1, 2 at position 1
     *  yarray.insert(1, [1, 2])
     *
     * @param {number} index The index to insert content at.
     * @param {Array<T>} content The array of content
     */
    insert(index3, content5) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListInsertGenerics(
            transaction,
            this,
            index3,
            /** @type {any} */
            content5
          );
        });
      } else {
        this._prelimContent.splice(index3, 0, ...content5);
      }
    }
    /**
     * Appends content to this YArray.
     *
     * @param {Array<T>} content Array of content to append.
     *
     * @todo Use the following implementation in all types.
     */
    push(content5) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListPushGenerics(
            transaction,
            this,
            /** @type {any} */
            content5
          );
        });
      } else {
        this._prelimContent.push(...content5);
      }
    }
    /**
     * Prepends content to this YArray.
     *
     * @param {Array<T>} content Array of content to prepend.
     */
    unshift(content5) {
      this.insert(0, content5);
    }
    /**
     * Deletes elements starting from an index.
     *
     * @param {number} index Index at which to start deleting elements
     * @param {number} length The number of elements to remove. Defaults to 1.
     */
    delete(index3, length3 = 1) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListDelete(transaction, this, index3, length3);
        });
      } else {
        this._prelimContent.splice(index3, length3);
      }
    }
    /**
     * Returns the i-th element from a YArray.
     *
     * @param {number} index The index of the element to return from the YArray
     * @return {T}
     */
    get(index3) {
      return typeListGet(this, index3);
    }
    /**
     * Transforms this YArray to a JavaScript Array.
     *
     * @return {Array<T>}
     */
    toArray() {
      return typeListToArray(this);
    }
    /**
     * Returns a portion of this YArray into a JavaScript Array selected
     * from start to end (end not included).
     *
     * @param {number} [start]
     * @param {number} [end]
     * @return {Array<T>}
     */
    slice(start = 0, end = this.length) {
      return typeListSlice(this, start, end);
    }
    /**
     * Transforms this Shared Type to a JSON object.
     *
     * @return {Array<any>}
     */
    toJSON() {
      return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
    }
    /**
     * Returns an Array with the result of calling a provided function on every
     * element of this YArray.
     *
     * @template M
     * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
     * @return {Array<M>} A new array with each element being the result of the
     *                 callback function
     */
    map(f) {
      return typeListMap(
        this,
        /** @type {any} */
        f
      );
    }
    /**
     * Executes a provided function once on every element of this YArray.
     *
     * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
     */
    forEach(f) {
      typeListForEach(this, f);
    }
    /**
     * @return {IterableIterator<T>}
     */
    [Symbol.iterator]() {
      return typeListCreateIterator(this);
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     */
    _write(encoder) {
      encoder.writeTypeRef(YArrayRefID);
    }
  };
  var readYArray = (_decoder) => new YArray();
  var YMapEvent = class extends YEvent {
    /**
     * @param {YMap<T>} ymap The YArray that changed.
     * @param {Transaction} transaction
     * @param {Set<any>} subs The keys that changed.
     */
    constructor(ymap, transaction, subs) {
      super(ymap, transaction);
      this.keysChanged = subs;
    }
  };
  var YMap = class _YMap extends AbstractType {
    /**
     *
     * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
     */
    constructor(entries) {
      super();
      this._prelimContent = null;
      if (entries === void 0) {
        this._prelimContent = /* @__PURE__ */ new Map();
      } else {
        this._prelimContent = new Map(entries);
      }
    }
    /**
     * Integrate this type into the Yjs instance.
     *
     * * Save this struct in the os
     * * This type is sent to other client
     * * Observer functions are fired
     *
     * @param {Doc} y The Yjs instance
     * @param {Item} item
     */
    _integrate(y, item) {
      super._integrate(y, item);
      this._prelimContent.forEach((value, key2) => {
        this.set(key2, value);
      });
      this._prelimContent = null;
    }
    /**
     * @return {YMap<MapType>}
     */
    _copy() {
      return new _YMap();
    }
    /**
     * Makes a copy of this data type that can be included somewhere else.
     *
     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
     *
     * @return {YMap<MapType>}
     */
    clone() {
      const map9 = new _YMap();
      this.forEach((value, key2) => {
        map9.set(key2, value instanceof AbstractType ? (
          /** @type {typeof value} */
          value.clone()
        ) : value);
      });
      return map9;
    }
    /**
     * Creates YMapEvent and calls observers.
     *
     * @param {Transaction} transaction
     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
     */
    _callObserver(transaction, parentSubs) {
      callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
    }
    /**
     * Transforms this Shared Type to a JSON object.
     *
     * @return {Object<string,any>}
     */
    toJSON() {
      this.doc ?? warnPrematureAccess();
      const map9 = {};
      this._map.forEach((item, key2) => {
        if (!item.deleted) {
          const v2 = item.content.getContent()[item.length - 1];
          map9[key2] = v2 instanceof AbstractType ? v2.toJSON() : v2;
        }
      });
      return map9;
    }
    /**
     * Returns the size of the YMap (count of key/value pairs)
     *
     * @return {number}
     */
    get size() {
      return [...createMapIterator(this)].length;
    }
    /**
     * Returns the keys for each element in the YMap Type.
     *
     * @return {IterableIterator<string>}
     */
    keys() {
      return iteratorMap(
        createMapIterator(this),
        /** @param {any} v */
        (v2) => v2[0]
      );
    }
    /**
     * Returns the values for each element in the YMap Type.
     *
     * @return {IterableIterator<MapType>}
     */
    values() {
      return iteratorMap(
        createMapIterator(this),
        /** @param {any} v */
        (v2) => v2[1].content.getContent()[v2[1].length - 1]
      );
    }
    /**
     * Returns an Iterator of [key, value] pairs
     *
     * @return {IterableIterator<[string, MapType]>}
     */
    entries() {
      return iteratorMap(
        createMapIterator(this),
        /** @param {any} v */
        (v2) => (
          /** @type {any} */
          [v2[0], v2[1].content.getContent()[v2[1].length - 1]]
        )
      );
    }
    /**
     * Executes a provided function on once on every key-value pair.
     *
     * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
     */
    forEach(f) {
      this.doc ?? warnPrematureAccess();
      this._map.forEach((item, key2) => {
        if (!item.deleted) {
          f(item.content.getContent()[item.length - 1], key2, this);
        }
      });
    }
    /**
     * Returns an Iterator of [key, value] pairs
     *
     * @return {IterableIterator<[string, MapType]>}
     */
    [Symbol.iterator]() {
      return this.entries();
    }
    /**
     * Remove a specified element from this YMap.
     *
     * @param {string} key The key of the element to remove.
     */
    delete(key2) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapDelete(transaction, this, key2);
        });
      } else {
        this._prelimContent.delete(key2);
      }
    }
    /**
     * Adds or updates an element with a specified key and value.
     * @template {MapType} VAL
     *
     * @param {string} key The key of the element to add to this YMap
     * @param {VAL} value The value of the element to add
     * @return {VAL}
     */
    set(key2, value) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapSet(
            transaction,
            this,
            key2,
            /** @type {any} */
            value
          );
        });
      } else {
        this._prelimContent.set(key2, value);
      }
      return value;
    }
    /**
     * Returns a specified element from this YMap.
     *
     * @param {string} key
     * @return {MapType|undefined}
     */
    get(key2) {
      return (
        /** @type {any} */
        typeMapGet(this, key2)
      );
    }
    /**
     * Returns a boolean indicating whether the specified key exists or not.
     *
     * @param {string} key The key to test.
     * @return {boolean}
     */
    has(key2) {
      return typeMapHas(this, key2);
    }
    /**
     * Removes all elements from this YMap.
     */
    clear() {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          this.forEach(function(_value, key2, map9) {
            typeMapDelete(transaction, map9, key2);
          });
        });
      } else {
        this._prelimContent.clear();
      }
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     */
    _write(encoder) {
      encoder.writeTypeRef(YMapRefID);
    }
  };
  var readYMap = (_decoder) => new YMap();
  var equalAttrs = (a2, b) => a2 === b || typeof a2 === "object" && typeof b === "object" && a2 && b && equalFlat2(a2, b);
  var ItemTextListPosition = class {
    /**
     * @param {Item|null} left
     * @param {Item|null} right
     * @param {number} index
     * @param {Map<string,any>} currentAttributes
     */
    constructor(left, right, index3, currentAttributes) {
      this.left = left;
      this.right = right;
      this.index = index3;
      this.currentAttributes = currentAttributes;
    }
    /**
     * Only call this if you know that this.right is defined
     */
    forward() {
      if (this.right === null) {
        unexpectedCase();
      }
      switch (this.right.content.constructor) {
        case ContentFormat:
          if (!this.right.deleted) {
            updateCurrentAttributes(
              this.currentAttributes,
              /** @type {ContentFormat} */
              this.right.content
            );
          }
          break;
        default:
          if (!this.right.deleted) {
            this.index += this.right.length;
          }
          break;
      }
      this.left = this.right;
      this.right = this.right.right;
    }
  };
  var findNextPosition = (transaction, pos, count) => {
    while (pos.right !== null && count > 0) {
      switch (pos.right.content.constructor) {
        case ContentFormat:
          if (!pos.right.deleted) {
            updateCurrentAttributes(
              pos.currentAttributes,
              /** @type {ContentFormat} */
              pos.right.content
            );
          }
          break;
        default:
          if (!pos.right.deleted) {
            if (count < pos.right.length) {
              getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
            }
            pos.index += pos.right.length;
            count -= pos.right.length;
          }
          break;
      }
      pos.left = pos.right;
      pos.right = pos.right.right;
    }
    return pos;
  };
  var findPosition = (transaction, parent, index3, useSearchMarker) => {
    const currentAttributes = /* @__PURE__ */ new Map();
    const marker = useSearchMarker ? findMarker(parent, index3) : null;
    if (marker) {
      const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
      return findNextPosition(transaction, pos, index3 - marker.index);
    } else {
      const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
      return findNextPosition(transaction, pos, index3);
    }
  };
  var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
    while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
      negatedAttributes.get(
        /** @type {ContentFormat} */
        currPos.right.content.key
      ),
      /** @type {ContentFormat} */
      currPos.right.content.value
    ))) {
      if (!currPos.right.deleted) {
        negatedAttributes.delete(
          /** @type {ContentFormat} */
          currPos.right.content.key
        );
      }
      currPos.forward();
    }
    const doc4 = transaction.doc;
    const ownClientId = doc4.clientID;
    negatedAttributes.forEach((val, key2) => {
      const left = currPos.left;
      const right = currPos.right;
      const nextFormat = new Item2(createID(ownClientId, getState(doc4.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key2, val));
      nextFormat.integrate(transaction, 0);
      currPos.right = nextFormat;
      currPos.forward();
    });
  };
  var updateCurrentAttributes = (currentAttributes, format2) => {
    const { key: key2, value } = format2;
    if (value === null) {
      currentAttributes.delete(key2);
    } else {
      currentAttributes.set(key2, value);
    }
  };
  var minimizeAttributeChanges = (currPos, attributes) => {
    while (true) {
      if (currPos.right === null) {
        break;
      } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
        attributes[
          /** @type {ContentFormat} */
          currPos.right.content.key
        ] ?? null,
        /** @type {ContentFormat} */
        currPos.right.content.value
      )) ;
      else {
        break;
      }
      currPos.forward();
    }
  };
  var insertAttributes = (transaction, parent, currPos, attributes) => {
    const doc4 = transaction.doc;
    const ownClientId = doc4.clientID;
    const negatedAttributes = /* @__PURE__ */ new Map();
    for (const key2 in attributes) {
      const val = attributes[key2];
      const currentVal = currPos.currentAttributes.get(key2) ?? null;
      if (!equalAttrs(currentVal, val)) {
        negatedAttributes.set(key2, currentVal);
        const { left, right } = currPos;
        currPos.right = new Item2(createID(ownClientId, getState(doc4.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key2, val));
        currPos.right.integrate(transaction, 0);
        currPos.forward();
      }
    }
    return negatedAttributes;
  };
  var insertText = (transaction, parent, currPos, text10, attributes) => {
    currPos.currentAttributes.forEach((_val, key2) => {
      if (attributes[key2] === void 0) {
        attributes[key2] = null;
      }
    });
    const doc4 = transaction.doc;
    const ownClientId = doc4.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    const content5 = text10.constructor === String ? new ContentString(
      /** @type {string} */
      text10
    ) : text10 instanceof AbstractType ? new ContentType(text10) : new ContentEmbed(text10);
    let { left, right, index: index3 } = currPos;
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, currPos.index, content5.getLength());
    }
    right = new Item2(createID(ownClientId, getState(doc4.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content5);
    right.integrate(transaction, 0);
    currPos.right = right;
    currPos.index = index3;
    currPos.forward();
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
  };
  var formatText = (transaction, parent, currPos, length3, attributes) => {
    const doc4 = transaction.doc;
    const ownClientId = doc4.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    iterationLoop: while (currPos.right !== null && (length3 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
      if (!currPos.right.deleted) {
        switch (currPos.right.content.constructor) {
          case ContentFormat: {
            const { key: key2, value } = (
              /** @type {ContentFormat} */
              currPos.right.content
            );
            const attr = attributes[key2];
            if (attr !== void 0) {
              if (equalAttrs(attr, value)) {
                negatedAttributes.delete(key2);
              } else {
                if (length3 === 0) {
                  break iterationLoop;
                }
                negatedAttributes.set(key2, value);
              }
              currPos.right.delete(transaction);
            } else {
              currPos.currentAttributes.set(key2, value);
            }
            break;
          }
          default:
            if (length3 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
            }
            length3 -= currPos.right.length;
            break;
        }
      }
      currPos.forward();
    }
    if (length3 > 0) {
      let newlines = "";
      for (; length3 > 0; length3--) {
        newlines += "\n";
      }
      currPos.right = new Item2(createID(ownClientId, getState(doc4.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
  };
  var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
    let end = start;
    const endFormats = create5();
    while (end && (!end.countable || end.deleted)) {
      if (!end.deleted && end.content.constructor === ContentFormat) {
        const cf = (
          /** @type {ContentFormat} */
          end.content
        );
        endFormats.set(cf.key, cf);
      }
      end = end.right;
    }
    let cleanups = 0;
    let reachedCurr = false;
    while (start !== end) {
      if (curr === start) {
        reachedCurr = true;
      }
      if (!start.deleted) {
        const content5 = start.content;
        switch (content5.constructor) {
          case ContentFormat: {
            const { key: key2, value } = (
              /** @type {ContentFormat} */
              content5
            );
            const startAttrValue = startAttributes.get(key2) ?? null;
            if (endFormats.get(key2) !== content5 || startAttrValue === value) {
              start.delete(transaction);
              cleanups++;
              if (!reachedCurr && (currAttributes.get(key2) ?? null) === value && startAttrValue !== value) {
                if (startAttrValue === null) {
                  currAttributes.delete(key2);
                } else {
                  currAttributes.set(key2, startAttrValue);
                }
              }
            }
            if (!reachedCurr && !start.deleted) {
              updateCurrentAttributes(
                currAttributes,
                /** @type {ContentFormat} */
                content5
              );
            }
            break;
          }
        }
      }
      start = /** @type {Item} */
      start.right;
    }
    return cleanups;
  };
  var cleanupContextlessFormattingGap = (transaction, item) => {
    while (item && item.right && (item.right.deleted || !item.right.countable)) {
      item = item.right;
    }
    const attrs = /* @__PURE__ */ new Set();
    while (item && (item.deleted || !item.countable)) {
      if (!item.deleted && item.content.constructor === ContentFormat) {
        const key2 = (
          /** @type {ContentFormat} */
          item.content.key
        );
        if (attrs.has(key2)) {
          item.delete(transaction);
        } else {
          attrs.add(key2);
        }
      }
      item = item.left;
    }
  };
  var cleanupYTextFormatting = (type) => {
    let res = 0;
    transact(
      /** @type {Doc} */
      type.doc,
      (transaction) => {
        let start = (
          /** @type {Item} */
          type._start
        );
        let end = type._start;
        let startAttributes = create5();
        const currentAttributes = copy2(startAttributes);
        while (end) {
          if (end.deleted === false) {
            switch (end.content.constructor) {
              case ContentFormat:
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  end.content
                );
                break;
              default:
                res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
                startAttributes = copy2(currentAttributes);
                start = end;
                break;
            }
          }
          end = end.right;
        }
      }
    );
    return res;
  };
  var cleanupYTextAfterTransaction = (transaction) => {
    const needFullCleanup = /* @__PURE__ */ new Set();
    const doc4 = transaction.doc;
    for (const [client, afterClock] of transaction.afterState.entries()) {
      const clock = transaction.beforeState.get(client) || 0;
      if (afterClock === clock) {
        continue;
      }
      iterateStructs(
        transaction,
        /** @type {Array<Item|GC>} */
        doc4.store.clients.get(client),
        clock,
        afterClock,
        (item) => {
          if (!item.deleted && /** @type {Item} */
          item.content.constructor === ContentFormat && item.constructor !== GC) {
            needFullCleanup.add(
              /** @type {any} */
              item.parent
            );
          }
        }
      );
    }
    transact(doc4, (t2) => {
      iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
        if (item instanceof GC || !/** @type {YText} */
        item.parent._hasFormatting || needFullCleanup.has(
          /** @type {YText} */
          item.parent
        )) {
          return;
        }
        const parent = (
          /** @type {YText} */
          item.parent
        );
        if (item.content.constructor === ContentFormat) {
          needFullCleanup.add(parent);
        } else {
          cleanupContextlessFormattingGap(t2, item);
        }
      });
      for (const yText of needFullCleanup) {
        cleanupYTextFormatting(yText);
      }
    });
  };
  var deleteText = (transaction, currPos, length3) => {
    const startLength = length3;
    const startAttrs = copy2(currPos.currentAttributes);
    const start = currPos.right;
    while (length3 > 0 && currPos.right !== null) {
      if (currPos.right.deleted === false) {
        switch (currPos.right.content.constructor) {
          case ContentType:
          case ContentEmbed:
          case ContentString:
            if (length3 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
            }
            length3 -= currPos.right.length;
            currPos.right.delete(transaction);
            break;
        }
      }
      currPos.forward();
    }
    if (start) {
      cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
    }
    const parent = (
      /** @type {AbstractType<any>} */
      /** @type {Item} */
      (currPos.left || currPos.right).parent
    );
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length3);
    }
    return currPos;
  };
  var YTextEvent = class extends YEvent {
    /**
     * @param {YText} ytext
     * @param {Transaction} transaction
     * @param {Set<any>} subs The keys that changed
     */
    constructor(ytext, transaction, subs) {
      super(ytext, transaction);
      this.childListChanged = false;
      this.keysChanged = /* @__PURE__ */ new Set();
      subs.forEach((sub) => {
        if (sub === null) {
          this.childListChanged = true;
        } else {
          this.keysChanged.add(sub);
        }
      });
    }
    /**
     * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
     */
    get changes() {
      if (this._changes === null) {
        const changes = {
          keys: this.keys,
          delta: this.delta,
          added: /* @__PURE__ */ new Set(),
          deleted: /* @__PURE__ */ new Set()
        };
        this._changes = changes;
      }
      return (
        /** @type {any} */
        this._changes
      );
    }
    /**
     * Compute the changes in the delta format.
     * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
     *
     * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
     *
     * @public
     */
    get delta() {
      if (this._delta === null) {
        const y = (
          /** @type {Doc} */
          this.target.doc
        );
        const delta = [];
        transact(y, (transaction) => {
          const currentAttributes = /* @__PURE__ */ new Map();
          const oldAttributes = /* @__PURE__ */ new Map();
          let item = this.target._start;
          let action = null;
          const attributes = {};
          let insert = "";
          let retain = 0;
          let deleteLen = 0;
          const addOp = () => {
            if (action !== null) {
              let op = null;
              switch (action) {
                case "delete":
                  if (deleteLen > 0) {
                    op = { delete: deleteLen };
                  }
                  deleteLen = 0;
                  break;
                case "insert":
                  if (typeof insert === "object" || insert.length > 0) {
                    op = { insert };
                    if (currentAttributes.size > 0) {
                      op.attributes = {};
                      currentAttributes.forEach((value, key2) => {
                        if (value !== null) {
                          op.attributes[key2] = value;
                        }
                      });
                    }
                  }
                  insert = "";
                  break;
                case "retain":
                  if (retain > 0) {
                    op = { retain };
                    if (!isEmpty2(attributes)) {
                      op.attributes = assign2({}, attributes);
                    }
                  }
                  retain = 0;
                  break;
              }
              if (op) delta.push(op);
              action = null;
            }
          };
          while (item !== null) {
            switch (item.content.constructor) {
              case ContentType:
              case ContentEmbed:
                if (this.adds(item)) {
                  if (!this.deletes(item)) {
                    addOp();
                    action = "insert";
                    insert = item.content.getContent()[0];
                    addOp();
                  }
                } else if (this.deletes(item)) {
                  if (action !== "delete") {
                    addOp();
                    action = "delete";
                  }
                  deleteLen += 1;
                } else if (!item.deleted) {
                  if (action !== "retain") {
                    addOp();
                    action = "retain";
                  }
                  retain += 1;
                }
                break;
              case ContentString:
                if (this.adds(item)) {
                  if (!this.deletes(item)) {
                    if (action !== "insert") {
                      addOp();
                      action = "insert";
                    }
                    insert += /** @type {ContentString} */
                    item.content.str;
                  }
                } else if (this.deletes(item)) {
                  if (action !== "delete") {
                    addOp();
                    action = "delete";
                  }
                  deleteLen += item.length;
                } else if (!item.deleted) {
                  if (action !== "retain") {
                    addOp();
                    action = "retain";
                  }
                  retain += item.length;
                }
                break;
              case ContentFormat: {
                const { key: key2, value } = (
                  /** @type {ContentFormat} */
                  item.content
                );
                if (this.adds(item)) {
                  if (!this.deletes(item)) {
                    const curVal = currentAttributes.get(key2) ?? null;
                    if (!equalAttrs(curVal, value)) {
                      if (action === "retain") {
                        addOp();
                      }
                      if (equalAttrs(value, oldAttributes.get(key2) ?? null)) {
                        delete attributes[key2];
                      } else {
                        attributes[key2] = value;
                      }
                    } else if (value !== null) {
                      item.delete(transaction);
                    }
                  }
                } else if (this.deletes(item)) {
                  oldAttributes.set(key2, value);
                  const curVal = currentAttributes.get(key2) ?? null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    attributes[key2] = curVal;
                  }
                } else if (!item.deleted) {
                  oldAttributes.set(key2, value);
                  const attr = attributes[key2];
                  if (attr !== void 0) {
                    if (!equalAttrs(attr, value)) {
                      if (action === "retain") {
                        addOp();
                      }
                      if (value === null) {
                        delete attributes[key2];
                      } else {
                        attributes[key2] = value;
                      }
                    } else if (attr !== null) {
                      item.delete(transaction);
                    }
                  }
                }
                if (!item.deleted) {
                  if (action === "insert") {
                    addOp();
                  }
                  updateCurrentAttributes(
                    currentAttributes,
                    /** @type {ContentFormat} */
                    item.content
                  );
                }
                break;
              }
            }
            item = item.right;
          }
          addOp();
          while (delta.length > 0) {
            const lastOp = delta[delta.length - 1];
            if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
              delta.pop();
            } else {
              break;
            }
          }
        });
        this._delta = delta;
      }
      return (
        /** @type {any} */
        this._delta
      );
    }
  };
  var YText = class _YText extends AbstractType {
    /**
     * @param {String} [string] The initial value of the YText.
     */
    constructor(string3) {
      super();
      this._pending = string3 !== void 0 ? [() => this.insert(0, string3)] : [];
      this._searchMarker = [];
      this._hasFormatting = false;
    }
    /**
     * Number of characters of this text type.
     *
     * @type {number}
     */
    get length() {
      this.doc ?? warnPrematureAccess();
      return this._length;
    }
    /**
     * @param {Doc} y
     * @param {Item} item
     */
    _integrate(y, item) {
      super._integrate(y, item);
      try {
        this._pending.forEach((f) => f());
      } catch (e) {
        console.error(e);
      }
      this._pending = null;
    }
    _copy() {
      return new _YText();
    }
    /**
     * Makes a copy of this data type that can be included somewhere else.
     *
     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
     *
     * @return {YText}
     */
    clone() {
      const text10 = new _YText();
      text10.applyDelta(this.toDelta());
      return text10;
    }
    /**
     * Creates YTextEvent and calls observers.
     *
     * @param {Transaction} transaction
     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
     */
    _callObserver(transaction, parentSubs) {
      super._callObserver(transaction, parentSubs);
      const event = new YTextEvent(this, transaction, parentSubs);
      callTypeObservers(this, transaction, event);
      if (!transaction.local && this._hasFormatting) {
        transaction._needFormattingCleanup = true;
      }
    }
    /**
     * Returns the unformatted string representation of this YText type.
     *
     * @public
     */
    toString() {
      this.doc ?? warnPrematureAccess();
      let str = "";
      let n = this._start;
      while (n !== null) {
        if (!n.deleted && n.countable && n.content.constructor === ContentString) {
          str += /** @type {ContentString} */
          n.content.str;
        }
        n = n.right;
      }
      return str;
    }
    /**
     * Returns the unformatted string representation of this YText type.
     *
     * @return {string}
     * @public
     */
    toJSON() {
      return this.toString();
    }
    /**
     * Apply a {@link Delta} on this shared YText type.
     *
     * @param {Array<any>} delta The changes to apply on this element.
     * @param {object}  opts
     * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
     *
     *
     * @public
     */
    applyDelta(delta, { sanitize = true } = {}) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
          for (let i = 0; i < delta.length; i++) {
            const op = delta[i];
            if (op.insert !== void 0) {
              const ins = !sanitize && typeof op.insert === "string" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
              if (typeof ins !== "string" || ins.length > 0) {
                insertText(transaction, this, currPos, ins, op.attributes || {});
              }
            } else if (op.retain !== void 0) {
              formatText(transaction, this, currPos, op.retain, op.attributes || {});
            } else if (op.delete !== void 0) {
              deleteText(transaction, currPos, op.delete);
            }
          }
        });
      } else {
        this._pending.push(() => this.applyDelta(delta));
      }
    }
    /**
     * Returns the Delta representation of this YText type.
     *
     * @param {Snapshot} [snapshot]
     * @param {Snapshot} [prevSnapshot]
     * @param {function('removed' | 'added', ID):any} [computeYChange]
     * @return {any} The Delta representation of this type.
     *
     * @public
     */
    toDelta(snapshot2, prevSnapshot, computeYChange) {
      this.doc ?? warnPrematureAccess();
      const ops = [];
      const currentAttributes = /* @__PURE__ */ new Map();
      const doc4 = (
        /** @type {Doc} */
        this.doc
      );
      let str = "";
      let n = this._start;
      function packStr() {
        if (str.length > 0) {
          const attributes = {};
          let addAttributes = false;
          currentAttributes.forEach((value, key2) => {
            addAttributes = true;
            attributes[key2] = value;
          });
          const op = { insert: str };
          if (addAttributes) {
            op.attributes = attributes;
          }
          ops.push(op);
          str = "";
        }
      }
      const computeDelta = () => {
        while (n !== null) {
          if (isVisible(n, snapshot2) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {
            switch (n.content.constructor) {
              case ContentString: {
                const cur = currentAttributes.get("ychange");
                if (snapshot2 !== void 0 && !isVisible(n, snapshot2)) {
                  if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                    packStr();
                    currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                  }
                } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {
                  if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                    packStr();
                    currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                  }
                } else if (cur !== void 0) {
                  packStr();
                  currentAttributes.delete("ychange");
                }
                str += /** @type {ContentString} */
                n.content.str;
                break;
              }
              case ContentType:
              case ContentEmbed: {
                packStr();
                const op = {
                  insert: n.content.getContent()[0]
                };
                if (currentAttributes.size > 0) {
                  const attrs = (
                    /** @type {Object<string,any>} */
                    {}
                  );
                  op.attributes = attrs;
                  currentAttributes.forEach((value, key2) => {
                    attrs[key2] = value;
                  });
                }
                ops.push(op);
                break;
              }
              case ContentFormat:
                if (isVisible(n, snapshot2)) {
                  packStr();
                  updateCurrentAttributes(
                    currentAttributes,
                    /** @type {ContentFormat} */
                    n.content
                  );
                }
                break;
            }
          }
          n = n.right;
        }
        packStr();
      };
      if (snapshot2 || prevSnapshot) {
        transact(doc4, (transaction) => {
          if (snapshot2) {
            splitSnapshotAffectedStructs(transaction, snapshot2);
          }
          if (prevSnapshot) {
            splitSnapshotAffectedStructs(transaction, prevSnapshot);
          }
          computeDelta();
        }, "cleanup");
      } else {
        computeDelta();
      }
      return ops;
    }
    /**
     * Insert text at a given index.
     *
     * @param {number} index The index at which to start inserting.
     * @param {String} text The text to insert at the specified position.
     * @param {TextAttributes} [attributes] Optionally define some formatting
     *                                    information to apply on the inserted
     *                                    Text.
     * @public
     */
    insert(index3, text10, attributes) {
      if (text10.length <= 0) {
        return;
      }
      const y = this.doc;
      if (y !== null) {
        transact(y, (transaction) => {
          const pos = findPosition(transaction, this, index3, !attributes);
          if (!attributes) {
            attributes = {};
            pos.currentAttributes.forEach((v2, k) => {
              attributes[k] = v2;
            });
          }
          insertText(transaction, this, pos, text10, attributes);
        });
      } else {
        this._pending.push(() => this.insert(index3, text10, attributes));
      }
    }
    /**
     * Inserts an embed at a index.
     *
     * @param {number} index The index to insert the embed at.
     * @param {Object | AbstractType<any>} embed The Object that represents the embed.
     * @param {TextAttributes} [attributes] Attribute information to apply on the
     *                                    embed
     *
     * @public
     */
    insertEmbed(index3, embed, attributes) {
      const y = this.doc;
      if (y !== null) {
        transact(y, (transaction) => {
          const pos = findPosition(transaction, this, index3, !attributes);
          insertText(transaction, this, pos, embed, attributes || {});
        });
      } else {
        this._pending.push(() => this.insertEmbed(index3, embed, attributes || {}));
      }
    }
    /**
     * Deletes text starting from an index.
     *
     * @param {number} index Index at which to start deleting.
     * @param {number} length The number of characters to remove. Defaults to 1.
     *
     * @public
     */
    delete(index3, length3) {
      if (length3 === 0) {
        return;
      }
      const y = this.doc;
      if (y !== null) {
        transact(y, (transaction) => {
          deleteText(transaction, findPosition(transaction, this, index3, true), length3);
        });
      } else {
        this._pending.push(() => this.delete(index3, length3));
      }
    }
    /**
     * Assigns properties to a range of text.
     *
     * @param {number} index The position where to start formatting.
     * @param {number} length The amount of characters to assign properties to.
     * @param {TextAttributes} attributes Attribute information to apply on the
     *                                    text.
     *
     * @public
     */
    format(index3, length3, attributes) {
      if (length3 === 0) {
        return;
      }
      const y = this.doc;
      if (y !== null) {
        transact(y, (transaction) => {
          const pos = findPosition(transaction, this, index3, false);
          if (pos.right === null) {
            return;
          }
          formatText(transaction, this, pos, length3, attributes);
        });
      } else {
        this._pending.push(() => this.format(index3, length3, attributes));
      }
    }
    /**
     * Removes an attribute.
     *
     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
     *
     * @param {String} attributeName The attribute name that is to be removed.
     *
     * @public
     */
    removeAttribute(attributeName) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapDelete(transaction, this, attributeName);
        });
      } else {
        this._pending.push(() => this.removeAttribute(attributeName));
      }
    }
    /**
     * Sets or updates an attribute.
     *
     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
     *
     * @param {String} attributeName The attribute name that is to be set.
     * @param {any} attributeValue The attribute value that is to be set.
     *
     * @public
     */
    setAttribute(attributeName, attributeValue) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapSet(transaction, this, attributeName, attributeValue);
        });
      } else {
        this._pending.push(() => this.setAttribute(attributeName, attributeValue));
      }
    }
    /**
     * Returns an attribute value that belongs to the attribute name.
     *
     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
     *
     * @param {String} attributeName The attribute name that identifies the
     *                               queried value.
     * @return {any} The queried attribute value.
     *
     * @public
     */
    getAttribute(attributeName) {
      return (
        /** @type {any} */
        typeMapGet(this, attributeName)
      );
    }
    /**
     * Returns all attribute name/value pairs in a JSON Object.
     *
     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
     *
     * @return {Object<string, any>} A JSON Object that describes the attributes.
     *
     * @public
     */
    getAttributes() {
      return typeMapGetAll(this);
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     */
    _write(encoder) {
      encoder.writeTypeRef(YTextRefID);
    }
  };
  var readYText = (_decoder) => new YText();
  var YXmlTreeWalker = class {
    /**
     * @param {YXmlFragment | YXmlElement} root
     * @param {function(AbstractType<any>):boolean} [f]
     */
    constructor(root6, f = () => true) {
      this._filter = f;
      this._root = root6;
      this._currentNode = /** @type {Item} */
      root6._start;
      this._firstCall = true;
      root6.doc ?? warnPrematureAccess();
    }
    [Symbol.iterator]() {
      return this;
    }
    /**
     * Get the next node.
     *
     * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
     *
     * @public
     */
    next() {
      let n = this._currentNode;
      let type = n && n.content && /** @type {any} */
      n.content.type;
      if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
        do {
          type = /** @type {any} */
          n.content.type;
          if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
            n = type._start;
          } else {
            while (n !== null) {
              const nxt = n.next;
              if (nxt !== null) {
                n = nxt;
                break;
              } else if (n.parent === this._root) {
                n = null;
              } else {
                n = /** @type {AbstractType<any>} */
                n.parent._item;
              }
            }
          }
        } while (n !== null && (n.deleted || !this._filter(
          /** @type {ContentType} */
          n.content.type
        )));
      }
      this._firstCall = false;
      if (n === null) {
        return { value: void 0, done: true };
      }
      this._currentNode = n;
      return { value: (
        /** @type {any} */
        n.content.type
      ), done: false };
    }
  };
  var YXmlFragment = class _YXmlFragment extends AbstractType {
    constructor() {
      super();
      this._prelimContent = [];
    }
    /**
     * @type {YXmlElement|YXmlText|null}
     */
    get firstChild() {
      const first3 = this._first;
      return first3 ? first3.content.getContent()[0] : null;
    }
    /**
     * Integrate this type into the Yjs instance.
     *
     * * Save this struct in the os
     * * This type is sent to other client
     * * Observer functions are fired
     *
     * @param {Doc} y The Yjs instance
     * @param {Item} item
     */
    _integrate(y, item) {
      super._integrate(y, item);
      this.insert(
        0,
        /** @type {Array<any>} */
        this._prelimContent
      );
      this._prelimContent = null;
    }
    _copy() {
      return new _YXmlFragment();
    }
    /**
     * Makes a copy of this data type that can be included somewhere else.
     *
     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
     *
     * @return {YXmlFragment}
     */
    clone() {
      const el = new _YXmlFragment();
      el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
      return el;
    }
    get length() {
      this.doc ?? warnPrematureAccess();
      return this._prelimContent === null ? this._length : this._prelimContent.length;
    }
    /**
     * Create a subtree of childNodes.
     *
     * @example
     * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
     * for (let node in walker) {
     *   // `node` is a div node
     *   nop(node)
     * }
     *
     * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
     *                          returns a Boolean indicating whether the child
     *                          is to be included in the subtree.
     * @return {YXmlTreeWalker} A subtree and a position within it.
     *
     * @public
     */
    createTreeWalker(filter) {
      return new YXmlTreeWalker(this, filter);
    }
    /**
     * Returns the first YXmlElement that matches the query.
     * Similar to DOM's {@link querySelector}.
     *
     * Query support:
     *   - tagname
     * TODO:
     *   - id
     *   - attribute
     *
     * @param {CSS_Selector} query The query on the children.
     * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
     *
     * @public
     */
    querySelector(query) {
      query = query.toUpperCase();
      const iterator = new YXmlTreeWalker(this, (element7) => element7.nodeName && element7.nodeName.toUpperCase() === query);
      const next2 = iterator.next();
      if (next2.done) {
        return null;
      } else {
        return next2.value;
      }
    }
    /**
     * Returns all YXmlElements that match the query.
     * Similar to Dom's {@link querySelectorAll}.
     *
     * @todo Does not yet support all queries. Currently only query by tagName.
     *
     * @param {CSS_Selector} query The query on the children
     * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
     *
     * @public
     */
    querySelectorAll(query) {
      query = query.toUpperCase();
      return from3(new YXmlTreeWalker(this, (element7) => element7.nodeName && element7.nodeName.toUpperCase() === query));
    }
    /**
     * Creates YXmlEvent and calls observers.
     *
     * @param {Transaction} transaction
     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
     */
    _callObserver(transaction, parentSubs) {
      callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
    }
    /**
     * Get the string representation of all the children of this YXmlFragment.
     *
     * @return {string} The string representation of all children.
     */
    toString() {
      return typeListMap(this, (xml2) => xml2.toString()).join("");
    }
    /**
     * @return {string}
     */
    toJSON() {
      return this.toString();
    }
    /**
     * Creates a Dom Element that mirrors this YXmlElement.
     *
     * @param {Document} [_document=document] The document object (you must define
     *                                        this when calling this method in
     *                                        nodejs)
     * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
     *                                             are presented in the DOM
     * @param {any} [binding] You should not set this property. This is
     *                               used if DomBinding wants to create a
     *                               association to the created DOM type.
     * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
     *
     * @public
     */
    toDOM(_document = document, hooks = {}, binding) {
      const fragment2 = _document.createDocumentFragment();
      if (binding !== void 0) {
        binding._createAssociation(fragment2, this);
      }
      typeListForEach(this, (xmlType) => {
        fragment2.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
      });
      return fragment2;
    }
    /**
     * Inserts new content at an index.
     *
     * @example
     *  // Insert character 'a' at position 0
     *  xml.insert(0, [new Y.XmlText('text')])
     *
     * @param {number} index The index to insert content at
     * @param {Array<YXmlElement|YXmlText>} content The array of content
     */
    insert(index3, content5) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListInsertGenerics(transaction, this, index3, content5);
        });
      } else {
        this._prelimContent.splice(index3, 0, ...content5);
      }
    }
    /**
     * Inserts new content at an index.
     *
     * @example
     *  // Insert character 'a' at position 0
     *  xml.insert(0, [new Y.XmlText('text')])
     *
     * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
     * @param {Array<YXmlElement|YXmlText>} content The array of content
     */
    insertAfter(ref, content5) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
          typeListInsertGenericsAfter(transaction, this, refItem, content5);
        });
      } else {
        const pc = (
          /** @type {Array<any>} */
          this._prelimContent
        );
        const index3 = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
        if (index3 === 0 && ref !== null) {
          throw create8("Reference item not found");
        }
        pc.splice(index3, 0, ...content5);
      }
    }
    /**
     * Deletes elements starting from an index.
     *
     * @param {number} index Index at which to start deleting elements
     * @param {number} [length=1] The number of elements to remove. Defaults to 1.
     */
    delete(index3, length3 = 1) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeListDelete(transaction, this, index3, length3);
        });
      } else {
        this._prelimContent.splice(index3, length3);
      }
    }
    /**
     * Transforms this YArray to a JavaScript Array.
     *
     * @return {Array<YXmlElement|YXmlText|YXmlHook>}
     */
    toArray() {
      return typeListToArray(this);
    }
    /**
     * Appends content to this YArray.
     *
     * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
     */
    push(content5) {
      this.insert(this.length, content5);
    }
    /**
     * Prepends content to this YArray.
     *
     * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
     */
    unshift(content5) {
      this.insert(0, content5);
    }
    /**
     * Returns the i-th element from a YArray.
     *
     * @param {number} index The index of the element to return from the YArray
     * @return {YXmlElement|YXmlText}
     */
    get(index3) {
      return typeListGet(this, index3);
    }
    /**
     * Returns a portion of this YXmlFragment into a JavaScript Array selected
     * from start to end (end not included).
     *
     * @param {number} [start]
     * @param {number} [end]
     * @return {Array<YXmlElement|YXmlText>}
     */
    slice(start = 0, end = this.length) {
      return typeListSlice(this, start, end);
    }
    /**
     * Executes a provided function on once on every child element.
     *
     * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
     */
    forEach(f) {
      typeListForEach(this, f);
    }
    /**
     * Transform the properties of this type to binary and write it to an
     * BinaryEncoder.
     *
     * This is called when this Item is sent to a remote peer.
     *
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
     */
    _write(encoder) {
      encoder.writeTypeRef(YXmlFragmentRefID);
    }
  };
  var readYXmlFragment = (_decoder) => new YXmlFragment();
  var YXmlElement = class _YXmlElement extends YXmlFragment {
    constructor(nodeName = "UNDEFINED") {
      super();
      this.nodeName = nodeName;
      this._prelimAttrs = /* @__PURE__ */ new Map();
    }
    /**
     * @type {YXmlElement|YXmlText|null}
     */
    get nextSibling() {
      const n = this._item ? this._item.next : null;
      return n ? (
        /** @type {YXmlElement|YXmlText} */
        /** @type {ContentType} */
        n.content.type
      ) : null;
    }
    /**
     * @type {YXmlElement|YXmlText|null}
     */
    get prevSibling() {
      const n = this._item ? this._item.prev : null;
      return n ? (
        /** @type {YXmlElement|YXmlText} */
        /** @type {ContentType} */
        n.content.type
      ) : null;
    }
    /**
     * Integrate this type into the Yjs instance.
     *
     * * Save this struct in the os
     * * This type is sent to other client
     * * Observer functions are fired
     *
     * @param {Doc} y The Yjs instance
     * @param {Item} item
     */
    _integrate(y, item) {
      super._integrate(y, item);
      /** @type {Map<string, any>} */
      this._prelimAttrs.forEach((value, key2) => {
        this.setAttribute(key2, value);
      });
      this._prelimAttrs = null;
    }
    /**
     * Creates an Item with the same effect as this Item (without position effect)
     *
     * @return {YXmlElement}
     */
    _copy() {
      return new _YXmlElement(this.nodeName);
    }
    /**
     * Makes a copy of this data type that can be included somewhere else.
     *
     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
     *
     * @return {YXmlElement<KV>}
     */
    clone() {
      const el = new _YXmlElement(this.nodeName);
      const attrs = this.getAttributes();
      forEach3(attrs, (value, key2) => {
        if (typeof value === "string") {
          el.setAttribute(key2, value);
        }
      });
      el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
      return el;
    }
    /**
     * Returns the XML serialization of this YXmlElement.
     * The attributes are ordered by attribute-name, so you can easily use this
     * method to compare YXmlElements
     *
     * @return {string} The string representation of this type.
     *
     * @public
     */
    toString() {
      const attrs = this.getAttributes();
      const stringBuilder = [];
      const keys4 = [];
      for (const key2 in attrs) {
        keys4.push(key2);
      }
      keys4.sort();
      const keysLen = keys4.length;
      for (let i = 0; i < keysLen; i++) {
        const key2 = keys4[i];
        stringBuilder.push(key2 + '="' + attrs[key2] + '"');
      }
      const nodeName = this.nodeName.toLocaleLowerCase();
      const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
      return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
    }
    /**
     * Removes an attribute from this YXmlElement.
     *
     * @param {string} attributeName The attribute name that is to be removed.
     *
     * @public
     */
    removeAttribute(attributeName) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapDelete(transaction, this, attributeName);
        });
      } else {
        this._prelimAttrs.delete(attributeName);
      }
    }
    /**
     * Sets or updates an attribute.
     *
     * @template {keyof KV & string} KEY
     *
     * @param {KEY} attributeName The attribute name that is to be set.
     * @param {KV[KEY]} attributeValue The attribute value that is to be set.
     *
     * @public
     */
    setAttribute(attributeName, attributeValue) {
      if (this.doc !== null) {
        transact(this.doc, (transaction) => {
          typeMapSet(transaction, this, attributeName, attributeValue);
        });
      } else {
        this._prelimAttrs.set(attributeName, attributeValue);
      }
    }
    /**
     * Returns an attribute value that belongs to the attribute name.
     *
     * @template {keyof KV & string} KEY
     *
     * @param {KEY} attributeName The attribute name that identifies the
     *                               queried value.
     * @return {KV[KEY]|undefined} The queried attribute value.
     *
     * @public
     */
    getAttribute(attributeName) {
      return (
        /** @type {any} */
        typeMapGet(this, attributeName)
      );
    }
    /**
     * Returns whether an attribute exists
     *
     * @param {string} attributeName The attribute name to check for existence.
     * @return {boolean} whether the attribute exists.
     *
     * @public
     */
    hasAttribute(attributeName) {
      return (
        /** @type {any} */
        typeMapHas(this, attributeName)
      );
    }
    /**
     * Returns all attribute name/value pairs in a JSON Object.
     *
     * @param {Snapshot} [snapshot]
     * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
     *
     * @public
     */
    getAttributes(snapshot2) {
      return (
        /** @type {any} */
        snapshot2 ? typeMapGetAllSnapshot(this, snapshot2) : typeMapGetAll(this)
      );
    }
    /**
     * Creates a Dom Element that mirrors this YXmlElement.
     *
     * @param {Document} [_document=document] The document object (you must define
     *                                        this when calling this method in
     *                                        nodejs)
     * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
     *                                             are presented in the DOM
     * @param {any} [binding] You should not set this property. This is
     *                               used if DomBinding wants to create a
     *                               association to the created DOM type.
     * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
     *
     * @public
     */
    toDOM(_document = document, hooks = {}, binding) {
      const dom = _document.createElement(this.nodeName);
      const attrs = this.getAttributes();
      for (const key2 in attrs) {
        const value = attrs[key2];
        if (typeof value === "string") {
          dom.setAttribute(key2, value);
        }
      }
      typeListForEach(this, (yxml) => {
        dom.appendChild(yxml.toDOM(_document, hooks, binding));
      });
      if (binding !== void 0) {
        binding._createAssociation(dom, this);
      }
      return dom;
    }
    /**
     * Transform the properties of this type to binary and write it to an
     * BinaryEncoder.
     *
     * This is called when this Item is sent to a remote peer.
     *
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
     */
    _write(encoder) {
      encoder.writeTypeRef(YXmlElementRefID);
      encoder.writeKey(this.nodeName);
    }
  };
  var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
  var YXmlEvent = class extends YEvent {
    /**
     * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
     * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
     *                   child list changed.
     * @param {Transaction} transaction The transaction instance with which the
     *                                  change was created.
     */
    constructor(target, subs, transaction) {
      super(target, transaction);
      this.childListChanged = false;
      this.attributesChanged = /* @__PURE__ */ new Set();
      subs.forEach((sub) => {
        if (sub === null) {
          this.childListChanged = true;
        } else {
          this.attributesChanged.add(sub);
        }
      });
    }
  };
  var YXmlHook = class _YXmlHook extends YMap {
    /**
     * @param {string} hookName nodeName of the Dom Node.
     */
    constructor(hookName) {
      super();
      this.hookName = hookName;
    }
    /**
     * Creates an Item with the same effect as this Item (without position effect)
     */
    _copy() {
      return new _YXmlHook(this.hookName);
    }
    /**
     * Makes a copy of this data type that can be included somewhere else.
     *
     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
     *
     * @return {YXmlHook}
     */
    clone() {
      const el = new _YXmlHook(this.hookName);
      this.forEach((value, key2) => {
        el.set(key2, value);
      });
      return el;
    }
    /**
     * Creates a Dom Element that mirrors this YXmlElement.
     *
     * @param {Document} [_document=document] The document object (you must define
     *                                        this when calling this method in
     *                                        nodejs)
     * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
     *                                             are presented in the DOM
     * @param {any} [binding] You should not set this property. This is
     *                               used if DomBinding wants to create a
     *                               association to the created DOM type
     * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
     *
     * @public
     */
    toDOM(_document = document, hooks = {}, binding) {
      const hook = hooks[this.hookName];
      let dom;
      if (hook !== void 0) {
        dom = hook.createDom(this);
      } else {
        dom = document.createElement(this.hookName);
      }
      dom.setAttribute("data-yjs-hook", this.hookName);
      if (binding !== void 0) {
        binding._createAssociation(dom, this);
      }
      return dom;
    }
    /**
     * Transform the properties of this type to binary and write it to an
     * BinaryEncoder.
     *
     * This is called when this Item is sent to a remote peer.
     *
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
     */
    _write(encoder) {
      encoder.writeTypeRef(YXmlHookRefID);
      encoder.writeKey(this.hookName);
    }
  };
  var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
  var YXmlText = class _YXmlText extends YText {
    /**
     * @type {YXmlElement|YXmlText|null}
     */
    get nextSibling() {
      const n = this._item ? this._item.next : null;
      return n ? (
        /** @type {YXmlElement|YXmlText} */
        /** @type {ContentType} */
        n.content.type
      ) : null;
    }
    /**
     * @type {YXmlElement|YXmlText|null}
     */
    get prevSibling() {
      const n = this._item ? this._item.prev : null;
      return n ? (
        /** @type {YXmlElement|YXmlText} */
        /** @type {ContentType} */
        n.content.type
      ) : null;
    }
    _copy() {
      return new _YXmlText();
    }
    /**
     * Makes a copy of this data type that can be included somewhere else.
     *
     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
     *
     * @return {YXmlText}
     */
    clone() {
      const text10 = new _YXmlText();
      text10.applyDelta(this.toDelta());
      return text10;
    }
    /**
     * Creates a Dom Element that mirrors this YXmlText.
     *
     * @param {Document} [_document=document] The document object (you must define
     *                                        this when calling this method in
     *                                        nodejs)
     * @param {Object<string, any>} [hooks] Optional property to customize how hooks
     *                                             are presented in the DOM
     * @param {any} [binding] You should not set this property. This is
     *                               used if DomBinding wants to create a
     *                               association to the created DOM type.
     * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
     *
     * @public
     */
    toDOM(_document = document, hooks, binding) {
      const dom = _document.createTextNode(this.toString());
      if (binding !== void 0) {
        binding._createAssociation(dom, this);
      }
      return dom;
    }
    toString() {
      return this.toDelta().map((delta) => {
        const nestedNodes = [];
        for (const nodeName in delta.attributes) {
          const attrs = [];
          for (const key2 in delta.attributes[nodeName]) {
            attrs.push({ key: key2, value: delta.attributes[nodeName][key2] });
          }
          attrs.sort((a2, b) => a2.key < b.key ? -1 : 1);
          nestedNodes.push({ nodeName, attrs });
        }
        nestedNodes.sort((a2, b) => a2.nodeName < b.nodeName ? -1 : 1);
        let str = "";
        for (let i = 0; i < nestedNodes.length; i++) {
          const node2 = nestedNodes[i];
          str += `<${node2.nodeName}`;
          for (let j2 = 0; j2 < node2.attrs.length; j2++) {
            const attr = node2.attrs[j2];
            str += ` ${attr.key}="${attr.value}"`;
          }
          str += ">";
        }
        str += delta.insert;
        for (let i = nestedNodes.length - 1; i >= 0; i--) {
          str += `</${nestedNodes[i].nodeName}>`;
        }
        return str;
      }).join("");
    }
    /**
     * @return {string}
     */
    toJSON() {
      return this.toString();
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     */
    _write(encoder) {
      encoder.writeTypeRef(YXmlTextRefID);
    }
  };
  var readYXmlText = (decoder) => new YXmlText();
  var AbstractStruct = class {
    /**
     * @param {ID} id
     * @param {number} length
     */
    constructor(id2, length3) {
      this.id = id2;
      this.length = length3;
    }
    /**
     * @type {boolean}
     */
    get deleted() {
      throw methodUnimplemented();
    }
    /**
     * Merge this struct with the item to the right.
     * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
     * Also this method does *not* remove right from StructStore!
     * @param {AbstractStruct} right
     * @return {boolean} whether this merged with right
     */
    mergeWith(right) {
      return false;
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
     * @param {number} offset
     * @param {number} encodingRef
     */
    write(encoder, offset, encodingRef) {
      throw methodUnimplemented();
    }
    /**
     * @param {Transaction} transaction
     * @param {number} offset
     */
    integrate(transaction, offset) {
      throw methodUnimplemented();
    }
  };
  var structGCRefNumber = 0;
  var GC = class extends AbstractStruct {
    get deleted() {
      return true;
    }
    delete() {
    }
    /**
     * @param {GC} right
     * @return {boolean}
     */
    mergeWith(right) {
      if (this.constructor !== right.constructor) {
        return false;
      }
      this.length += right.length;
      return true;
    }
    /**
     * @param {Transaction} transaction
     * @param {number} offset
     */
    integrate(transaction, offset) {
      if (offset > 0) {
        this.id.clock += offset;
        this.length -= offset;
      }
      addStruct(transaction.doc.store, this);
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeInfo(structGCRefNumber);
      encoder.writeLen(this.length - offset);
    }
    /**
     * @param {Transaction} transaction
     * @param {StructStore} store
     * @return {null | number}
     */
    getMissing(transaction, store) {
      return null;
    }
  };
  var ContentBinary = class _ContentBinary {
    /**
     * @param {Uint8Array} content
     */
    constructor(content5) {
      this.content = content5;
    }
    /**
     * @return {number}
     */
    getLength() {
      return 1;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [this.content];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentBinary}
     */
    copy() {
      return new _ContentBinary(this.content);
    }
    /**
     * @param {number} offset
     * @return {ContentBinary}
     */
    splice(offset) {
      throw methodUnimplemented();
    }
    /**
     * @param {ContentBinary} right
     * @return {boolean}
     */
    mergeWith(right) {
      return false;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeBuf(this.content);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 3;
    }
  };
  var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
  var ContentDeleted = class _ContentDeleted {
    /**
     * @param {number} len
     */
    constructor(len) {
      this.len = len;
    }
    /**
     * @return {number}
     */
    getLength() {
      return this.len;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return false;
    }
    /**
     * @return {ContentDeleted}
     */
    copy() {
      return new _ContentDeleted(this.len);
    }
    /**
     * @param {number} offset
     * @return {ContentDeleted}
     */
    splice(offset) {
      const right = new _ContentDeleted(this.len - offset);
      this.len = offset;
      return right;
    }
    /**
     * @param {ContentDeleted} right
     * @return {boolean}
     */
    mergeWith(right) {
      this.len += right.len;
      return true;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
      addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
      item.markDeleted();
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeLen(this.len - offset);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 1;
    }
  };
  var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
  var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
  var ContentDoc = class _ContentDoc {
    /**
     * @param {Doc} doc
     */
    constructor(doc4) {
      if (doc4._item) {
        console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
      }
      this.doc = doc4;
      const opts = {};
      this.opts = opts;
      if (!doc4.gc) {
        opts.gc = false;
      }
      if (doc4.autoLoad) {
        opts.autoLoad = true;
      }
      if (doc4.meta !== null) {
        opts.meta = doc4.meta;
      }
    }
    /**
     * @return {number}
     */
    getLength() {
      return 1;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [this.doc];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentDoc}
     */
    copy() {
      return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
    }
    /**
     * @param {number} offset
     * @return {ContentDoc}
     */
    splice(offset) {
      throw methodUnimplemented();
    }
    /**
     * @param {ContentDoc} right
     * @return {boolean}
     */
    mergeWith(right) {
      return false;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
      this.doc._item = item;
      transaction.subdocsAdded.add(this.doc);
      if (this.doc.shouldLoad) {
        transaction.subdocsLoaded.add(this.doc);
      }
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
      if (transaction.subdocsAdded.has(this.doc)) {
        transaction.subdocsAdded.delete(this.doc);
      } else {
        transaction.subdocsRemoved.add(this.doc);
      }
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeString(this.doc.guid);
      encoder.writeAny(this.opts);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 9;
    }
  };
  var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
  var ContentEmbed = class _ContentEmbed {
    /**
     * @param {Object} embed
     */
    constructor(embed) {
      this.embed = embed;
    }
    /**
     * @return {number}
     */
    getLength() {
      return 1;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [this.embed];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentEmbed}
     */
    copy() {
      return new _ContentEmbed(this.embed);
    }
    /**
     * @param {number} offset
     * @return {ContentEmbed}
     */
    splice(offset) {
      throw methodUnimplemented();
    }
    /**
     * @param {ContentEmbed} right
     * @return {boolean}
     */
    mergeWith(right) {
      return false;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeJSON(this.embed);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 5;
    }
  };
  var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
  var ContentFormat = class _ContentFormat {
    /**
     * @param {string} key
     * @param {Object} value
     */
    constructor(key2, value) {
      this.key = key2;
      this.value = value;
    }
    /**
     * @return {number}
     */
    getLength() {
      return 1;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return false;
    }
    /**
     * @return {ContentFormat}
     */
    copy() {
      return new _ContentFormat(this.key, this.value);
    }
    /**
     * @param {number} _offset
     * @return {ContentFormat}
     */
    splice(_offset) {
      throw methodUnimplemented();
    }
    /**
     * @param {ContentFormat} _right
     * @return {boolean}
     */
    mergeWith(_right) {
      return false;
    }
    /**
     * @param {Transaction} _transaction
     * @param {Item} item
     */
    integrate(_transaction, item) {
      const p5 = (
        /** @type {YText} */
        item.parent
      );
      p5._searchMarker = null;
      p5._hasFormatting = true;
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeKey(this.key);
      encoder.writeJSON(this.value);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 6;
    }
  };
  var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());
  var ContentJSON = class _ContentJSON {
    /**
     * @param {Array<any>} arr
     */
    constructor(arr) {
      this.arr = arr;
    }
    /**
     * @return {number}
     */
    getLength() {
      return this.arr.length;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return this.arr;
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentJSON}
     */
    copy() {
      return new _ContentJSON(this.arr);
    }
    /**
     * @param {number} offset
     * @return {ContentJSON}
     */
    splice(offset) {
      const right = new _ContentJSON(this.arr.slice(offset));
      this.arr = this.arr.slice(0, offset);
      return right;
    }
    /**
     * @param {ContentJSON} right
     * @return {boolean}
     */
    mergeWith(right) {
      this.arr = this.arr.concat(right.arr);
      return true;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      const len = this.arr.length;
      encoder.writeLen(len - offset);
      for (let i = offset; i < len; i++) {
        const c = this.arr[i];
        encoder.writeString(c === void 0 ? "undefined" : JSON.stringify(c));
      }
    }
    /**
     * @return {number}
     */
    getRef() {
      return 2;
    }
  };
  var readContentJSON = (decoder) => {
    const len = decoder.readLen();
    const cs2 = [];
    for (let i = 0; i < len; i++) {
      const c = decoder.readString();
      if (c === "undefined") {
        cs2.push(void 0);
      } else {
        cs2.push(JSON.parse(c));
      }
    }
    return new ContentJSON(cs2);
  };
  var isDevMode = getVariable("node_env") === "development";
  var ContentAny = class _ContentAny {
    /**
     * @param {Array<any>} arr
     */
    constructor(arr) {
      this.arr = arr;
      isDevMode && deepFreeze(arr);
    }
    /**
     * @return {number}
     */
    getLength() {
      return this.arr.length;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return this.arr;
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentAny}
     */
    copy() {
      return new _ContentAny(this.arr);
    }
    /**
     * @param {number} offset
     * @return {ContentAny}
     */
    splice(offset) {
      const right = new _ContentAny(this.arr.slice(offset));
      this.arr = this.arr.slice(0, offset);
      return right;
    }
    /**
     * @param {ContentAny} right
     * @return {boolean}
     */
    mergeWith(right) {
      this.arr = this.arr.concat(right.arr);
      return true;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      const len = this.arr.length;
      encoder.writeLen(len - offset);
      for (let i = offset; i < len; i++) {
        const c = this.arr[i];
        encoder.writeAny(c);
      }
    }
    /**
     * @return {number}
     */
    getRef() {
      return 8;
    }
  };
  var readContentAny = (decoder) => {
    const len = decoder.readLen();
    const cs2 = [];
    for (let i = 0; i < len; i++) {
      cs2.push(decoder.readAny());
    }
    return new ContentAny(cs2);
  };
  var ContentString = class _ContentString {
    /**
     * @param {string} str
     */
    constructor(str) {
      this.str = str;
    }
    /**
     * @return {number}
     */
    getLength() {
      return this.str.length;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return this.str.split("");
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentString}
     */
    copy() {
      return new _ContentString(this.str);
    }
    /**
     * @param {number} offset
     * @return {ContentString}
     */
    splice(offset) {
      const right = new _ContentString(this.str.slice(offset));
      this.str = this.str.slice(0, offset);
      const firstCharCode = this.str.charCodeAt(offset - 1);
      if (firstCharCode >= 55296 && firstCharCode <= 56319) {
        this.str = this.str.slice(0, offset - 1) + "\uFFFD";
        right.str = "\uFFFD" + right.str.slice(1);
      }
      return right;
    }
    /**
     * @param {ContentString} right
     * @return {boolean}
     */
    mergeWith(right) {
      this.str += right.str;
      return true;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
    }
    /**
     * @return {number}
     */
    getRef() {
      return 4;
    }
  };
  var readContentString = (decoder) => new ContentString(decoder.readString());
  var typeRefs = [
    readYArray,
    readYMap,
    readYText,
    readYXmlElement,
    readYXmlFragment,
    readYXmlHook,
    readYXmlText
  ];
  var YArrayRefID = 0;
  var YMapRefID = 1;
  var YTextRefID = 2;
  var YXmlElementRefID = 3;
  var YXmlFragmentRefID = 4;
  var YXmlHookRefID = 5;
  var YXmlTextRefID = 6;
  var ContentType = class _ContentType {
    /**
     * @param {AbstractType<any>} type
     */
    constructor(type) {
      this.type = type;
    }
    /**
     * @return {number}
     */
    getLength() {
      return 1;
    }
    /**
     * @return {Array<any>}
     */
    getContent() {
      return [this.type];
    }
    /**
     * @return {boolean}
     */
    isCountable() {
      return true;
    }
    /**
     * @return {ContentType}
     */
    copy() {
      return new _ContentType(this.type._copy());
    }
    /**
     * @param {number} offset
     * @return {ContentType}
     */
    splice(offset) {
      throw methodUnimplemented();
    }
    /**
     * @param {ContentType} right
     * @return {boolean}
     */
    mergeWith(right) {
      return false;
    }
    /**
     * @param {Transaction} transaction
     * @param {Item} item
     */
    integrate(transaction, item) {
      this.type._integrate(transaction.doc, item);
    }
    /**
     * @param {Transaction} transaction
     */
    delete(transaction) {
      let item = this.type._start;
      while (item !== null) {
        if (!item.deleted) {
          item.delete(transaction);
        } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
          transaction._mergeStructs.push(item);
        }
        item = item.right;
      }
      this.type._map.forEach((item2) => {
        if (!item2.deleted) {
          item2.delete(transaction);
        } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
          transaction._mergeStructs.push(item2);
        }
      });
      transaction.changed.delete(this.type);
    }
    /**
     * @param {StructStore} store
     */
    gc(store) {
      let item = this.type._start;
      while (item !== null) {
        item.gc(store, true);
        item = item.right;
      }
      this.type._start = null;
      this.type._map.forEach(
        /** @param {Item | null} item */
        (item2) => {
          while (item2 !== null) {
            item2.gc(store, true);
            item2 = item2.left;
          }
        }
      );
      this.type._map = /* @__PURE__ */ new Map();
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      this.type._write(encoder);
    }
    /**
     * @return {number}
     */
    getRef() {
      return 7;
    }
  };
  var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
  var followRedone = (store, id2) => {
    let nextID = id2;
    let diff = 0;
    let item;
    do {
      if (diff > 0) {
        nextID = createID(nextID.client, nextID.clock + diff);
      }
      item = getItem(store, nextID);
      diff = nextID.clock - item.id.clock;
      nextID = item.redone;
    } while (nextID !== null && item instanceof Item2);
    return {
      item,
      diff
    };
  };
  var keepItem = (item, keep) => {
    while (item !== null && item.keep !== keep) {
      item.keep = keep;
      item = /** @type {AbstractType<any>} */
      item.parent._item;
    }
  };
  var splitItem = (transaction, leftItem, diff) => {
    const { client, clock } = leftItem.id;
    const rightItem = new Item2(
      createID(client, clock + diff),
      leftItem,
      createID(client, clock + diff - 1),
      leftItem.right,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
    if (leftItem.deleted) {
      rightItem.markDeleted();
    }
    if (leftItem.keep) {
      rightItem.keep = true;
    }
    if (leftItem.redone !== null) {
      rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
    }
    leftItem.right = rightItem;
    if (rightItem.right !== null) {
      rightItem.right.left = rightItem;
    }
    transaction._mergeStructs.push(rightItem);
    if (rightItem.parentSub !== null && rightItem.right === null) {
      rightItem.parent._map.set(rightItem.parentSub, rightItem);
    }
    leftItem.length = diff;
    return rightItem;
  };
  var isDeletedByUndoStack = (stack, id2) => some(
    stack,
    /** @param {StackItem} s */
    (s2) => isDeleted(s2.deletions, id2)
  );
  var redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {
    const doc4 = transaction.doc;
    const store = doc4.store;
    const ownClientID = doc4.clientID;
    const redone = item.redone;
    if (redone !== null) {
      return getItemCleanStart(transaction, redone);
    }
    let parentItem = (
      /** @type {AbstractType<any>} */
      item.parent._item
    );
    let left = null;
    let right;
    if (parentItem !== null && parentItem.deleted === true) {
      if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
        return null;
      }
      while (parentItem.redone !== null) {
        parentItem = getItemCleanStart(transaction, parentItem.redone);
      }
    }
    const parentType = parentItem === null ? (
      /** @type {AbstractType<any>} */
      item.parent
    ) : (
      /** @type {ContentType} */
      parentItem.content.type
    );
    if (item.parentSub === null) {
      left = item.left;
      right = item;
      while (left !== null) {
        let leftTrace = left;
        while (leftTrace !== null && /** @type {AbstractType<any>} */
        leftTrace.parent._item !== parentItem) {
          leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
        }
        if (leftTrace !== null && /** @type {AbstractType<any>} */
        leftTrace.parent._item === parentItem) {
          left = leftTrace;
          break;
        }
        left = left.left;
      }
      while (right !== null) {
        let rightTrace = right;
        while (rightTrace !== null && /** @type {AbstractType<any>} */
        rightTrace.parent._item !== parentItem) {
          rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
        }
        if (rightTrace !== null && /** @type {AbstractType<any>} */
        rightTrace.parent._item === parentItem) {
          right = rightTrace;
          break;
        }
        right = right.right;
      }
    } else {
      right = null;
      if (item.right && !ignoreRemoteMapChanges) {
        left = item;
        while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
          left = left.right;
          while (left.redone) left = getItemCleanStart(transaction, left.redone);
        }
        if (left && left.right !== null) {
          return null;
        }
      } else {
        left = parentType._map.get(item.parentSub) || null;
      }
    }
    const nextClock = getState(store, ownClientID);
    const nextId = createID(ownClientID, nextClock);
    const redoneItem = new Item2(
      nextId,
      left,
      left && left.lastId,
      right,
      right && right.id,
      parentType,
      item.parentSub,
      item.content.copy()
    );
    item.redone = nextId;
    keepItem(redoneItem, true);
    redoneItem.integrate(transaction, 0);
    return redoneItem;
  };
  var Item2 = class _Item extends AbstractStruct {
    /**
     * @param {ID} id
     * @param {Item | null} left
     * @param {ID | null} origin
     * @param {Item | null} right
     * @param {ID | null} rightOrigin
     * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
     * @param {string | null} parentSub
     * @param {AbstractContent} content
     */
    constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content5) {
      super(id2, content5.getLength());
      this.origin = origin;
      this.left = left;
      this.right = right;
      this.rightOrigin = rightOrigin;
      this.parent = parent;
      this.parentSub = parentSub;
      this.redone = null;
      this.content = content5;
      this.info = this.content.isCountable() ? BIT2 : 0;
    }
    /**
     * This is used to mark the item as an indexed fast-search marker
     *
     * @type {boolean}
     */
    set marker(isMarked) {
      if ((this.info & BIT4) > 0 !== isMarked) {
        this.info ^= BIT4;
      }
    }
    get marker() {
      return (this.info & BIT4) > 0;
    }
    /**
     * If true, do not garbage collect this Item.
     */
    get keep() {
      return (this.info & BIT1) > 0;
    }
    set keep(doKeep) {
      if (this.keep !== doKeep) {
        this.info ^= BIT1;
      }
    }
    get countable() {
      return (this.info & BIT2) > 0;
    }
    /**
     * Whether this item was deleted or not.
     * @type {Boolean}
     */
    get deleted() {
      return (this.info & BIT3) > 0;
    }
    set deleted(doDelete) {
      if (this.deleted !== doDelete) {
        this.info ^= BIT3;
      }
    }
    markDeleted() {
      this.info |= BIT3;
    }
    /**
     * Return the creator clientID of the missing op or define missing items and return null.
     *
     * @param {Transaction} transaction
     * @param {StructStore} store
     * @return {null | number}
     */
    getMissing(transaction, store) {
      if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
        return this.origin.client;
      }
      if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
        return this.rightOrigin.client;
      }
      if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
        return this.parent.client;
      }
      if (this.origin) {
        this.left = getItemCleanEnd(transaction, store, this.origin);
        this.origin = this.left.lastId;
      }
      if (this.rightOrigin) {
        this.right = getItemCleanStart(transaction, this.rightOrigin);
        this.rightOrigin = this.right.id;
      }
      if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
        this.parent = null;
      } else if (!this.parent) {
        if (this.left && this.left.constructor === _Item) {
          this.parent = this.left.parent;
          this.parentSub = this.left.parentSub;
        } else if (this.right && this.right.constructor === _Item) {
          this.parent = this.right.parent;
          this.parentSub = this.right.parentSub;
        }
      } else if (this.parent.constructor === ID) {
        const parentItem = getItem(store, this.parent);
        if (parentItem.constructor === GC) {
          this.parent = null;
        } else {
          this.parent = /** @type {ContentType} */
          parentItem.content.type;
        }
      }
      return null;
    }
    /**
     * @param {Transaction} transaction
     * @param {number} offset
     */
    integrate(transaction, offset) {
      if (offset > 0) {
        this.id.clock += offset;
        this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
        this.origin = this.left.lastId;
        this.content = this.content.splice(offset);
        this.length -= offset;
      }
      if (this.parent) {
        if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
          let left = this.left;
          let o;
          if (left !== null) {
            o = left.right;
          } else if (this.parentSub !== null) {
            o = /** @type {AbstractType<any>} */
            this.parent._map.get(this.parentSub) || null;
            while (o !== null && o.left !== null) {
              o = o.left;
            }
          } else {
            o = /** @type {AbstractType<any>} */
            this.parent._start;
          }
          const conflictingItems = /* @__PURE__ */ new Set();
          const itemsBeforeOrigin = /* @__PURE__ */ new Set();
          while (o !== null && o !== this.right) {
            itemsBeforeOrigin.add(o);
            conflictingItems.add(o);
            if (compareIDs(this.origin, o.origin)) {
              if (o.id.client < this.id.client) {
                left = o;
                conflictingItems.clear();
              } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
                break;
              }
            } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
              if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
                left = o;
                conflictingItems.clear();
              }
            } else {
              break;
            }
            o = o.right;
          }
          this.left = left;
        }
        if (this.left !== null) {
          const right = this.left.right;
          this.right = right;
          this.left.right = this;
        } else {
          let r;
          if (this.parentSub !== null) {
            r = /** @type {AbstractType<any>} */
            this.parent._map.get(this.parentSub) || null;
            while (r !== null && r.left !== null) {
              r = r.left;
            }
          } else {
            r = /** @type {AbstractType<any>} */
            this.parent._start;
            this.parent._start = this;
          }
          this.right = r;
        }
        if (this.right !== null) {
          this.right.left = this;
        } else if (this.parentSub !== null) {
          this.parent._map.set(this.parentSub, this);
          if (this.left !== null) {
            this.left.delete(transaction);
          }
        }
        if (this.parentSub === null && this.countable && !this.deleted) {
          this.parent._length += this.length;
        }
        addStruct(transaction.doc.store, this);
        this.content.integrate(transaction, this);
        addChangedTypeToTransaction(
          transaction,
          /** @type {AbstractType<any>} */
          this.parent,
          this.parentSub
        );
        if (
          /** @type {AbstractType<any>} */
          this.parent._item !== null && /** @type {AbstractType<any>} */
          this.parent._item.deleted || this.parentSub !== null && this.right !== null
        ) {
          this.delete(transaction);
        }
      } else {
        new GC(this.id, this.length).integrate(transaction, 0);
      }
    }
    /**
     * Returns the next non-deleted item
     */
    get next() {
      let n = this.right;
      while (n !== null && n.deleted) {
        n = n.right;
      }
      return n;
    }
    /**
     * Returns the previous non-deleted item
     */
    get prev() {
      let n = this.left;
      while (n !== null && n.deleted) {
        n = n.left;
      }
      return n;
    }
    /**
     * Computes the last content address of this Item.
     */
    get lastId() {
      return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
    }
    /**
     * Try to merge two items
     *
     * @param {Item} right
     * @return {boolean}
     */
    mergeWith(right) {
      if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
        const searchMarker = (
          /** @type {AbstractType<any>} */
          this.parent._searchMarker
        );
        if (searchMarker) {
          searchMarker.forEach((marker) => {
            if (marker.p === right) {
              marker.p = this;
              if (!this.deleted && this.countable) {
                marker.index -= this.length;
              }
            }
          });
        }
        if (right.keep) {
          this.keep = true;
        }
        this.right = right.right;
        if (this.right !== null) {
          this.right.left = this;
        }
        this.length += right.length;
        return true;
      }
      return false;
    }
    /**
     * Mark this Item as deleted.
     *
     * @param {Transaction} transaction
     */
    delete(transaction) {
      if (!this.deleted) {
        const parent = (
          /** @type {AbstractType<any>} */
          this.parent
        );
        if (this.countable && this.parentSub === null) {
          parent._length -= this.length;
        }
        this.markDeleted();
        addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
        addChangedTypeToTransaction(transaction, parent, this.parentSub);
        this.content.delete(transaction);
      }
    }
    /**
     * @param {StructStore} store
     * @param {boolean} parentGCd
     */
    gc(store, parentGCd) {
      if (!this.deleted) {
        throw unexpectedCase();
      }
      this.content.gc(store);
      if (parentGCd) {
        replaceStruct(store, this, new GC(this.id, this.length));
      } else {
        this.content = new ContentDeleted(this.length);
      }
    }
    /**
     * Transform the properties of this type to binary and write it to an
     * BinaryEncoder.
     *
     * This is called when this Item is sent to a remote peer.
     *
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
     * @param {number} offset
     */
    write(encoder, offset) {
      const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
      const rightOrigin = this.rightOrigin;
      const parentSub = this.parentSub;
      const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
      (rightOrigin === null ? 0 : BIT7) | // right origin is defined
      (parentSub === null ? 0 : BIT6);
      encoder.writeInfo(info);
      if (origin !== null) {
        encoder.writeLeftID(origin);
      }
      if (rightOrigin !== null) {
        encoder.writeRightID(rightOrigin);
      }
      if (origin === null && rightOrigin === null) {
        const parent = (
          /** @type {AbstractType<any>} */
          this.parent
        );
        if (parent._item !== void 0) {
          const parentItem = parent._item;
          if (parentItem === null) {
            const ykey = findRootTypeKey(parent);
            encoder.writeParentInfo(true);
            encoder.writeString(ykey);
          } else {
            encoder.writeParentInfo(false);
            encoder.writeLeftID(parentItem.id);
          }
        } else if (parent.constructor === String) {
          encoder.writeParentInfo(true);
          encoder.writeString(parent);
        } else if (parent.constructor === ID) {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parent);
        } else {
          unexpectedCase();
        }
        if (parentSub !== null) {
          encoder.writeString(parentSub);
        }
      }
      this.content.write(encoder, offset);
    }
  };
  var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
  var contentRefs = [
    () => {
      unexpectedCase();
    },
    // GC is not ItemContent
    readContentDeleted,
    // 1
    readContentJSON,
    // 2
    readContentBinary,
    // 3
    readContentString,
    // 4
    readContentEmbed,
    // 5
    readContentFormat,
    // 6
    readContentType,
    // 7
    readContentAny,
    // 8
    readContentDoc,
    // 9
    () => {
      unexpectedCase();
    }
    // 10 - Skip is not ItemContent
  ];
  var structSkipRefNumber = 10;
  var Skip = class extends AbstractStruct {
    get deleted() {
      return true;
    }
    delete() {
    }
    /**
     * @param {Skip} right
     * @return {boolean}
     */
    mergeWith(right) {
      if (this.constructor !== right.constructor) {
        return false;
      }
      this.length += right.length;
      return true;
    }
    /**
     * @param {Transaction} transaction
     * @param {number} offset
     */
    integrate(transaction, offset) {
      unexpectedCase();
    }
    /**
     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
     * @param {number} offset
     */
    write(encoder, offset) {
      encoder.writeInfo(structSkipRefNumber);
      writeVarUint(encoder.restEncoder, this.length - offset);
    }
    /**
     * @param {Transaction} transaction
     * @param {StructStore} store
     * @return {null | number}
     */
    getMissing(transaction, store) {
      return null;
    }
  };
  var glo = (
    /** @type {any} */
    typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
  );
  var importIdentifier = "__ $YJS$ __";
  if (glo[importIdentifier] === true) {
    console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
  }
  glo[importIdentifier] = true;

  // node_modules/lib0/mutex.js
  var createMutex = () => {
    let token = true;
    return (f, g) => {
      if (token) {
        token = false;
        try {
          f();
        } finally {
          token = true;
        }
      } else if (g !== void 0) {
        g();
      }
    };
  };

  // node_modules/lib0/diff.js
  var highSurrogateRegex = /[\uD800-\uDBFF]/;
  var lowSurrogateRegex = /[\uDC00-\uDFFF]/;
  var simpleDiffString = (a2, b) => {
    let left = 0;
    let right = 0;
    while (left < a2.length && left < b.length && a2[left] === b[left]) {
      left++;
    }
    if (left > 0 && highSurrogateRegex.test(a2[left - 1])) left--;
    while (right + left < a2.length && right + left < b.length && a2[a2.length - right - 1] === b[b.length - right - 1]) {
      right++;
    }
    if (right > 0 && lowSurrogateRegex.test(a2[a2.length - right])) right--;
    return {
      index: left,
      remove: a2.length - left - right,
      insert: b.slice(left, b.length - right)
    };
  };
  var simpleDiff = simpleDiffString;
  var simpleDiffArray = (a2, b, compare = equalityStrict) => {
    let left = 0;
    let right = 0;
    while (left < a2.length && left < b.length && compare(a2[left], b[left])) {
      left++;
    }
    while (right + left < a2.length && right + left < b.length && compare(a2[a2.length - right - 1], b[b.length - right - 1])) {
      right++;
    }
    return {
      index: left,
      remove: a2.length - left - right,
      insert: b.slice(left, b.length - right)
    };
  };
  var simpleDiffStringWithCursor = (a2, b, cursor) => {
    let left = 0;
    let right = 0;
    while (left < a2.length && left < b.length && a2[left] === b[left] && left < cursor) {
      left++;
    }
    if (left > 0 && highSurrogateRegex.test(a2[left - 1])) left--;
    while (right + left < a2.length && right + left < b.length && a2[a2.length - right - 1] === b[b.length - right - 1]) {
      right++;
    }
    if (right > 0 && lowSurrogateRegex.test(a2[a2.length - right])) right--;
    while (right + left < a2.length && right + left < b.length && a2[left] === b[left]) {
      left++;
    }
    if (left > 0 && highSurrogateRegex.test(a2[left - 1])) left--;
    return {
      index: left,
      remove: a2.length - left - right,
      insert: b.slice(left, b.length - right)
    };
  };

  // node_modules/y-prosemirror/src/plugins/keys.js
  var ySyncPluginKey = new PluginKey("y-sync");
  var yUndoPluginKey = new PluginKey("y-undo");
  var yCursorPluginKey = new PluginKey("yjs-cursor");

  // node_modules/lib0/hash/sha256.js
  var rotr = (w, shift2) => w >>> shift2 | w << 32 - shift2;
  var sum0to256 = (x) => rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
  var sum1to256 = (x) => rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
  var sigma0to256 = (x) => rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
  var sigma1to256 = (x) => rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
  var K = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var HINIT = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var Hasher = class {
    constructor() {
      const buf = new ArrayBuffer(64 + 64 * 4);
      this._H = new Uint32Array(buf, 0, 8);
      this._H.set(HINIT);
      this._W = new Uint32Array(buf, 64, 64);
    }
    _updateHash() {
      const H = this._H;
      const W = this._W;
      for (let t2 = 16; t2 < 64; t2++) {
        W[t2] = sigma1to256(W[t2 - 2]) + W[t2 - 7] + sigma0to256(W[t2 - 15]) + W[t2 - 16];
      }
      let a2 = H[0];
      let b = H[1];
      let c = H[2];
      let d = H[3];
      let e = H[4];
      let f = H[5];
      let g = H[6];
      let h2 = H[7];
      for (let tt2 = 0, T1, T2; tt2 < 64; tt2++) {
        T1 = h2 + sum1to256(e) + (e & f ^ ~e & g) + K[tt2] + W[tt2] >>> 0;
        T2 = sum0to256(a2) + (a2 & b ^ a2 & c ^ b & c) >>> 0;
        h2 = g;
        g = f;
        f = e;
        e = d + T1 >>> 0;
        d = c;
        c = b;
        b = a2;
        a2 = T1 + T2 >>> 0;
      }
      H[0] += a2;
      H[1] += b;
      H[2] += c;
      H[3] += d;
      H[4] += e;
      H[5] += f;
      H[6] += g;
      H[7] += h2;
    }
    /**
     * Returns a 32-byte hash.
     *
     * @param {Uint8Array} data
     */
    digest(data) {
      let i = 0;
      for (; i + 56 <= data.length; ) {
        let j3 = 0;
        for (; j3 < 16 && i + 3 < data.length; j3++) {
          this._W[j3] = data[i++] << 24 | data[i++] << 16 | data[i++] << 8 | data[i++];
        }
        if (i % 64 !== 0) {
          this._W.fill(0, j3, 16);
          while (i < data.length) {
            this._W[j3] |= data[i] << (3 - i % 4) * 8;
            i++;
          }
          this._W[j3] |= BIT8 << (3 - i % 4) * 8;
        }
        this._updateHash();
      }
      const isPaddedWith1 = i % 64 !== 0;
      this._W.fill(0, 0, 16);
      let j2 = 0;
      for (; i < data.length; j2++) {
        for (let ci2 = 3; ci2 >= 0 && i < data.length; ci2--) {
          this._W[j2] |= data[i++] << ci2 * 8;
        }
      }
      if (!isPaddedWith1) {
        this._W[j2 - (i % 4 === 0 ? 0 : 1)] |= BIT8 << (3 - i % 4) * 8;
      }
      this._W[14] = data.byteLength / BIT30;
      this._W[15] = data.byteLength * 8;
      this._updateHash();
      const dv = new Uint8Array(32);
      for (let i2 = 0; i2 < this._H.length; i2++) {
        for (let ci2 = 0; ci2 < 4; ci2++) {
          dv[i2 * 4 + ci2] = this._H[i2] >>> (3 - ci2) * 8;
        }
      }
      return dv;
    }
  };
  var digest = (data) => new Hasher().digest(data);

  // node_modules/y-prosemirror/src/utils.js
  var _convolute = (digest2) => {
    const N2 = 6;
    for (let i = N2; i < digest2.length; i++) {
      digest2[i % N2] = digest2[i % N2] ^ digest2[i];
    }
    return digest2.slice(0, N2);
  };
  var hashOfJSON = (json) => toBase64(_convolute(digest(encodeAny(json))));

  // node_modules/y-prosemirror/src/plugins/sync-plugin.js
  var createEmptyMeta = () => ({
    mapping: /* @__PURE__ */ new Map(),
    isOMark: /* @__PURE__ */ new Map()
  });
  var isVisible2 = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && /** @type {number} */
  snapshot2.sv.get(item.id.client) > item.id.clock && !isDeleted(snapshot2.ds, item.id);
  var defaultColors = [{ light: "#ecd44433", dark: "#ecd444" }];
  var getUserColor = (colorMapping, colors, user) => {
    if (!colorMapping.has(user)) {
      if (colorMapping.size < colors.length) {
        const usedColors = create6();
        colorMapping.forEach((color2) => usedColors.add(color2));
        colors = colors.filter((color2) => !usedColors.has(color2));
      }
      colorMapping.set(user, oneOf(colors));
    }
    return (
      /** @type {ColorDef} */
      colorMapping.get(user)
    );
  };
  var ySyncPlugin = (yXmlFragment, {
    colors = defaultColors,
    colorMapping = /* @__PURE__ */ new Map(),
    permanentUserData = null,
    onFirstRender = () => {
    },
    mapping
  } = {}) => {
    let initialContentChanged = false;
    const binding = new ProsemirrorBinding(yXmlFragment, mapping);
    const plugin = new Plugin({
      props: {
        editable: (state) => {
          const syncState = ySyncPluginKey.getState(state);
          return syncState.snapshot == null && syncState.prevSnapshot == null;
        }
      },
      key: ySyncPluginKey,
      state: {
        /**
         * @returns {any}
         */
        init: (_initargs, _state) => {
          return {
            type: yXmlFragment,
            doc: yXmlFragment.doc,
            binding,
            snapshot: null,
            prevSnapshot: null,
            isChangeOrigin: false,
            isUndoRedoOperation: false,
            addToHistory: true,
            colors,
            colorMapping,
            permanentUserData
          };
        },
        apply: (tr3, pluginState) => {
          const change = tr3.getMeta(ySyncPluginKey);
          if (change !== void 0) {
            pluginState = Object.assign({}, pluginState);
            for (const key2 in change) {
              pluginState[key2] = change[key2];
            }
          }
          pluginState.addToHistory = tr3.getMeta("addToHistory") !== false;
          pluginState.isChangeOrigin = change !== void 0 && !!change.isChangeOrigin;
          pluginState.isUndoRedoOperation = change !== void 0 && !!change.isChangeOrigin && !!change.isUndoRedoOperation;
          if (binding.prosemirrorView !== null) {
            if (change !== void 0 && (change.snapshot != null || change.prevSnapshot != null)) {
              timeout(0, () => {
                if (binding.prosemirrorView == null) {
                  return;
                }
                if (change.restore == null) {
                  binding._renderSnapshot(
                    change.snapshot,
                    change.prevSnapshot,
                    pluginState
                  );
                } else {
                  binding._renderSnapshot(
                    change.snapshot,
                    change.snapshot,
                    pluginState
                  );
                  delete pluginState.restore;
                  delete pluginState.snapshot;
                  delete pluginState.prevSnapshot;
                  binding.mux(() => {
                    binding._prosemirrorChanged(
                      binding.prosemirrorView.state.doc
                    );
                  });
                }
              });
            }
          }
          return pluginState;
        }
      },
      view: (view) => {
        binding.initView(view);
        if (mapping == null) {
          binding._forceRerender();
        }
        onFirstRender();
        return {
          update: () => {
            const pluginState = plugin.getState(view.state);
            if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {
              if (
                // If the content doesn't change initially, we don't render anything to Yjs
                // If the content was cleared by a user action, we want to catch the change and
                // represent it in Yjs
                initialContentChanged || view.state.doc.content.findDiffStart(
                  view.state.doc.type.createAndFill().content
                ) !== null
              ) {
                initialContentChanged = true;
                if (pluginState.addToHistory === false && !pluginState.isChangeOrigin) {
                  const yUndoPluginState = yUndoPluginKey.getState(view.state);
                  const um = yUndoPluginState && yUndoPluginState.undoManager;
                  if (um) {
                    um.stopCapturing();
                  }
                }
                binding.mux(() => {
                  pluginState.doc.transact((tr3) => {
                    tr3.meta.set("addToHistory", pluginState.addToHistory);
                    binding._prosemirrorChanged(view.state.doc);
                  }, ySyncPluginKey);
                });
              }
            }
          },
          destroy: () => {
            binding.destroy();
          }
        };
      }
    });
    return plugin;
  };
  var restoreRelativeSelection = (tr3, relSel, binding) => {
    if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {
      if (relSel.type === "all") {
        tr3.setSelection(new AllSelection(tr3.doc));
      } else if (relSel.type === "node") {
        const anchor = relativePositionToAbsolutePosition(
          binding.doc,
          binding.type,
          relSel.anchor,
          binding.mapping
        );
        tr3.setSelection(NodeSelection.create(tr3.doc, anchor));
      } else {
        const anchor = relativePositionToAbsolutePosition(
          binding.doc,
          binding.type,
          relSel.anchor,
          binding.mapping
        );
        const head2 = relativePositionToAbsolutePosition(
          binding.doc,
          binding.type,
          relSel.head,
          binding.mapping
        );
        if (anchor !== null && head2 !== null) {
          tr3.setSelection(TextSelection.between(tr3.doc.resolve(anchor), tr3.doc.resolve(head2)));
        }
      }
    }
  };
  var getRelativeSelection = (pmbinding, state) => ({
    type: (
      /** @type {any} */
      state.selection.jsonID
    ),
    anchor: absolutePositionToRelativePosition(
      state.selection.anchor,
      pmbinding.type,
      pmbinding.mapping
    ),
    head: absolutePositionToRelativePosition(
      state.selection.head,
      pmbinding.type,
      pmbinding.mapping
    )
  });
  var ProsemirrorBinding = class {
    /**
     * @param {Y.XmlFragment} yXmlFragment The bind source
     * @param {ProsemirrorMapping} mapping
     */
    constructor(yXmlFragment, mapping = /* @__PURE__ */ new Map()) {
      this.type = yXmlFragment;
      this.prosemirrorView = null;
      this.mux = createMutex();
      this.mapping = mapping;
      this.isOMark = /* @__PURE__ */ new Map();
      this._observeFunction = this._typeChanged.bind(this);
      this.doc = yXmlFragment.doc;
      this.beforeTransactionSelection = null;
      this.beforeAllTransactions = () => {
        if (this.beforeTransactionSelection === null && this.prosemirrorView != null) {
          this.beforeTransactionSelection = getRelativeSelection(
            this,
            this.prosemirrorView.state
          );
        }
      };
      this.afterAllTransactions = () => {
        this.beforeTransactionSelection = null;
      };
      this._domSelectionInView = null;
    }
    /**
     * Create a transaction for changing the prosemirror state.
     *
     * @returns
     */
    get _tr() {
      return this.prosemirrorView.state.tr.setMeta("addToHistory", false);
    }
    _isLocalCursorInView() {
      if (!this.prosemirrorView.hasFocus()) return false;
      if (isBrowser && this._domSelectionInView === null) {
        timeout(0, () => {
          this._domSelectionInView = null;
        });
        this._domSelectionInView = this._isDomSelectionInView();
      }
      return this._domSelectionInView;
    }
    _isDomSelectionInView() {
      const selection = this.prosemirrorView._root.getSelection();
      if (selection == null || selection.anchorNode == null) return false;
      const range = this.prosemirrorView._root.createRange();
      range.setStart(selection.anchorNode, selection.anchorOffset);
      range.setEnd(selection.focusNode, selection.focusOffset);
      const rects = range.getClientRects();
      if (rects.length === 0) {
        if (range.startContainer && range.collapsed) {
          range.selectNodeContents(range.startContainer);
        }
      }
      const bounding = range.getBoundingClientRect();
      const documentElement = doc3.documentElement;
      return bounding.bottom >= 0 && bounding.right >= 0 && bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) && bounding.top <= (window.innerHeight || documentElement.clientHeight || 0);
    }
    /**
     * @param {Y.Snapshot} snapshot
     * @param {Y.Snapshot} prevSnapshot
     */
    renderSnapshot(snapshot2, prevSnapshot) {
      if (!prevSnapshot) {
        prevSnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
      }
      this.prosemirrorView.dispatch(
        this._tr.setMeta(ySyncPluginKey, { snapshot: snapshot2, prevSnapshot })
      );
    }
    unrenderSnapshot() {
      this.mapping.clear();
      this.mux(() => {
        const fragmentContent = this.type.toArray().map(
          (t2) => createNodeFromYElement(
            /** @type {Y.XmlElement} */
            t2,
            this.prosemirrorView.state.schema,
            this
          )
        ).filter((n) => n !== null);
        const tr3 = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new Slice(Fragment.from(fragmentContent), 0, 0)
        );
        tr3.setMeta(ySyncPluginKey, { snapshot: null, prevSnapshot: null });
        this.prosemirrorView.dispatch(tr3);
      });
    }
    _forceRerender() {
      this.mapping.clear();
      this.mux(() => {
        const sel = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection;
        const fragmentContent = this.type.toArray().map(
          (t2) => createNodeFromYElement(
            /** @type {Y.XmlElement} */
            t2,
            this.prosemirrorView.state.schema,
            this
          )
        ).filter((n) => n !== null);
        const tr3 = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new Slice(Fragment.from(fragmentContent), 0, 0)
        );
        if (sel) {
          const clampedAnchor = min(max(sel.anchor, 0), tr3.doc.content.size);
          const clampedHead = min(max(sel.head, 0), tr3.doc.content.size);
          tr3.setSelection(TextSelection.create(tr3.doc, clampedAnchor, clampedHead));
        }
        this.prosemirrorView.dispatch(
          tr3.setMeta(ySyncPluginKey, { isChangeOrigin: true, binding: this })
        );
      });
    }
    /**
     * @param {Y.Snapshot|Uint8Array} snapshot
     * @param {Y.Snapshot|Uint8Array} prevSnapshot
     * @param {Object} pluginState
     */
    _renderSnapshot(snapshot2, prevSnapshot, pluginState) {
      let historyDoc = this.doc;
      let historyType = this.type;
      if (!snapshot2) {
        snapshot2 = snapshot(this.doc);
      }
      if (snapshot2 instanceof Uint8Array || prevSnapshot instanceof Uint8Array) {
        if (!(snapshot2 instanceof Uint8Array) || !(prevSnapshot instanceof Uint8Array)) {
          unexpectedCase();
        }
        historyDoc = new Doc({ gc: false });
        applyUpdateV2(historyDoc, prevSnapshot);
        prevSnapshot = snapshot(historyDoc);
        applyUpdateV2(historyDoc, snapshot2);
        snapshot2 = snapshot(historyDoc);
        if (historyType._item === null) {
          const rootKey = Array.from(this.doc.share.keys()).find(
            (key2) => this.doc.share.get(key2) === this.type
          );
          historyType = historyDoc.getXmlFragment(rootKey);
        } else {
          const historyStructs = historyDoc.store.clients.get(historyType._item.id.client) ?? [];
          const itemIndex = findIndexSS(
            historyStructs,
            historyType._item.id.clock
          );
          const item = (
            /** @type {Y.Item} */
            historyStructs[itemIndex]
          );
          const content5 = (
            /** @type {Y.ContentType} */
            item.content
          );
          historyType = /** @type {Y.XmlFragment} */
          content5.type;
        }
      }
      this.mapping.clear();
      this.mux(() => {
        historyDoc.transact((transaction) => {
          const pud = pluginState.permanentUserData;
          if (pud) {
            pud.dss.forEach((ds2) => {
              iterateDeletedStructs(transaction, ds2, (_item) => {
              });
            });
          }
          const computeYChange = (type, id2) => {
            const user = type === "added" ? pud.getUserByClientId(id2.client) : pud.getUserByDeletedId(id2);
            return {
              user,
              type,
              color: getUserColor(
                pluginState.colorMapping,
                pluginState.colors,
                user
              )
            };
          };
          const fragmentContent = typeListToArraySnapshot(
            historyType,
            new Snapshot(prevSnapshot.ds, snapshot2.sv)
          ).map((t2) => {
            if (!t2._item.deleted || isVisible2(t2._item, snapshot2) || isVisible2(t2._item, prevSnapshot)) {
              return createNodeFromYElement(
                t2,
                this.prosemirrorView.state.schema,
                { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() },
                snapshot2,
                prevSnapshot,
                computeYChange
              );
            } else {
              return null;
            }
          }).filter((n) => n !== null);
          const tr3 = this._tr.replace(
            0,
            this.prosemirrorView.state.doc.content.size,
            new Slice(Fragment.from(fragmentContent), 0, 0)
          );
          this.prosemirrorView.dispatch(
            tr3.setMeta(ySyncPluginKey, { isChangeOrigin: true })
          );
        }, ySyncPluginKey);
      });
    }
    /**
     * @param {Array<Y.YEvent<any>>} events
     * @param {Y.Transaction} transaction
     */
    _typeChanged(events, transaction) {
      if (this.prosemirrorView == null) return;
      const syncState = ySyncPluginKey.getState(this.prosemirrorView.state);
      if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {
        this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);
        return;
      }
      this.mux(() => {
        const delType = (_2, type) => this.mapping.delete(type);
        iterateDeletedStructs(
          transaction,
          transaction.deleteSet,
          (struct) => {
            if (struct.constructor === Item2) {
              const type = (
                /** @type {Y.ContentType} */
                /** @type {Y.Item} */
                struct.content.type
              );
              type && this.mapping.delete(type);
            }
          }
        );
        transaction.changed.forEach(delType);
        transaction.changedParentTypes.forEach(delType);
        const fragmentContent = this.type.toArray().map(
          (t2) => createNodeIfNotExists(
            /** @type {Y.XmlElement | Y.XmlHook} */
            t2,
            this.prosemirrorView.state.schema,
            this
          )
        ).filter((n) => n !== null);
        let tr3 = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new Slice(Fragment.from(fragmentContent), 0, 0)
        );
        restoreRelativeSelection(tr3, this.beforeTransactionSelection, this);
        tr3 = tr3.setMeta(ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof UndoManager });
        if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {
          tr3.scrollIntoView();
        }
        this.prosemirrorView.dispatch(tr3);
      });
    }
    /**
     * @param {import('prosemirror-model').Node} doc
     */
    _prosemirrorChanged(doc4) {
      this.doc.transact(() => {
        updateYFragment(this.doc, this.type, doc4, this);
        this.beforeTransactionSelection = getRelativeSelection(
          this,
          this.prosemirrorView.state
        );
      }, ySyncPluginKey);
    }
    /**
     * View is ready to listen to changes. Register observers.
     * @param {any} prosemirrorView
     */
    initView(prosemirrorView) {
      if (this.prosemirrorView != null) this.destroy();
      this.prosemirrorView = prosemirrorView;
      this.doc.on("beforeAllTransactions", this.beforeAllTransactions);
      this.doc.on("afterAllTransactions", this.afterAllTransactions);
      this.type.observeDeep(this._observeFunction);
    }
    destroy() {
      if (this.prosemirrorView == null) return;
      this.prosemirrorView = null;
      this.type.unobserveDeep(this._observeFunction);
      this.doc.off("beforeAllTransactions", this.beforeAllTransactions);
      this.doc.off("afterAllTransactions", this.afterAllTransactions);
    }
  };
  var createNodeIfNotExists = (el, schema, meta2, snapshot2, prevSnapshot, computeYChange) => {
    const node2 = (
      /** @type {PModel.Node} */
      meta2.mapping.get(el)
    );
    if (node2 === void 0) {
      if (el instanceof YXmlElement) {
        return createNodeFromYElement(
          el,
          schema,
          meta2,
          snapshot2,
          prevSnapshot,
          computeYChange
        );
      } else {
        throw methodUnimplemented();
      }
    }
    return node2;
  };
  var createNodeFromYElement = (el, schema, meta2, snapshot2, prevSnapshot, computeYChange) => {
    const children = [];
    const createChildren = (type) => {
      if (type instanceof YXmlElement) {
        const n = createNodeIfNotExists(
          type,
          schema,
          meta2,
          snapshot2,
          prevSnapshot,
          computeYChange
        );
        if (n !== null) {
          children.push(n);
        }
      } else {
        const nextytext = (
          /** @type {Y.ContentType} */
          type._item.right?.content?.type
        );
        if (nextytext instanceof YText && !nextytext._item.deleted && nextytext._item.id.client === nextytext.doc.clientID) {
          type.applyDelta([
            { retain: type.length },
            ...nextytext.toDelta()
          ]);
          nextytext.doc.transact((tr3) => {
            nextytext._item.delete(tr3);
          });
        }
        const ns2 = createTextNodesFromYText(
          type,
          schema,
          meta2,
          snapshot2,
          prevSnapshot,
          computeYChange
        );
        if (ns2 !== null) {
          ns2.forEach((textchild) => {
            if (textchild !== null) {
              children.push(textchild);
            }
          });
        }
      }
    };
    if (snapshot2 === void 0 || prevSnapshot === void 0) {
      el.toArray().forEach(createChildren);
    } else {
      typeListToArraySnapshot(el, new Snapshot(prevSnapshot.ds, snapshot2.sv)).forEach(createChildren);
    }
    try {
      const attrs = el.getAttributes(snapshot2);
      if (snapshot2 !== void 0) {
        if (!isVisible2(
          /** @type {Y.Item} */
          el._item,
          snapshot2
        )) {
          attrs.ychange = computeYChange ? computeYChange(
            "removed",
            /** @type {Y.Item} */
            el._item.id
          ) : { type: "removed" };
        } else if (!isVisible2(
          /** @type {Y.Item} */
          el._item,
          prevSnapshot
        )) {
          attrs.ychange = computeYChange ? computeYChange(
            "added",
            /** @type {Y.Item} */
            el._item.id
          ) : { type: "added" };
        }
      }
      const node2 = schema.node(el.nodeName, attrs, children);
      meta2.mapping.set(el, node2);
      return node2;
    } catch (e) {
      el.doc.transact((transaction) => {
        el._item.delete(transaction);
      }, ySyncPluginKey);
      meta2.mapping.delete(el);
      return null;
    }
  };
  var createTextNodesFromYText = (text10, schema, _meta, snapshot2, prevSnapshot, computeYChange) => {
    const nodes = [];
    const deltas = text10.toDelta(snapshot2, prevSnapshot, computeYChange);
    try {
      for (let i = 0; i < deltas.length; i++) {
        const delta = deltas[i];
        nodes.push(schema.text(delta.insert, attributesToMarks(delta.attributes, schema)));
      }
    } catch (e) {
      text10.doc.transact((transaction) => {
        text10._item.delete(transaction);
      }, ySyncPluginKey);
      return null;
    }
    return nodes;
  };
  var createTypeFromTextNodes = (nodes, meta2) => {
    const type = new YXmlText();
    const delta = nodes.map((node2) => ({
      // @ts-ignore
      insert: node2.text,
      attributes: marksToAttributes(node2.marks, meta2)
    }));
    type.applyDelta(delta);
    meta2.mapping.set(type, nodes);
    return type;
  };
  var createTypeFromElementNode = (node2, meta2) => {
    const type = new YXmlElement(node2.type.name);
    for (const key2 in node2.attrs) {
      const val = node2.attrs[key2];
      if (val !== null && key2 !== "ychange") {
        type.setAttribute(key2, val);
      }
    }
    type.insert(
      0,
      normalizePNodeContent(node2).map(
        (n) => createTypeFromTextOrElementNode(n, meta2)
      )
    );
    meta2.mapping.set(type, node2);
    return type;
  };
  var createTypeFromTextOrElementNode = (node2, meta2) => node2 instanceof Array ? createTypeFromTextNodes(node2, meta2) : createTypeFromElementNode(node2, meta2);
  var isObject = (val) => typeof val === "object" && val !== null;
  var equalAttrs2 = (pattrs, yattrs) => {
    const keys4 = Object.keys(pattrs).filter((key2) => pattrs[key2] !== null);
    let eq = keys4.length === (yattrs == null ? 0 : Object.keys(yattrs).filter((key2) => yattrs[key2] !== null).length);
    for (let i = 0; i < keys4.length && eq; i++) {
      const key2 = keys4[i];
      const l = pattrs[key2];
      const r = yattrs[key2];
      eq = key2 === "ychange" || l === r || isObject(l) && isObject(r) && equalAttrs2(l, r);
    }
    return eq;
  };
  var normalizePNodeContent = (pnode) => {
    const c = pnode.content.content;
    const res = [];
    for (let i = 0; i < c.length; i++) {
      const n = c[i];
      if (n.isText) {
        const textNodes = [];
        for (let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]) {
          textNodes.push(tnode);
        }
        i--;
        res.push(textNodes);
      } else {
        res.push(n);
      }
    }
    return res;
  };
  var equalYTextPText = (ytext, ptexts) => {
    const delta = ytext.toDelta();
    return delta.length === ptexts.length && delta.every(
      /** @type {(d:any,i:number) => boolean} */
      (d, i) => d.insert === /** @type {any} */
      ptexts[i].text && keys3(d.attributes || {}).length === ptexts[i].marks.length && every2(d.attributes, (attr, yattrname) => {
        const markname = yattr2markname(yattrname);
        const pmarks = ptexts[i].marks;
        return equalAttrs2(attr, pmarks.find(
          /** @param {any} mark */
          (mark2) => mark2.type.name === markname
        )?.attrs);
      })
    );
  };
  var equalYTypePNode = (ytype, pnode) => {
    if (ytype instanceof YXmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {
      const normalizedContent = normalizePNodeContent(pnode);
      return ytype._length === normalizedContent.length && equalAttrs2(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every(
        (ychild, i) => equalYTypePNode(ychild, normalizedContent[i])
      );
    }
    return ytype instanceof YXmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);
  };
  var mappedIdentity = (mapped, pcontent) => mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every(
    (a2, i) => pcontent[i] === a2
  );
  var computeChildEqualityFactor = (ytype, pnode, meta2) => {
    const yChildren = ytype.toArray();
    const pChildren = normalizePNodeContent(pnode);
    const pChildCnt = pChildren.length;
    const yChildCnt = yChildren.length;
    const minCnt = min(yChildCnt, pChildCnt);
    let left = 0;
    let right = 0;
    let foundMappedChild = false;
    for (; left < minCnt; left++) {
      const leftY = yChildren[left];
      const leftP = pChildren[left];
      if (mappedIdentity(meta2.mapping.get(leftY), leftP)) {
        foundMappedChild = true;
      } else if (!equalYTypePNode(leftY, leftP)) {
        break;
      }
    }
    for (; left + right < minCnt; right++) {
      const rightY = yChildren[yChildCnt - right - 1];
      const rightP = pChildren[pChildCnt - right - 1];
      if (mappedIdentity(meta2.mapping.get(rightY), rightP)) {
        foundMappedChild = true;
      } else if (!equalYTypePNode(rightY, rightP)) {
        break;
      }
    }
    return {
      equalityFactor: left + right,
      foundMappedChild
    };
  };
  var ytextTrans = (ytext) => {
    let str = "";
    let n = ytext._start;
    const nAttrs = {};
    while (n !== null) {
      if (!n.deleted) {
        if (n.countable && n.content instanceof ContentString) {
          str += n.content.str;
        } else if (n.content instanceof ContentFormat) {
          nAttrs[n.content.key] = null;
        }
      }
      n = n.right;
    }
    return {
      str,
      nAttrs
    };
  };
  var updateYText = (ytext, ptexts, meta2) => {
    meta2.mapping.set(ytext, ptexts);
    const { nAttrs, str } = ytextTrans(ytext);
    const content5 = ptexts.map((p5) => ({
      insert: (
        /** @type {any} */
        p5.text
      ),
      attributes: Object.assign({}, nAttrs, marksToAttributes(p5.marks, meta2))
    }));
    const { insert, remove: remove2, index: index3 } = simpleDiff(
      str,
      content5.map((c) => c.insert).join("")
    );
    ytext.delete(index3, remove2);
    ytext.insert(index3, insert);
    ytext.applyDelta(
      content5.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))
    );
  };
  var hashedMarkNameRegex = /(.*)(--[a-zA-Z0-9+/=]{8})$/;
  var yattr2markname = (attrName) => hashedMarkNameRegex.exec(attrName)?.[1] ?? attrName;
  var attributesToMarks = (attrs, schema) => {
    const marks = [];
    for (const markName in attrs) {
      marks.push(schema.mark(yattr2markname(markName), attrs[markName]));
    }
    return marks;
  };
  var marksToAttributes = (marks, meta2) => {
    const pattrs = {};
    marks.forEach((mark2) => {
      if (mark2.type.name !== "ychange") {
        const isOverlapping = setIfUndefined(meta2.isOMark, mark2.type, () => !mark2.type.excludes(mark2.type));
        pattrs[isOverlapping ? `${mark2.type.name}--${hashOfJSON(mark2.toJSON())}` : mark2.type.name] = mark2.attrs;
      }
    });
    return pattrs;
  };
  var updateYFragment = (y, yDomFragment, pNode, meta2) => {
    if (yDomFragment instanceof YXmlElement && yDomFragment.nodeName !== pNode.type.name) {
      throw new Error("node name mismatch!");
    }
    meta2.mapping.set(yDomFragment, pNode);
    if (yDomFragment instanceof YXmlElement) {
      const yDomAttrs = yDomFragment.getAttributes();
      const pAttrs = pNode.attrs;
      for (const key2 in pAttrs) {
        if (pAttrs[key2] !== null) {
          if (yDomAttrs[key2] !== pAttrs[key2] && key2 !== "ychange") {
            yDomFragment.setAttribute(key2, pAttrs[key2]);
          }
        } else {
          yDomFragment.removeAttribute(key2);
        }
      }
      for (const key2 in yDomAttrs) {
        if (pAttrs[key2] === void 0) {
          yDomFragment.removeAttribute(key2);
        }
      }
    }
    const pChildren = normalizePNodeContent(pNode);
    const pChildCnt = pChildren.length;
    const yChildren = yDomFragment.toArray();
    const yChildCnt = yChildren.length;
    const minCnt = min(pChildCnt, yChildCnt);
    let left = 0;
    let right = 0;
    for (; left < minCnt; left++) {
      const leftY = yChildren[left];
      const leftP = pChildren[left];
      if (!mappedIdentity(meta2.mapping.get(leftY), leftP)) {
        if (equalYTypePNode(leftY, leftP)) {
          meta2.mapping.set(leftY, leftP);
        } else {
          break;
        }
      }
    }
    for (; right + left + 1 < minCnt; right++) {
      const rightY = yChildren[yChildCnt - right - 1];
      const rightP = pChildren[pChildCnt - right - 1];
      if (!mappedIdentity(meta2.mapping.get(rightY), rightP)) {
        if (equalYTypePNode(rightY, rightP)) {
          meta2.mapping.set(rightY, rightP);
        } else {
          break;
        }
      }
    }
    y.transact(() => {
      while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {
        const leftY = yChildren[left];
        const leftP = pChildren[left];
        const rightY = yChildren[yChildCnt - right - 1];
        const rightP = pChildren[pChildCnt - right - 1];
        if (leftY instanceof YXmlText && leftP instanceof Array) {
          if (!equalYTextPText(leftY, leftP)) {
            updateYText(leftY, leftP, meta2);
          }
          left += 1;
        } else {
          let updateLeft = leftY instanceof YXmlElement && matchNodeName(leftY, leftP);
          let updateRight = rightY instanceof YXmlElement && matchNodeName(rightY, rightP);
          if (updateLeft && updateRight) {
            const equalityLeft = computeChildEqualityFactor(
              /** @type {Y.XmlElement} */
              leftY,
              /** @type {PModel.Node} */
              leftP,
              meta2
            );
            const equalityRight = computeChildEqualityFactor(
              /** @type {Y.XmlElement} */
              rightY,
              /** @type {PModel.Node} */
              rightP,
              meta2
            );
            if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {
              updateRight = false;
            } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {
              updateLeft = false;
            } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {
              updateLeft = false;
            } else {
              updateRight = false;
            }
          }
          if (updateLeft) {
            updateYFragment(
              y,
              /** @type {Y.XmlFragment} */
              leftY,
              /** @type {PModel.Node} */
              leftP,
              meta2
            );
            left += 1;
          } else if (updateRight) {
            updateYFragment(
              y,
              /** @type {Y.XmlFragment} */
              rightY,
              /** @type {PModel.Node} */
              rightP,
              meta2
            );
            right += 1;
          } else {
            meta2.mapping.delete(yDomFragment.get(left));
            yDomFragment.delete(left, 1);
            yDomFragment.insert(left, [
              createTypeFromTextOrElementNode(leftP, meta2)
            ]);
            left += 1;
          }
        }
      }
      const yDelLen = yChildCnt - left - right;
      if (yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof YXmlText) {
        meta2.mapping.delete(yChildren[0]);
        yChildren[0].delete(0, yChildren[0].length);
      } else if (yDelLen > 0) {
        yDomFragment.slice(left, left + yDelLen).forEach((type) => meta2.mapping.delete(type));
        yDomFragment.delete(left, yDelLen);
      }
      if (left + right < pChildCnt) {
        const ins = [];
        for (let i = left; i < pChildCnt - right; i++) {
          ins.push(createTypeFromTextOrElementNode(pChildren[i], meta2));
        }
        yDomFragment.insert(left, ins);
      }
    }, ySyncPluginKey);
  };
  var matchNodeName = (yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name;

  // node_modules/y-prosemirror/src/lib.js
  var viewsToUpdate = null;
  var updateMetas = () => {
    const ups = (
      /** @type {Map<EditorView, Map<any, any>>} */
      viewsToUpdate
    );
    viewsToUpdate = null;
    ups.forEach((metas, view) => {
      const tr3 = view.state.tr;
      const syncState = ySyncPluginKey.getState(view.state);
      if (syncState && syncState.binding && !syncState.binding.isDestroyed) {
        metas.forEach((val, key2) => {
          tr3.setMeta(key2, val);
        });
        view.dispatch(tr3);
      }
    });
  };
  var setMeta2 = (view, key2, value) => {
    if (!viewsToUpdate) {
      viewsToUpdate = /* @__PURE__ */ new Map();
      timeout(0, updateMetas);
    }
    setIfUndefined(viewsToUpdate, view, create5).set(key2, value);
  };
  var absolutePositionToRelativePosition = (pos, type, mapping) => {
    if (pos === 0) {
      return createRelativePositionFromTypeIndex(type, 0, -1);
    }
    let n = type._first === null ? null : (
      /** @type {Y.ContentType} */
      type._first.content.type
    );
    while (n !== null && type !== n) {
      if (n instanceof YXmlText) {
        if (n._length >= pos) {
          return createRelativePositionFromTypeIndex(n, pos, -1);
        } else {
          pos -= n._length;
        }
        if (n._item !== null && n._item.next !== null) {
          n = /** @type {Y.ContentType} */
          n._item.next.content.type;
        } else {
          do {
            n = n._item === null ? null : n._item.parent;
            pos--;
          } while (n !== type && n !== null && n._item !== null && n._item.next === null);
          if (n !== null && n !== type) {
            n = n._item === null ? null : (
              /** @type {Y.ContentType} */
              /** @type Y.Item */
              n._item.next.content.type
            );
          }
        }
      } else {
        const pNodeSize = (
          /** @type {any} */
          (mapping.get(n) || { nodeSize: 0 }).nodeSize
        );
        if (n._first !== null && pos < pNodeSize) {
          n = /** @type {Y.ContentType} */
          n._first.content.type;
          pos--;
        } else {
          if (pos === 1 && n._length === 0 && pNodeSize > 1) {
            return new RelativePosition(n._item === null ? null : n._item.id, n._item === null ? findRootTypeKey(n) : null, null);
          }
          pos -= pNodeSize;
          if (n._item !== null && n._item.next !== null) {
            n = /** @type {Y.ContentType} */
            n._item.next.content.type;
          } else {
            if (pos === 0) {
              n = n._item === null ? n : n._item.parent;
              return new RelativePosition(n._item === null ? null : n._item.id, n._item === null ? findRootTypeKey(n) : null, null);
            }
            do {
              n = /** @type {Y.Item} */
              n._item.parent;
              pos--;
            } while (n !== type && /** @type {Y.Item} */
            n._item.next === null);
            if (n !== type) {
              n = /** @type {Y.ContentType} */
              /** @type {Y.Item} */
              /** @type {Y.Item} */
              n._item.next.content.type;
            }
          }
        }
      }
      if (n === null) {
        throw unexpectedCase();
      }
      if (pos === 0 && n.constructor !== YXmlText && n !== type) {
        return createRelativePosition2(n._item.parent, n._item);
      }
    }
    return createRelativePositionFromTypeIndex(type, type._length, -1);
  };
  var createRelativePosition2 = (type, item) => {
    let typeid = null;
    let tname = null;
    if (type._item === null) {
      tname = findRootTypeKey(type);
    } else {
      typeid = createID(type._item.id.client, type._item.id.clock);
    }
    return new RelativePosition(typeid, tname, item.id);
  };
  var relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {
    const decodedPos = createAbsolutePositionFromRelativePosition(relPos, y);
    if (decodedPos === null || decodedPos.type !== documentType && !isParentOf2(documentType, decodedPos.type._item)) {
      return null;
    }
    let type = decodedPos.type;
    let pos = 0;
    if (type.constructor === YXmlText) {
      pos = decodedPos.index;
    } else if (type._item === null || !type._item.deleted) {
      let n = type._first;
      let i = 0;
      while (i < type._length && i < decodedPos.index && n !== null) {
        if (!n.deleted) {
          const t2 = (
            /** @type {Y.ContentType} */
            n.content.type
          );
          i++;
          if (t2 instanceof YXmlText) {
            pos += t2._length;
          } else {
            pos += /** @type {any} */
            mapping.get(t2).nodeSize;
          }
        }
        n = /** @type {Y.Item} */
        n.right;
      }
      pos += 1;
    }
    while (type !== documentType && type._item !== null) {
      const parent = type._item.parent;
      if (parent._item === null || !parent._item.deleted) {
        pos += 1;
        let n = (
          /** @type {Y.AbstractType} */
          parent._first
        );
        while (n !== null) {
          const contentType = (
            /** @type {Y.ContentType} */
            n.content.type
          );
          if (contentType === type) {
            break;
          }
          if (!n.deleted) {
            if (contentType instanceof YXmlText) {
              pos += contentType._length;
            } else {
              pos += /** @type {any} */
              mapping.get(contentType).nodeSize;
            }
          }
          n = n.right;
        }
      }
      type = /** @type {Y.AbstractType} */
      parent;
    }
    return pos - 1;
  };
  var yXmlFragmentToProseMirrorFragment = (yXmlFragment, schema) => {
    const fragmentContent = yXmlFragment.toArray().map(
      (t2) => createNodeFromYElement(
        /** @type {Y.XmlElement} */
        t2,
        schema,
        createEmptyMeta()
      )
    ).filter((n) => n !== null);
    return Fragment.fromArray(fragmentContent);
  };
  var yXmlFragmentToProseMirrorRootNode = (yXmlFragment, schema) => schema.topNodeType.create(null, yXmlFragmentToProseMirrorFragment(yXmlFragment, schema));
  var initProseMirrorDoc = (yXmlFragment, schema) => {
    const meta2 = createEmptyMeta();
    const fragmentContent = yXmlFragment.toArray().map(
      (t2) => createNodeFromYElement(
        /** @type {Y.XmlElement} */
        t2,
        schema,
        meta2
      )
    ).filter((n) => n !== null);
    const doc4 = schema.topNodeType.create(null, Fragment.fromArray(fragmentContent));
    return { doc: doc4, meta: meta2, mapping: meta2.mapping };
  };
  function prosemirrorToYDoc(doc4, xmlFragment = "prosemirror") {
    const ydoc = new Doc();
    const type = (
      /** @type {Y.XmlFragment} */
      ydoc.get(xmlFragment, YXmlFragment)
    );
    if (!type.doc) {
      return ydoc;
    }
    prosemirrorToYXmlFragment(doc4, type);
    return type.doc;
  }
  function prosemirrorToYXmlFragment(doc4, xmlFragment) {
    const type = xmlFragment || new YXmlFragment();
    const ydoc = type.doc ? type.doc : { transact: (transaction) => transaction(void 0) };
    updateYFragment(ydoc, type, doc4, { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() });
    return type;
  }
  function prosemirrorJSONToYDoc(schema, state, xmlFragment = "prosemirror") {
    const doc4 = Node2.fromJSON(schema, state);
    return prosemirrorToYDoc(doc4, xmlFragment);
  }
  function prosemirrorJSONToYXmlFragment(schema, state, xmlFragment) {
    const doc4 = Node2.fromJSON(schema, state);
    return prosemirrorToYXmlFragment(doc4, xmlFragment);
  }
  function yDocToProsemirror(schema, ydoc) {
    const state = yDocToProsemirrorJSON(ydoc);
    return Node2.fromJSON(schema, state);
  }
  function yXmlFragmentToProsemirror(schema, xmlFragment) {
    const state = yXmlFragmentToProsemirrorJSON(xmlFragment);
    return Node2.fromJSON(schema, state);
  }
  function yDocToProsemirrorJSON(ydoc, xmlFragment = "prosemirror") {
    return yXmlFragmentToProsemirrorJSON(ydoc.getXmlFragment(xmlFragment));
  }
  function yXmlFragmentToProsemirrorJSON(xmlFragment) {
    const items = xmlFragment.toArray();
    const serialize4 = (item) => {
      let response;
      if (item instanceof YXmlText) {
        const delta = item.toDelta();
        response = delta.map(
          /** @param {any} d */
          (d) => {
            const text10 = {
              type: "text",
              text: d.insert
            };
            if (d.attributes) {
              text10.marks = Object.keys(d.attributes).map((type_) => {
                const attrs = d.attributes[type_];
                const type = yattr2markname(type_);
                const mark2 = {
                  type
                };
                if (Object.keys(attrs)) {
                  mark2.attrs = attrs;
                }
                return mark2;
              });
            }
            return text10;
          }
        );
      } else if (item instanceof YXmlElement) {
        response = {
          type: item.nodeName
        };
        const attrs = item.getAttributes();
        if (Object.keys(attrs).length) {
          response.attrs = attrs;
        }
        const children = item.toArray();
        if (children.length) {
          response.content = children.map(serialize4).flat();
        }
      } else {
        unexpectedCase();
      }
      return response;
    };
    return {
      type: "doc",
      content: items.map(serialize4)
    };
  }

  // node_modules/y-prosemirror/src/plugins/cursor-plugin.js
  var defaultAwarenessStateFilter = (currentClientId, userClientId, _user) => currentClientId !== userClientId;
  var defaultCursorBuilder = (user) => {
    const cursor = document.createElement("span");
    cursor.classList.add("ProseMirror-yjs-cursor");
    cursor.setAttribute("style", `border-color: ${user.color}`);
    const userDiv = document.createElement("div");
    userDiv.setAttribute("style", `background-color: ${user.color}`);
    userDiv.insertBefore(document.createTextNode(user.name), null);
    const nonbreakingSpace1 = document.createTextNode("\u2060");
    const nonbreakingSpace2 = document.createTextNode("\u2060");
    cursor.insertBefore(nonbreakingSpace1, null);
    cursor.insertBefore(userDiv, null);
    cursor.insertBefore(nonbreakingSpace2, null);
    return cursor;
  };
  var defaultSelectionBuilder = (user) => {
    return {
      style: `background-color: ${user.color}70`,
      class: "ProseMirror-yjs-selection"
    };
  };
  var rxValidColor = /^#[0-9a-fA-F]{6}$/;
  var createDecorations = (state, awareness, awarenessFilter, createCursor, createSelection) => {
    const ystate = ySyncPluginKey.getState(state);
    const y = ystate.doc;
    const decorations = [];
    if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding.mapping.size === 0) {
      return DecorationSet.create(state.doc, []);
    }
    awareness.getStates().forEach((aw, clientId) => {
      if (!awarenessFilter(y.clientID, clientId, aw)) {
        return;
      }
      if (aw.cursor != null) {
        const user = aw.user || {};
        if (user.color == null) {
          user.color = "#ffa500";
        } else if (!rxValidColor.test(user.color)) {
          console.warn("A user uses an unsupported color format", user);
        }
        if (user.name == null) {
          user.name = `User: ${clientId}`;
        }
        let anchor = relativePositionToAbsolutePosition(
          y,
          ystate.type,
          createRelativePositionFromJSON(aw.cursor.anchor),
          ystate.binding.mapping
        );
        let head2 = relativePositionToAbsolutePosition(
          y,
          ystate.type,
          createRelativePositionFromJSON(aw.cursor.head),
          ystate.binding.mapping
        );
        if (anchor !== null && head2 !== null) {
          const maxsize = max(state.doc.content.size - 1, 0);
          anchor = min(anchor, maxsize);
          head2 = min(head2, maxsize);
          decorations.push(
            Decoration.widget(head2, () => createCursor(user, clientId), {
              key: clientId + "",
              side: 10
            })
          );
          const from4 = min(anchor, head2);
          const to2 = max(anchor, head2);
          decorations.push(
            Decoration.inline(from4, to2, createSelection(user, clientId), {
              inclusiveEnd: true,
              inclusiveStart: false
            })
          );
        }
      }
    });
    return DecorationSet.create(state.doc, decorations);
  };
  var yCursorPlugin = (awareness, {
    awarenessStateFilter = defaultAwarenessStateFilter,
    cursorBuilder = defaultCursorBuilder,
    selectionBuilder = defaultSelectionBuilder,
    getSelection: getSelection2 = (state) => state.selection
  } = {}, cursorStateField = "cursor") => new Plugin({
    key: yCursorPluginKey,
    state: {
      init(_2, state) {
        return createDecorations(
          state,
          awareness,
          awarenessStateFilter,
          cursorBuilder,
          selectionBuilder
        );
      },
      apply(tr3, prevState, _oldState, newState) {
        const ystate = ySyncPluginKey.getState(newState);
        const yCursorState = tr3.getMeta(yCursorPluginKey);
        if (ystate && ystate.isChangeOrigin || yCursorState && yCursorState.awarenessUpdated) {
          return createDecorations(
            newState,
            awareness,
            awarenessStateFilter,
            cursorBuilder,
            selectionBuilder
          );
        }
        return prevState.map(tr3.mapping, tr3.doc);
      }
    },
    props: {
      decorations: (state) => {
        return yCursorPluginKey.getState(state);
      }
    },
    view: (view) => {
      const awarenessListener = () => {
        if (view.docView) {
          setMeta2(view, yCursorPluginKey, { awarenessUpdated: true });
        }
      };
      const updateCursorInfo = () => {
        const ystate = ySyncPluginKey.getState(view.state);
        const current = awareness.getLocalState() || {};
        if (view.hasFocus()) {
          const selection = getSelection2(view.state);
          const anchor = absolutePositionToRelativePosition(
            selection.anchor,
            ystate.type,
            ystate.binding.mapping
          );
          const head2 = absolutePositionToRelativePosition(
            selection.head,
            ystate.type,
            ystate.binding.mapping
          );
          if (current.cursor == null || !compareRelativePositions(
            createRelativePositionFromJSON(current.cursor.anchor),
            anchor
          ) || !compareRelativePositions(
            createRelativePositionFromJSON(current.cursor.head),
            head2
          )) {
            awareness.setLocalStateField(cursorStateField, {
              anchor,
              head: head2
            });
          }
        } else if (current.cursor != null && relativePositionToAbsolutePosition(
          ystate.doc,
          ystate.type,
          createRelativePositionFromJSON(current.cursor.anchor),
          ystate.binding.mapping
        ) !== null) {
          awareness.setLocalStateField(cursorStateField, null);
        }
      };
      awareness.on("change", awarenessListener);
      view.dom.addEventListener("focusin", updateCursorInfo);
      view.dom.addEventListener("focusout", updateCursorInfo);
      return {
        update: updateCursorInfo,
        destroy: () => {
          view.dom.removeEventListener("focusin", updateCursorInfo);
          view.dom.removeEventListener("focusout", updateCursorInfo);
          awareness.off("change", awarenessListener);
          awareness.setLocalStateField(cursorStateField, null);
        }
      };
    }
  });

  // node_modules/y-prosemirror/src/plugins/undo-plugin.js
  var undo2 = (state) => yUndoPluginKey.getState(state)?.undoManager?.undo() != null;
  var redo2 = (state) => yUndoPluginKey.getState(state)?.undoManager?.redo() != null;
  var undoCommand = (state, dispatch) => dispatch == null ? yUndoPluginKey.getState(state)?.undoManager?.canUndo() : undo2(state);
  var redoCommand = (state, dispatch) => dispatch == null ? yUndoPluginKey.getState(state)?.undoManager?.canRedo() : redo2(state);
  var defaultProtectedNodes = /* @__PURE__ */ new Set(["paragraph"]);
  var defaultDeleteFilter = (item, protectedNodes) => !(item instanceof Item2) || !(item.content instanceof ContentType) || !(item.content.type instanceof YText || item.content.type instanceof YXmlElement && protectedNodes.has(item.content.type.nodeName)) || item.content.type._length === 0;
  var yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new Plugin({
    key: yUndoPluginKey,
    state: {
      init: (initargs, state) => {
        const ystate = ySyncPluginKey.getState(state);
        const _undoManager = undoManager || new UndoManager(ystate.type, {
          trackedOrigins: new Set([ySyncPluginKey].concat(trackedOrigins)),
          deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes),
          captureTransaction: (tr3) => tr3.meta.get("addToHistory") !== false
        });
        return {
          undoManager: _undoManager,
          prevSel: null,
          hasUndoOps: _undoManager.undoStack.length > 0,
          hasRedoOps: _undoManager.redoStack.length > 0
        };
      },
      apply: (tr3, val, oldState, state) => {
        const binding = ySyncPluginKey.getState(state).binding;
        const undoManager2 = val.undoManager;
        const hasUndoOps = undoManager2.undoStack.length > 0;
        const hasRedoOps = undoManager2.redoStack.length > 0;
        if (binding) {
          return {
            undoManager: undoManager2,
            prevSel: getRelativeSelection(binding, oldState),
            hasUndoOps,
            hasRedoOps
          };
        } else {
          if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {
            return Object.assign({}, val, {
              hasUndoOps: undoManager2.undoStack.length > 0,
              hasRedoOps: undoManager2.redoStack.length > 0
            });
          } else {
            return val;
          }
        }
      }
    },
    view: (view) => {
      const ystate = ySyncPluginKey.getState(view.state);
      const undoManager2 = yUndoPluginKey.getState(view.state).undoManager;
      undoManager2.on("stack-item-added", ({ stackItem }) => {
        const binding = ystate.binding;
        if (binding) {
          stackItem.meta.set(binding, yUndoPluginKey.getState(view.state).prevSel);
        }
      });
      undoManager2.on("stack-item-popped", ({ stackItem }) => {
        const binding = ystate.binding;
        if (binding) {
          binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection;
        }
      });
      return {
        destroy: () => {
          undoManager2.destroy();
        }
      };
    }
  });

  // node_modules/prosemirror-dropcursor/dist/index.js
  function dropCursor(options2 = {}) {
    return new Plugin({
      view(editorView) {
        return new DropCursorView(editorView, options2);
      }
    });
  }
  var DropCursorView = class {
    constructor(editorView, options2) {
      var _a3;
      this.editorView = editorView;
      this.cursorPos = null;
      this.element = null;
      this.timeout = -1;
      this.width = (_a3 = options2.width) !== null && _a3 !== void 0 ? _a3 : 1;
      this.color = options2.color === false ? void 0 : options2.color || "black";
      this.class = options2.class;
      this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
        let handler = (e) => {
          this[name](e);
        };
        editorView.dom.addEventListener(name, handler);
        return { name, handler };
      });
    }
    destroy() {
      this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
    }
    update(editorView, prevState) {
      if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
        if (this.cursorPos > editorView.state.doc.content.size)
          this.setCursor(null);
        else
          this.updateOverlay();
      }
    }
    setCursor(pos) {
      if (pos == this.cursorPos)
        return;
      this.cursorPos = pos;
      if (pos == null) {
        this.element.parentNode.removeChild(this.element);
        this.element = null;
      } else {
        this.updateOverlay();
      }
    }
    updateOverlay() {
      let $pos = this.editorView.state.doc.resolve(this.cursorPos);
      let isBlock = !$pos.parent.inlineContent, rect;
      let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
      let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
      if (isBlock) {
        let before = $pos.nodeBefore, after = $pos.nodeAfter;
        if (before || after) {
          let node2 = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
          if (node2) {
            let nodeRect = node2.getBoundingClientRect();
            let top = before ? nodeRect.bottom : nodeRect.top;
            if (before && after)
              top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
            let halfWidth = this.width / 2 * scaleY;
            rect = { left: nodeRect.left, right: nodeRect.right, top: top - halfWidth, bottom: top + halfWidth };
          }
        }
      }
      if (!rect) {
        let coords = this.editorView.coordsAtPos(this.cursorPos);
        let halfWidth = this.width / 2 * scaleX;
        rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
      }
      let parent = this.editorView.dom.offsetParent;
      if (!this.element) {
        this.element = parent.appendChild(document.createElement("div"));
        if (this.class)
          this.element.className = this.class;
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
        if (this.color) {
          this.element.style.backgroundColor = this.color;
        }
      }
      this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
      this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
      let parentLeft, parentTop;
      if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
        parentLeft = -pageXOffset;
        parentTop = -pageYOffset;
      } else {
        let rect2 = parent.getBoundingClientRect();
        let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
        parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
        parentTop = rect2.top - parent.scrollTop * parentScaleY;
      }
      this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
      this.element.style.top = (rect.top - parentTop) / scaleY + "px";
      this.element.style.width = (rect.right - rect.left) / scaleX + "px";
      this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
    }
    scheduleRemoval(timeout2) {
      clearTimeout(this.timeout);
      this.timeout = setTimeout(() => this.setCursor(null), timeout2);
    }
    dragover(event) {
      if (!this.editorView.editable)
        return;
      let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
      let node2 = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
      let disableDropCursor = node2 && node2.type.spec.disableDropCursor;
      let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
      if (pos && !disabled) {
        let target = pos.pos;
        if (this.editorView.dragging && this.editorView.dragging.slice) {
          let point5 = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
          if (point5 != null)
            target = point5;
        }
        this.setCursor(target);
        this.scheduleRemoval(5e3);
      }
    }
    dragend() {
      this.scheduleRemoval(20);
    }
    drop() {
      this.scheduleRemoval(20);
    }
    dragleave(event) {
      if (!this.editorView.dom.contains(event.relatedTarget))
        this.setCursor(null);
    }
  };

  // node_modules/@blocknote/core/dist/en-qGo6sk9V.js
  var t = {
    slash_menu: {
      heading: {
        title: "Heading 1",
        subtext: "Top-level heading",
        aliases: ["h", "heading1", "h1"],
        group: "Headings"
      },
      heading_2: {
        title: "Heading 2",
        subtext: "Key section heading",
        aliases: ["h2", "heading2", "subheading"],
        group: "Headings"
      },
      heading_3: {
        title: "Heading 3",
        subtext: "Subsection and group heading",
        aliases: ["h3", "heading3", "subheading"],
        group: "Headings"
      },
      quote: {
        title: "Quote",
        subtext: "Quote or excerpt",
        aliases: ["quotation", "blockquote", "bq"],
        group: "Basic blocks"
      },
      numbered_list: {
        title: "Numbered List",
        subtext: "List with ordered items",
        aliases: ["ol", "li", "list", "numberedlist", "numbered list"],
        group: "Basic blocks"
      },
      bullet_list: {
        title: "Bullet List",
        subtext: "List with unordered items",
        aliases: ["ul", "li", "list", "bulletlist", "bullet list"],
        group: "Basic blocks"
      },
      check_list: {
        title: "Check List",
        subtext: "List with checkboxes",
        aliases: [
          "ul",
          "li",
          "list",
          "checklist",
          "check list",
          "checked list",
          "checkbox"
        ],
        group: "Basic blocks"
      },
      paragraph: {
        title: "Paragraph",
        subtext: "The body of your document",
        aliases: ["p", "paragraph"],
        group: "Basic blocks"
      },
      code_block: {
        title: "Code Block",
        subtext: "Code block with syntax highlighting",
        aliases: ["code", "pre"],
        group: "Basic blocks"
      },
      page_break: {
        title: "Page Break",
        subtext: "Page separator",
        aliases: ["page", "break", "separator"],
        group: "Basic blocks"
      },
      table: {
        title: "Table",
        subtext: "Table with editable cells",
        aliases: ["table"],
        group: "Advanced"
      },
      image: {
        title: "Image",
        subtext: "Resizable image with caption",
        aliases: [
          "image",
          "imageUpload",
          "upload",
          "img",
          "picture",
          "media",
          "url"
        ],
        group: "Media"
      },
      video: {
        title: "Video",
        subtext: "Resizable video with caption",
        aliases: [
          "video",
          "videoUpload",
          "upload",
          "mp4",
          "film",
          "media",
          "url"
        ],
        group: "Media"
      },
      audio: {
        title: "Audio",
        subtext: "Embedded audio with caption",
        aliases: [
          "audio",
          "audioUpload",
          "upload",
          "mp3",
          "sound",
          "media",
          "url"
        ],
        group: "Media"
      },
      file: {
        title: "File",
        subtext: "Embedded file",
        aliases: ["file", "upload", "embed", "media", "url"],
        group: "Media"
      },
      emoji: {
        title: "Emoji",
        subtext: "Search for and insert an emoji",
        aliases: ["emoji", "emote", "emotion", "face"],
        group: "Others"
      }
    },
    placeholders: {
      default: "Enter text or type '/' for commands",
      heading: "Heading",
      bulletListItem: "List",
      numberedListItem: "List",
      checkListItem: "List",
      emptyDocument: void 0,
      new_comment: "Write a comment...",
      edit_comment: "Edit comment...",
      comment_reply: "Add comment..."
    },
    file_blocks: {
      image: {
        add_button_text: "Add image"
      },
      video: {
        add_button_text: "Add video"
      },
      audio: {
        add_button_text: "Add audio"
      },
      file: {
        add_button_text: "Add file"
      }
    },
    // from react package:
    side_menu: {
      add_block_label: "Add block",
      drag_handle_label: "Open block menu"
    },
    drag_handle: {
      delete_menuitem: "Delete",
      colors_menuitem: "Colors",
      header_row_menuitem: "Header row",
      header_column_menuitem: "Header column"
    },
    table_handle: {
      delete_column_menuitem: "Delete column",
      delete_row_menuitem: "Delete row",
      add_left_menuitem: "Add column left",
      add_right_menuitem: "Add column right",
      add_above_menuitem: "Add row above",
      add_below_menuitem: "Add row below",
      split_cell_menuitem: "Split cell",
      merge_cells_menuitem: "Merge cells",
      background_color_menuitem: "Background color"
    },
    suggestion_menu: {
      no_items_title: "No items found"
    },
    color_picker: {
      text_title: "Text",
      background_title: "Background",
      colors: {
        default: "Default",
        gray: "Gray",
        brown: "Brown",
        red: "Red",
        orange: "Orange",
        yellow: "Yellow",
        green: "Green",
        blue: "Blue",
        purple: "Purple",
        pink: "Pink"
      }
    },
    formatting_toolbar: {
      bold: {
        tooltip: "Bold",
        secondary_tooltip: "Mod+B"
      },
      italic: {
        tooltip: "Italic",
        secondary_tooltip: "Mod+I"
      },
      underline: {
        tooltip: "Underline",
        secondary_tooltip: "Mod+U"
      },
      strike: {
        tooltip: "Strike",
        secondary_tooltip: "Mod+Shift+S"
      },
      code: {
        tooltip: "Code",
        secondary_tooltip: ""
      },
      colors: {
        tooltip: "Colors"
      },
      link: {
        tooltip: "Create link",
        secondary_tooltip: "Mod+K"
      },
      file_caption: {
        tooltip: "Edit caption",
        input_placeholder: "Edit caption"
      },
      file_replace: {
        tooltip: {
          image: "Replace image",
          video: "Replace video",
          audio: "Replace audio",
          file: "Replace file"
        }
      },
      file_rename: {
        tooltip: {
          image: "Rename image",
          video: "Rename video",
          audio: "Rename audio",
          file: "Rename file"
        },
        input_placeholder: {
          image: "Rename image",
          video: "Rename video",
          audio: "Rename audio",
          file: "Rename file"
        }
      },
      file_download: {
        tooltip: {
          image: "Download image",
          video: "Download video",
          audio: "Download audio",
          file: "Download file"
        }
      },
      file_delete: {
        tooltip: {
          image: "Delete image",
          video: "Delete video",
          audio: "Delete audio",
          file: "Delete file"
        }
      },
      file_preview_toggle: {
        tooltip: "Toggle preview"
      },
      nest: {
        tooltip: "Nest block",
        secondary_tooltip: "Tab"
      },
      unnest: {
        tooltip: "Unnest block",
        secondary_tooltip: "Shift+Tab"
      },
      align_left: {
        tooltip: "Align text left"
      },
      align_center: {
        tooltip: "Align text center"
      },
      align_right: {
        tooltip: "Align text right"
      },
      align_justify: {
        tooltip: "Justify text"
      },
      table_cell_merge: {
        tooltip: "Merge cells"
      },
      comment: {
        tooltip: "Add comment"
      }
    },
    file_panel: {
      upload: {
        title: "Upload",
        file_placeholder: {
          image: "Upload image",
          video: "Upload video",
          audio: "Upload audio",
          file: "Upload file"
        },
        upload_error: "Error: Upload failed"
      },
      embed: {
        title: "Embed",
        embed_button: {
          image: "Embed image",
          video: "Embed video",
          audio: "Embed audio",
          file: "Embed file"
        },
        url_placeholder: "Enter URL"
      }
    },
    link_toolbar: {
      delete: {
        tooltip: "Remove link"
      },
      edit: {
        text: "Edit link",
        tooltip: "Edit"
      },
      open: {
        tooltip: "Open in new tab"
      },
      form: {
        title_placeholder: "Edit title",
        url_placeholder: "Edit URL"
      }
    },
    comments: {
      actions: {
        add_reaction: "Add reaction",
        resolve: "Resolve",
        edit_comment: "Edit comment",
        delete_comment: "Delete comment",
        more_actions: "More actions"
      },
      reactions: {
        reacted_by: "Reacted by"
      },
      sidebar: {
        marked_as_resolved: "Marked as resolved",
        more_replies: (e) => `${e} more replies`
      }
    },
    generic: {
      ctrl_shortcut: "Ctrl"
    }
  };

  // node_modules/@blocknote/core/dist/blocknote.js
  var so = Object.defineProperty;
  var io = (e, n, t2) => n in e ? so(e, n, { enumerable: true, configurable: true, writable: true, value: t2 }) : e[n] = t2;
  var p4 = (e, n, t2) => io(e, typeof n != "symbol" ? n + "" : n, t2);
  function or(e, n = JSON.stringify) {
    const t2 = {};
    return e.filter((o) => {
      const r = n(o);
      return Object.prototype.hasOwnProperty.call(t2, r) ? false : t2[r] = true;
    });
  }
  function rr(e) {
    const n = e.filter(
      (o, r) => e.indexOf(o) !== r
    );
    return or(n);
  }
  var We = Extension.create({
    name: "uniqueID",
    // well set a very high priority to make sure this runs first
    // and is compatible with `appendTransaction` hooks of other extensions
    priority: 1e4,
    addOptions() {
      return {
        attributeName: "id",
        types: [],
        setIdAttribute: false,
        generateID: () => {
          if (typeof window < "u" && window.__TEST_OPTIONS) {
            const e = window.__TEST_OPTIONS;
            return e.mockID === void 0 ? e.mockID = 0 : e.mockID++, e.mockID.toString();
          }
          return v4_default();
        },
        filterTransaction: null
      };
    },
    addGlobalAttributes() {
      return [
        {
          types: this.options.types,
          attributes: {
            [this.options.attributeName]: {
              default: null,
              parseHTML: (e) => e.getAttribute(`data-${this.options.attributeName}`),
              renderHTML: (e) => {
                const n = {
                  [`data-${this.options.attributeName}`]: e[this.options.attributeName]
                };
                return this.options.setIdAttribute ? {
                  ...n,
                  id: e[this.options.attributeName]
                } : n;
              }
            }
          }
        }
      ];
    },
    // check initial content for missing ids
    // onCreate() {
    //   // Dont do this when the collaboration extension is active
    //   // because this may update the content, so Y.js tries to merge these changes.
    //   // This leads to empty block nodes.
    //   // See: https://github.com/ueberdosis/tiptap/issues/2400
    //   if (
    //     this.editor.extensionManager.extensions.find(
    //       (extension) => extension.name === "collaboration"
    //     )
    //   ) {
    //     return;
    //   }
    //   const { view, state } = this.editor;
    //   const { tr, doc } = state;
    //   const { types, attributeName, generateID } = this.options;
    //   const nodesWithoutId = findChildren(doc, (node) => {
    //     return (
    //       types.includes(node.type.name) && node.attrs[attributeName] === null
    //     );
    //   });
    //   nodesWithoutId.forEach(({ node, pos }) => {
    //     tr.setNodeMarkup(pos, undefined, {
    //       ...node.attrs,
    //       [attributeName]: generateID(),
    //     });
    //   });
    //   tr.setMeta("addToHistory", false);
    //   view.dispatch(tr);
    // },
    addProseMirrorPlugins() {
      let e = null, n = false;
      return [
        new Plugin({
          key: new PluginKey("uniqueID"),
          appendTransaction: (t2, o, r) => {
            const s2 = t2.some((m) => m.docChanged) && !o.doc.eq(r.doc), i = this.options.filterTransaction && t2.some((m) => {
              let g, b;
              return !(!((b = (g = this.options).filterTransaction) === null || b === void 0) && b.call(g, m));
            });
            if (!s2 || i)
              return;
            const { tr: a2 } = r, { types: c, attributeName: l, generateID: d } = this.options, u = combineTransactionSteps(
              o.doc,
              t2
            ), { mapping: h2 } = u;
            if (getChangedRanges(u).forEach(({ newRange: m }) => {
              const g = findChildrenInRange(
                r.doc,
                m,
                (w) => c.includes(w.type.name)
              ), b = g.map(({ node: w }) => w.attrs[l]).filter((w) => w !== null), k = rr(b);
              g.forEach(({ node: w, pos: C }) => {
                let B;
                const P = (B = a2.doc.nodeAt(C)) === null || B === void 0 ? void 0 : B.attrs[l];
                if (P === null) {
                  const y = o.doc.type.createAndFill().content;
                  if (o.doc.content.findDiffStart(y) === null) {
                    const se = JSON.parse(
                      JSON.stringify(r.doc.toJSON())
                    );
                    if (se.content[0].content[0].attrs.id = "initialBlockId", JSON.stringify(se.content) === JSON.stringify(y.toJSON())) {
                      a2.setNodeMarkup(C, void 0, {
                        ...w.attrs,
                        [l]: "initialBlockId"
                      });
                      return;
                    }
                  }
                  a2.setNodeMarkup(C, void 0, {
                    ...w.attrs,
                    [l]: d()
                  });
                  return;
                }
                const { deleted: $2 } = h2.invert().mapResult(C);
                $2 && k.includes(P) && a2.setNodeMarkup(C, void 0, {
                  ...w.attrs,
                  [l]: d()
                });
              });
            }), !!a2.steps.length)
              return a2;
          },
          // we register a global drag handler to track the current drag source element
          view(t2) {
            const o = (r) => {
              let s2;
              e = !((s2 = t2.dom.parentElement) === null || s2 === void 0) && s2.contains(r.target) ? t2.dom.parentElement : null;
            };
            return window.addEventListener("dragstart", o), {
              destroy() {
                window.removeEventListener("dragstart", o);
              }
            };
          },
          props: {
            // `handleDOMEvents` is called before `transformPasted` so we can do
            // some checks before. However, `transformPasted` only runs when
            // editor content is pasted - not external content.
            handleDOMEvents: {
              // only create new ids for dropped content while holding `alt`
              // or content is dragged from another editor
              drop: (t2, o) => {
                let r;
                return e !== t2.dom.parentElement || ((r = o.dataTransfer) === null || r === void 0 ? void 0 : r.effectAllowed) === "copy" ? n = true : n = false, e = null, false;
              },
              // always create new ids on pasted content
              paste: () => (n = true, false)
            },
            // well remove ids for every pasted node
            // so we can create a new one within `appendTransaction`
            transformPasted: (t2) => {
              if (!n)
                return t2;
              const { types: o, attributeName: r } = this.options, s2 = (i) => {
                const a2 = [];
                return i.forEach((c) => {
                  if (c.isText) {
                    a2.push(c);
                    return;
                  }
                  if (!o.includes(c.type.name)) {
                    a2.push(c.copy(s2(c.content)));
                    return;
                  }
                  const l = c.type.create(
                    {
                      ...c.attrs,
                      [r]: null
                    },
                    s2(c.content),
                    c.marks
                  );
                  a2.push(l);
                }), Fragment.from(a2);
              };
              return n = false, new Slice(
                s2(t2.content),
                t2.openStart,
                t2.openEnd
              );
            }
          }
        })
      ];
    }
  });
  function Ot(e) {
    return e.type === "link";
  }
  function hn(e) {
    return typeof e != "string" && e.type === "link";
  }
  function de(e) {
    return typeof e != "string" && e.type === "text";
  }
  function rt(e) {
    var n, t2, o, r, s2;
    return bt(e) ? { ...e } : Ce(e) ? {
      type: "tableCell",
      content: [].concat(e.content),
      props: {
        backgroundColor: ((n = e.props) == null ? void 0 : n.backgroundColor) ?? "default",
        textColor: ((t2 = e.props) == null ? void 0 : t2.textColor) ?? "default",
        textAlignment: ((o = e.props) == null ? void 0 : o.textAlignment) ?? "left",
        colspan: ((r = e.props) == null ? void 0 : r.colspan) ?? 1,
        rowspan: ((s2 = e.props) == null ? void 0 : s2.rowspan) ?? 1
      }
    } : {
      type: "tableCell",
      content: [].concat(e),
      props: {
        backgroundColor: "default",
        textColor: "default",
        textAlignment: "left",
        colspan: 1,
        rowspan: 1
      }
    };
  }
  function Ce(e) {
    return e != null && typeof e != "string" && !Array.isArray(e) && e.type === "tableCell";
  }
  function bt(e) {
    return Ce(e) && e.props !== void 0 && e.content !== void 0;
  }
  function ve(e) {
    return bt(e) ? e.props.colspan ?? 1 : 1;
  }
  function st(e) {
    return bt(e) ? e.props.rowspan ?? 1 : 1;
  }
  var j = class extends Error {
    constructor(n) {
      super(`Unreachable case: ${n}`);
    }
  };
  function xc(e, n = true) {
    const { "data-test": t2, ...o } = e;
    if (Object.keys(o).length > 0 && n)
      throw new Error("Object must be empty " + JSON.stringify(e));
  }
  var sr = () => typeof navigator < "u" && (/Mac/.test(navigator.platform) || /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent));
  function Z(e, n = "Ctrl") {
    return sr() ? e.replace("Mod", "\u2318") : e.replace("Mod", n);
  }
  function Q(...e) {
    return e.filter((n) => n).join(" ");
  }
  var Tc = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  function G(e, n, t2, o) {
    const r = document.createElement("div");
    r.className = Q(
      "bn-block-content",
      t2.class
    ), r.setAttribute("data-content-type", e);
    for (const [i, a2] of Object.entries(t2))
      i !== "class" && r.setAttribute(i, a2);
    const s2 = document.createElement(n);
    s2.className = Q(
      "bn-inline-content",
      o.class
    );
    for (const [i, a2] of Object.entries(
      o
    ))
      i !== "class" && s2.setAttribute(i, a2);
    return r.appendChild(s2), {
      dom: r,
      contentDOM: s2
    };
  }
  var Rt = (e, n) => {
    let t2 = pe(e, n.pmSchema);
    t2.type.name === "blockContainer" && (t2 = t2.firstChild);
    const o = n.pmSchema.nodes[t2.type.name].spec.toDOM;
    if (o === void 0)
      throw new Error(
        "This block has no default HTML serialization as its corresponding TipTap node doesn't implement `renderHTML`."
      );
    const r = o(t2);
    if (typeof r != "object" || !("dom" in r))
      throw new Error(
        "Cannot use this block's default HTML serialization as its corresponding TipTap node's `renderHTML` function does not return an object with the `dom` property."
      );
    return r;
  };
  function Mc(e) {
    const n = e.querySelectorAll("p");
    if (n.length > 1) {
      const t2 = n[0];
      for (let o = 1; o < n.length; o++) {
        const r = n[o];
        t2.innerHTML += "<br>" + r.innerHTML, r.remove();
      }
    }
  }
  var T = {
    backgroundColor: {
      default: "default"
    },
    textColor: {
      default: "default"
    },
    textAlignment: {
      default: "left",
      values: ["left", "center", "right", "justify"]
    }
  }, fn = ["backgroundColor", "textColor"];
  function Ve(e) {
    return "data-" + e.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }
  function Pc(e) {
    const n = e.split("/");
    return !n.length || // invalid?
    n[n.length - 1] === "" ? e : n[n.length - 1];
  }
  function Be(e) {
    const n = {};
    return Object.entries(e).filter(([t2, o]) => !fn.includes(t2)).forEach(([t2, o]) => {
      n[t2] = {
        default: o.default,
        keepOnSplit: true,
        // Props are displayed in kebab-case as HTML attributes. If a prop's
        // value is the same as its default, we don't display an HTML
        // attribute for it.
        parseHTML: (r) => {
          const s2 = r.getAttribute(Ve(t2));
          if (s2 === null)
            return null;
          if (o.default === void 0 && o.type === "boolean" || o.default !== void 0 && typeof o.default == "boolean")
            return s2 === "true" ? true : s2 === "false" ? false : null;
          if (o.default === void 0 && o.type === "number" || o.default !== void 0 && typeof o.default == "number") {
            const i = parseFloat(s2);
            return !Number.isNaN(i) && Number.isFinite(i) ? i : null;
          }
          return s2;
        },
        renderHTML: (r) => r[t2] !== o.default ? {
          [Ve(t2)]: r[t2]
        } : {}
      };
    }), n;
  }
  function ir(e, n, t2, o) {
    if (typeof e == "boolean")
      throw new Error(
        "Cannot find node position as getPos is a boolean, not a function."
      );
    const r = e(), i = t2.state.doc.resolve(r).node().attrs.id;
    if (!i)
      throw new Error("Block doesn't have id");
    const a2 = n.getBlock(i);
    if (a2.type !== o)
      throw new Error("Block type does not match");
    return a2;
  }
  function Ie(e, n, t2, o, r = false, s2) {
    const i = document.createElement("div");
    if (s2 !== void 0)
      for (const [a2, c] of Object.entries(s2))
        a2 !== "class" && i.setAttribute(a2, c);
    i.className = Q(
      "bn-block-content",
      (s2 == null ? void 0 : s2.class) || ""
    ), i.setAttribute("data-content-type", n);
    for (const [a2, c] of Object.entries(t2)) {
      const d = o[a2].default;
      !fn.includes(a2) && c !== d && i.setAttribute(Ve(a2), c);
    }
    return r && i.setAttribute("data-file-block", ""), i.appendChild(e.dom), e.contentDOM !== void 0 && (e.contentDOM.className = Q(
      "bn-inline-content",
      e.contentDOM.className
    )), {
      ...e,
      dom: i
    };
  }
  function q2(e) {
    return Node3.create(e);
  }
  function mn(e, n) {
    return {
      config: e,
      implementation: n
    };
  }
  function oe(e, n, t2) {
    return mn(
      {
        type: e.name,
        content: e.config.content === "inline*" ? "inline" : e.config.content === "tableRow+" ? "table" : "none",
        propSchema: n
      },
      {
        node: e,
        requiredExtensions: t2,
        toInternalHTML: Rt,
        toExternalHTML: Rt
        // parse: () => undefined, // parse rules are in node already
      }
    );
  }
  function gn(e) {
    return Object.fromEntries(
      Object.entries(e).map(([n, t2]) => [n, t2.config])
    );
  }
  function ar(e, n) {
    e.stopEvent = (t2) => (t2.type === "mousedown" && setTimeout(() => {
      n.view.dom.blur();
    }, 10), true);
  }
  function cr(e, n) {
    const t2 = [
      {
        tag: "[data-content-type=" + e.type + "]",
        contentElement: ".bn-inline-content"
      }
    ];
    return n && t2.push({
      tag: "*",
      getAttrs(o) {
        if (typeof o == "string")
          return false;
        const r = n == null ? void 0 : n(o);
        return r === void 0 ? false : r;
      }
    }), t2;
  }
  function xe(e, n) {
    const t2 = q2({
      name: e.type,
      content: e.content === "inline" ? "inline*" : "",
      group: "blockContent",
      selectable: e.isSelectable ?? true,
      isolating: true,
      addAttributes() {
        return Be(e.propSchema);
      },
      parseHTML() {
        return cr(e, n.parse);
      },
      renderHTML({ HTMLAttributes: o }) {
        const r = document.createElement("div");
        return Ie(
          {
            dom: r,
            contentDOM: e.content === "inline" ? r : void 0
          },
          e.type,
          {},
          e.propSchema,
          e.isFileBlock,
          o
        );
      },
      addNodeView() {
        return ({ getPos: o }) => {
          var l;
          const r = this.options.editor, s2 = ir(
            o,
            r,
            this.editor,
            e.type
          ), i = ((l = this.options.domAttributes) == null ? void 0 : l.blockContent) || {}, a2 = n.render(s2, r), c = Ie(
            a2,
            s2.type,
            s2.props,
            e.propSchema,
            i
          );
          return e.isSelectable === false && ar(c, this.editor), c;
        };
      }
    });
    if (t2.name !== e.type)
      throw new Error(
        "Node name does not match block type. This is a bug in BlockNote."
      );
    return mn(e, {
      node: t2,
      toInternalHTML: (o, r) => {
        var a2;
        const s2 = ((a2 = t2.options.domAttributes) == null ? void 0 : a2.blockContent) || {}, i = n.render(o, r);
        return Ie(
          i,
          o.type,
          o.props,
          e.propSchema,
          e.isFileBlock,
          s2
        );
      },
      // TODO: this should not have wrapInBlockStructure and generally be a lot simpler
      // post-processing in externalHTMLExporter should not be necessary
      toExternalHTML: (o, r) => {
        var a2, c;
        const s2 = ((a2 = t2.options.domAttributes) == null ? void 0 : a2.blockContent) || {};
        let i = (c = n.toExternalHTML) == null ? void 0 : c.call(
          n,
          o,
          r
        );
        return i === void 0 && (i = n.render(o, r)), Ie(
          i,
          o.type,
          o.props,
          e.propSchema,
          s2
        );
      }
    });
  }
  function X(e, n) {
    const t2 = e.resolve(n);
    if (t2.nodeAfter && t2.nodeAfter.type.isInGroup("bnBlock"))
      return {
        posBeforeNode: t2.pos,
        node: t2.nodeAfter
      };
    let o = t2.depth, r = t2.node(o);
    for (; o > 0; ) {
      if (r.type.isInGroup("bnBlock"))
        return {
          posBeforeNode: t2.before(o),
          node: r
        };
      o--, r = t2.node(o);
    }
    const s2 = [];
    e.descendants((a2, c) => {
      a2.type.isInGroup("bnBlock") && s2.push(c);
    }), console.warn(`Position ${n} is not within a blockContainer node.`);
    const i = e.resolve(
      s2.find((a2) => a2 >= n) || s2[s2.length - 1]
    );
    return {
      posBeforeNode: i.pos,
      node: i.nodeAfter
    };
  }
  function kt(e, n) {
    if (!e.type.isInGroup("bnBlock"))
      throw new Error(
        `Attempted to get bnBlock node at position but found node of different type ${e.type.name}`
      );
    const t2 = e, o = n, r = o + t2.nodeSize, s2 = {
      node: t2,
      beforePos: o,
      afterPos: r
    };
    if (t2.type.name === "blockContainer") {
      let i, a2;
      if (t2.forEach((c, l) => {
        if (c.type.spec.group === "blockContent") {
          const d = c, u = o + l + 1, h2 = u + c.nodeSize;
          i = {
            node: d,
            beforePos: u,
            afterPos: h2
          };
        } else if (c.type.name === "blockGroup") {
          const d = c, u = o + l + 1, h2 = u + c.nodeSize;
          a2 = {
            node: d,
            beforePos: u,
            afterPos: h2
          };
        }
      }), !i)
        throw new Error(
          `blockContainer node does not contain a blockContent node in its children: ${t2}`
        );
      return {
        isBlockContainer: true,
        bnBlock: s2,
        blockContent: i,
        childContainer: a2,
        blockNoteType: i.node.type.name
      };
    } else {
      if (!s2.node.type.isInGroup("childContainer"))
        throw new Error(
          `bnBlock node is not in the childContainer group: ${s2.node}`
        );
      return {
        isBlockContainer: false,
        bnBlock: s2,
        childContainer: s2,
        blockNoteType: s2.node.type.name
      };
    }
  }
  function ee(e) {
    return kt(e.node, e.posBeforeNode);
  }
  function Te(e) {
    if (!e.nodeAfter)
      throw new Error(
        `Attempted to get blockContainer node at position ${e.pos} but a node at this position does not exist`
      );
    return kt(e.nodeAfter, e.pos);
  }
  function v(e) {
    const n = X(e.doc, e.selection.anchor);
    return ee(n);
  }
  function je(e) {
    const n = X(e.doc, e.selection.anchor);
    return ee(n);
  }
  function M(e) {
    return "doc" in e ? e.doc.type.schema : e.type.schema;
  }
  function bn(e) {
    return e.cached.blockNoteEditor;
  }
  function Me(e) {
    return bn(e).schema;
  }
  function wt(e) {
    return Me(e).blockSchema;
  }
  function yt(e) {
    return Me(e).inlineContentSchema;
  }
  function be(e) {
    return Me(e).styleSchema;
  }
  function Ct(e) {
    return bn(e).blockCache;
  }
  function kn(e, n, t2) {
    var s2, i;
    const o = {
      type: "tableContent",
      columnWidths: [],
      headerRows: void 0,
      headerCols: void 0,
      rows: []
    }, r = [];
    e.content.forEach((a2, c, l) => {
      const d = {
        cells: []
      };
      l === 0 && a2.content.forEach((u) => {
        let h2 = u.attrs.colwidth;
        h2 == null && (h2 = new Array(u.attrs.colspan ?? 1).fill(void 0)), o.columnWidths.push(...h2);
      }), d.cells = a2.content.content.map((u, h2) => (r[l] || (r[l] = []), r[l][h2] = u.type.name === "tableHeader", {
        type: "tableCell",
        content: u.content.content.map(
          (m) => Ge(m, n, t2)
        ).reduce(
          (m, g) => {
            if (!m.length)
              return g;
            const b = m[m.length - 1], k = g[0];
            return k && de(b) && de(k) && JSON.stringify(b.styles) === JSON.stringify(k.styles) ? (b.text += `
` + k.text, m.push(...g.slice(1)), m) : (m.push(...g), m);
          },
          []
        ),
        props: {
          colspan: u.attrs.colspan,
          rowspan: u.attrs.rowspan,
          backgroundColor: u.attrs.backgroundColor,
          textColor: u.attrs.textColor,
          textAlignment: u.attrs.textAlignment
        }
      })), o.rows.push(d);
    });
    for (let a2 = 0; a2 < r.length; a2++)
      (s2 = r[a2]) != null && s2.every((c) => c) && (o.headerRows = (o.headerRows ?? 0) + 1);
    for (let a2 = 0; a2 < ((i = r[0]) == null ? void 0 : i.length); a2++)
      r != null && r.every((c) => c[a2]) && (o.headerCols = (o.headerCols ?? 0) + 1);
    return o;
  }
  function Ge(e, n, t2) {
    const o = [];
    let r;
    return e.content.forEach((s2) => {
      if (s2.type.name === "hardBreak") {
        if (r)
          if (de(r))
            r.text += `
`;
          else if (Ot(r))
            r.content[r.content.length - 1].text += `
`;
          else
            throw new Error("unexpected");
        else
          r = {
            type: "text",
            text: `
`,
            styles: {}
          };
        return;
      }
      if (s2.type.name !== "link" && s2.type.name !== "text") {
        if (!n[s2.type.name]) {
          console.warn("unrecognized inline content type", s2.type.name);
          return;
        }
        r && (o.push(r), r = void 0), o.push(
          it(s2, n, t2)
        );
        return;
      }
      const i = {};
      let a2;
      for (const c of s2.marks)
        if (c.type.name === "link")
          a2 = c;
        else {
          const l = t2[c.type.name];
          if (!l) {
            if (c.type.spec.blocknoteIgnore)
              continue;
            throw new Error(`style ${c.type.name} not found in styleSchema`);
          }
          if (l.propSchema === "boolean")
            i[l.type] = true;
          else if (l.propSchema === "string")
            i[l.type] = c.attrs.stringValue;
          else
            throw new j(l.propSchema);
        }
      r ? de(r) ? a2 ? (o.push(r), r = {
        type: "link",
        href: a2.attrs.href,
        content: [
          {
            type: "text",
            text: s2.textContent,
            styles: i
          }
        ]
      }) : JSON.stringify(r.styles) === JSON.stringify(i) ? r.text += s2.textContent : (o.push(r), r = {
        type: "text",
        text: s2.textContent,
        styles: i
      }) : Ot(r) && (a2 ? r.href === a2.attrs.href ? JSON.stringify(
        r.content[r.content.length - 1].styles
      ) === JSON.stringify(i) ? r.content[r.content.length - 1].text += s2.textContent : r.content.push({
        type: "text",
        text: s2.textContent,
        styles: i
      }) : (o.push(r), r = {
        type: "link",
        href: a2.attrs.href,
        content: [
          {
            type: "text",
            text: s2.textContent,
            styles: i
          }
        ]
      }) : (o.push(r), r = {
        type: "text",
        text: s2.textContent,
        styles: i
      })) : a2 ? r = {
        type: "link",
        href: a2.attrs.href,
        content: [
          {
            type: "text",
            text: s2.textContent,
            styles: i
          }
        ]
      } : r = {
        type: "text",
        text: s2.textContent,
        styles: i
      };
    }), r && o.push(r), o;
  }
  function it(e, n, t2) {
    if (e.type.name === "text" || e.type.name === "link")
      throw new Error("unexpected");
    const o = {}, r = n[e.type.name];
    for (const [a2, c] of Object.entries(e.attrs)) {
      if (!r)
        throw Error("ic node is of an unrecognized type: " + e.type.name);
      const l = r.propSchema;
      a2 in l && (o[a2] = c);
    }
    let s2;
    return r.content === "styled" ? s2 = Ge(
      e,
      n,
      t2
    ) : s2 = void 0, {
      type: e.type.name,
      props: o,
      content: s2
    };
  }
  function E(e, n, t2 = wt(n), o = yt(n), r = be(n), s2 = Ct(n)) {
    var g;
    if (!e.type.isInGroup("bnBlock"))
      throw Error("Node should be a bnBlock, but is instead: " + e.type.name);
    const i = s2 == null ? void 0 : s2.get(e);
    if (i)
      return i;
    const a2 = kt(e, 0);
    let c = a2.bnBlock.node.attrs.id;
    c === null && (c = We.options.generateID());
    const l = t2[a2.blockNoteType];
    if (!l)
      throw Error("Block is of an unrecognized type: " + a2.blockNoteType);
    const d = {};
    for (const [b, k] of Object.entries({
      ...e.attrs,
      ...a2.isBlockContainer ? a2.blockContent.node.attrs : {}
    })) {
      const w = l.propSchema;
      b in w && !(w[b].default === void 0 && k === void 0) && (d[b] = k);
    }
    const u = t2[a2.blockNoteType], h2 = [];
    (g = a2.childContainer) == null || g.node.forEach((b) => {
      h2.push(
        E(
          b,
          n,
          t2,
          o,
          r,
          s2
        )
      );
    });
    let f;
    if (u.content === "inline") {
      if (!a2.isBlockContainer)
        throw new Error("impossible");
      f = Ge(
        a2.blockContent.node,
        o,
        r
      );
    } else if (u.content === "table") {
      if (!a2.isBlockContainer)
        throw new Error("impossible");
      f = kn(
        a2.blockContent.node,
        o,
        r
      );
    } else if (u.content === "none")
      f = void 0;
    else
      throw new j(u.content);
    const m = {
      id: c,
      type: u.type,
      props: d,
      content: f,
      children: h2
    };
    return s2 == null || s2.set(e, m), m;
  }
  function lr(e, n, t2 = wt(n), o = yt(n), r = be(n), s2 = Ct(n)) {
    const i = [];
    return e.firstChild.descendants((a2) => (i.push(
      E(
        a2,
        n,
        t2,
        o,
        r,
        s2
      )
    ), false)), i;
  }
  function dr(e, n, t2 = wt(n), o = yt(n), r = be(n), s2 = Ct(n)) {
    function i(a2, c, l) {
      if (a2.type.name !== "blockGroup")
        throw new Error("unexpected");
      const d = [];
      let u, h2;
      return a2.forEach((f, m, g) => {
        if (f.type.name !== "blockContainer")
          throw new Error("unexpected");
        if (f.childCount === 0)
          return;
        if (f.childCount === 0 || f.childCount > 2)
          throw new Error(
            "unexpected, blockContainer.childCount: " + f.childCount
          );
        const b = g === 0, k = g === a2.childCount - 1;
        if (f.firstChild.type.name === "blockGroup") {
          if (!b)
            throw new Error("unexpected");
          const P = i(
            f.firstChild,
            Math.max(0, c - 1),
            k ? Math.max(0, l - 1) : 0
          );
          u = P.blockCutAtStart, k && (h2 = P.blockCutAtEnd), d.push(...P.blocks);
          return;
        }
        const w = E(
          f,
          n,
          t2,
          o,
          r,
          s2
        ), C = f.childCount > 1 ? f.child(1) : void 0;
        let B = [];
        if (C) {
          const P = i(
            C,
            0,
            // TODO: can this be anything other than 0?
            k ? Math.max(0, l - 1) : 0
          );
          B = P.blocks, k && (h2 = P.blockCutAtEnd);
        }
        k && !C && l > 1 && (h2 = w.id), b && c > 1 && (u = w.id), d.push({
          ...w,
          children: B
        });
      }), { blocks: d, blockCutAtStart: u, blockCutAtEnd: h2 };
    }
    if (e.content.childCount === 0)
      return {
        blocks: [],
        blockCutAtStart: void 0,
        blockCutAtEnd: void 0
      };
    if (e.content.childCount !== 1)
      throw new Error(
        "slice must be a single block, did you forget includeParents=true?"
      );
    return i(
      e.content.firstChild,
      Math.max(e.openStart - 1, 0),
      Math.max(e.openEnd - 1, 0)
    );
  }
  function Vt(e, n, t2, o) {
    return e.dom.setAttribute("data-inline-content-type", n), Object.entries(t2).filter(([r, s2]) => {
      const i = o[r];
      return s2 !== i.default;
    }).map(([r, s2]) => [Ve(r), s2]).forEach(([r, s2]) => e.dom.setAttribute(r, s2)), e.contentDOM !== void 0 && e.contentDOM.setAttribute("data-editable", ""), e;
  }
  function ur(e) {
    return {
      Backspace: ({ editor: n }) => {
        const t2 = n.state.selection.$from;
        return n.state.selection.empty && t2.node().type.name === e.type && t2.parentOffset === 0;
      }
    };
  }
  function pr(e, n) {
    return {
      config: e,
      implementation: n
    };
  }
  function hr2(e, n) {
    return pr(
      {
        type: e.name,
        propSchema: n,
        content: e.config.content === "inline*" ? "styled" : "none"
      },
      {
        node: e
      }
    );
  }
  function wn(e) {
    return Object.fromEntries(
      Object.entries(e).map(([n, t2]) => [n, t2.config])
    );
  }
  function fr(e) {
    return [
      {
        tag: `[data-inline-content-type="${e.type}"]`,
        contentElement: (n) => {
          const t2 = n;
          return t2.matches("[data-editable]") ? t2 : t2.querySelector("[data-editable]") || t2;
        }
      }
    ];
  }
  function Ic(e, n) {
    const t2 = Node3.create({
      name: e.type,
      inline: true,
      group: "inline",
      selectable: e.content === "styled",
      atom: e.content === "none",
      content: e.content === "styled" ? "inline*" : "",
      addAttributes() {
        return Be(e.propSchema);
      },
      addKeyboardShortcuts() {
        return ur(e);
      },
      parseHTML() {
        return fr(e);
      },
      renderHTML({ node: o }) {
        const r = this.options.editor, s2 = n.render(
          it(
            o,
            r.schema.inlineContentSchema,
            r.schema.styleSchema
          ),
          // TODO: fix cast
          () => {
          },
          r
        );
        return Vt(
          s2,
          e.type,
          o.attrs,
          e.propSchema
        );
      },
      addNodeView() {
        return ({ node: o, getPos: r }) => {
          const s2 = this.options.editor, i = n.render(
            it(
              o,
              s2.schema.inlineContentSchema,
              s2.schema.styleSchema
            ),
            // TODO: fix cast
            (a2) => {
              if (typeof r == "boolean")
                return;
              const c = F([a2], s2.pmSchema);
              s2.transact(
                (l) => l.replaceWith(r(), r() + o.nodeSize, c)
              );
            },
            s2
          );
          return Vt(
            i,
            e.type,
            o.attrs,
            e.propSchema
          );
        };
      }
    });
    return hr2(
      t2,
      e.propSchema
    );
  }
  function mr(e) {
    return e === "boolean" ? {} : {
      stringValue: {
        default: void 0,
        keepOnSplit: true,
        parseHTML: (n) => n.getAttribute("data-value"),
        renderHTML: (n) => n.stringValue !== void 0 ? {
          "data-value": n.stringValue
        } : {}
      }
    };
  }
  function gr(e, n, t2, o) {
    return e.dom.setAttribute("data-style-type", n), o === "string" && e.dom.setAttribute("data-value", t2), e.contentDOM !== void 0 && e.contentDOM.setAttribute("data-editable", ""), e;
  }
  function yn(e, n) {
    return {
      config: e,
      implementation: n
    };
  }
  function ie3(e, n) {
    return yn(
      {
        type: e.name,
        propSchema: n
      },
      {
        mark: e
      }
    );
  }
  function Cn(e) {
    return Object.fromEntries(
      Object.entries(e).map(([n, t2]) => [n, t2.config])
    );
  }
  function br3(e) {
    return [
      {
        tag: `[data-style-type="${e.type}"]`,
        contentElement: (n) => {
          const t2 = n;
          return t2.matches("[data-editable]") ? t2 : t2.querySelector("[data-editable]") || t2;
        }
      }
    ];
  }
  function Lc(e, n) {
    const t2 = Mark2.create({
      name: e.type,
      addAttributes() {
        return mr(e.propSchema);
      },
      parseHTML() {
        return br3(e);
      },
      renderHTML({ mark: o }) {
        let r;
        if (e.propSchema === "boolean")
          r = n.render();
        else if (e.propSchema === "string")
          r = n.render(o.attrs.stringValue);
        else
          throw new j(e.propSchema);
        return gr(
          r,
          e.type,
          o.attrs.stringValue,
          e.propSchema
        );
      }
    });
    return yn(e, {
      mark: t2
    });
  }
  function re2(e) {
    const { height: n, width: t2 } = vt(e), o = new Array(n).fill(false).map(() => new Array(t2).fill(null)), r = (s2, i) => {
      for (let a2 = s2; a2 < n; a2++)
        for (let c = i; c < t2; c++)
          if (!o[a2][c])
            return { row: a2, col: c };
      throw new Error(
        "Unable to create occupancy grid for table, no more available cells"
      );
    };
    for (let s2 = 0; s2 < e.content.rows.length; s2++)
      for (let i = 0; i < e.content.rows[s2].cells.length; i++) {
        const a2 = rt(e.content.rows[s2].cells[i]), c = st(a2), l = ve(a2), { row: d, col: u } = r(s2, i);
        for (let h2 = d; h2 < d + c; h2++)
          for (let f = u; f < u + l; f++) {
            if (o[h2][f])
              throw new Error(
                `Unable to create occupancy grid for table, cell at ${h2},${f} is already occupied`
              );
            o[h2][f] = {
              row: s2,
              col: i,
              rowspan: c,
              colspan: l,
              cell: a2
            };
          }
      }
    return o;
  }
  function Ee(e) {
    const n = /* @__PURE__ */ new Set();
    return e.map((t2) => ({
      cells: t2.map((o) => n.has(o.row + ":" + o.col) ? false : (n.add(o.row + ":" + o.col), o.cell)).filter((o) => o !== false)
    }));
  }
  function ue(e, n, t2 = re2(n)) {
    for (let o = 0; o < t2.length; o++)
      for (let r = 0; r < t2[o].length; r++) {
        const s2 = t2[o][r];
        if (s2.row === e.row && s2.col === e.col)
          return { row: o, col: r, cell: s2.cell };
      }
    throw new Error(
      `Unable to resolve relative table cell indices for table, cell at ${e.row},${e.col} is not occupied`
    );
  }
  function vt(e) {
    const n = e.content.rows.length;
    let t2 = 0;
    return e.content.rows.forEach((o) => {
      let r = 0;
      o.cells.forEach((s2) => {
        r += ve(s2);
      }), t2 = Math.max(t2, r);
    }), { height: n, width: t2 };
  }
  function vn(e, n, t2 = re2(n)) {
    var r;
    const o = (r = t2[e.row]) == null ? void 0 : r[e.col];
    if (o)
      return {
        row: o.row,
        col: o.col,
        cell: o.cell
      };
  }
  function at(e, n) {
    var s2;
    const t2 = re2(e);
    if (n < 0 || n >= t2.length)
      return [];
    let o = 0;
    for (let i = 0; i < n; i++) {
      const a2 = (s2 = t2[o]) == null ? void 0 : s2[0];
      if (!a2)
        return [];
      o += a2.rowspan;
    }
    const r = new Array(t2[0].length).fill(false).map((i, a2) => vn(
      { row: o, col: a2 },
      e,
      t2
    )).filter(
      (i) => i !== void 0
    );
    return r.filter((i, a2) => r.findIndex((c) => c.row === i.row && c.col === i.col) === a2);
  }
  function ct(e, n) {
    var s2;
    const t2 = re2(e);
    if (n < 0 || n >= t2[0].length)
      return [];
    let o = 0;
    for (let i = 0; i < n; i++) {
      const a2 = (s2 = t2[0]) == null ? void 0 : s2[o];
      if (!a2)
        return [];
      o += a2.colspan;
    }
    const r = new Array(t2.length).fill(false).map((i, a2) => vn(
      { row: a2, col: o },
      e,
      t2
    )).filter(
      (i) => i !== void 0
    );
    return r.filter((i, a2) => r.findIndex((c) => c.row === i.row && c.col === i.col) === a2);
  }
  function kr(e, n, t2, o = re2(e)) {
    const { col: r } = ue(
      {
        row: 0,
        col: n
      },
      e,
      o
    ), { col: s2 } = ue(
      {
        row: 0,
        col: t2
      },
      e,
      o
    );
    return o.forEach((i) => {
      const [a2] = i.splice(r, 1);
      i.splice(s2, 0, a2);
    }), Ee(o);
  }
  function wr(e, n, t2, o = re2(e)) {
    const { row: r } = ue(
      {
        row: n,
        col: 0
      },
      e,
      o
    ), { row: s2 } = ue(
      {
        row: t2,
        col: 0
      },
      e,
      o
    ), [i] = o.splice(r, 1);
    return o.splice(s2, 0, i), Ee(o);
  }
  function lt(e) {
    return e ? Ce(e) ? lt(e.content) : typeof e == "string" ? e.length === 0 : Array.isArray(e) ? e.every(
      (n) => typeof n == "string" ? n.length === 0 : de(n) ? n.text.length === 0 : hn(n) ? typeof n.content == "string" ? n.content.length === 0 : n.content.every((t2) => t2.text.length === 0) : false
    ) : false : true;
  }
  function yr(e, n, t2 = re2(e)) {
    if (n === "columns") {
      let s2 = 0;
      for (let i = t2[0].length - 1; i >= 0 && t2.every(
        (c) => lt(c[i].cell) && c[i].colspan === 1
      ); i--)
        s2++;
      for (let i = t2.length - 1; i >= 0; i--) {
        const a2 = Math.max(
          t2[i].length - s2,
          1
        );
        t2[i] = t2[i].slice(0, a2);
      }
      return Ee(t2);
    }
    let o = 0;
    for (let s2 = t2.length - 1; s2 >= 0 && t2[s2].every(
      (a2) => lt(a2.cell) && a2.rowspan === 1
    ); s2--)
      o++;
    const r = Math.min(o, t2.length - 1);
    return t2.splice(t2.length - r, r), Ee(t2);
  }
  function Cr(e, n, t2, o = re2(e)) {
    const { width: r, height: s2 } = vt(e);
    if (n === "columns")
      o.forEach((i, a2) => {
        if (t2 >= 0)
          for (let c = 0; c < t2; c++)
            i.push({
              row: a2,
              col: Math.max(...i.map((l) => l.col)) + 1,
              rowspan: 1,
              colspan: 1,
              cell: rt("")
            });
        else
          i.splice(r + t2, -1 * t2);
      });
    else if (t2 > 0)
      for (let i = 0; i < t2; i++) {
        const a2 = new Array(r).fill(null).map((c, l) => ({
          row: s2 + i,
          col: l,
          rowspan: 1,
          colspan: 1,
          cell: rt("")
        }));
        o.push(a2);
      }
    else t2 < 0 && o.splice(s2 + t2, -1 * t2);
    return Ee(o);
  }
  function En(e, n, t2) {
    const o = at(e, t2);
    if (!o.some((c) => st(c.cell) > 1))
      return true;
    let s2 = t2, i = t2;
    return o.forEach((c) => {
      const l = st(c.cell);
      s2 = Math.max(s2, c.row + l - 1), i = Math.min(i, c.row);
    }), n < t2 ? t2 === s2 : t2 === i;
  }
  function Sn(e, n, t2) {
    const o = ct(e, t2);
    if (!o.some((c) => ve(c.cell) > 1))
      return true;
    let s2 = t2, i = t2;
    return o.forEach((c) => {
      const l = ve(c.cell);
      s2 = Math.max(s2, c.col + l - 1), i = Math.min(i, c.col);
    }), n < t2 ? t2 === s2 : t2 === i;
  }
  function vr(e, n, t2) {
    const o = ue(e, t2), r = ue(n, t2);
    return o.col === r.col;
  }
  function Ut(e, n, t2, o) {
    const r = [];
    for (const [i, a2] of Object.entries(e.styles || {})) {
      const c = t2[i];
      if (!c)
        throw new Error(`style ${i} not found in styleSchema`);
      if (c.propSchema === "boolean")
        a2 && r.push(n.mark(i));
      else if (c.propSchema === "string")
        a2 && r.push(n.mark(i, { stringValue: a2 }));
      else
        throw new j(c.propSchema);
    }
    return !o || !n.nodes[o].spec.code ? e.text.split(/(\n)/g).filter((i) => i.length > 0).map((i) => i === `
` ? n.nodes.hardBreak.createChecked() : n.text(i, r)) : e.text.length > 0 ? [n.text(e.text, r)] : [];
  }
  function Er(e, n, t2) {
    const o = n.marks.link.create({
      href: e.href
    });
    return dt2(e.content, n, t2).map(
      (r) => {
        if (r.type.name === "text")
          return r.mark([...r.marks, o]);
        if (r.type.name === "hardBreak")
          return r;
        throw new Error("unexpected node type");
      }
    );
  }
  function dt2(e, n, t2, o) {
    const r = [];
    if (typeof e == "string")
      return r.push(
        ...Ut(
          { text: e, styles: {} },
          n,
          t2,
          o
        )
      ), r;
    for (const s2 of e)
      r.push(
        ...Ut(s2, n, t2, o)
      );
    return r;
  }
  function F(e, n, t2, o = be(n)) {
    const r = [];
    for (const s2 of e)
      typeof s2 == "string" ? r.push(
        ...dt2(s2, n, o, t2)
      ) : hn(s2) ? r.push(...Er(s2, n, o)) : de(s2) ? r.push(
        ...dt2([s2], n, o, t2)
      ) : r.push(
        Bn(s2, n, o)
      );
    return r;
  }
  function qe(e, n, t2 = be(n)) {
    const o = [], r = new Array(e.headerRows ?? 0).fill(true), s2 = new Array(e.headerCols ?? 0).fill(true), i = e.columnWidths ?? [];
    for (let a2 = 0; a2 < e.rows.length; a2++) {
      const c = e.rows[a2], l = [], d = r[a2];
      for (let h2 = 0; h2 < c.cells.length; h2++) {
        const f = c.cells[h2], m = s2[h2], g = void 0;
        let b = null;
        const k = ue(
          {
            row: a2,
            col: h2
          },
          { content: e }
        );
        let w = i[k.col] ? [i[k.col]] : null;
        if (f) if (typeof f == "string")
          b = n.text(f);
        else if (Ce(f)) {
          f.content && (b = F(
            f.content,
            n,
            "tableParagraph",
            t2
          ));
          const B = ve(f);
          B > 1 && (w = new Array(B).fill(false).map((P, $2) => i[k.col + $2] ?? void 0));
        } else
          b = F(
            f,
            n,
            "tableParagraph",
            t2
          );
        const C = n.nodes[m || d ? "tableHeader" : "tableCell"].createChecked(
          {
            ...Ce(f) ? f.props : {},
            colwidth: w
          },
          n.nodes.tableParagraph.createChecked(g, b)
        );
        l.push(C);
      }
      const u = n.nodes.tableRow.createChecked({}, l);
      o.push(u);
    }
    return o;
  }
  function Bn(e, n, t2) {
    let o, r = e.type;
    if (r === void 0 && (r = "paragraph"), !n.nodes[r])
      throw new Error(`node type ${r} not found in schema`);
    if (!e.content)
      o = n.nodes[r].createChecked(e.props);
    else if (typeof e.content == "string") {
      const s2 = F(
        [e.content],
        n,
        r,
        t2
      );
      o = n.nodes[r].createChecked(e.props, s2);
    } else if (Array.isArray(e.content)) {
      const s2 = F(
        e.content,
        n,
        r,
        t2
      );
      o = n.nodes[r].createChecked(e.props, s2);
    } else if (e.content.type === "tableContent") {
      const s2 = qe(e.content, n, t2);
      o = n.nodes[r].createChecked(e.props, s2);
    } else
      throw new j(e.content.type);
    return o;
  }
  function pe(e, n, t2 = be(n)) {
    let o = e.id;
    o === void 0 && (o = We.options.generateID());
    const r = [];
    if (e.children)
      for (const i of e.children)
        r.push(pe(i, n, t2));
    if (!e.type || // can happen if block.type is not defined (this should create the default node)
    n.nodes[e.type].isInGroup("blockContent")) {
      const i = Bn(
        e,
        n,
        t2
      ), a2 = r.length > 0 ? n.nodes.blockGroup.createChecked({}, r) : void 0;
      return n.nodes.blockContainer.createChecked(
        {
          id: o,
          ...e.props
        },
        a2 ? [i, a2] : i
      );
    } else {
      if (n.nodes[e.type].isInGroup("bnBlock"))
        return n.nodes[e.type].createChecked(
          {
            id: o,
            ...e.props
          },
          r
        );
      throw new Error(
        `block type ${e.type} doesn't match blockContent or bnBlock group`
      );
    }
  }
  function _(e, n) {
    let t2, o;
    if (n.firstChild.descendants((r, s2) => t2 ? false : !ut(r) || r.attrs.id !== e ? true : (t2 = r, o = s2 + 1, false)), !(t2 === void 0 || o === void 0))
      return {
        node: t2,
        posBeforeNode: o
      };
  }
  function ut(e) {
    return e.type.isInGroup("bnBlock");
  }
  function Sr(e, n) {
    return e.id !== n.id || e.type !== n.type || JSON.stringify(e.props) !== JSON.stringify(n.props) || JSON.stringify(e.content) !== JSON.stringify(n.content);
  }
  function Br(e, n = []) {
    let t2 = { type: "local" };
    e.getMeta("paste") ? t2 = { type: "paste" } : e.getMeta("uiEvent") === "drop" ? t2 = { type: "drop" } : e.getMeta("history$") ? t2 = {
      type: e.getMeta("history$").redo ? "redo" : "undo"
    } : e.getMeta("y-sync$") && (e.getMeta("y-sync$").isUndoRedoOperation ? t2 = {
      type: "undo-redo"
    } : t2 = {
      type: "yjs-remote"
    });
    const o = M(e), r = combineTransactionSteps(e.before, [
      e,
      ...n
    ]), s2 = getChangedRanges(r), i = s2.flatMap((u) => findChildrenInRange(
      r.before,
      u.oldRange,
      ut
    )).map(({ node: u }) => E(u, o)), a2 = s2.flatMap((u) => findChildrenInRange(
      r.doc,
      u.newRange,
      ut
    )).map(({ node: u }) => E(u, o)), c = new Map(
      a2.map((u) => [u.id, u])
    ), l = new Map(
      i.map((u) => [u.id, u])
    ), d = [];
    for (const [u, h2] of c)
      l.has(u) || d.push({
        type: "insert",
        block: h2,
        source: t2,
        prevBlock: void 0
      });
    for (const [u, h2] of l)
      c.has(u) || d.push({
        type: "delete",
        block: h2,
        source: t2,
        prevBlock: void 0
      });
    for (const [u, h2] of c)
      if (l.has(u)) {
        const f = l.get(u);
        Sr(f, h2) && d.push({
          type: "update",
          block: h2,
          prevBlock: f,
          source: t2
        });
      }
    return d;
  }
  function xr(e, n, t2, o = "before") {
    const r = typeof t2 == "string" ? t2 : t2.id, s2 = M(e), i = n.map(
      (d) => pe(d, s2)
    ), a2 = _(r, e.doc);
    if (!a2)
      throw new Error(`Block with ID ${r} not found`);
    let c = a2.posBeforeNode;
    return o === "after" && (c += a2.node.nodeSize), e.step(
      new ReplaceStep(c, c, new Slice(Fragment.from(i), 0, 0))
    ), i.map(
      (d) => E(d, s2)
    );
  }
  function _t(e, n, t2) {
    const o = M(e), r = t2.map(
      (d) => pe(d, o)
    ), s2 = new Set(
      n.map(
        (d) => typeof d == "string" ? d : d.id
      )
    ), i = [], a2 = typeof n[0] == "string" ? n[0] : n[0].id;
    let c = 0;
    if (e.doc.descendants((d, u) => {
      if (s2.size === 0)
        return false;
      if (!d.type.isInGroup("bnBlock") || !s2.has(d.attrs.id))
        return true;
      if (i.push(E(d, o)), s2.delete(d.attrs.id), t2.length > 0 && d.attrs.id === a2) {
        const g = e.doc.nodeSize;
        e.insert(u, r);
        const b = e.doc.nodeSize;
        c += g - b;
      }
      const h2 = e.doc.nodeSize, f = e.doc.resolve(u - c);
      f.node().type.name === "blockGroup" && f.node(f.depth - 1).type.name !== "doc" && f.node().childCount === 1 ? e.delete(f.before(), f.after()) : e.delete(u - c, u - c + d.nodeSize);
      const m = e.doc.nodeSize;
      return c += h2 - m, false;
    }), s2.size > 0) {
      const d = [...s2].join(`
`);
      throw Error(
        "Blocks with the following IDs could not be found in the editor: " + d
      );
    }
    return { insertedBlocks: r.map(
      (d) => E(d, o)
    ), removedBlocks: i };
  }
  var I = (e, n) => ({
    tr: t2,
    dispatch: o
  }) => (o && xn(t2, e, n), true);
  function xn(e, n, t2, o, r) {
    const s2 = Te(e.doc.resolve(n)), i = M(e);
    if (o !== void 0 && r !== void 0 && o > r)
      throw new Error("Invalid replaceFromPos or replaceToPos");
    const a2 = i.nodes[s2.blockNoteType], c = i.nodes[t2.type || s2.blockNoteType], l = c.isInGroup("bnBlock") ? c : i.nodes.blockContainer;
    if (s2.isBlockContainer && c.isInGroup("blockContent")) {
      const d = o !== void 0 && o > s2.blockContent.beforePos && o < s2.blockContent.afterPos ? o - s2.blockContent.beforePos - 1 : void 0, u = r !== void 0 && r > s2.blockContent.beforePos && r < s2.blockContent.afterPos ? r - s2.blockContent.beforePos - 1 : void 0;
      $t(t2, e, s2), Tr(
        t2,
        e,
        a2,
        c,
        s2,
        d,
        u
      );
    } else if (!s2.isBlockContainer && c.isInGroup("bnBlock"))
      $t(t2, e, s2);
    else {
      const d = E(s2.bnBlock.node, i);
      e.replaceWith(
        s2.bnBlock.beforePos,
        s2.bnBlock.afterPos,
        pe(
          {
            children: d.children,
            // if no children are passed in, use existing children
            ...t2
          },
          i
        )
      );
      return;
    }
    e.setNodeMarkup(s2.bnBlock.beforePos, l, {
      ...s2.bnBlock.node.attrs,
      ...t2.props
    });
  }
  function Tr(e, n, t2, o, r, s2, i) {
    const a2 = M(n);
    let c = "keep";
    if (e.content)
      if (typeof e.content == "string")
        c = F(
          [e.content],
          a2,
          o.name
        );
      else if (Array.isArray(e.content))
        c = F(e.content, a2, o.name);
      else if (e.content.type === "tableContent")
        c = qe(e.content, a2);
      else
        throw new j(e.content.type);
    else
      t2.spec.content === "" || o.spec.content !== t2.spec.content && (c = []);
    if (c === "keep")
      n.setNodeMarkup(r.blockContent.beforePos, o, {
        ...r.blockContent.node.attrs,
        ...e.props
      });
    else if (s2 !== void 0 || i !== void 0) {
      n.setNodeMarkup(r.blockContent.beforePos, o, {
        ...r.blockContent.node.attrs,
        ...e.props
      });
      const l = r.blockContent.beforePos + 1 + (s2 ?? 0), d = r.blockContent.beforePos + 1 + (i ?? r.blockContent.node.content.size), u = n.doc.resolve(r.blockContent.beforePos).depth, h2 = n.doc.resolve(l).depth, f = n.doc.resolve(d).depth;
      n.replace(
        l,
        d,
        new Slice(
          Fragment.from(c),
          h2 - u - 1,
          f - u - 1
        )
      );
    } else
      n.replaceWith(
        r.blockContent.beforePos,
        r.blockContent.afterPos,
        o.createChecked(
          {
            ...r.blockContent.node.attrs,
            ...e.props
          },
          c
        )
      );
  }
  function $t(e, n, t2) {
    const o = M(n);
    if (e.children !== void 0 && e.children.length > 0) {
      const r = e.children.map((s2) => pe(s2, o));
      if (t2.childContainer)
        n.step(
          new ReplaceStep(
            t2.childContainer.beforePos + 1,
            t2.childContainer.afterPos - 1,
            new Slice(Fragment.from(r), 0, 0)
          )
        );
      else {
        if (!t2.isBlockContainer)
          throw new Error("impossible");
        n.insert(
          t2.blockContent.afterPos,
          o.nodes.blockGroup.createChecked({}, r)
        );
      }
    }
  }
  function Mr(e, n, t2, o, r) {
    const s2 = typeof n == "string" ? n : n.id, i = _(s2, e.doc);
    if (!i)
      throw new Error(`Block with ID ${s2} not found`);
    xn(
      e,
      i.posBeforeNode,
      t2,
      o,
      r
    );
    const a2 = e.doc.resolve(i.posBeforeNode + 1).node(), c = M(e);
    return E(a2, c);
  }
  function Tn(e) {
    const n = Array.from(e.classList).filter(
      (t2) => !t2.startsWith("bn-")
    ) || [];
    n.length > 0 ? e.className = n.join(" ") : e.removeAttribute("class");
  }
  function Mn(e, n, t2, o) {
    let r;
    if (n)
      if (typeof n == "string")
        r = F([n], e.pmSchema);
      else if (Array.isArray(n))
        r = F(n, e.pmSchema);
      else if (n.type === "tableContent")
        r = qe(n, e.pmSchema);
      else
        throw new j(n.type);
    else throw new Error("blockContent is required");
    const s2 = t2.serializeFragment(Fragment.from(r), o);
    return s2.nodeType === 1 && Tn(s2), s2;
  }
  function Pr(e, n, t2, o, r, s2, i) {
    var g, b, k, w, C, B, P, $2;
    const a2 = (i == null ? void 0 : i.document) ?? document, c = n.pmSchema.nodes.blockContainer;
    let l = t2.props;
    if (!t2.props) {
      l = {};
      for (const [S, y] of Object.entries(
        n.schema.blockSchema[t2.type].propSchema
      ))
        y.default !== void 0 && (l[S] = y.default);
    }
    const d = (b = (g = c.spec) == null ? void 0 : g.toDOM) == null ? void 0 : b.call(
      g,
      c.create({
        id: t2.id,
        ...l
      })
    ), u = Array.from(d.dom.attributes), h2 = n.blockImplementations[t2.type].implementation.toExternalHTML({ ...t2, props: l }, n), f = a2.createDocumentFragment();
    if (h2.dom.classList.contains("bn-block-content")) {
      const S = [
        ...u,
        ...Array.from(h2.dom.attributes)
      ].filter(
        (y) => y.name.startsWith("data") && y.name !== "data-content-type" && y.name !== "data-file-block" && y.name !== "data-node-view-wrapper" && y.name !== "data-node-type" && y.name !== "data-id" && y.name !== "data-index" && y.name !== "data-editable"
      );
      for (const y of S)
        h2.dom.firstChild.setAttribute(y.name, y.value);
      Tn(h2.dom.firstChild), f.append(...Array.from(h2.dom.childNodes));
    } else
      f.append(h2.dom);
    if (h2.contentDOM && t2.content) {
      const S = Mn(
        n,
        t2.content,
        // TODO
        o,
        i
      );
      h2.contentDOM.appendChild(S);
    }
    let m;
    if (r.has(t2.type) ? m = "OL" : s2.has(t2.type) && (m = "UL"), m) {
      if (((k = e.lastChild) == null ? void 0 : k.nodeName) !== m) {
        const y = a2.createElement(m);
        m === "OL" && (l != null && l.start) && (l == null ? void 0 : l.start) !== 1 && y.setAttribute("start", l.start + ""), e.append(y);
      }
      const S = a2.createElement("li");
      S.append(f), e.lastChild.appendChild(S);
    } else
      e.append(f);
    if (t2.children && t2.children.length > 0) {
      const S = a2.createDocumentFragment();
      if (Pn(
        S,
        n,
        t2.children,
        o,
        r,
        s2,
        i
      ), ((w = e.lastChild) == null ? void 0 : w.nodeName) === "UL" || ((C = e.lastChild) == null ? void 0 : C.nodeName) === "OL")
        for (; ((B = S.firstChild) == null ? void 0 : B.nodeName) === "UL" || ((P = S.firstChild) == null ? void 0 : P.nodeName) === "OL"; )
          e.lastChild.lastChild.appendChild(S.firstChild);
      n.pmSchema.nodes[t2.type].isInGroup("blockContent") ? e.append(S) : ($2 = h2.contentDOM) == null || $2.append(S);
    }
  }
  var Pn = (e, n, t2, o, r, s2, i) => {
    for (const a2 of t2)
      Pr(
        e,
        n,
        a2,
        o,
        r,
        s2,
        i
      );
  }, Ir = (e, n, t2, o, r, s2) => {
    const a2 = ((s2 == null ? void 0 : s2.document) ?? document).createDocumentFragment();
    return Pn(
      a2,
      e,
      n,
      t2,
      o,
      r,
      s2
    ), a2;
  }, Ke = (e, n) => {
    const t2 = DOMSerializer.fromSchema(e);
    return {
      exportBlocks: (o, r) => {
        const s2 = Ir(
          n,
          o,
          t2,
          /* @__PURE__ */ new Set(["numberedListItem"]),
          /* @__PURE__ */ new Set(["bulletListItem", "checkListItem"]),
          r
        ), i = document.createElement("div");
        return i.append(s2), i.innerHTML;
      },
      exportInlineContent: (o, r) => {
        const s2 = Mn(
          n,
          o,
          t2,
          r
        ), i = document.createElement("div");
        return i.append(s2.cloneNode(true)), i.innerHTML;
      }
    };
  };
  function Lr(e, n, t2, o, r) {
    let s2;
    if (n)
      if (typeof n == "string")
        s2 = F([n], e.pmSchema, o);
      else if (Array.isArray(n))
        s2 = F(n, e.pmSchema, o);
      else if (n.type === "tableContent")
        s2 = qe(n, e.pmSchema);
      else
        throw new j(n.type);
    else throw new Error("blockContent is required");
    return t2.serializeFragment(Fragment.from(s2), r);
  }
  function Ar(e, n, t2, o, r) {
    var u, h2, f, m, g;
    const s2 = e.pmSchema.nodes.blockContainer;
    let i = n.props;
    if (!n.props) {
      i = {};
      for (const [b, k] of Object.entries(
        e.schema.blockSchema[n.type].propSchema
      ))
        k.default !== void 0 && (i[b] = k.default);
    }
    const c = e.blockImplementations[n.type].implementation.toInternalHTML({ ...n, props: i }, e);
    if (n.type === "numberedListItem" && c.dom.setAttribute("data-index", o.toString()), c.contentDOM && n.content) {
      const b = Lr(
        e,
        n.content,
        // TODO
        t2,
        n.type,
        r
      );
      c.contentDOM.appendChild(b);
    }
    if (e.pmSchema.nodes[n.type].isInGroup("bnBlock")) {
      if (n.children && n.children.length > 0) {
        const b = In(
          e,
          n.children,
          t2,
          r
        );
        (u = c.contentDOM) == null || u.append(b);
      }
      return c.dom;
    }
    const d = (f = (h2 = s2.spec) == null ? void 0 : h2.toDOM) == null ? void 0 : f.call(
      h2,
      s2.create({
        id: n.id,
        ...i
      })
    );
    return (m = d.contentDOM) == null || m.appendChild(c.dom), n.children && n.children.length > 0 && ((g = d.contentDOM) == null || g.appendChild(
      Ln(e, n.children, t2, r)
    )), d.dom;
  }
  function In(e, n, t2, o) {
    const s2 = ((o == null ? void 0 : o.document) ?? document).createDocumentFragment();
    let i = 0;
    for (const a2 of n) {
      a2.type === "numberedListItem" ? i++ : i = 0;
      const c = Ar(
        e,
        a2,
        t2,
        i,
        o
      );
      s2.appendChild(c);
    }
    return s2;
  }
  var Ln = (e, n, t2, o) => {
    var a2;
    const r = e.pmSchema.nodes.blockGroup, s2 = r.spec.toDOM(r.create({})), i = In(e, n, t2, o);
    return (a2 = s2.contentDOM) == null || a2.appendChild(i), s2.dom;
  }, Nr = (e, n) => {
    const t2 = DOMSerializer.fromSchema(e);
    return {
      serializeBlocks: (o, r) => Ln(n, o, t2, r).outerHTML
    };
  }, Je = (e, n) => {
    const t2 = e.querySelector(
      n
    );
    if (!t2)
      return;
    const o = e.querySelector("figcaption"), r = (o == null ? void 0 : o.textContent) ?? void 0;
    return { targetElement: t2, caption: r };
  }, Hr = (e, n, t2, o) => {
    const r = document.createElement("div");
    r.className = "bn-add-file-button";
    const s2 = document.createElement("div");
    s2.className = "bn-add-file-button-icon", o ? s2.appendChild(o) : s2.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z"></path></svg>', r.appendChild(s2);
    const i = document.createElement("p");
    i.className = "bn-add-file-button-text", i.innerHTML = t2 || n.dictionary.file_blocks.file.add_button_text, r.appendChild(i);
    const a2 = (l) => {
      l.preventDefault();
    }, c = () => {
      n.transact(
        (l) => l.setMeta(n.filePanel.plugins[0], {
          block: e
        })
      );
    };
    return r.addEventListener(
      "mousedown",
      a2,
      true
    ), r.addEventListener("click", c, true), {
      dom: r,
      destroy: () => {
        r.removeEventListener(
          "mousedown",
          a2,
          true
        ), r.removeEventListener(
          "click",
          c,
          true
        );
      }
    };
  }, Dr = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M3 8L9.00319 2H19.9978C20.5513 2 21 2.45531 21 2.9918V21.0082C21 21.556 20.5551 22 20.0066 22H3.9934C3.44476 22 3 21.5501 3 20.9932V8ZM10 4V9H5V20H19V4H10Z"></path></svg>', Or = (e) => {
    const n = document.createElement("div");
    n.className = "bn-file-name-with-icon";
    const t2 = document.createElement("div");
    t2.className = "bn-file-icon", t2.innerHTML = Dr, n.appendChild(t2);
    const o = document.createElement("p");
    return o.className = "bn-file-name", o.textContent = e.props.name, n.appendChild(o), {
      dom: n
    };
  }, Et = (e, n, t2, o, r) => {
    const s2 = document.createElement("div");
    if (s2.className = "bn-file-block-content-wrapper", e.props.url === "") {
      const a2 = Hr(
        e,
        n,
        o,
        r
      );
      s2.appendChild(a2.dom);
      const c = n.onUploadStart((l) => {
        if (l === e.id) {
          s2.removeChild(a2.dom);
          const d = document.createElement("div");
          d.className = "bn-file-loading-preview", d.textContent = "Loading...", s2.appendChild(d);
        }
      });
      return {
        dom: s2,
        destroy: () => {
          c(), a2.destroy();
        }
      };
    }
    const i = { dom: s2 };
    if (e.props.showPreview === false || !t2) {
      const a2 = Or(e);
      s2.appendChild(a2.dom), i.destroy = () => {
        var c;
        (c = a2.destroy) == null || c.call(a2);
      };
    } else
      s2.appendChild(t2.dom);
    if (e.props.caption) {
      const a2 = document.createElement("p");
      a2.className = "bn-file-caption", a2.textContent = e.props.caption, s2.appendChild(a2);
    }
    return i;
  }, St = (e, n) => {
    const t2 = document.createElement("figure"), o = document.createElement("figcaption");
    return o.textContent = n, t2.appendChild(e), t2.appendChild(o), { dom: t2 };
  }, Xe = (e, n) => {
    const t2 = document.createElement("div"), o = document.createElement("p");
    return o.textContent = n, t2.appendChild(e), t2.appendChild(o), {
      dom: t2
    };
  }, Ft = (e) => ({ url: e.src || void 0 }), Rr = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 16.0001H5.88889L11.1834 20.3319C11.2727 20.405 11.3846 20.4449 11.5 20.4449C11.7761 20.4449 12 20.2211 12 19.9449V4.05519C12 3.93977 11.9601 3.8279 11.887 3.73857C11.7121 3.52485 11.3971 3.49335 11.1834 3.66821L5.88889 8.00007H2C1.44772 8.00007 1 8.44778 1 9.00007V15.0001C1 15.5524 1.44772 16.0001 2 16.0001ZM23 12C23 15.292 21.5539 18.2463 19.2622 20.2622L17.8445 18.8444C19.7758 17.1937 21 14.7398 21 12C21 9.26016 19.7758 6.80629 17.8445 5.15557L19.2622 3.73779C21.5539 5.75368 23 8.70795 23 12ZM18 12C18 10.0883 17.106 8.38548 15.7133 7.28673L14.2842 8.71584C15.3213 9.43855 16 10.64 16 12C16 13.36 15.3213 14.5614 14.2842 15.2841L15.7133 16.7132C17.106 15.6145 18 13.9116 18 12Z"></path></svg>', Vr = {
    backgroundColor: T.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    },
    showPreview: {
      default: true
    }
  }, Ur = {
    type: "audio",
    propSchema: Vr,
    content: "none",
    isFileBlock: true,
    fileBlockAccept: ["audio/*"]
  }, _r = (e, n) => {
    const t2 = document.createElement("div");
    t2.innerHTML = Rr;
    const o = document.createElement("audio");
    return o.className = "bn-audio", n.resolveFileUrl ? n.resolveFileUrl(e.props.url).then((r) => {
      o.src = r;
    }) : o.src = e.props.url, o.controls = true, o.contentEditable = "false", o.draggable = false, Et(
      e,
      n,
      { dom: o },
      n.dictionary.file_blocks.audio.add_button_text,
      t2.firstElementChild
    );
  }, $r = (e) => {
    if (e.tagName === "AUDIO")
      return e.closest("figure") ? void 0 : Ft(e);
    if (e.tagName === "FIGURE") {
      const n = Je(e, "audio");
      if (!n)
        return;
      const { targetElement: t2, caption: o } = n;
      return {
        ...Ft(t2),
        caption: o
      };
    }
  }, Fr = (e) => {
    if (!e.props.url) {
      const t2 = document.createElement("p");
      return t2.textContent = "Add audio", {
        dom: t2
      };
    }
    let n;
    return e.props.showPreview ? (n = document.createElement("audio"), n.src = e.props.url) : (n = document.createElement("a"), n.href = e.props.url, n.textContent = e.props.name || e.props.url), e.props.caption ? e.props.showPreview ? St(n, e.props.caption) : Xe(n, e.props.caption) : {
      dom: n
    };
  }, zr = xe(Ur, {
    render: _r,
    parse: $r,
    toExternalHTML: Fr
  }), zt = Symbol.for("blocknote.shikiParser"), Ye = Symbol.for(
    "blocknote.shikiHighlighterPromise"
  ), Wr = {
    language: {
      default: "text"
    }
  }, jr = q2({
    name: "codeBlock",
    content: "inline*",
    group: "blockContent",
    marks: "insertion deletion modification",
    code: true,
    defining: true,
    addOptions() {
      return {
        defaultLanguage: "text",
        indentLineWithTab: true,
        supportedLanguages: {}
      };
    },
    addAttributes() {
      const e = this.options;
      return {
        language: {
          default: e.editor.settings.codeBlock.defaultLanguage,
          parseHTML: (n) => {
            let t2 = n, o = null;
            (t2 == null ? void 0 : t2.tagName) === "DIV" && (t2 == null ? void 0 : t2.dataset.contentType) === "codeBlock" && (t2 = t2.children[0]), (t2 == null ? void 0 : t2.tagName) === "PRE" && (t2 = t2 == null ? void 0 : t2.children[0]);
            const r = t2 == null ? void 0 : t2.getAttribute("data-language");
            if (r)
              o = r.toLowerCase();
            else {
              const i = [...(t2 == null ? void 0 : t2.className.split(" ")) || []].filter((a2) => a2.startsWith("language-")).map((a2) => a2.replace("language-", ""));
              i.length > 0 && (o = i[0].toLowerCase());
            }
            return o ? Ze(e.editor.settings.codeBlock, o) ?? o : null;
          },
          renderHTML: (n) => n.language ? {
            class: `language-${n.language}`,
            "data-language": n.language
          } : {}
        }
      };
    },
    parseHTML() {
      return [
        // Parse from internal HTML.
        {
          tag: "div[data-content-type=" + this.name + "]",
          contentElement: ".bn-inline-content"
        },
        // Parse from external HTML.
        {
          tag: "pre",
          // contentElement: "code",
          preserveWhitespace: "full"
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      var r, s2;
      const n = document.createElement("pre"), { dom: t2, contentDOM: o } = G(
        this.name,
        "code",
        ((r = this.options.domAttributes) == null ? void 0 : r.blockContent) || {},
        {
          ...((s2 = this.options.domAttributes) == null ? void 0 : s2.inlineContent) || {},
          ...e
        }
      );
      return t2.removeChild(o), t2.appendChild(n), n.appendChild(o), {
        dom: t2,
        contentDOM: o
      };
    },
    addNodeView() {
      const e = this.options;
      return ({ editor: n, node: t2, getPos: o, HTMLAttributes: r }) => {
        var u, h2;
        const s2 = document.createElement("pre"), i = document.createElement("select"), a2 = document.createElement("div"), { dom: c, contentDOM: l } = G(
          this.name,
          "code",
          {
            ...((u = this.options.domAttributes) == null ? void 0 : u.blockContent) || {},
            ...r
          },
          ((h2 = this.options.domAttributes) == null ? void 0 : h2.inlineContent) || {}
        ), d = (f) => {
          const m = f.target.value;
          n.commands.command(({ tr: g }) => (g.setNodeAttribute(o(), "language", m), true));
        };
        return Object.entries(
          e.editor.settings.codeBlock.supportedLanguages
        ).forEach(([f, { name: m }]) => {
          const g = document.createElement("option");
          g.value = f, g.text = m, i.appendChild(g);
        }), a2.contentEditable = "false", i.value = t2.attrs.language || e.editor.settings.codeBlock.defaultLanguage, c.removeChild(l), c.appendChild(a2), c.appendChild(s2), s2.appendChild(l), a2.appendChild(i), i.addEventListener("change", d), {
          dom: c,
          contentDOM: l,
          update: (f) => f.type === this.type,
          destroy: () => {
            i.removeEventListener("change", d);
          }
        };
      };
    },
    addProseMirrorPlugins() {
      const e = this.options, n = globalThis;
      let t2, o, r = false;
      return [createHighlightPlugin({
        parser: (a2) => {
          if (!e.editor.settings.codeBlock.createHighlighter)
            return !r && (console.log(
              "For syntax highlighting of code blocks, you must provide a `codeBlock.createHighlighter` function"
            ), r = true), [];
          if (!t2)
            return n[Ye] = n[Ye] || e.editor.settings.codeBlock.createHighlighter(), n[Ye].then(
              (l) => {
                t2 = l;
              }
            );
          const c = Ze(
            e.editor.settings.codeBlock,
            a2.language
          );
          return !c || c === "text" || c === "none" || c === "plaintext" || c === "txt" ? [] : t2.getLoadedLanguages().includes(c) ? (o || (o = n[zt] || createParser(t2), n[zt] = o), o(a2)) : t2.loadLanguage(c);
        },
        languageExtractor: (a2) => a2.attrs.language,
        nodeTypes: [this.name]
      })];
    },
    addInputRules() {
      const e = this.options;
      return [
        new InputRule({
          find: /^```(.*?)\s$/,
          handler: ({ state: n, range: t2, match: o }) => {
            const r = n.doc.resolve(t2.from), s2 = o[1].trim(), i = {
              language: Ze(e.editor.settings.codeBlock, s2) ?? s2
            };
            if (!r.node(-1).canReplaceWith(
              r.index(-1),
              r.indexAfter(-1),
              this.type
            ))
              return null;
            n.tr.delete(t2.from, t2.to).setBlockType(t2.from, t2.from, this.type, i).setSelection(TextSelection.create(n.tr.doc, t2.from));
          }
        })
      ];
    },
    addKeyboardShortcuts() {
      return {
        Delete: ({ editor: e }) => {
          const { selection: n } = e.state, { $from: t2 } = n;
          if (e.isActive(this.name) && !t2.parent.textContent && isTextSelection(n)) {
            const o = t2.pos - t2.parentOffset - 2;
            return e.chain().setNodeSelection(o).deleteSelection().run(), true;
          }
          return false;
        },
        Tab: ({ editor: e }) => this.options.indentLineWithTab && e.isActive(this.name) ? (e.commands.insertContent("  "), true) : false,
        Enter: ({ editor: e }) => {
          const { $from: n } = e.state.selection;
          if (!e.isActive(this.name))
            return false;
          const t2 = n.parentOffset === n.parent.nodeSize - 2, o = n.parent.textContent.endsWith(`

`);
          return !t2 || !o ? (e.commands.insertContent(`
`), true) : e.chain().command(({ tr: r }) => (r.delete(n.pos - 2, n.pos), true)).exitCode().run();
        },
        "Shift-Enter": ({ editor: e }) => {
          const { $from: n } = e.state.selection;
          return e.isActive(this.name) ? (e.chain().insertContentAt(
            n.pos - n.parentOffset + n.parent.nodeSize,
            {
              type: "paragraph"
            }
          ).run(), true) : false;
        }
      };
    }
  }), Gr = oe(
    jr,
    Wr
  );
  function Ze(e, n) {
    var t2;
    return (t2 = Object.entries(e.supportedLanguages).find(
      ([o, { aliases: r }]) => (r == null ? void 0 : r.includes(n)) || o === n
    )) == null ? void 0 : t2[0];
  }
  var qr = Mark2.create({
    name: "backgroundColor",
    addAttributes() {
      return {
        stringValue: {
          default: void 0,
          parseHTML: (e) => e.getAttribute("data-background-color"),
          renderHTML: (e) => ({
            "data-background-color": e.stringValue
          })
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "span",
          getAttrs: (e) => typeof e == "string" ? false : e.hasAttribute("data-background-color") ? {
            stringValue: e.getAttribute("data-background-color")
          } : false
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["span", e, 0];
    }
  }), Kr = ie3(
    qr,
    "string"
  ), Jr = Mark2.create({
    name: "textColor",
    addAttributes() {
      return {
        stringValue: {
          default: void 0,
          parseHTML: (e) => e.getAttribute("data-text-color"),
          renderHTML: (e) => ({
            "data-text-color": e.stringValue
          })
        }
      };
    },
    parseHTML() {
      return [
        {
          tag: "span",
          getAttrs: (e) => typeof e == "string" ? false : e.hasAttribute("data-text-color") ? { stringValue: e.getAttribute("data-text-color") } : false
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["span", e, 0];
    }
  }), Xr = ie3(Jr, "string"), Wt = (e) => ({ url: e.src || void 0 }), Yr = {
    backgroundColor: T.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    }
  }, Zr = {
    type: "file",
    propSchema: Yr,
    content: "none",
    isFileBlock: true
  }, Qr = (e, n) => Et(e, n), es = (e) => {
    if (e.tagName === "EMBED")
      return e.closest("figure") ? void 0 : Wt(e);
    if (e.tagName === "FIGURE") {
      const n = Je(e, "embed");
      if (!n)
        return;
      const { targetElement: t2, caption: o } = n;
      return {
        ...Wt(t2),
        caption: o
      };
    }
  }, ts2 = (e) => {
    if (!e.props.url) {
      const t2 = document.createElement("p");
      return t2.textContent = "Add file", {
        dom: t2
      };
    }
    const n = document.createElement("a");
    return n.href = e.props.url, n.textContent = e.props.name || e.props.url, e.props.caption ? Xe(n, e.props.caption) : {
      dom: n
    };
  }, ns = xe(Zr, {
    render: Qr,
    parse: es,
    toExternalHTML: ts2
  }), An = {
    ...T,
    level: { default: 1, values: [1, 2, 3] }
  }, os2 = q2({
    name: "heading",
    content: "inline*",
    group: "blockContent",
    addAttributes() {
      return Be(An);
    },
    addInputRules() {
      return [
        ...[1, 2, 3].map((e) => new InputRule({
          find: new RegExp(`^(#{${e}})\\s$`),
          handler: ({ state: n, chain: t2, range: o }) => {
            const r = v(n);
            !r.isBlockContainer || r.blockContent.node.type.spec.content !== "inline*" || t2().command(
              I(r.bnBlock.beforePos, {
                type: "heading",
                props: {
                  level: e
                }
              })
            ).deleteRange({ from: o.from, to: o.to }).run();
          }
        }))
      ];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-1": () => {
          const e = v(this.editor.state);
          return !e.isBlockContainer || e.blockContent.node.type.spec.content !== "inline*" ? true : this.editor.commands.command(
            I(e.bnBlock.beforePos, {
              type: "heading",
              props: {
                level: 1
              }
            })
          );
        },
        "Mod-Alt-2": () => {
          const e = v(this.editor.state);
          return !e.isBlockContainer || e.blockContent.node.type.spec.content !== "inline*" ? true : this.editor.commands.command(
            I(e.bnBlock.beforePos, {
              type: "heading",
              props: {
                level: 2
              }
            })
          );
        },
        "Mod-Alt-3": () => {
          const e = v(this.editor.state);
          return !e.isBlockContainer || e.blockContent.node.type.spec.content !== "inline*" ? true : this.editor.commands.command(
            I(e.bnBlock.beforePos, {
              type: "heading",
              props: {
                level: 3
              }
            })
          );
        }
      };
    },
    parseHTML() {
      return [
        // Parse from internal HTML.
        {
          tag: "div[data-content-type=" + this.name + "]",
          contentElement: ".bn-inline-content"
        },
        // Parse from external HTML.
        {
          tag: "h1",
          attrs: { level: 1 },
          node: "heading"
        },
        {
          tag: "h2",
          attrs: { level: 2 },
          node: "heading"
        },
        {
          tag: "h3",
          attrs: { level: 3 },
          node: "heading"
        }
      ];
    },
    renderHTML({ node: e, HTMLAttributes: n }) {
      var t2, o;
      return G(
        this.name,
        `h${e.attrs.level}`,
        {
          ...((t2 = this.options.domAttributes) == null ? void 0 : t2.blockContent) || {},
          ...n
        },
        ((o = this.options.domAttributes) == null ? void 0 : o.inlineContent) || {}
      );
    }
  }), rs = oe(
    os2,
    An
  ), Nn = (e, n, t2, o, r, s2) => {
    const { dom: i, destroy: a2 } = Et(
      e,
      n,
      t2,
      r,
      s2
    ), c = i;
    e.props.url && e.props.showPreview && (e.props.previewWidth ? c.style.width = `${e.props.previewWidth}px` : c.style.width = "fit-content");
    const l = document.createElement("div");
    l.className = "bn-resize-handle", l.style.left = "4px";
    const d = document.createElement("div");
    d.className = "bn-resize-handle", d.style.right = "4px";
    let u, h2 = e.props.previewWidth;
    const f = (C) => {
      var $2, S;
      if (!u) {
        !n.isEditable && o.contains(l) && o.contains(d) && (o.removeChild(l), o.removeChild(d));
        return;
      }
      let B;
      e.props.textAlignment === "center" ? u.handleUsed === "left" ? B = u.initialWidth + (u.initialClientX - C.clientX) * 2 : B = u.initialWidth + (C.clientX - u.initialClientX) * 2 : u.handleUsed === "left" ? B = u.initialWidth + u.initialClientX - C.clientX : B = u.initialWidth + C.clientX - u.initialClientX, h2 = Math.min(
        Math.max(B, 64),
        ((S = ($2 = n.domElement) == null ? void 0 : $2.firstElementChild) == null ? void 0 : S.clientWidth) || Number.MAX_VALUE
      ), c.style.width = `${h2}px`;
    }, m = (C) => {
      (!C.target || !c.contains(C.target) || !n.isEditable) && o.contains(l) && o.contains(d) && (o.removeChild(l), o.removeChild(d)), u && (u = void 0, n.updateBlock(e, {
        props: {
          previewWidth: h2
        }
      }));
    }, g = () => {
      n.isEditable && (o.appendChild(l), o.appendChild(d));
    }, b = (C) => {
      C.relatedTarget === l || C.relatedTarget === d || u || n.isEditable && o.contains(l) && o.contains(d) && (o.removeChild(l), o.removeChild(d));
    }, k = (C) => {
      C.preventDefault(), u = {
        handleUsed: "left",
        initialWidth: c.clientWidth,
        initialClientX: C.clientX
      };
    }, w = (C) => {
      C.preventDefault(), u = {
        handleUsed: "right",
        initialWidth: c.clientWidth,
        initialClientX: C.clientX
      };
    };
    return window.addEventListener("mousemove", f), window.addEventListener("mouseup", m), c.addEventListener("mouseenter", g), c.addEventListener("mouseleave", b), l.addEventListener(
      "mousedown",
      k
    ), d.addEventListener(
      "mousedown",
      w
    ), {
      dom: c,
      destroy: () => {
        a2 == null || a2(), window.removeEventListener("mousemove", f), window.removeEventListener("mouseup", m), c.removeEventListener("mouseenter", g), c.removeEventListener("mouseleave", b), l.removeEventListener(
          "mousedown",
          k
        ), d.removeEventListener(
          "mousedown",
          w
        );
      }
    };
  }, jt = (e) => {
    const n = e.src || void 0, t2 = e.width || void 0;
    return { url: n, previewWidth: t2 };
  }, ss = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M5 11.1005L7 9.1005L12.5 14.6005L16 11.1005L19 14.1005V5H5V11.1005ZM4 3H20C20.5523 3 21 3.44772 21 4V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V4C3 3.44772 3.44772 3 4 3ZM15.5 10C14.6716 10 14 9.32843 14 8.5C14 7.67157 14.6716 7 15.5 7C16.3284 7 17 7.67157 17 8.5C17 9.32843 16.3284 10 15.5 10Z"></path></svg>', is3 = {
    textAlignment: T.textAlignment,
    backgroundColor: T.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    },
    showPreview: {
      default: true
    },
    // File preview width in px.
    previewWidth: {
      default: void 0,
      type: "number"
    }
  }, as = {
    type: "image",
    propSchema: is3,
    content: "none",
    isFileBlock: true,
    fileBlockAccept: ["image/*"]
  }, cs = (e, n) => {
    const t2 = document.createElement("div");
    t2.innerHTML = ss;
    const o = document.createElement("div");
    o.className = "bn-visual-media-wrapper";
    const r = document.createElement("img");
    return r.className = "bn-visual-media", n.resolveFileUrl ? n.resolveFileUrl(e.props.url).then((s2) => {
      r.src = s2;
    }) : r.src = e.props.url, r.alt = e.props.name || e.props.caption || "BlockNote image", r.contentEditable = "false", r.draggable = false, o.appendChild(r), Nn(
      e,
      n,
      { dom: o },
      o,
      n.dictionary.file_blocks.image.add_button_text,
      t2.firstElementChild
    );
  }, ls = (e) => {
    if (e.tagName === "IMG")
      return e.closest("figure") ? void 0 : jt(e);
    if (e.tagName === "FIGURE") {
      const n = Je(e, "img");
      if (!n)
        return;
      const { targetElement: t2, caption: o } = n;
      return {
        ...jt(t2),
        caption: o
      };
    }
  }, ds = (e) => {
    if (!e.props.url) {
      const t2 = document.createElement("p");
      return t2.textContent = "Add image", {
        dom: t2
      };
    }
    let n;
    return e.props.showPreview ? (n = document.createElement("img"), n.src = e.props.url, n.alt = e.props.name || e.props.caption || "BlockNote image", e.props.previewWidth && (n.width = e.props.previewWidth)) : (n = document.createElement("a"), n.href = e.props.url, n.textContent = e.props.name || e.props.url), e.props.caption ? e.props.showPreview ? St(n, e.props.caption) : Xe(n, e.props.caption) : {
      dom: n
    };
  }, us = xe(as, {
    render: cs,
    parse: ls,
    toExternalHTML: ds
  });
  function Bt(e, n, t2) {
    var u, h2, f;
    const o = DOMParser2.fromSchema(n), r = e, s2 = document.createElement("div");
    s2.setAttribute("data-node-type", "blockGroup");
    for (const m of Array.from(r.childNodes))
      s2.appendChild(m.cloneNode(true));
    let i = o.parse(s2, {
      topNode: n.nodes.blockGroup.create()
    });
    ((h2 = (u = i.firstChild) == null ? void 0 : u.firstChild) == null ? void 0 : h2.type.name) === "checkListItem" && (i = i.copy(
      i.content.cut(
        i.firstChild.firstChild.nodeSize + 2
      )
    ));
    const a2 = (f = i.firstChild) == null ? void 0 : f.firstChild;
    if (!(a2 != null && a2.isTextblock))
      return Fragment.from(i);
    const c = n.nodes[t2].create(
      {},
      a2.content
    ), l = i.content.cut(
      // +2 for the `blockGroup` node's start and end markers
      a2.nodeSize + 2
    );
    if (l.size > 0) {
      const m = i.copy(l);
      return c.content.addToEnd(m);
    }
    return c.content;
  }
  var Hn = (e, n, t2) => ({
    state: o,
    dispatch: r
  }) => {
    const s2 = X(o.doc, e), i = ee(s2);
    if (!i.isBlockContainer)
      throw new Error(
        `BlockContainer expected when calling splitBlock, position ${e}`
      );
    const a2 = [
      {
        type: i.bnBlock.node.type,
        // always keep blockcontainer type
        attrs: t2 ? { ...i.bnBlock.node.attrs, id: void 0 } : {}
      },
      {
        type: n ? i.blockContent.node.type : o.schema.nodes.paragraph,
        attrs: t2 ? { ...i.blockContent.node.attrs } : {}
      }
    ];
    return r && o.tr.split(e, 2, a2), true;
  }, xt = (e) => {
    const { blockInfo: n, selectionEmpty: t2 } = e.transact((s2) => ({
      blockInfo: je(s2),
      selectionEmpty: s2.selection.anchor === s2.selection.head
    }));
    if (!n.isBlockContainer)
      return false;
    const { bnBlock: o, blockContent: r } = n;
    return !(r.node.type.name === "bulletListItem" || r.node.type.name === "numberedListItem" || r.node.type.name === "checkListItem") || !t2 ? false : e._tiptapEditor.commands.first(({ state: s2, chain: i, commands: a2 }) => [
      () => (
        // Changes list item block to a paragraph block if the content is empty.
        a2.command(() => r.node.childCount === 0 ? a2.command(
          I(o.beforePos, {
            type: "paragraph",
            props: {}
          })
        ) : false)
      ),
      () => (
        // Splits the current block, moving content inside that's after the cursor
        // to a new block of the same type below.
        a2.command(() => r.node.childCount > 0 ? (i().deleteSelection().command(Hn(s2.selection.from, true)).run(), true) : false)
      )
    ]);
  }, ps = {
    ...T
  }, hs = q2({
    name: "bulletListItem",
    content: "inline*",
    group: "blockContent",
    // This is to make sure that check list parse rules run before, since they
    // both parse `li` elements but check lists are more specific.
    priority: 90,
    addInputRules() {
      return [
        // Creates an unordered list when starting with "-", "+", or "*".
        new InputRule({
          find: new RegExp("^[-+*]\\s$"),
          handler: ({ state: e, chain: n, range: t2 }) => {
            const o = v(e);
            !o.isBlockContainer || o.blockContent.node.type.spec.content !== "inline*" || n().command(
              I(o.bnBlock.beforePos, {
                type: "bulletListItem",
                props: {}
              })
            ).deleteRange({ from: t2.from, to: t2.to });
          }
        })
      ];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => xt(this.options.editor),
        "Mod-Shift-8": () => {
          const e = v(this.editor.state);
          return !e.isBlockContainer || e.blockContent.node.type.spec.content !== "inline*" ? true : this.editor.commands.command(
            I(e.bnBlock.beforePos, {
              type: "bulletListItem",
              props: {}
            })
          );
        }
      };
    },
    parseHTML() {
      return [
        // Parse from internal HTML.
        {
          tag: "div[data-content-type=" + this.name + "]",
          contentElement: ".bn-inline-content"
        },
        // Parse from external HTML.
        {
          tag: "li",
          getAttrs: (e) => {
            var t2;
            if (typeof e == "string")
              return false;
            const n = e.parentElement;
            return n === null ? false : n.tagName === "UL" || n.tagName === "DIV" && ((t2 = n.parentElement) == null ? void 0 : t2.tagName) === "UL" ? {} : false;
          },
          // As `li` elements can contain multiple paragraphs, we need to merge their contents
          // into a single one so that ProseMirror can parse everything correctly.
          getContent: (e, n) => Bt(e, n, this.name),
          node: "bulletListItem"
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      var n, t2;
      return G(
        this.name,
        // We use a <p> tag, because for <li> tags we'd need a <ul> element to put
        // them in to be semantically correct, which we can't have due to the
        // schema.
        "p",
        {
          ...((n = this.options.domAttributes) == null ? void 0 : n.blockContent) || {},
          ...e
        },
        ((t2 = this.options.domAttributes) == null ? void 0 : t2.inlineContent) || {}
      );
    }
  }), fs = oe(
    hs,
    ps
  ), Dn = {
    ...T,
    checked: {
      default: false
    }
  }, ms = q2({
    name: "checkListItem",
    content: "inline*",
    group: "blockContent",
    addAttributes() {
      return Be(Dn);
    },
    addInputRules() {
      return [
        // Creates a checklist when starting with "[]" or "[X]".
        new InputRule({
          find: new RegExp("\\[\\s*\\]\\s$"),
          handler: ({ state: e, chain: n, range: t2 }) => {
            const o = v(e);
            !o.isBlockContainer || o.blockContent.node.type.spec.content !== "inline*" || n().command(
              I(o.bnBlock.beforePos, {
                type: "checkListItem",
                props: {
                  checked: false
                }
              })
            ).deleteRange({ from: t2.from, to: t2.to });
          }
        }),
        new InputRule({
          find: new RegExp("\\[[Xx]\\]\\s$"),
          handler: ({ state: e, chain: n, range: t2 }) => {
            const o = v(e);
            !o.isBlockContainer || o.blockContent.node.type.spec.content !== "inline*" || n().command(
              I(o.bnBlock.beforePos, {
                type: "checkListItem",
                props: {
                  checked: true
                }
              })
            ).deleteRange({ from: t2.from, to: t2.to });
          }
        })
      ];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => xt(this.options.editor),
        "Mod-Shift-9": () => {
          const e = v(this.editor.state);
          return !e.isBlockContainer || e.blockContent.node.type.spec.content !== "inline*" ? true : this.editor.commands.command(
            I(e.bnBlock.beforePos, {
              type: "checkListItem",
              props: {}
            })
          );
        }
      };
    },
    parseHTML() {
      return [
        // Parse from internal HTML.
        {
          tag: "div[data-content-type=" + this.name + "]",
          contentElement: ".bn-inline-content"
        },
        // Parse from external HTML.
        {
          tag: "input",
          getAttrs: (e) => typeof e == "string" || e.closest("[data-content-type]") || e.closest("li") ? false : e.type === "checkbox" ? { checked: e.checked } : false,
          node: "checkListItem"
        },
        {
          tag: "li",
          getAttrs: (e) => {
            var t2;
            if (typeof e == "string")
              return false;
            const n = e.parentElement;
            if (n === null)
              return false;
            if (n.tagName === "UL" || n.tagName === "DIV" && ((t2 = n.parentElement) == null ? void 0 : t2.tagName) === "UL") {
              const o = e.querySelector(
                "input[type=checkbox]"
              ) || null;
              return o === null ? false : { checked: o.checked };
            }
            return false;
          },
          // As `li` elements can contain multiple paragraphs, we need to merge their contents
          // into a single one so that ProseMirror can parse everything correctly.
          getContent: (e, n) => Bt(e, n, this.name),
          node: "checkListItem"
        }
      ];
    },
    // Since there is no HTML checklist element, there isn't really any
    // standardization for what checklists should look like in the DOM. GDocs'
    // and Notion's aren't cross compatible, for example. This implementation
    // has a semantically correct DOM structure (though missing a label for the
    // checkbox) which is also converted correctly to Markdown by remark.
    renderHTML({ node: e, HTMLAttributes: n }) {
      var s2, i;
      const t2 = document.createElement("input");
      t2.type = "checkbox", t2.checked = e.attrs.checked, e.attrs.checked && t2.setAttribute("checked", "");
      const { dom: o, contentDOM: r } = G(
        this.name,
        "p",
        {
          ...((s2 = this.options.domAttributes) == null ? void 0 : s2.blockContent) || {},
          ...n
        },
        ((i = this.options.domAttributes) == null ? void 0 : i.inlineContent) || {}
      );
      return o.insertBefore(t2, r), { dom: o, contentDOM: r };
    },
    // Need to render node view since the checkbox needs to be able to update the
    // node. This is only possible with a node view as it exposes `getPos`.
    addNodeView() {
      return ({ node: e, getPos: n, editor: t2, HTMLAttributes: o }) => {
        var d, u;
        const r = document.createElement("div"), s2 = document.createElement("div");
        s2.contentEditable = "false";
        const i = document.createElement("input");
        i.type = "checkbox", i.checked = e.attrs.checked, e.attrs.checked && i.setAttribute("checked", "");
        const a2 = () => {
          if (!t2.isEditable) {
            i.checked = !i.checked;
            return;
          }
          if (typeof n != "boolean") {
            const h2 = X(
              t2.state.doc,
              n()
            );
            if (h2.node.type.name !== "blockContainer")
              throw new Error(
                `Expected blockContainer node, got ${h2.node.type.name}`
              );
            this.editor.commands.command(
              I(h2.posBeforeNode, {
                type: "checkListItem",
                props: {
                  checked: i.checked
                }
              })
            );
          }
        };
        i.addEventListener("change", a2);
        const { dom: c, contentDOM: l } = G(
          this.name,
          "p",
          {
            ...((d = this.options.domAttributes) == null ? void 0 : d.blockContent) || {},
            ...o
          },
          ((u = this.options.domAttributes) == null ? void 0 : u.inlineContent) || {}
        );
        if (typeof n != "boolean") {
          const f = "label-" + this.editor.state.doc.resolve(n()).node().attrs.id;
          i.setAttribute("aria-labelledby", f), l.id = f;
        }
        return c.removeChild(l), c.appendChild(r), r.appendChild(s2), r.appendChild(l), s2.appendChild(i), {
          dom: c,
          contentDOM: l,
          destroy: () => {
            i.removeEventListener("change", a2);
          }
        };
      };
    }
  }), gs = oe(
    ms,
    Dn
  ), bs = new PluginKey("numbered-list-indexing"), ks = () => new Plugin({
    key: bs,
    appendTransaction: (e, n, t2) => {
      const o = t2.tr;
      o.setMeta("numberedListIndexing", true);
      let r = false;
      return t2.doc.descendants((s2, i) => {
        var a2;
        if (s2.type.name === "blockContainer" && s2.firstChild.type.name === "numberedListItem") {
          let c = `${s2.firstChild.attrs.start || 1}`;
          const l = ee({
            posBeforeNode: i,
            node: s2
          });
          if (!l.isBlockContainer)
            throw new Error("impossible");
          const d = o.doc.resolve(
            l.bnBlock.beforePos
          ).nodeBefore;
          if (d) {
            const m = ee({
              posBeforeNode: l.bnBlock.beforePos - d.nodeSize,
              node: d
            });
            if (m.blockNoteType === "numberedListItem") {
              if (!m.isBlockContainer)
                throw new Error("impossible");
              const b = m.blockContent.node.attrs.index;
              c = (parseInt(b) + 1).toString();
            }
          }
          const u = l.blockContent.node, h2 = u.attrs.index, f = ((a2 = d == null ? void 0 : d.firstChild) == null ? void 0 : a2.type.name) !== "numberedListItem";
          if (h2 !== c || u.attrs.start && !f) {
            r = true;
            const { start: m, ...g } = u.attrs;
            o.setNodeMarkup(l.blockContent.beforePos, void 0, {
              ...g,
              index: c,
              ...typeof m == "number" && f && {
                start: m
              }
            });
          }
        }
      }), r ? o : null;
    }
  }), On = {
    ...T,
    start: { default: void 0, type: "number" }
  }, ws = q2({
    name: "numberedListItem",
    content: "inline*",
    group: "blockContent",
    priority: 90,
    addAttributes() {
      return {
        ...Be(On),
        // the index attribute is only used internally (it's not part of the blocknote schema)
        // that's why it's defined explicitly here, and not part of the prop schema
        index: {
          default: null,
          parseHTML: (e) => e.getAttribute("data-index"),
          renderHTML: (e) => ({
            "data-index": e.index
          })
        }
      };
    },
    addInputRules() {
      return [
        // Creates an ordered list when starting with "1.".
        new InputRule({
          find: new RegExp("^(\\d+)\\.\\s$"),
          handler: ({ state: e, chain: n, range: t2, match: o }) => {
            const r = v(e);
            if (!r.isBlockContainer || r.blockContent.node.type.spec.content !== "inline*" || r.blockNoteType === "numberedListItem")
              return;
            const s2 = parseInt(o[1]);
            n().command(
              I(r.bnBlock.beforePos, {
                type: "numberedListItem",
                props: s2 === 1 && {} || {
                  start: s2
                }
              })
            ).deleteRange({ from: t2.from, to: t2.to });
          }
        })
      ];
    },
    addKeyboardShortcuts() {
      return {
        Enter: () => xt(this.options.editor),
        "Mod-Shift-7": () => {
          const e = v(this.editor.state);
          return !e.isBlockContainer || e.blockContent.node.type.spec.content !== "inline*" ? true : this.editor.commands.command(
            I(e.bnBlock.beforePos, {
              type: "numberedListItem",
              props: {}
            })
          );
        }
      };
    },
    addProseMirrorPlugins() {
      return [ks()];
    },
    parseHTML() {
      return [
        // Parse from internal HTML.
        {
          tag: "div[data-content-type=" + this.name + "]",
          contentElement: ".bn-inline-content"
        },
        // Parse from external HTML.
        {
          tag: "li",
          getAttrs: (e) => {
            var t2;
            if (typeof e == "string")
              return false;
            const n = e.parentElement;
            if (n === null)
              return false;
            if (n.tagName === "OL" || n.tagName === "DIV" && ((t2 = n.parentElement) == null ? void 0 : t2.tagName) === "OL") {
              const o = parseInt(n.getAttribute("start") || "1") || 1;
              return e.previousSibling || o === 1 ? {} : {
                start: o
              };
            }
            return false;
          },
          // As `li` elements can contain multiple paragraphs, we need to merge their contents
          // into a single one so that ProseMirror can parse everything correctly.
          getContent: (e, n) => Bt(e, n, this.name),
          priority: 300,
          node: "numberedListItem"
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      var n, t2;
      return G(
        this.name,
        // We use a <p> tag, because for <li> tags we'd need an <ol> element to
        // put them in to be semantically correct, which we can't have due to the
        // schema.
        "p",
        {
          ...((n = this.options.domAttributes) == null ? void 0 : n.blockContent) || {},
          ...e
        },
        ((t2 = this.options.domAttributes) == null ? void 0 : t2.inlineContent) || {}
      );
    }
  }), ys = oe(
    ws,
    On
  ), Cs = {
    ...T
  }, vs = q2({
    name: "paragraph",
    content: "inline*",
    group: "blockContent",
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-0": () => {
          const e = v(this.editor.state);
          return !e.isBlockContainer || e.blockContent.node.type.spec.content !== "inline*" ? true : this.editor.commands.command(
            I(e.bnBlock.beforePos, {
              type: "paragraph",
              props: {}
            })
          );
        }
      };
    },
    parseHTML() {
      return [
        // Parse from internal HTML.
        {
          tag: "div[data-content-type=" + this.name + "]",
          contentElement: ".bn-inline-content"
        },
        // Parse from external HTML.
        {
          tag: "p",
          getAttrs: (e) => {
            var n;
            return typeof e == "string" || !((n = e.textContent) != null && n.trim()) ? false : {};
          },
          node: "paragraph"
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      var n, t2;
      return G(
        this.name,
        "p",
        {
          ...((n = this.options.domAttributes) == null ? void 0 : n.blockContent) || {},
          ...e
        },
        ((t2 = this.options.domAttributes) == null ? void 0 : t2.inlineContent) || {}
      );
    }
  }), Es = oe(
    vs,
    Cs
  ), Ss = {
    ...T
  }, Bs = q2({
    name: "quote",
    content: "inline*",
    group: "blockContent",
    addInputRules() {
      return [
        // Creates a block quote when starting with ">".
        new InputRule({
          find: new RegExp("^>\\s$"),
          handler: ({ state: e, chain: n, range: t2 }) => {
            const o = v(e);
            !o.isBlockContainer || o.blockContent.node.type.spec.content !== "inline*" || n().command(
              I(o.bnBlock.beforePos, {
                type: "quote",
                props: {}
              })
            ).deleteRange({ from: t2.from, to: t2.to });
          }
        })
      ];
    },
    addKeyboardShortcuts() {
      return {
        "Mod-Alt-q": () => {
          const e = v(this.editor.state);
          return !e.isBlockContainer || e.blockContent.node.type.spec.content !== "inline*" ? true : this.editor.commands.command(
            I(e.bnBlock.beforePos, {
              type: "quote"
            })
          );
        }
      };
    },
    parseHTML() {
      return [
        // Parse from internal HTML.
        {
          tag: "div[data-content-type=" + this.name + "]",
          contentElement: ".bn-inline-content"
        },
        // Parse from external HTML.
        {
          tag: "blockquote",
          node: "quote"
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      var n, t2;
      return G(
        this.name,
        "blockquote",
        {
          ...((n = this.options.domAttributes) == null ? void 0 : n.blockContent) || {},
          ...e
        },
        ((t2 = this.options.domAttributes) == null ? void 0 : t2.inlineContent) || {}
      );
    }
  }), xs = oe(
    Bs,
    Ss
  ), Ts = 35, Rn = 120, Ac = 31, Ms = Extension.create({
    name: "BlockNoteTableExtension",
    addProseMirrorPlugins: () => [
      columnResizing({
        cellMinWidth: Ts,
        defaultCellMinWidth: Rn,
        // We set this to null as we implement our own node view in the table
        // block content. This node view is the same as what's used by default,
        // but is wrapped in a `blockContent` HTML element.
        View: null
      }),
      tableEditing()
    ],
    addKeyboardShortcuts() {
      return {
        // Makes enter create a new line within the cell.
        Enter: () => this.editor.state.selection.empty && this.editor.state.selection.$head.parent.type.name === "tableParagraph" ? (this.editor.commands.insertContent({ type: "hardBreak" }), true) : false,
        // Ensures that backspace won't delete the table if the text cursor is at
        // the start of a cell and the selection is empty.
        Backspace: () => {
          const e = this.editor.state.selection, n = e.empty, t2 = e.$head.parentOffset === 0, o = e.$head.node().type.name === "tableParagraph";
          return n && t2 && o;
        },
        // Enables navigating cells using the tab key.
        Tab: () => this.editor.commands.command(
          ({ state: e, dispatch: n, view: t2 }) => goToNextCell(1)(e, n, t2)
        ),
        "Shift-Tab": () => this.editor.commands.command(
          ({ state: e, dispatch: n, view: t2 }) => goToNextCell(-1)(e, n, t2)
        )
      };
    },
    extendNodeSchema(e) {
      const n = {
        name: e.name,
        options: e.options,
        storage: e.storage
      };
      return {
        tableRole: callOrReturn(
          getExtensionField(e, "tableRole", n)
        )
      };
    }
  }), Ps = {
    textColor: T.textColor
  }, Is = q2({
    name: "table",
    content: "tableRow+",
    group: "blockContent",
    tableRole: "table",
    marks: "deletion insertion modification",
    isolating: true,
    parseHTML() {
      return [
        {
          tag: "table"
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      var n, t2;
      return G(
        this.name,
        "table",
        {
          ...((n = this.options.domAttributes) == null ? void 0 : n.blockContent) || {},
          ...e
        },
        ((t2 = this.options.domAttributes) == null ? void 0 : t2.inlineContent) || {}
      );
    },
    // This node view is needed for the `columnResizing` plugin. By default, the
    // plugin adds its own node view, which overrides how the node is rendered vs
    // `renderHTML`. This means that the wrapping `blockContent` HTML element is
    // no longer rendered. The `columnResizing` plugin uses the `TableView` as its
    // default node view. `BlockNoteTableView` extends it by wrapping it in a
    // `blockContent` element, so the DOM structure is consistent with other block
    // types.
    addNodeView() {
      return ({ node: e, HTMLAttributes: n }) => {
        var o;
        class t2 extends TableView {
          constructor(s2, i, a2) {
            super(s2, i), this.node = s2, this.cellMinWidth = i, this.blockContentHTMLAttributes = a2;
            const c = document.createElement("div");
            c.className = Q(
              "bn-block-content",
              a2.class
            ), c.setAttribute("data-content-type", "table");
            for (const [h2, f] of Object.entries(
              a2
            ))
              h2 !== "class" && c.setAttribute(h2, f);
            const l = this.dom, d = document.createElement("div");
            d.className = "tableWrapper-inner", d.appendChild(l.firstChild), l.appendChild(d), c.appendChild(l);
            const u = document.createElement("div");
            u.className = "table-widgets-container", u.style.position = "relative", l.appendChild(u), this.dom = c;
          }
          ignoreMutation(s2) {
            return !s2.target.closest(".tableWrapper-inner") || super.ignoreMutation(s2);
          }
        }
        return new t2(e, Rn, {
          ...((o = this.options.domAttributes) == null ? void 0 : o.blockContent) || {},
          ...n
        });
      };
    }
  }), Ls = q2({
    name: "tableParagraph",
    group: "tableContent",
    content: "inline*",
    parseHTML() {
      return [
        {
          tag: "p",
          getAttrs: (e) => {
            if (typeof e == "string" || !e.textContent || !e.closest("[data-content-type]"))
              return false;
            const n = e.parentElement;
            return n === null ? false : n.tagName === "TD" || n.tagName === "TH" ? {} : false;
          },
          node: "tableParagraph"
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["p", e, 0];
    }
  }), As = Node3.create({
    name: "tableRow",
    addOptions() {
      return {
        HTMLAttributes: {}
      };
    },
    content: "(tableCell | tableHeader)+",
    tableRole: "row",
    marks: "deletion insertion modification",
    parseHTML() {
      return [{ tag: "tr" }];
    },
    renderHTML({ HTMLAttributes: e }) {
      return [
        "tr",
        mergeAttributes(this.options.HTMLAttributes, e),
        0
      ];
    }
  });
  function Gt(e, n) {
    const o = DOMParser2.fromSchema(n).parse(e, {
      topNode: n.nodes.blockGroup.create()
    }), r = [];
    return o.content.descendants((s2) => {
      if (s2.isInline)
        return r.push(s2), false;
    }), Fragment.fromArray(r);
  }
  var Ns = oe(
    Is,
    Ps,
    [
      Ms,
      Ls,
      TableHeader.extend({
        /**
         * We allow table headers and cells to have multiple tableContent nodes because
         * when merging cells, prosemirror-tables will concat the contents of the cells naively.
         * This would cause that content to overflow into other cells when prosemirror tries to enforce the cell structure.
         *
         * So, we manually fix this up when reading back in the `nodeToBlock` and only ever place a single tableContent back into the cell.
         */
        content: "tableContent+",
        parseHTML() {
          return [
            {
              tag: "th",
              // As `th` elements can contain multiple paragraphs, we need to merge their contents
              // into a single one so that ProseMirror can parse everything correctly.
              getContent: (e, n) => Gt(e, n)
            }
          ];
        }
      }),
      TableCell.extend({
        content: "tableContent+",
        parseHTML() {
          return [
            {
              tag: "td",
              // As `td` elements can contain multiple paragraphs, we need to merge their contents
              // into a single one so that ProseMirror can parse everything correctly.
              getContent: (e, n) => Gt(e, n)
            }
          ];
        }
      }),
      As
    ]
  ), qt = (e) => {
    const n = e.src || void 0, t2 = e.width || void 0;
    return { url: n, previewWidth: t2 };
  }, Hs = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M2 3.9934C2 3.44476 2.45531 3 2.9918 3H21.0082C21.556 3 22 3.44495 22 3.9934V20.0066C22 20.5552 21.5447 21 21.0082 21H2.9918C2.44405 21 2 20.5551 2 20.0066V3.9934ZM8 5V19H16V5H8ZM4 5V7H6V5H4ZM18 5V7H20V5H18ZM4 9V11H6V9H4ZM18 9V11H20V9H18ZM4 13V15H6V13H4ZM18 13V15H20V13H18ZM4 17V19H6V17H4ZM18 17V19H20V17H18Z"></path></svg>', Ds = {
    textAlignment: T.textAlignment,
    backgroundColor: T.backgroundColor,
    // File name.
    name: {
      default: ""
    },
    // File url.
    url: {
      default: ""
    },
    // File caption.
    caption: {
      default: ""
    },
    showPreview: {
      default: true
    },
    // File preview width in px.
    previewWidth: {
      default: void 0,
      type: "number"
    }
  }, Os = {
    type: "video",
    propSchema: Ds,
    content: "none",
    isFileBlock: true,
    fileBlockAccept: ["video/*"]
  }, Rs = (e, n) => {
    const t2 = document.createElement("div");
    t2.innerHTML = Hs;
    const o = document.createElement("div");
    o.className = "bn-visual-media-wrapper";
    const r = document.createElement("video");
    return r.className = "bn-visual-media", n.resolveFileUrl ? n.resolveFileUrl(e.props.url).then((s2) => {
      r.src = s2;
    }) : r.src = e.props.url, r.controls = true, r.contentEditable = "false", r.draggable = false, r.width = e.props.previewWidth, o.appendChild(r), Nn(
      e,
      n,
      { dom: o },
      o,
      n.dictionary.file_blocks.video.add_button_text,
      t2.firstElementChild
    );
  }, Vs = (e) => {
    if (e.tagName === "VIDEO")
      return e.closest("figure") ? void 0 : qt(e);
    if (e.tagName === "FIGURE") {
      const n = Je(e, "video");
      if (!n)
        return;
      const { targetElement: t2, caption: o } = n;
      return {
        ...qt(t2),
        caption: o
      };
    }
  }, Us = (e) => {
    if (!e.props.url) {
      const t2 = document.createElement("p");
      return t2.textContent = "Add video", {
        dom: t2
      };
    }
    let n;
    return e.props.showPreview ? (n = document.createElement("video"), n.src = e.props.url, e.props.previewWidth && (n.width = e.props.previewWidth)) : (n = document.createElement("a"), n.href = e.props.url, n.textContent = e.props.name || e.props.url), e.props.caption ? e.props.showPreview ? St(n, e.props.caption) : Xe(n, e.props.caption) : {
      dom: n
    };
  }, _s = xe(Os, {
    render: Rs,
    parse: Vs,
    toExternalHTML: Us
  }), Vn = {
    paragraph: Es,
    heading: rs,
    quote: xs,
    codeBlock: Gr,
    bulletListItem: fs,
    numberedListItem: ys,
    checkListItem: gs,
    table: Ns,
    file: ns,
    image: us,
    video: _s,
    audio: zr
  }, $s = gn(Vn), Un = {
    bold: ie3(Bold, "boolean"),
    italic: ie3(Italic, "boolean"),
    underline: ie3(Underline, "boolean"),
    strike: ie3(Strike, "boolean"),
    code: ie3(Code, "boolean"),
    textColor: Xr,
    backgroundColor: Kr
  }, Nc = Cn(Un), _n = {
    text: { config: "text", implementation: {} },
    link: { config: "link", implementation: {} }
  }, Fs = wn(
    _n
  );
  function O(e, n) {
    return e in n.schema.blockSchema && n.schema.blockSchema[e] === $s[e];
  }
  function zs(e, n) {
    return e in n.schema.inlineContentSchema && n.schema.inlineContentSchema[e] === Fs[e];
  }
  function Ws(e, n, t2) {
    return n.type === e && n.type in t2.schema.blockSchema && O(n.type, t2);
  }
  function Hc(e, n) {
    return e.type in n.schema.blockSchema && n.schema.blockSchema[e.type].isFileBlock || false;
  }
  function Dc(e, n) {
    return e.type in n.schema.blockSchema && n.schema.blockSchema[e.type].isFileBlock && "showPreview" in n.schema.blockSchema[e.type].propSchema || false;
  }
  function Oc(e, n) {
    return n.schema.blockSchema[e.type].isFileBlock && !e.props.url;
  }
  function js(e, n, t2) {
    return n in t2.schema.blockSchema && e in t2.schema.blockSchema[n].propSchema && t2.schema.blockSchema[n].propSchema[e] === T[e];
  }
  function Rc(e, n, t2) {
    return js(e, n.type, t2);
  }
  function Kt(e) {
    return e instanceof CellSelection;
  }
  var Vc = async (e) => {
    const n = new FormData();
    return n.append("file", e), (await (await fetch("https://tmpfiles.org/api/v1/upload", {
      method: "POST",
      body: n
    })).json()).data.url.replace(
      "tmpfiles.org/",
      "tmpfiles.org/dl/"
    );
  };
  function Gs(e) {
    let n = e.getTextCursorPosition().block, t2 = e.schema.blockSchema[n.type].content;
    for (; t2 === "none"; ) {
      if (n = e.getTextCursorPosition().nextBlock, n === void 0)
        return;
      t2 = e.schema.blockSchema[n.type].content, e.setTextCursorPosition(n, "end");
    }
  }
  function N(e, n) {
    const t2 = e.getTextCursorPosition().block;
    if (t2.content === void 0)
      throw new Error("Slash Menu open in a block that doesn't contain content.");
    let o;
    return Array.isArray(t2.content) && (t2.content.length === 1 && de(t2.content[0]) && t2.content[0].type === "text" && t2.content[0].text === "/" || t2.content.length === 0) ? (o = e.updateBlock(t2, n), e.setTextCursorPosition(o)) : (o = e.insertBlocks([n], t2, "after")[0], e.setTextCursorPosition(e.getTextCursorPosition().nextBlock)), Gs(e), o;
  }
  function Uc(e) {
    const n = [];
    return O("heading", e) && n.push(
      {
        onItemClick: () => {
          N(e, {
            type: "heading",
            props: { level: 1 }
          });
        },
        badge: Z("Mod-Alt-1"),
        key: "heading",
        ...e.dictionary.slash_menu.heading
      },
      {
        onItemClick: () => {
          N(e, {
            type: "heading",
            props: { level: 2 }
          });
        },
        badge: Z("Mod-Alt-2"),
        key: "heading_2",
        ...e.dictionary.slash_menu.heading_2
      },
      {
        onItemClick: () => {
          N(e, {
            type: "heading",
            props: { level: 3 }
          });
        },
        badge: Z("Mod-Alt-3"),
        key: "heading_3",
        ...e.dictionary.slash_menu.heading_3
      }
    ), O("quote", e) && n.push({
      onItemClick: () => {
        N(e, {
          type: "quote"
        });
      },
      key: "quote",
      ...e.dictionary.slash_menu.quote
    }), O("numberedListItem", e) && n.push({
      onItemClick: () => {
        N(e, {
          type: "numberedListItem"
        });
      },
      badge: Z("Mod-Shift-7"),
      key: "numbered_list",
      ...e.dictionary.slash_menu.numbered_list
    }), O("bulletListItem", e) && n.push({
      onItemClick: () => {
        N(e, {
          type: "bulletListItem"
        });
      },
      badge: Z("Mod-Shift-8"),
      key: "bullet_list",
      ...e.dictionary.slash_menu.bullet_list
    }), O("checkListItem", e) && n.push({
      onItemClick: () => {
        N(e, {
          type: "checkListItem"
        });
      },
      badge: Z("Mod-Shift-9"),
      key: "check_list",
      ...e.dictionary.slash_menu.check_list
    }), O("paragraph", e) && n.push({
      onItemClick: () => {
        N(e, {
          type: "paragraph"
        });
      },
      badge: Z("Mod-Alt-0"),
      key: "paragraph",
      ...e.dictionary.slash_menu.paragraph
    }), O("codeBlock", e) && n.push({
      onItemClick: () => {
        N(e, {
          type: "codeBlock"
        });
      },
      badge: Z("Mod-Alt-c"),
      key: "code_block",
      ...e.dictionary.slash_menu.code_block
    }), O("table", e) && n.push({
      onItemClick: () => {
        N(e, {
          type: "table",
          content: {
            type: "tableContent",
            rows: [
              {
                cells: ["", "", ""]
              },
              {
                cells: ["", "", ""]
              }
            ]
          }
        });
      },
      badge: void 0,
      key: "table",
      ...e.dictionary.slash_menu.table
    }), O("image", e) && n.push({
      onItemClick: () => {
        const t2 = N(e, {
          type: "image"
        });
        e.transact(
          (o) => o.setMeta(e.filePanel.plugins[0], {
            block: t2
          })
        );
      },
      key: "image",
      ...e.dictionary.slash_menu.image
    }), O("video", e) && n.push({
      onItemClick: () => {
        const t2 = N(e, {
          type: "video"
        });
        e.transact(
          (o) => o.setMeta(e.filePanel.plugins[0], {
            block: t2
          })
        );
      },
      key: "video",
      ...e.dictionary.slash_menu.video
    }), O("audio", e) && n.push({
      onItemClick: () => {
        const t2 = N(e, {
          type: "audio"
        });
        e.transact(
          (o) => o.setMeta(e.filePanel.plugins[0], {
            block: t2
          })
        );
      },
      key: "audio",
      ...e.dictionary.slash_menu.audio
    }), O("file", e) && n.push({
      onItemClick: () => {
        const t2 = N(e, {
          type: "file"
        });
        e.transact(
          (o) => o.setMeta(e.filePanel.plugins[0], {
            block: t2
          })
        );
      },
      key: "file",
      ...e.dictionary.slash_menu.file
    }), n.push({
      onItemClick: () => {
        e.openSuggestionMenu(":", {
          deleteTriggerCharacter: true,
          ignoreQueryLength: true
        });
      },
      key: "emoji",
      ...e.dictionary.slash_menu.emoji
    }), n;
  }
  function _c(e, n) {
    return e.filter(
      ({ title: t2, aliases: o }) => t2.toLowerCase().includes(n.toLowerCase()) || o && o.filter(
        (r) => r.toLowerCase().includes(n.toLowerCase())
      ).length !== 0
    );
  }
  function Qe(e) {
    return e && Object.fromEntries(
      Object.entries(e).filter(([, n]) => n !== void 0)
    );
  }
  var Pe = class _Pe {
    constructor(n) {
      p4(this, "blockSpecs");
      p4(this, "inlineContentSpecs");
      p4(this, "styleSpecs");
      p4(this, "blockSchema");
      p4(this, "inlineContentSchema");
      p4(this, "styleSchema");
      p4(this, "BlockNoteEditor", "only for types");
      p4(this, "Block", "only for types");
      p4(this, "PartialBlock", "only for types");
      this.blockSpecs = Qe(n == null ? void 0 : n.blockSpecs) || Vn, this.inlineContentSpecs = Qe(n == null ? void 0 : n.inlineContentSpecs) || _n, this.styleSpecs = Qe(n == null ? void 0 : n.styleSpecs) || Un, this.blockSchema = gn(this.blockSpecs), this.inlineContentSchema = wn(
        this.inlineContentSpecs
      ), this.styleSchema = Cn(this.styleSpecs);
    }
    static create(n) {
      return new _Pe(n);
    }
  };
  var qs = {
    type: "pageBreak",
    propSchema: {},
    content: "none",
    isFileBlock: false,
    isSelectable: false
  }, Ks = () => {
    const e = document.createElement("div");
    return e.className = "bn-page-break", e.setAttribute("data-page-break", ""), {
      dom: e
    };
  }, Js = (e) => {
    if (e.tagName === "DIV" && e.hasAttribute("data-page-break"))
      return {
        type: "pageBreak"
      };
  }, Xs = () => {
    const e = document.createElement("div");
    return e.setAttribute("data-page-break", ""), {
      dom: e
    };
  }, Ys = xe(qs, {
    render: Ks,
    parse: Js,
    toExternalHTML: Xs
  }), $n = Pe.create({
    blockSpecs: {
      pageBreak: Ys
    }
  }), $c = (e) => Pe.create({
    blockSpecs: {
      ...e.blockSpecs,
      ...$n.blockSpecs
    },
    inlineContentSpecs: e.inlineContentSpecs,
    styleSpecs: e.styleSpecs
  });
  function Zs(e) {
    return "pageBreak" in e.schema.blockSchema && e.schema.blockSchema.pageBreak === $n.blockSchema.pageBreak;
  }
  function Fc(e) {
    const n = [];
    return Zs(e) && n.push({
      ...e.dictionary.slash_menu.page_break,
      onItemClick: () => {
        N(e, {
          type: "pageBreak"
        });
      },
      key: "page_break"
    }), n;
  }
  function Qs(e) {
    return e.transact((n) => {
      const t2 = X(n.doc, n.selection.anchor);
      if (n.selection instanceof CellSelection)
        return {
          type: "cell",
          anchorBlockId: t2.node.attrs.id,
          anchorCellOffset: n.selection.$anchorCell.pos - t2.posBeforeNode,
          headCellOffset: n.selection.$headCell.pos - t2.posBeforeNode
        };
      if (n.selection instanceof NodeSelection)
        return {
          type: "node",
          anchorBlockId: t2.node.attrs.id
        };
      {
        const o = X(n.doc, n.selection.head);
        return {
          type: "text",
          anchorBlockId: t2.node.attrs.id,
          headBlockId: o.node.attrs.id,
          anchorOffset: n.selection.anchor - t2.posBeforeNode,
          headOffset: n.selection.head - o.posBeforeNode
        };
      }
    });
  }
  function ei(e, n) {
    var r, s2;
    const t2 = (r = _(n.anchorBlockId, e.doc)) == null ? void 0 : r.posBeforeNode;
    if (t2 === void 0)
      throw new Error(
        `Could not find block with ID ${n.anchorBlockId} to update selection`
      );
    let o;
    if (n.type === "cell")
      o = CellSelection.create(
        e.doc,
        t2 + n.anchorCellOffset,
        t2 + n.headCellOffset
      );
    else if (n.type === "node")
      o = NodeSelection.create(e.doc, t2 + 1);
    else {
      const i = (s2 = _(n.headBlockId, e.doc)) == null ? void 0 : s2.posBeforeNode;
      if (i === void 0)
        throw new Error(
          `Could not find block with ID ${n.headBlockId} to update selection`
        );
      o = TextSelection.create(
        e.doc,
        t2 + n.anchorOffset,
        i + n.headOffset
      );
    }
    e.setSelection(o);
  }
  function pt(e) {
    return e.map((n) => n.type === "columnList" ? n.children.map((t2) => pt(t2.children)).flat() : {
      ...n,
      children: pt(n.children)
    }).flat();
  }
  function Fn(e, n, t2) {
    e.transact((o) => {
      var i;
      const r = ((i = e.getSelection()) == null ? void 0 : i.blocks) || [
        e.getTextCursorPosition().block
      ], s2 = Qs(e);
      e.removeBlocks(r), e.insertBlocks(pt(r), n, t2), ei(o, s2);
    });
  }
  function zn(e) {
    return !e || e.type !== "columnList";
  }
  function Wn(e, n, t2) {
    let o, r;
    if (n ? n.children.length > 0 ? (o = n.children[n.children.length - 1], r = "after") : (o = n, r = "before") : t2 && (o = t2, r = "before"), !o || !r)
      return;
    const s2 = e.getParentBlock(o);
    return zn(s2) ? { referenceBlock: o, placement: r } : Wn(
      e,
      r === "after" ? o : e.getPrevBlock(o),
      s2
    );
  }
  function jn(e, n, t2) {
    let o, r;
    if (n ? n.children.length > 0 ? (o = n.children[0], r = "before") : (o = n, r = "after") : t2 && (o = t2, r = "after"), !o || !r)
      return;
    const s2 = e.getParentBlock(o);
    return zn(s2) ? { referenceBlock: o, placement: r } : jn(
      e,
      r === "before" ? o : e.getNextBlock(o),
      s2
    );
  }
  function ti(e) {
    e.transact(() => {
      const n = e.getSelection(), t2 = (n == null ? void 0 : n.blocks[0]) || e.getTextCursorPosition().block, o = Wn(
        e,
        e.getPrevBlock(t2),
        e.getParentBlock(t2)
      );
      o && Fn(
        e,
        o.referenceBlock,
        o.placement
      );
    });
  }
  function ni(e) {
    e.transact(() => {
      const n = e.getSelection(), t2 = (n == null ? void 0 : n.blocks[(n == null ? void 0 : n.blocks.length) - 1]) || e.getTextCursorPosition().block, o = jn(
        e,
        e.getNextBlock(t2),
        e.getParentBlock(t2)
      );
      o && Fn(
        e,
        o.referenceBlock,
        o.placement
      );
    });
  }
  function oi(e, n) {
    return function(t2, o) {
      const { $from: r, $to: s2 } = t2.selection, i = r.blockRange(
        s2,
        (d) => d.childCount > 0 && (d.type.name === "blockGroup" || d.type.name === "column")
        // change necessary to not look at first item child type
      );
      if (!i)
        return false;
      const a2 = i.startIndex;
      if (a2 === 0)
        return false;
      const l = i.parent.child(a2 - 1);
      if (l.type !== e)
        return false;
      if (o) {
        const d = l.lastChild && l.lastChild.type === n, u = Fragment.from(d ? e.create() : null), h2 = new Slice(
          Fragment.from(
            e.create(null, Fragment.from(n.create(null, u)))
            // change necessary to create "groupType" instead of parent.type
          ),
          d ? 3 : 1,
          0
        ), f = i.start, m = i.end;
        o(
          t2.tr.step(
            new ReplaceAroundStep(
              f - (d ? 3 : 1),
              m,
              f,
              m,
              h2,
              1,
              true
            )
          ).scrollIntoView()
        );
      }
      return true;
    };
  }
  function Gn(e) {
    return e.exec(
      (n, t2) => oi(
        n.schema.nodes.blockContainer,
        n.schema.nodes.blockGroup
      )(n, t2)
    );
  }
  function ri(e) {
    e._tiptapEditor.commands.liftListItem("blockContainer");
  }
  function si(e) {
    return e.transact((n) => {
      const { bnBlock: t2 } = je(n);
      return n.doc.resolve(t2.beforePos).nodeBefore !== null;
    });
  }
  function ii(e) {
    return e.transact((n) => {
      const { bnBlock: t2 } = je(n);
      return n.doc.resolve(t2.beforePos).depth > 1;
    });
  }
  function ai(e, n) {
    const t2 = typeof n == "string" ? n : n.id, o = M(e), r = _(t2, e);
    if (r)
      return E(r.node, o);
  }
  function ci(e, n) {
    const t2 = typeof n == "string" ? n : n.id, o = _(t2, e), r = M(e);
    if (!o)
      return;
    const i = e.resolve(o.posBeforeNode).nodeBefore;
    if (i)
      return E(i, r);
  }
  function li3(e, n) {
    const t2 = typeof n == "string" ? n : n.id, o = _(t2, e), r = M(e);
    if (!o)
      return;
    const i = e.resolve(
      o.posBeforeNode + o.node.nodeSize
    ).nodeAfter;
    if (i)
      return E(i, r);
  }
  function di(e, n) {
    const t2 = typeof n == "string" ? n : n.id, o = M(e), r = _(t2, e);
    if (!r)
      return;
    const s2 = e.resolve(r.posBeforeNode), i = s2.node(), a2 = s2.node(-1), c = a2.type.name !== "doc" ? i.type.name === "blockGroup" ? a2 : i : void 0;
    if (c)
      return E(c, o);
  }
  function ui(e, n, t2, o = { updateSelection: true }) {
    let { from: r, to: s2 } = typeof n == "number" ? { from: n, to: n } : { from: n.from, to: n.to }, i = true, a2 = true, c = "";
    if (t2.forEach((l) => {
      l.check(), i && l.isText && l.marks.length === 0 ? c += l.text : i = false, a2 = a2 ? l.isBlock : false;
    }), r === s2 && a2) {
      const { parent: l } = e.doc.resolve(r);
      l.isTextblock && !l.type.spec.code && !l.childCount && (r -= 1, s2 += 1);
    }
    return i ? e.insertText(c, r, s2) : e.replaceWith(r, s2, t2), o.updateSelection && selectionToInsertionEnd2(e, e.steps.length - 1, -1), true;
  }
  function pi(e) {
    const n = M(e);
    if (e.selection.empty || "node" in e.selection)
      return;
    const t2 = e.doc.resolve(
      X(e.doc, e.selection.from).posBeforeNode
    ), o = e.doc.resolve(
      X(e.doc, e.selection.to).posBeforeNode
    ), r = (l, d) => {
      const u = t2.posAtIndex(l, d), h2 = e.doc.resolve(u).nodeAfter;
      if (!h2)
        throw new Error(
          `Error getting selection - node not found at position ${u}`
        );
      return E(h2, n);
    }, s2 = [], i = t2.sharedDepth(o.pos), a2 = t2.index(i), c = o.index(i);
    if (t2.depth > i) {
      s2.push(E(t2.nodeAfter, n));
      for (let l = t2.depth; l > i; l--)
        if (t2.node(l).type.isInGroup("childContainer")) {
          const u = t2.index(l) + 1, h2 = t2.node(l).childCount;
          for (let f = u; f < h2; f++)
            s2.push(r(f, l));
        }
    } else
      s2.push(r(a2, i));
    for (let l = a2 + 1; l <= c; l++)
      s2.push(r(l, i));
    if (s2.length === 0)
      throw new Error(
        `Error getting selection - selection doesn't span any blocks (${e.selection})`
      );
    return {
      blocks: s2
    };
  }
  function hi(e, n, t2) {
    const o = typeof n == "string" ? n : n.id, r = typeof t2 == "string" ? t2 : t2.id, s2 = M(e), i = Me(s2);
    if (o === r)
      throw new Error(
        `Attempting to set selection with the same anchor and head blocks (id ${o})`
      );
    const a2 = _(o, e.doc);
    if (!a2)
      throw new Error(`Block with ID ${o} not found`);
    const c = _(r, e.doc);
    if (!c)
      throw new Error(`Block with ID ${r} not found`);
    const l = ee(a2), d = ee(c), u = i.blockSchema[l.blockNoteType], h2 = i.blockSchema[d.blockNoteType];
    if (!l.isBlockContainer || u.content === "none")
      throw new Error(
        `Attempting to set selection anchor in block without content (id ${o})`
      );
    if (!d.isBlockContainer || h2.content === "none")
      throw new Error(
        `Attempting to set selection anchor in block without content (id ${r})`
      );
    let f, m;
    if (u.content === "table") {
      const g = TableMap.get(l.blockContent.node);
      f = l.blockContent.beforePos + g.positionAt(0, 0, l.blockContent.node) + 1 + 2;
    } else
      f = l.blockContent.beforePos + 1;
    if (h2.content === "table") {
      const g = TableMap.get(d.blockContent.node), b = d.blockContent.beforePos + g.positionAt(
        g.height - 1,
        g.width - 1,
        d.blockContent.node
      ) + 1, k = e.doc.resolve(b).nodeAfter.nodeSize;
      m = b + k - 2;
    } else
      m = d.blockContent.afterPos - 1;
    e.setSelection(TextSelection.create(e.doc, f, m));
  }
  function fi(e) {
    const n = M(e);
    let t2 = e.selection.$from, o = e.selection.$to;
    for (; o.parentOffset >= o.parent.nodeSize - 2 && o.depth > 0; )
      o = e.doc.resolve(o.pos + 1);
    for (; o.parentOffset === 0 && o.depth > 0; )
      o = e.doc.resolve(o.pos - 1);
    for (; t2.parentOffset === 0 && t2.depth > 0; )
      t2 = e.doc.resolve(t2.pos - 1);
    for (; t2.parentOffset >= t2.parent.nodeSize - 2 && t2.depth > 0; )
      t2 = e.doc.resolve(t2.pos + 1);
    const r = dr(
      e.doc.slice(t2.pos, o.pos, true),
      n
    );
    return {
      _meta: {
        startPos: t2.pos,
        endPos: o.pos
      },
      ...r
    };
  }
  function mi(e) {
    const { bnBlock: n } = je(e), t2 = M(e.doc), o = e.doc.resolve(n.beforePos), r = o.nodeBefore, s2 = e.doc.resolve(n.afterPos).nodeAfter;
    let i;
    return o.depth > 1 && (i = o.node(), i.type.isInGroup("bnBlock") || (i = o.node(o.depth - 1))), {
      block: E(n.node, t2),
      prevBlock: r === null ? void 0 : E(r, t2),
      nextBlock: s2 === null ? void 0 : E(s2, t2),
      parentBlock: i === void 0 ? void 0 : E(i, t2)
    };
  }
  function qn(e, n, t2 = "start") {
    const o = typeof n == "string" ? n : n.id, r = M(e.doc), s2 = Me(r), i = _(o, e.doc);
    if (!i)
      throw new Error(`Block with ID ${o} not found`);
    const a2 = ee(i), c = s2.blockSchema[a2.blockNoteType].content;
    if (a2.isBlockContainer) {
      const l = a2.blockContent;
      if (c === "none") {
        e.setSelection(NodeSelection.create(e.doc, l.beforePos));
        return;
      }
      if (c === "inline")
        t2 === "start" ? e.setSelection(
          TextSelection.create(e.doc, l.beforePos + 1)
        ) : e.setSelection(
          TextSelection.create(e.doc, l.afterPos - 1)
        );
      else if (c === "table")
        t2 === "start" ? e.setSelection(
          TextSelection.create(e.doc, l.beforePos + 4)
        ) : e.setSelection(
          TextSelection.create(e.doc, l.afterPos - 4)
        );
      else
        throw new j(c);
    } else {
      const l = t2 === "start" ? a2.childContainer.node.firstChild : a2.childContainer.node.lastChild;
      qn(e, l.attrs.id, t2);
    }
  }
  var fe;
  async function Tt() {
    if (fe)
      return fe;
    const e = await Promise.all([
      Promise.resolve().then(() => (init_rehype_parse(), rehype_parse_exports)),
      Promise.resolve().then(() => (init_rehype_stringify(), rehype_stringify_exports)),
      Promise.resolve().then(() => (init_unified(), unified_exports)),
      Promise.resolve().then(() => (init_hast_util_from_dom(), hast_util_from_dom_exports)),
      Promise.resolve().then(() => (init_rehype_remark(), rehype_remark_exports)),
      Promise.resolve().then(() => (init_remark_gfm(), remark_gfm_exports)),
      Promise.resolve().then(() => (init_remark_stringify(), remark_stringify_exports)),
      Promise.resolve().then(() => (init_remark_parse(), remark_parse_exports)),
      Promise.resolve().then(() => (init_remark_rehype(), remark_rehype_exports)),
      Promise.resolve().then(() => (init_rehype_format(), rehype_format_exports))
    ]);
    return fe = {
      rehypeParse: e[0],
      rehypeStringify: e[1],
      unified: e[2],
      hastUtilFromDom: e[3],
      rehypeRemark: e[4],
      remarkGfm: e[5],
      remarkStringify: e[6],
      remarkParse: e[7],
      remarkRehype: e[8],
      rehypeFormat: e[9]
    }, fe;
  }
  function gi() {
    const e = (n) => {
      let t2 = n.children.length;
      for (let o = 0; o < t2; o++) {
        const r = n.children[o];
        if (r.type === "element" && (e(r), r.tagName === "u"))
          if (r.children.length > 0) {
            n.children.splice(o, 1, ...r.children);
            const s2 = r.children.length - 1;
            t2 += s2, o += s2;
          } else
            n.children.splice(o, 1), t2--, o--;
      }
    };
    return e;
  }
  function bi() {
    const e = fe;
    if (!e)
      throw new Error(
        "addSpacesToCheckboxes requires ESM dependencies to be initialized"
      );
    const n = (t2) => {
      var o;
      if (t2.children && "length" in t2.children && t2.children.length)
        for (let r = t2.children.length - 1; r >= 0; r--) {
          const s2 = t2.children[r], i = r + 1 < t2.children.length ? t2.children[r + 1] : void 0;
          s2.type === "element" && s2.tagName === "input" && ((o = s2.properties) == null ? void 0 : o.type) === "checkbox" && (i == null ? void 0 : i.type) === "element" && i.tagName === "p" ? (i.tagName = "span", i.children.splice(
            0,
            0,
            e.hastUtilFromDom.fromDom(
              document.createTextNode(" ")
            )
          )) : n(s2);
        }
    };
    return n;
  }
  function Mt(e) {
    const n = fe;
    if (!n)
      throw new Error(
        "cleanHTMLToMarkdown requires ESM dependencies to be initialized"
      );
    return n.unified.unified().use(n.rehypeParse.default, { fragment: true }).use(gi).use(bi).use(n.rehypeRemark.default).use(n.remarkGfm.default).use(n.remarkStringify.default, {
      handlers: { text: (o) => o.value }
    }).processSync(e).value;
  }
  async function ki(e, n, t2, o) {
    await Tt();
    const s2 = Ke(n, t2).exportBlocks(e, o);
    return Mt(s2);
  }
  function wi(e) {
    return Array.prototype.indexOf.call(e.parentElement.childNodes, e);
  }
  function yi(e) {
    return e.nodeType === 3 && !/\S/.test(e.nodeValue || "");
  }
  function Ci(e) {
    e.querySelectorAll("li > ul, li > ol").forEach((n) => {
      const t2 = wi(n), o = n.parentElement, r = Array.from(o.childNodes).slice(
        t2 + 1
      );
      n.remove(), r.forEach((s2) => {
        s2.remove();
      }), o.insertAdjacentElement("afterend", n), r.reverse().forEach((s2) => {
        if (yi(s2))
          return;
        const i = document.createElement("li");
        i.append(s2), n.insertAdjacentElement("afterend", i);
      }), o.childNodes.length === 0 && o.remove();
    });
  }
  function vi(e) {
    e.querySelectorAll("li + ul, li + ol").forEach((n) => {
      var s2, i;
      const t2 = n.previousElementSibling, o = document.createElement("div");
      t2.insertAdjacentElement("afterend", o), o.append(t2);
      const r = document.createElement("div");
      for (r.setAttribute("data-node-type", "blockGroup"), o.append(r); ((s2 = o.nextElementSibling) == null ? void 0 : s2.nodeName) === "UL" || ((i = o.nextElementSibling) == null ? void 0 : i.nodeName) === "OL"; )
        r.append(o.nextElementSibling);
    });
  }
  var Jt = null;
  function Ei() {
    return Jt || (Jt = document.implementation.createHTMLDocument("title"));
  }
  function Kn(e) {
    if (typeof e == "string") {
      const n = Ei().createElement("div");
      n.innerHTML = e, e = n;
    }
    return Ci(e), vi(e), e;
  }
  async function Jn(e, n) {
    const t2 = Kn(e), r = DOMParser2.fromSchema(n).parse(t2, {
      topNode: n.nodes.blockGroup.create()
    }), s2 = [];
    for (let i = 0; i < r.childCount; i++)
      s2.push(E(r.child(i), n));
    return s2;
  }
  function Si(e, n) {
    const t2 = n.value ? n.value : "", o = {};
    n.lang && (o["data-language"] = n.lang);
    let r = {
      type: "element",
      tagName: "code",
      properties: o,
      children: [{ type: "text", value: t2 }]
    };
    return n.meta && (r.data = { meta: n.meta }), e.patch(n, r), r = e.applyData(n, r), r = {
      type: "element",
      tagName: "pre",
      properties: {},
      children: [r]
    }, e.patch(n, r), r;
  }
  async function Xn(e) {
    const n = await Tt();
    return n.unified.unified().use(n.remarkParse.default).use(n.remarkGfm.default).use(n.remarkRehype.default, {
      handlers: {
        ...n.remarkRehype.defaultHandlers,
        code: Si
      }
    }).use(n.rehypeStringify.default).processSync(e).value;
  }
  async function Bi(e, n) {
    const t2 = await Xn(e);
    return Jn(t2, n);
  }
  var Pt = [
    "vscode-editor-data",
    "blocknote/html",
    "text/markdown",
    "text/html",
    "text/plain",
    "Files"
  ];
  function xi(e, n) {
    if (!e.startsWith(".") || !n.startsWith("."))
      throw new Error("The strings provided are not valid file extensions.");
    return e === n;
  }
  function Ti(e, n) {
    const t2 = e.split("/"), o = n.split("/");
    if (t2.length !== 2)
      throw new Error(`The string ${e} is not a valid MIME type.`);
    if (o.length !== 2)
      throw new Error(`The string ${n} is not a valid MIME type.`);
    return t2[1] === "*" || o[1] === "*" ? t2[0] === o[0] : (t2[0] === "*" || o[0] === "*" || t2[0] === o[0]) && t2[1] === o[1];
  }
  function Xt(e, n, t2) {
    let o;
    return Array.isArray(n.content) && n.content.length === 0 ? o = e.updateBlock(n, t2).id : o = e.insertBlocks(
      [t2],
      n,
      "after"
    )[0].id, o;
  }
  async function Yn(e, n) {
    var i;
    if (!n.uploadFile) {
      console.warn(
        "Attempted ot insert file, but uploadFile is not set in the BlockNote editor options"
      );
      return;
    }
    const t2 = "dataTransfer" in e ? e.dataTransfer : e.clipboardData;
    if (t2 === null)
      return;
    let o = null;
    for (const a2 of Pt)
      if (t2.types.includes(a2)) {
        o = a2;
        break;
      }
    if (o !== "Files")
      return;
    const r = t2.items;
    if (!r)
      return;
    e.preventDefault();
    const s2 = Object.values(n.schema.blockSchema).filter(
      (a2) => a2.isFileBlock
    );
    for (let a2 = 0; a2 < r.length; a2++) {
      let c = "file";
      for (const d of s2)
        for (const u of d.fileBlockAccept || []) {
          const h2 = u.startsWith("."), f = r[a2].getAsFile();
          if (f && (!h2 && f.type && Ti(r[a2].type, u) || h2 && xi(
            "." + f.name.split(".").pop(),
            u
          ))) {
            c = d.type;
            break;
          }
        }
      const l = r[a2].getAsFile();
      if (l) {
        const d = {
          type: c,
          props: {
            name: l.name
          }
        };
        let u;
        if (e.type === "paste") {
          const m = n.getTextCursorPosition().block;
          u = Xt(n, m, d);
        } else if (e.type === "drop") {
          const m = {
            left: e.clientX,
            top: e.clientY
          }, g = (i = n.prosemirrorView) == null ? void 0 : i.posAtCoords(m);
          if (!g)
            return;
          u = n.transact((b) => {
            const k = X(b.doc, g.pos);
            return Xt(
              n,
              n.getBlock(k.node.attrs.id),
              d
            );
          });
        } else
          return;
        const h2 = await n.uploadFile(l, u), f = typeof h2 == "string" ? {
          props: {
            url: h2
          }
        } : { ...h2 };
        n.updateBlock(u, f);
      }
    }
  }
  var Mi = (e) => Extension.create({
    name: "dropFile",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          props: {
            handleDOMEvents: {
              drop(n, t2) {
                if (!e.isEditable)
                  return;
                let o = null;
                for (const r of Pt)
                  if (t2.dataTransfer.types.includes(r)) {
                    o = r;
                    break;
                  }
                return o === null ? true : o === "Files" ? (Yn(t2, e), true) : false;
              }
            }
          }
        })
      ];
    }
  }), Pi = /(^|\n) {0,3}#{1,6} {1,8}[^\n]{1,64}\r?\n\r?\n\s{0,32}\S/, Ii = new RegExp("(?:\\s|^)(_|__|\\*|\\*\\*|~~|==|\\+\\+)(?!\\s).{1,64}(?<!\\s)(?=\\1)"), Li = /\[[^\]]{1,128}\]\(https?:\/\/\S{1,999}\)/, Ai = new RegExp("(?:\\s|^)`(?!\\s)[^`]{1,48}(?<!\\s)`([^\\w]|$)"), Ni = /(?:^|\n)\s{0,5}-\s{1}[^\n]+\n\s{0,15}-\s/, Hi = /(?:^|\n)\s{0,5}\d+\.\s{1}[^\n]+\n\s{0,15}\d+\.\s/, Di = /\n{2} {0,3}-{2,48}\n{2}/, Oi = /(?:\n|^)(```|~~~|\$\$)(?!`|~)[^\s]{0,64} {0,64}[^\n]{0,64}\n[\s\S]{0,9999}?\s*\1 {0,64}(?:\n+|$)/, Ri = /(?:\n|^)(?!\s)\w[^\n]{0,64}\r?\n(-|=)\1{0,64}\n\n\s{0,64}(\w|$)/, Vi = /(?:^|(\r?\n\r?\n))( {0,3}>[^\n]{1,333}\n){1,999}($|(\r?\n))/, Ui = /^\s*\|(.+\|)+\s*$/m, _i = /^\s*\|(\s*[-:]+[-:]\s*\|)+\s*$/m, $i = /^\s*\|(.+\|)+\s*$/m, Fi = (e) => Pi.test(e) || Ii.test(e) || Li.test(e) || Ai.test(e) || Ni.test(e) || Hi.test(e) || Di.test(e) || Oi.test(e) || Ri.test(e) || Vi.test(e) || Ui.test(e) || _i.test(e) || $i.test(e);
  async function zi(e, n) {
    const { schema: t2 } = n.state;
    if (!e.clipboardData)
      return false;
    const o = e.clipboardData.getData("text/plain");
    if (!o)
      return false;
    if (!t2.nodes.codeBlock)
      return n.pasteText(o), true;
    const r = e.clipboardData.getData("vscode-editor-data"), s2 = r ? JSON.parse(r) : void 0, i = s2 == null ? void 0 : s2.mode;
    return i ? (n.pasteHTML(
      `<pre><code class="language-${i}">${o.replace(
        /\r\n?/g,
        `
`
      )}</code></pre>`
    ), true) : false;
  }
  function Wi({
    event: e,
    editor: n,
    prioritizeMarkdownOverHTML: t2,
    plainTextAsMarkdown: o
  }) {
    var a2;
    if (n.transact(
      (c) => c.selection.$from.parent.type.spec.code && c.selection.$to.parent.type.spec.code
    )) {
      const c = (a2 = e.clipboardData) == null ? void 0 : a2.getData("text/plain");
      if (c)
        return n.pasteText(c), true;
    }
    let s2;
    for (const c of Pt)
      if (e.clipboardData.types.includes(c)) {
        s2 = c;
        break;
      }
    if (!s2)
      return true;
    if (s2 === "vscode-editor-data")
      return zi(e, n.prosemirrorView), true;
    if (s2 === "Files")
      return Yn(e, n), true;
    const i = e.clipboardData.getData(s2);
    if (s2 === "blocknote/html")
      return n.pasteHTML(i, true), true;
    if (s2 === "text/markdown")
      return n.pasteMarkdown(i), true;
    if (t2) {
      const c = e.clipboardData.getData("text/plain");
      if (Fi(c))
        return n.pasteMarkdown(c), true;
    }
    return s2 === "text/html" ? (n.pasteHTML(i), true) : o ? (n.pasteMarkdown(i), true) : (n.pasteText(i), true);
  }
  var ji = (e, n) => Extension.create({
    name: "pasteFromClipboard",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          props: {
            handleDOMEvents: {
              paste(t2, o) {
                if (o.preventDefault(), !!e.isEditable)
                  return n({
                    event: o,
                    editor: e,
                    defaultPasteHandler: ({
                      prioritizeMarkdownOverHTML: r = true,
                      plainTextAsMarkdown: s2 = true
                    } = {}) => Wi({
                      event: o,
                      editor: e,
                      prioritizeMarkdownOverHTML: r,
                      plainTextAsMarkdown: s2
                    })
                  });
              }
            }
          }
        })
      ];
    }
  });
  function Zn(e) {
    const n = [];
    return e.descendants((t2) => {
      var r, s2;
      const o = M(t2);
      return t2.type.name === "blockContainer" && ((r = t2.firstChild) == null ? void 0 : r.type.name) === "blockGroup" ? true : t2.type.name === "columnList" && t2.childCount === 1 ? ((s2 = t2.firstChild) == null || s2.forEach((i) => {
        n.push(E(i, o));
      }), false) : t2.type.isInGroup("bnBlock") ? (n.push(E(t2, o)), false) : true;
    }), n;
  }
  function Gi(e, n, t2) {
    var a2;
    let o = false;
    const r = e.state.selection instanceof CellSelection;
    if (!r) {
      const c = e.state.doc.slice(
        e.state.selection.from,
        e.state.selection.to,
        false
      ).content, l = [];
      for (let d = 0; d < c.childCount; d++)
        l.push(c.child(d));
      o = l.find(
        (d) => d.type.isInGroup("bnBlock") || d.type.name === "blockGroup" || d.type.spec.group === "blockContent"
      ) === void 0, o && (n = c);
    }
    let s2;
    const i = Ke(
      e.state.schema,
      t2
    );
    if (r) {
      ((a2 = n.firstChild) == null ? void 0 : a2.type.name) === "table" && (n = n.firstChild.content);
      const c = kn(
        n,
        t2.schema.inlineContentSchema,
        t2.schema.styleSchema
      );
      s2 = `<table>${i.exportInlineContent(
        c,
        {}
      )}</table>`;
    } else if (o) {
      const c = Ge(
        n,
        t2.schema.inlineContentSchema,
        t2.schema.styleSchema
      );
      s2 = i.exportInlineContent(c, {});
    } else {
      const c = Zn(n);
      s2 = i.exportBlocks(c, {});
    }
    return s2;
  }
  function Qn(e, n) {
    "node" in e.state.selection && e.state.selection.node.type.spec.group === "blockContent" && n.transact(
      (i) => i.setSelection(
        new NodeSelection(i.doc.resolve(e.state.selection.from - 1))
      )
    );
    const t2 = e.serializeForClipboard(
      e.state.selection.content()
    ).dom.innerHTML, o = e.state.selection.content().content, r = Gi(
      e,
      o,
      n
    ), s2 = Mt(r);
    return { clipboardHTML: t2, externalHTML: r, markdown: s2 };
  }
  var Yt = () => {
    const e = window.getSelection();
    if (!e || e.isCollapsed)
      return true;
    let n = e.focusNode;
    for (; n; ) {
      if (n instanceof HTMLElement && n.getAttribute("contenteditable") === "false")
        return true;
      n = n.parentElement;
    }
    return false;
  }, Zt = (e, n, t2) => {
    t2.preventDefault(), t2.clipboardData.clearData();
    const { clipboardHTML: o, externalHTML: r, markdown: s2 } = Qn(
      n,
      e
    );
    t2.clipboardData.setData("blocknote/html", o), t2.clipboardData.setData("text/html", r), t2.clipboardData.setData("text/plain", s2);
  }, qi = (e) => Extension.create({
    name: "copyToClipboard",
    addProseMirrorPlugins() {
      return [
        new Plugin({
          props: {
            handleDOMEvents: {
              copy(n, t2) {
                return Yt() || Zt(e, n, t2), true;
              },
              cut(n, t2) {
                return Yt() || (Zt(e, n, t2), n.editable && n.dispatch(n.state.tr.deleteSelection())), true;
              },
              // This is for the use-case in which only a block without content
              // is selected, e.g. an image block, and dragged (not using the
              // drag handle).
              dragstart(n, t2) {
                if (!("node" in n.state.selection) || n.state.selection.node.type.spec.group !== "blockContent")
                  return;
                e.transact(
                  (i) => i.setSelection(
                    new NodeSelection(
                      i.doc.resolve(n.state.selection.from - 1)
                    )
                  )
                ), t2.preventDefault(), t2.dataTransfer.clearData();
                const { clipboardHTML: o, externalHTML: r, markdown: s2 } = Qn(n, e);
                return t2.dataTransfer.setData("blocknote/html", o), t2.dataTransfer.setData("text/html", r), t2.dataTransfer.setData("text/plain", s2), true;
              }
            }
          }
        })
      ];
    }
  }), Ki = Extension.create({
    name: "blockBackgroundColor",
    addGlobalAttributes() {
      return [
        {
          types: ["blockContainer", "tableCell", "tableHeader"],
          attributes: {
            backgroundColor: {
              default: T.backgroundColor.default,
              parseHTML: (e) => e.hasAttribute("data-background-color") ? e.getAttribute("data-background-color") : T.backgroundColor.default,
              renderHTML: (e) => e.backgroundColor === T.backgroundColor.default ? {} : {
                "data-background-color": e.backgroundColor
              }
            }
          }
        }
      ];
    }
  });
  var It = class {
    constructor() {
      p4(this, "callbacks", {});
    }
    on(n, t2) {
      return this.callbacks[n] || (this.callbacks[n] = []), this.callbacks[n].push(t2), () => this.off(n, t2);
    }
    emit(n, ...t2) {
      const o = this.callbacks[n];
      o && o.forEach((r) => r.apply(this, t2));
    }
    off(n, t2) {
      const o = this.callbacks[n];
      o && (t2 ? this.callbacks[n] = o.filter((r) => r !== t2) : delete this.callbacks[n]);
    }
    removeAllListeners() {
      this.callbacks = {};
    }
  };
  var L = class extends It {
    // eslint-disable-next-line
    constructor(...t2) {
      super();
      p4(this, "plugins", []);
    }
    static key() {
      throw new Error("You must implement the key method in your extension");
    }
    addProsemirrorPlugin(t2) {
      this.plugins.push(t2);
    }
    get priority() {
    }
  };
  var $e = class $e2 extends L {
    constructor(t2) {
      super();
      p4(this, "provider");
      p4(this, "recentlyUpdatedCursors");
      p4(this, "renderCursor", (t3, o) => {
        let r = this.recentlyUpdatedCursors.get(o);
        if (!r) {
          const s2 = (this.collaboration.renderCursor ?? $e2.defaultCursorRender)(t3);
          this.collaboration.showCursorLabels !== "always" && (s2.addEventListener("mouseenter", () => {
            const i = this.recentlyUpdatedCursors.get(o);
            i.element.setAttribute("data-active", ""), i.hideTimeout && (clearTimeout(i.hideTimeout), this.recentlyUpdatedCursors.set(o, {
              element: i.element,
              hideTimeout: void 0
            }));
          }), s2.addEventListener("mouseleave", () => {
            const i = this.recentlyUpdatedCursors.get(o);
            this.recentlyUpdatedCursors.set(o, {
              element: i.element,
              hideTimeout: setTimeout(() => {
                i.element.removeAttribute("data-active");
              }, 2e3)
            });
          })), r = {
            element: s2,
            hideTimeout: void 0
          }, this.recentlyUpdatedCursors.set(o, r);
        }
        return r.element;
      });
      p4(this, "updateUser", (t3) => {
        this.provider.awareness.setLocalStateField("user", t3);
      });
      this.collaboration = t2, this.provider = t2.provider, this.recentlyUpdatedCursors = /* @__PURE__ */ new Map(), this.provider.awareness.setLocalStateField("user", t2.user), t2.showCursorLabels !== "always" && this.provider.awareness.on(
        "change",
        ({
          updated: o
        }) => {
          for (const r of o) {
            const s2 = this.recentlyUpdatedCursors.get(r);
            s2 && (s2.element.setAttribute("data-active", ""), s2.hideTimeout && clearTimeout(s2.hideTimeout), this.recentlyUpdatedCursors.set(r, {
              element: s2.element,
              hideTimeout: setTimeout(() => {
                s2.element.removeAttribute("data-active");
              }, 2e3)
            }));
          }
        }
      ), this.addProsemirrorPlugin(
        yCursorPlugin(this.provider.awareness, {
          selectionBuilder: defaultSelectionBuilder,
          cursorBuilder: this.renderCursor
        })
      );
    }
    static key() {
      return "yCursorPlugin";
    }
    get priority() {
      return 999;
    }
  };
  p4($e, "defaultCursorRender", (t2) => {
    const o = document.createElement("span");
    o.classList.add("bn-collaboration-cursor__base");
    const r = document.createElement("span");
    r.setAttribute("contentedEditable", "false"), r.classList.add("bn-collaboration-cursor__caret"), r.setAttribute("style", `background-color: ${t2.color}`);
    const s2 = document.createElement("span");
    return s2.classList.add("bn-collaboration-cursor__label"), s2.setAttribute("style", `background-color: ${t2.color}`), s2.insertBefore(document.createTextNode(t2.name), null), r.insertBefore(s2, null), o.insertBefore(document.createTextNode("\u2060"), null), o.insertBefore(r, null), o.insertBefore(document.createTextNode("\u2060"), null), o;
  });
  var Ue = $e;
  var ht = class extends L {
    static key() {
      return "ySyncPlugin";
    }
    constructor(n) {
      super(), this.addProsemirrorPlugin(ySyncPlugin(n));
    }
    get priority() {
      return 1001;
    }
  };
  var ft = class extends L {
    static key() {
      return "yUndoPlugin";
    }
    constructor() {
      super(), this.addProsemirrorPlugin(yUndoPlugin());
    }
    get priority() {
      return 1e3;
    }
  };
  var eo = Mark2.create({
    name: "comment",
    excludes: "",
    inclusive: false,
    keepOnSplit: true,
    addAttributes() {
      return {
        // orphans are marks that currently don't have an active thread. It could be
        // that users have resolved the thread. Resolved threads by default are not shown in the document,
        // but we need to keep the mark (positioning) data so we can still "revive" it when the thread is unresolved
        // or we enter a "comments" view that includes resolved threads.
        orphan: {
          parseHTML: (e) => !!e.getAttribute("data-orphan"),
          renderHTML: (e) => e.orphan ? {
            "data-orphan": "true"
          } : {},
          default: false
        },
        threadId: {
          parseHTML: (e) => e.getAttribute("data-bn-thread-id"),
          renderHTML: (e) => ({
            "data-bn-thread-id": e.threadId
          }),
          default: ""
        }
      };
    },
    renderHTML({ HTMLAttributes: e }) {
      return [
        "span",
        mergeAttributes(e, {
          class: "bn-thread-mark"
        })
      ];
    },
    parseHTML() {
      return [{ tag: "span.bn-thread-mark" }];
    },
    extendMarkSchema(e) {
      return e.name === "comment" ? {
        blocknoteIgnore: true
      } : {};
    }
  });
  var Ji = class extends It {
    constructor(t2) {
      super();
      p4(this, "userCache", /* @__PURE__ */ new Map());
      p4(this, "loadingUsers", /* @__PURE__ */ new Set());
      this.resolveUsers = t2;
    }
    /**
     * Load information about users based on an array of user ids.
     */
    async loadUsers(t2) {
      const o = t2.filter(
        (r) => !this.userCache.has(r) && !this.loadingUsers.has(r)
      );
      if (o.length !== 0) {
        for (const r of o)
          this.loadingUsers.add(r);
        try {
          const r = await this.resolveUsers(o);
          for (const s2 of r)
            this.userCache.set(s2.id, s2);
          this.emit("update", this.userCache);
        } finally {
          for (const r of o)
            this.loadingUsers.delete(r);
        }
      }
    }
    /**
     * Retrieve information about a user based on their id, if cached.
     *
     * The user will have to be loaded via `loadUsers` first
     */
    getUser(t2) {
      return this.userCache.get(t2);
    }
    /**
     * Subscribe to changes in the user store.
     *
     * @param cb - The callback to call when the user store changes.
     * @returns A function to unsubscribe from the user store.
     */
    subscribe(t2) {
      return this.on("update", t2);
    }
  };
  var Le = new PluginKey("blocknote-comments"), Xi = "SET_SELECTED_THREAD_ID";
  function Yi(e, n) {
    const t2 = /* @__PURE__ */ new Map();
    return e.descendants((o, r) => {
      o.marks.forEach((s2) => {
        if (s2.type.name === n) {
          const i = s2.attrs.threadId;
          if (!i)
            return;
          const a2 = r, c = a2 + o.nodeSize, l = t2.get(i) ?? {
            from: 1 / 0,
            to: 0
          };
          t2.set(i, {
            from: Math.min(a2, l.from),
            to: Math.max(c, l.to)
          });
        }
      });
    }), t2;
  }
  var Zi = class extends L {
    constructor(t2, o, r) {
      super();
      p4(this, "userStore");
      p4(this, "pendingComment", false);
      p4(this, "selectedThreadId");
      p4(this, "threadPositions", /* @__PURE__ */ new Map());
      p4(this, "updateMarksFromThreads", (t3) => {
        this.editor.transact((o2) => {
          o2.doc.descendants((r2, s3) => {
            r2.marks.forEach((i) => {
              if (i.type.name === this.markType) {
                const a2 = i.type, c = i.attrs.threadId, l = t3.get(c), d = !!(!l || l.resolved || l.deletedAt);
                if (d !== i.attrs.orphan) {
                  const u = Math.max(s3, 0), h2 = Math.min(
                    s3 + r2.nodeSize,
                    o2.doc.content.size - 1,
                    o2.doc.content.size - 1
                  );
                  o2.removeMark(u, h2, i), o2.addMark(
                    u,
                    h2,
                    a2.create({
                      ...i.attrs,
                      orphan: d
                    })
                  ), d && this.selectedThreadId === c && (this.selectedThreadId = void 0, this.emitStateUpdate());
                }
              }
            });
          });
        });
      });
      if (this.editor = t2, this.threadStore = o, this.markType = r, !t2.resolveUsers)
        throw new Error("resolveUsers is required for comments");
      this.userStore = new Ji(t2.resolveUsers), this.threadStore.subscribe(this.updateMarksFromThreads), t2.onCreate(() => {
        this.updateMarksFromThreads(this.threadStore.getThreads()), t2.onSelectionChange(() => {
          this.pendingComment && (this.pendingComment = false, this.emitStateUpdate());
        });
      });
      const s2 = this;
      this.addProsemirrorPlugin(
        new Plugin({
          key: Le,
          state: {
            init() {
              return {
                decorations: DecorationSet.empty
              };
            },
            apply(i, a2) {
              const c = i.getMeta(Le);
              if (!i.docChanged && !c)
                return a2;
              const l = i.docChanged ? Yi(i.doc, s2.markType) : s2.threadPositions;
              (l.size > 0 || s2.threadPositions.size > 0) && (s2.threadPositions = l, s2.emitStateUpdate());
              const d = [];
              if (s2.selectedThreadId) {
                const u = l.get(
                  s2.selectedThreadId
                );
                u && d.push(
                  Decoration.inline(
                    u.from,
                    u.to,
                    {
                      class: "bn-thread-mark-selected"
                    }
                  )
                );
              }
              return {
                decorations: DecorationSet.create(i.doc, d)
              };
            }
          },
          props: {
            decorations(i) {
              var a2;
              return ((a2 = Le.getState(i)) == null ? void 0 : a2.decorations) ?? DecorationSet.empty;
            },
            /**
             * Handle click on a thread mark and mark it as selected
             */
            handleClick: (i, a2, c) => {
              if (c.button !== 0)
                return;
              const l = i.state.doc.nodeAt(a2);
              if (!l) {
                s2.selectThread(void 0);
                return;
              }
              const d = l.marks.find(
                (h2) => h2.type.name === r && h2.attrs.orphan !== true
              ), u = d == null ? void 0 : d.attrs.threadId;
              s2.selectThread(u, false);
            }
          }
        })
      );
    }
    static key() {
      return "comments";
    }
    emitStateUpdate() {
      this.emit("update", {
        selectedThreadId: this.selectedThreadId,
        pendingComment: this.pendingComment,
        threadPositions: this.threadPositions
      });
    }
    /**
     * Subscribe to state updates
     */
    onUpdate(t2) {
      return this.on("update", t2);
    }
    /**
     * Set the selected thread
     */
    selectThread(t2, o = true) {
      var r, s2;
      if (this.selectedThreadId !== t2 && (this.selectedThreadId = t2, this.emitStateUpdate(), this.editor.transact(
        (i) => i.setMeta(Le, {
          name: Xi
        })
      ), t2 && o)) {
        const i = this.threadPositions.get(t2);
        if (!i)
          return;
        (s2 = (r = this.editor.prosemirrorView) == null ? void 0 : r.domAtPos(i.from).node) == null || s2.scrollIntoView({
          behavior: "smooth",
          block: "center"
        });
      }
    }
    /**
     * Start a pending comment (e.g.: when clicking the "Add comment" button)
     */
    startPendingComment() {
      this.pendingComment = true, this.emitStateUpdate();
    }
    /**
     * Stop a pending comment (e.g.: user closes the comment composer)
     */
    stopPendingComment() {
      this.pendingComment = false, this.emitStateUpdate();
    }
    /**
     * Create a thread at the current selection
     */
    async createThread(t2) {
      const o = await this.threadStore.createThread(t2);
      if (this.threadStore.addThreadToDocument) {
        const r = this.editor.prosemirrorView, s2 = r.state.selection, i = ySyncPluginKey.getState(r.state), a2 = {
          prosemirror: {
            head: s2.head,
            anchor: s2.anchor
          },
          yjs: i ? getRelativeSelection(i.binding, r.state) : void 0
          // if we're not using yjs
        };
        await this.threadStore.addThreadToDocument({
          threadId: o.id,
          selection: a2
        });
      } else
        this.editor._tiptapEditor.commands.setMark(this.markType, {
          orphan: false,
          threadId: o.id
        });
    }
  };
  var Qi = class {
    constructor(n, t2, o, r) {
      p4(this, "state");
      p4(this, "emitUpdate");
      p4(this, "mouseDownHandler", () => {
        var n2;
        (n2 = this.state) != null && n2.show && (this.state.show = false, this.emitUpdate());
      });
      p4(this, "dragstartHandler", () => {
        var n2;
        (n2 = this.state) != null && n2.show && (this.state.show = false, this.emitUpdate());
      });
      p4(this, "scrollHandler", () => {
        var n2;
        if ((n2 = this.state) != null && n2.show) {
          const t3 = this.pmView.root.querySelector(
            `[data-node-type="blockContainer"][data-id="${this.state.block.id}"]`
          );
          if (!t3)
            return;
          this.state.referencePos = t3.getBoundingClientRect(), this.emitUpdate();
        }
      });
      p4(this, "closeMenu", () => {
        var n2;
        (n2 = this.state) != null && n2.show && (this.state.show = false, this.emitUpdate());
      });
      this.editor = n, this.pluginKey = t2, this.pmView = o, this.emitUpdate = () => {
        if (!this.state)
          throw new Error("Attempting to update uninitialized file panel");
        r(this.state);
      }, o.dom.addEventListener("mousedown", this.mouseDownHandler), o.dom.addEventListener("dragstart", this.dragstartHandler), o.root.addEventListener("scroll", this.scrollHandler, true);
    }
    update(n, t2) {
      var a2, c;
      const o = this.pluginKey.getState(n.state), r = this.pluginKey.getState(t2);
      if (!((a2 = this.state) != null && a2.show) && (o != null && o.block) && this.editor.isEditable) {
        const l = this.pmView.root.querySelector(
          `[data-node-type="blockContainer"][data-id="${o.block.id}"]`
        );
        if (!l)
          return;
        this.state = {
          show: true,
          referencePos: l.getBoundingClientRect(),
          block: o.block
        }, this.emitUpdate();
        return;
      }
      const s2 = (o == null ? void 0 : o.block) && !(r != null && r.block), i = !(o != null && o.block) && (r == null ? void 0 : r.block);
      s2 && this.state && !this.state.show && (this.state.show = true, this.emitUpdate()), i && ((c = this.state) != null && c.show) && (this.state.show = false, this.emitUpdate());
    }
    destroy() {
      this.pmView.dom.removeEventListener("mousedown", this.mouseDownHandler), this.pmView.dom.removeEventListener("dragstart", this.dragstartHandler), this.pmView.root.removeEventListener("scroll", this.scrollHandler, true);
    }
  };
  var et = new PluginKey(
    "FilePanelPlugin"
  );
  var ea = class extends L {
    constructor(t2) {
      super();
      p4(this, "view");
      p4(this, "closeMenu", () => {
        var t3;
        return (t3 = this.view) == null ? void 0 : t3.closeMenu();
      });
      this.addProsemirrorPlugin(
        new Plugin({
          key: et,
          view: (o) => (this.view = new Qi(
            t2,
            et,
            o,
            (r) => {
              this.emit("update", r);
            }
          ), this.view),
          props: {
            handleKeyDown: (o, r) => {
              var s2;
              return r.key === "Escape" && this.shown ? ((s2 = this.view) == null || s2.closeMenu(), true) : false;
            }
          },
          state: {
            init: () => ({
              block: void 0
            }),
            apply: (o, r) => {
              const s2 = o.getMeta(et);
              return s2 || (!o.getMeta(ySyncPluginKey) && (o.selectionSet || o.docChanged) ? { block: void 0 } : r);
            }
          }
        })
      );
    }
    static key() {
      return "filePanel";
    }
    get shown() {
      var t2, o;
      return ((o = (t2 = this.view) == null ? void 0 : t2.state) == null ? void 0 : o.show) || false;
    }
    onUpdate(t2) {
      return this.on("update", t2);
    }
  };
  var ta2 = class {
    constructor(n, t2, o) {
      p4(this, "state");
      p4(this, "emitUpdate");
      p4(this, "preventHide", false);
      p4(this, "preventShow", false);
      p4(this, "shouldShow", ({ view: n2, state: t3, from: o2, to: r }) => {
        const { doc: s2, selection: i } = t3, { empty: a2 } = i, c = !s2.textBetween(o2, r).length && isTextSelection(t3.selection);
        if (i.$from.parent.type.spec.code || isNodeSelection(i) && i.node.type.spec.code || a2 || c)
          return false;
        const l = document.activeElement;
        return !(!this.isElementWithinEditorWrapper(l) && n2.editable);
      });
      p4(this, "blurHandler", (n2) => {
        var o2;
        if (this.preventHide) {
          this.preventHide = false;
          return;
        }
        const t3 = this.pmView.dom.parentElement;
        n2 && n2.relatedTarget && // Element is inside the editor.
        (t3 === n2.relatedTarget || t3.contains(n2.relatedTarget) || n2.relatedTarget.matches(
          ".bn-ui-container, .bn-ui-container *"
        )) || (o2 = this.state) != null && o2.show && (this.state.show = false, this.emitUpdate());
      });
      p4(this, "isElementWithinEditorWrapper", (n2) => {
        if (!n2)
          return false;
        const t3 = this.pmView.dom.parentElement;
        return t3 ? t3.contains(n2) : false;
      });
      p4(this, "viewMousedownHandler", (n2) => {
        this.isElementWithinEditorWrapper(n2.target) || (this.preventShow = true);
      });
      p4(this, "mouseupHandler", () => {
        this.preventShow && (this.preventShow = false, setTimeout(() => this.update(this.pmView)));
      });
      p4(this, "dragHandler", () => {
        var n2;
        (n2 = this.state) != null && n2.show && (this.state.show = false, this.emitUpdate());
      });
      p4(this, "scrollHandler", () => {
        var n2;
        (n2 = this.state) != null && n2.show && (this.state.referencePos = this.getSelectionBoundingBox(), this.emitUpdate());
      });
      p4(this, "closeMenu", () => {
        var n2;
        (n2 = this.state) != null && n2.show && (this.state.show = false, this.emitUpdate());
      });
      this.editor = n, this.pmView = t2, this.emitUpdate = () => {
        if (!this.state)
          throw new Error(
            "Attempting to update uninitialized formatting toolbar"
          );
        o(this.state);
      }, t2.dom.addEventListener("mousedown", this.viewMousedownHandler), t2.root.addEventListener("mouseup", this.mouseupHandler), t2.dom.addEventListener("dragstart", this.dragHandler), t2.dom.addEventListener("dragover", this.dragHandler), t2.dom.addEventListener("blur", this.blurHandler), t2.root.addEventListener("scroll", this.scrollHandler, true);
    }
    update(n, t2) {
      var f, m, g;
      const { state: o, composing: r } = n, { doc: s2, selection: i } = o, a2 = t2 && t2.doc.eq(s2) && t2.selection.eq(i);
      if (r || a2)
        return;
      const { ranges: c } = i, l = Math.min(...c.map((b) => b.$from.pos)), d = Math.max(...c.map((b) => b.$to.pos)), u = this.shouldShow({
        view: n,
        state: o,
        from: l,
        to: d
      }), h2 = typeof Range.prototype.getClientRects > "u";
      if (!this.preventShow && (u || this.preventHide) && !h2) {
        const b = {
          show: true,
          referencePos: this.getSelectionBoundingBox()
        };
        (b.show !== ((f = this.state) == null ? void 0 : f.show) || b.referencePos.toJSON() !== ((m = this.state) == null ? void 0 : m.referencePos.toJSON())) && (this.state = b, this.emitUpdate());
        return;
      }
      if ((g = this.state) != null && g.show && !this.preventHide && (!u || this.preventShow || !this.editor.isEditable)) {
        this.state.show = false, this.emitUpdate();
        return;
      }
    }
    destroy() {
      this.pmView.dom.removeEventListener("mousedown", this.viewMousedownHandler), this.pmView.root.removeEventListener("mouseup", this.mouseupHandler), this.pmView.dom.removeEventListener("dragstart", this.dragHandler), this.pmView.dom.removeEventListener("dragover", this.dragHandler), this.pmView.dom.removeEventListener("blur", this.blurHandler), this.pmView.root.removeEventListener("scroll", this.scrollHandler, true);
    }
    getSelectionBoundingBox() {
      const { state: n } = this.pmView, { selection: t2 } = n, { ranges: o } = t2, r = Math.min(...o.map((i) => i.$from.pos)), s2 = Math.max(...o.map((i) => i.$to.pos));
      if (isNodeSelection(t2)) {
        const i = this.pmView.nodeDOM(r);
        if (i)
          return i.getBoundingClientRect();
      }
      return posToDOMRect(this.pmView, r, s2);
    }
  };
  var na = new PluginKey(
    "FormattingToolbarPlugin"
  );
  var oa = class extends L {
    constructor(t2) {
      super();
      p4(this, "view");
      p4(this, "closeMenu", () => this.view.closeMenu());
      this.addProsemirrorPlugin(
        new Plugin({
          key: na,
          view: (o) => (this.view = new ta2(t2, o, (r) => {
            this.emit("update", r);
          }), this.view),
          props: {
            handleKeyDown: (o, r) => r.key === "Escape" && this.shown ? (this.view.closeMenu(), true) : false
          }
        })
      );
    }
    static key() {
      return "formattingToolbar";
    }
    get shown() {
      var t2, o;
      return ((o = (t2 = this.view) == null ? void 0 : t2.state) == null ? void 0 : o.show) || false;
    }
    onUpdate(t2) {
      return this.on("update", t2);
    }
  };
  var ra = Node3.create({
    name: "hardBreak",
    inline: true,
    group: "inline",
    selectable: false,
    linebreakReplacement: true,
    priority: 10,
    parseHTML() {
      return [{ tag: "br" }];
    },
    renderHTML({ HTMLAttributes: e }) {
      return ["br", mergeAttributes(this.options.HTMLAttributes, e)];
    },
    renderText() {
      return `
`;
    }
  }), Qt = (e, n) => {
    const t2 = e.resolve(n);
    if (t2.depth <= 1)
      return;
    const o = t2.posAtIndex(
      t2.index(t2.depth - 1),
      t2.depth - 1
    );
    return Te(
      e.resolve(o)
    );
  }, Oe = (e, n) => {
    const t2 = e.resolve(n), o = t2.index();
    if (o === 0)
      return;
    const r = t2.posAtIndex(o - 1);
    return Te(
      e.resolve(r)
    );
  }, to = (e, n) => {
    for (; n.childContainer; ) {
      const t2 = n.childContainer.node, o = e.resolve(n.childContainer.beforePos + 1).posAtIndex(t2.childCount - 1);
      n = Te(e.resolve(o));
    }
    return n;
  }, sa = (e, n) => e.isBlockContainer && e.blockContent.node.type.spec.content === "inline*" && e.blockContent.node.childCount > 0 && n.isBlockContainer && n.blockContent.node.type.spec.content === "inline*", ia = (e, n, t2, o) => {
    if (!o.isBlockContainer)
      throw new Error(
        `Attempted to merge block at position ${o.bnBlock.beforePos} into previous block at position ${t2.bnBlock.beforePos}, but next block is not a block container`
      );
    if (o.childContainer) {
      const r = e.doc.resolve(
        o.childContainer.beforePos + 1
      ), s2 = e.doc.resolve(
        o.childContainer.afterPos - 1
      ), i = r.blockRange(s2);
      if (n) {
        const a2 = e.doc.resolve(o.bnBlock.beforePos);
        e.tr.lift(i, a2.depth);
      }
    }
    if (n) {
      if (!t2.isBlockContainer)
        throw new Error(
          `Attempted to merge block at position ${o.bnBlock.beforePos} into previous block at position ${t2.bnBlock.beforePos}, but previous block is not a block container`
        );
      n(
        e.tr.delete(
          t2.blockContent.afterPos - 1,
          o.blockContent.beforePos + 1
        )
      );
    }
    return true;
  }, en = (e) => ({
    state: n,
    dispatch: t2
  }) => {
    const o = n.doc.resolve(e), r = Te(o), s2 = Oe(
      n.doc,
      r.bnBlock.beforePos
    );
    if (!s2)
      return false;
    const i = to(
      n.doc,
      s2
    );
    return sa(i, r) ? ia(n, t2, i, r) : false;
  }, aa = Extension.create({
    priority: 50,
    // TODO: The shortcuts need a refactor. Do we want to use a command priority
    //  design as there is now, or clump the logic into a single function?
    addKeyboardShortcuts() {
      const e = () => this.editor.commands.first(({ chain: o, commands: r }) => [
        // Deletes the selection if it's not empty.
        () => r.deleteSelection(),
        // Undoes an input rule if one was triggered in the last editor state change.
        () => r.undoInputRule(),
        // Reverts block content type to a paragraph if the selection is at the start of the block.
        () => r.command(({ state: s2 }) => {
          const i = v(s2);
          if (!i.isBlockContainer)
            return false;
          const a2 = s2.selection.from === i.blockContent.beforePos + 1, c = i.blockContent.node.type.name === "paragraph";
          return a2 && !c ? r.command(
            I(i.bnBlock.beforePos, {
              type: "paragraph",
              props: {}
            })
          ) : false;
        }),
        // Removes a level of nesting if the block is indented if the selection is at the start of the block.
        () => r.command(({ state: s2 }) => {
          const i = v(s2);
          if (!i.isBlockContainer)
            return false;
          const { blockContent: a2 } = i;
          return s2.selection.from === a2.beforePos + 1 ? r.liftListItem("blockContainer") : false;
        }),
        // Merges block with the previous one if it isn't indented, and the selection is at the start of the
        // block. The target block for merging must contain inline content.
        () => r.command(({ state: s2 }) => {
          const i = v(s2);
          if (!i.isBlockContainer)
            return false;
          const { bnBlock: a2, blockContent: c } = i, l = s2.selection.from === c.beforePos + 1, d = s2.selection.empty, u = a2.beforePos;
          return l && d ? o().command(en(u)).scrollIntoView().run() : false;
        }),
        () => r.command(({ state: s2, dispatch: i }) => {
          const a2 = v(s2);
          if (!a2.isBlockContainer || !(s2.selection.from === a2.blockContent.beforePos + 1) || Oe(
            s2.doc,
            a2.bnBlock.beforePos
          ))
            return false;
          const d = Qt(
            s2.doc,
            a2.bnBlock.beforePos
          );
          if ((d == null ? void 0 : d.blockNoteType) !== "column")
            return false;
          const u = d, h2 = Qt(
            s2.doc,
            u.bnBlock.beforePos
          );
          if ((h2 == null ? void 0 : h2.blockNoteType) !== "columnList")
            throw new Error("parent of column is not a column list");
          const f = u.childContainer.node.childCount === 1, m = f && h2.childContainer.node.childCount === 2, g = h2.childContainer.node.firstChild === u.bnBlock.node;
          if (i) {
            const b = s2.doc.slice(
              a2.bnBlock.beforePos,
              a2.bnBlock.afterPos,
              false
            );
            if (m)
              if (g) {
                s2.tr.step(
                  new ReplaceAroundStep(
                    // replace entire column list
                    h2.bnBlock.beforePos,
                    h2.bnBlock.afterPos,
                    // select content of remaining column:
                    u.bnBlock.afterPos + 1,
                    h2.bnBlock.afterPos - 2,
                    b,
                    b.size,
                    // append existing content to blockToMove
                    false
                  )
                );
                const k = s2.tr.doc.resolve(u.bnBlock.beforePos);
                s2.tr.setSelection(TextSelection.between(k, k));
              } else {
                s2.tr.step(
                  new ReplaceAroundStep(
                    // replace entire column list
                    h2.bnBlock.beforePos,
                    h2.bnBlock.afterPos,
                    // select content of existing column:
                    h2.bnBlock.beforePos + 2,
                    u.bnBlock.beforePos - 1,
                    b,
                    0,
                    // prepend existing content to blockToMove
                    false
                  )
                );
                const k = s2.tr.doc.resolve(
                  s2.tr.mapping.map(u.bnBlock.beforePos - 1)
                );
                s2.tr.setSelection(TextSelection.between(k, k));
              }
            else if (f)
              if (g) {
                s2.tr.delete(
                  u.bnBlock.beforePos,
                  u.bnBlock.afterPos
                ), s2.tr.insert(
                  h2.bnBlock.beforePos,
                  b.content
                );
                const k = s2.tr.doc.resolve(
                  h2.bnBlock.beforePos
                );
                s2.tr.setSelection(TextSelection.between(k, k));
              } else
                s2.tr.delete(
                  u.bnBlock.beforePos - 1,
                  u.bnBlock.beforePos + 1
                );
            else {
              s2.tr.delete(
                a2.bnBlock.beforePos,
                a2.bnBlock.afterPos
              ), g ? s2.tr.insert(
                h2.bnBlock.beforePos - 1,
                b.content
              ) : s2.tr.insert(
                u.bnBlock.beforePos - 1,
                b.content
              );
              const k = s2.tr.doc.resolve(u.bnBlock.beforePos - 1);
              s2.tr.setSelection(TextSelection.between(k, k));
            }
          }
          return true;
        }),
        // Deletes the current block if it's an empty block with inline content,
        // and moves the selection to the previous block.
        () => r.command(({ state: s2 }) => {
          const i = v(s2);
          if (!i.isBlockContainer)
            return false;
          if (i.blockContent.node.childCount === 0 && i.blockContent.node.type.spec.content === "inline*") {
            const c = Oe(
              s2.doc,
              i.bnBlock.beforePos
            );
            if (!c || !c.isBlockContainer)
              return false;
            let l = o();
            if (c.blockContent.node.type.spec.content === "tableRow+") {
              const m = i.bnBlock.beforePos - 1 - 1 - 1 - 1 - 1;
              l = l.setTextSelection(
                m
              );
            } else if (c.blockContent.node.type.spec.content === "") {
              const d = c.blockContent.afterPos - c.blockContent.node.nodeSize;
              l = l.setNodeSelection(
                d
              );
            } else {
              const d = c.blockContent.afterPos - c.blockContent.node.nodeSize;
              l = l.setTextSelection(d);
            }
            return l.deleteRange({
              from: i.bnBlock.beforePos,
              to: i.bnBlock.afterPos
            }).scrollIntoView().run();
          }
          return false;
        }),
        // Deletes previous block if it contains no content and isn't a table,
        // when the selection is empty and at the start of the block. Moves the
        // current block into the deleted block's place.
        () => r.command(({ state: s2 }) => {
          const i = v(s2);
          if (!i.isBlockContainer)
            throw new Error("todo");
          const a2 = s2.selection.from === i.blockContent.beforePos + 1, c = s2.selection.empty, l = Oe(
            s2.doc,
            i.bnBlock.beforePos
          );
          if (l && a2 && c) {
            const d = to(
              s2.doc,
              l
            );
            if (!d.isBlockContainer)
              throw new Error("todo");
            if (d.blockContent.node.type.spec.content === "" || d.blockContent.node.type.spec.content === "inline*" && d.blockContent.node.childCount === 0)
              return o().cut(
                {
                  from: i.bnBlock.beforePos,
                  to: i.bnBlock.afterPos
                },
                d.bnBlock.afterPos
              ).deleteRange({
                from: d.bnBlock.beforePos,
                to: d.bnBlock.afterPos
              }).run();
          }
          return false;
        })
      ]), n = () => this.editor.commands.first(({ commands: o }) => [
        // Deletes the selection if it's not empty.
        () => o.deleteSelection(),
        // Merges block with the next one (at the same nesting level or lower),
        // if one exists, the block has no children, and the selection is at the
        // end of the block.
        () => o.command(({ state: r }) => {
          const s2 = v(r);
          if (!s2.isBlockContainer)
            return false;
          const {
            bnBlock: i,
            blockContent: a2,
            childContainer: c
          } = s2, { depth: l } = r.doc.resolve(i.beforePos), d = i.afterPos === r.doc.nodeSize - 3, u = r.selection.from === a2.afterPos - 1, h2 = r.selection.empty;
          if (!d && u && h2 && !(c !== void 0)) {
            let m = l, g = i.afterPos + 1, b = r.doc.resolve(g).depth;
            for (; b < m; )
              m = b, g += 2, b = r.doc.resolve(g).depth;
            return o.command(en(g - 1));
          }
          return false;
        })
      ]), t2 = (o = false) => this.editor.commands.first(({ commands: r }) => [
        // Removes a level of nesting if the block is empty & indented, while the selection is also empty & at the start
        // of the block.
        () => r.command(({ state: s2 }) => {
          const i = v(s2);
          if (!i.isBlockContainer)
            return false;
          const { bnBlock: a2, blockContent: c } = i, { depth: l } = s2.doc.resolve(a2.beforePos), d = s2.selection.$anchor.parentOffset === 0, u = s2.selection.anchor === s2.selection.head, h2 = c.node.childCount === 0, f = l > 1;
          return d && u && h2 && f ? r.liftListItem("blockContainer") : false;
        }),
        // Creates a hard break if block is configured to do so.
        () => r.command(({ state: s2 }) => {
          const i = v(s2), a2 = this.options.editor.schema.blockSchema[i.blockNoteType].hardBreakShortcut ?? "shift+enter";
          return a2 === "none" ? false : (
            // If shortcut is not configured, or is configured as "shift+enter",
            // create a hard break for shift+enter, but not for enter.
            a2 === "shift+enter" && o || // If shortcut is configured as "enter", create a hard break for
            // both enter and shift+enter.
            a2 === "enter" ? r.insertContent({
              type: "hardBreak"
            }) : false
          );
        }),
        // Creates a new block and moves the selection to it if the current one is empty, while the selection is also
        // empty & at the start of the block.
        () => r.command(({ state: s2, dispatch: i }) => {
          const a2 = v(s2);
          if (!a2.isBlockContainer)
            return false;
          const { bnBlock: c, blockContent: l } = a2, d = s2.selection.$anchor.parentOffset === 0, u = s2.selection.anchor === s2.selection.head, h2 = l.node.childCount === 0;
          if (d && u && h2) {
            const f = c.afterPos, m = f + 2;
            if (i) {
              const g = s2.schema.nodes.blockContainer.createAndFill();
              s2.tr.insert(f, g).scrollIntoView(), s2.tr.setSelection(
                new TextSelection(s2.doc.resolve(m))
              );
            }
            return true;
          }
          return false;
        }),
        // Splits the current block, moving content inside that's after the cursor to a new text block below. Also
        // deletes the selection beforehand, if it's not empty.
        () => r.command(({ state: s2, chain: i }) => {
          const a2 = v(s2);
          if (!a2.isBlockContainer)
            return false;
          const { blockContent: c } = a2, l = s2.selection.$anchor.parentOffset === 0;
          return c.node.childCount === 0 ? false : (i().deleteSelection().command(
            Hn(
              s2.selection.from,
              l,
              l
            )
          ).run(), true);
        })
      ]);
      return {
        Backspace: e,
        Delete: n,
        Enter: () => t2(),
        "Shift-Enter": () => t2(true),
        // Always returning true for tab key presses ensures they're not captured by the browser. Otherwise, they blur the
        // editor since the browser will try to use tab for keyboard navigation.
        Tab: () => {
          var o, r, s2;
          return this.options.tabBehavior !== "prefer-indent" && ((o = this.options.editor.formattingToolbar) != null && o.shown || (r = this.options.editor.linkToolbar) != null && r.shown || (s2 = this.options.editor.filePanel) != null && s2.shown) ? false : Gn(this.options.editor);
        },
        "Shift-Tab": () => {
          var o, r, s2;
          return this.options.tabBehavior !== "prefer-indent" && ((o = this.options.editor.formattingToolbar) != null && o.shown || (r = this.options.editor.linkToolbar) != null && r.shown || (s2 = this.options.editor.filePanel) != null && s2.shown) ? false : (this.editor.commands.liftListItem("blockContainer"), true);
        },
        "Shift-Mod-ArrowUp": () => (this.options.editor.moveBlocksUp(), true),
        "Shift-Mod-ArrowDown": () => (this.options.editor.moveBlocksDown(), true),
        "Mod-z": () => this.options.editor.undo(),
        "Mod-y": () => this.options.editor.redo(),
        "Shift-Mod-z": () => this.options.editor.redo()
      };
    }
  });
  var ca = class {
    constructor(n, t2, o) {
      p4(this, "state");
      p4(this, "emitUpdate");
      p4(this, "menuUpdateTimer");
      p4(this, "startMenuUpdateTimer");
      p4(this, "stopMenuUpdateTimer");
      p4(this, "mouseHoveredLinkMark");
      p4(this, "mouseHoveredLinkMarkRange");
      p4(this, "keyboardHoveredLinkMark");
      p4(this, "keyboardHoveredLinkMarkRange");
      p4(this, "linkMark");
      p4(this, "linkMarkRange");
      p4(this, "mouseOverHandler", (n2) => {
        if (this.mouseHoveredLinkMark = void 0, this.mouseHoveredLinkMarkRange = void 0, this.stopMenuUpdateTimer(), n2.target instanceof HTMLAnchorElement && n2.target.nodeName === "A") {
          const t3 = n2.target, o2 = this.pmView.posAtDOM(t3, 0) + 1, r = this.pmView.state.doc.resolve(o2), s2 = r.marks();
          for (const i of s2)
            if (i.type.name === this.pmView.state.schema.mark("link").type.name) {
              this.mouseHoveredLinkMark = i, this.mouseHoveredLinkMarkRange = getMarkRange(r, i.type, i.attrs) || void 0;
              break;
            }
        }
        return this.startMenuUpdateTimer(), false;
      });
      p4(this, "clickHandler", (n2) => {
        var o2;
        const t3 = this.pmView.dom.parentElement;
        this.linkMark && // An element is clicked.
        n2 && n2.target && // The clicked element is not the editor.
        !(t3 === n2.target || t3.contains(n2.target)) && (o2 = this.state) != null && o2.show && (this.state.show = false, this.emitUpdate());
      });
      p4(this, "scrollHandler", () => {
        var n2;
        this.linkMark !== void 0 && (n2 = this.state) != null && n2.show && (this.state.referencePos = posToDOMRect(
          this.pmView,
          this.linkMarkRange.from,
          this.linkMarkRange.to
        ), this.emitUpdate());
      });
      p4(this, "closeMenu", () => {
        var n2;
        (n2 = this.state) != null && n2.show && (this.state.show = false, this.emitUpdate());
      });
      this.editor = n, this.pmView = t2, this.emitUpdate = () => {
        if (!this.state)
          throw new Error("Attempting to update uninitialized link toolbar");
        o(this.state);
      }, this.startMenuUpdateTimer = () => {
        this.menuUpdateTimer = setTimeout(() => {
          this.update(this.pmView, void 0, true);
        }, 250);
      }, this.stopMenuUpdateTimer = () => (this.menuUpdateTimer && (clearTimeout(this.menuUpdateTimer), this.menuUpdateTimer = void 0), false), this.pmView.dom.addEventListener("mouseover", this.mouseOverHandler), this.pmView.root.addEventListener(
        "click",
        this.clickHandler,
        true
      ), this.pmView.root.addEventListener("scroll", this.scrollHandler, true);
    }
    editLink(n, t2) {
      var o;
      this.editor.transact((r) => {
        const s2 = M(r);
        r.insertText(t2, this.linkMarkRange.from, this.linkMarkRange.to), r.addMark(
          this.linkMarkRange.from,
          this.linkMarkRange.from + t2.length,
          s2.mark("link", { href: n })
        );
      }), this.pmView.focus(), (o = this.state) != null && o.show && (this.state.show = false, this.emitUpdate());
    }
    deleteLink() {
      var n;
      this.editor.transact(
        (t2) => t2.removeMark(
          this.linkMarkRange.from,
          this.linkMarkRange.to,
          this.linkMark.type
        ).setMeta("preventAutolink", true)
      ), this.pmView.focus(), (n = this.state) != null && n.show && (this.state.show = false, this.emitUpdate());
    }
    update(n, t2, o = false) {
      var a2;
      const { state: r } = n;
      if (t2 && t2.selection.from === r.selection.from && t2.selection.to === r.selection.to || !this.pmView.hasFocus())
        return;
      const i = this.linkMark;
      if (this.linkMark = void 0, this.linkMarkRange = void 0, this.keyboardHoveredLinkMark = void 0, this.keyboardHoveredLinkMarkRange = void 0, this.pmView.state.selection.empty) {
        const c = this.pmView.state.selection.$from.marks();
        for (const l of c)
          if (l.type.name === this.pmView.state.schema.mark("link").type.name) {
            this.keyboardHoveredLinkMark = l, this.keyboardHoveredLinkMarkRange = getMarkRange(
              this.pmView.state.selection.$from,
              l.type,
              l.attrs
            ) || void 0;
            break;
          }
      }
      if (this.mouseHoveredLinkMark && o && (this.linkMark = this.mouseHoveredLinkMark, this.linkMarkRange = this.mouseHoveredLinkMarkRange), this.keyboardHoveredLinkMark && (this.linkMark = this.keyboardHoveredLinkMark, this.linkMarkRange = this.keyboardHoveredLinkMarkRange), this.linkMark && this.editor.isEditable) {
        this.state = {
          show: true,
          referencePos: posToDOMRect(
            this.pmView,
            this.linkMarkRange.from,
            this.linkMarkRange.to
          ),
          url: this.linkMark.attrs.href,
          text: this.pmView.state.doc.textBetween(
            this.linkMarkRange.from,
            this.linkMarkRange.to
          )
        }, this.emitUpdate();
        return;
      }
      if ((a2 = this.state) != null && a2.show && i && (!this.linkMark || !this.editor.isEditable)) {
        this.state.show = false, this.emitUpdate();
        return;
      }
    }
    destroy() {
      this.pmView.dom.removeEventListener("mouseover", this.mouseOverHandler), this.pmView.root.removeEventListener("scroll", this.scrollHandler, true), this.pmView.root.removeEventListener(
        "click",
        this.clickHandler,
        true
      );
    }
  };
  var la = new PluginKey("LinkToolbarPlugin");
  var da = class extends L {
    constructor(t2) {
      super();
      p4(this, "view");
      p4(this, "editLink", (t3, o) => {
        this.view.editLink(t3, o);
      });
      p4(this, "deleteLink", () => {
        this.view.deleteLink();
      });
      p4(this, "startHideTimer", () => {
        this.view.startMenuUpdateTimer();
      });
      p4(this, "stopHideTimer", () => {
        this.view.stopMenuUpdateTimer();
      });
      p4(this, "closeMenu", () => this.view.closeMenu());
      this.addProsemirrorPlugin(
        new Plugin({
          key: la,
          view: (o) => (this.view = new ca(t2, o, (r) => {
            this.emit("update", r);
          }), this.view),
          props: {
            handleKeyDown: (o, r) => r.key === "Escape" && this.shown ? (this.view.closeMenu(), true) : false
          }
        })
      );
    }
    static key() {
      return "linkToolbar";
    }
    onUpdate(t2) {
      return this.on("update", t2);
    }
    get shown() {
      var t2, o;
      return ((o = (t2 = this.view) == null ? void 0 : t2.state) == null ? void 0 : o.show) || false;
    }
  };
  var ua = [
    "http",
    "https",
    "ftp",
    "ftps",
    "mailto",
    "tel",
    "callto",
    "sms",
    "cid",
    "xmpp"
  ], pa = "https", ha = new PluginKey("node-selection-keyboard");
  var fa = class extends L {
    static key() {
      return "nodeSelectionKeyboard";
    }
    constructor() {
      super(), this.addProsemirrorPlugin(
        new Plugin({
          key: ha,
          props: {
            handleKeyDown: (n, t2) => {
              if ("node" in n.state.selection) {
                if (t2.ctrlKey || t2.metaKey)
                  return false;
                if (t2.key.length === 1)
                  return t2.preventDefault(), true;
                if (t2.key === "Enter" && !t2.shiftKey && !t2.altKey && !t2.ctrlKey && !t2.metaKey) {
                  const o = n.state.tr;
                  return n.dispatch(
                    o.insert(
                      n.state.tr.selection.$to.after(),
                      n.state.schema.nodes.paragraph.createChecked()
                    ).setSelection(
                      new TextSelection(
                        o.doc.resolve(n.state.tr.selection.$to.after() + 1)
                      )
                    )
                  ), true;
                }
              }
              return false;
            }
          }
        })
      );
    }
  };
  var ma = new PluginKey("blocknote-placeholder");
  var ga = class extends L {
    static key() {
      return "placeholder";
    }
    constructor(n, t2) {
      super(), this.addProsemirrorPlugin(
        new Plugin({
          key: ma,
          view: (o) => {
            var l, d;
            const r = `placeholder-selector-${v4_default()}`;
            o.dom.classList.add(r);
            const s2 = document.createElement("style"), i = n._tiptapEditor.options.injectNonce;
            i && s2.setAttribute("nonce", i), ((l = n.prosemirrorView) == null ? void 0 : l.root) instanceof ShadowRoot ? n.prosemirrorView.root.append(s2) : (d = n.prosemirrorView) == null || d.root.head.appendChild(s2);
            const a2 = s2.sheet, c = (u = "") => `.${r} .bn-block-content${u} .bn-inline-content:has(> .ProseMirror-trailingBreak:only-child):before`;
            try {
              const {
                default: u,
                emptyDocument: h2,
                ...f
              } = t2;
              for (const [b, k] of Object.entries(f)) {
                const w = `[data-content-type="${b}"]`;
                a2.insertRule(
                  `${c(w)} { content: ${JSON.stringify(
                    k
                  )}; }`
                );
              }
              const m = "[data-is-only-empty-block]", g = "[data-is-empty-and-focused]";
              a2.insertRule(
                `${c(m)} { content: ${JSON.stringify(
                  h2
                )}; }`
              ), a2.insertRule(
                `${c(g)} { content: ${JSON.stringify(
                  u
                )}; }`
              );
            } catch (u) {
              console.warn(
                "Failed to insert placeholder CSS rule - this is likely due to the browser not supporting certain CSS pseudo-element selectors (:has, :only-child:, or :before)",
                u
              );
            }
            return {
              destroy: () => {
                var u, h2;
                ((u = n.prosemirrorView) == null ? void 0 : u.root) instanceof ShadowRoot ? n.prosemirrorView.root.removeChild(s2) : (h2 = n.prosemirrorView) == null || h2.root.head.removeChild(s2);
              }
            };
          },
          props: {
            decorations: (o) => {
              const { doc: r, selection: s2 } = o;
              if (!n.isEditable || !s2.empty || s2.$from.parent.type.spec.code)
                return;
              const i = [];
              o.doc.content.size === 6 && i.push(
                Decoration.node(2, 4, {
                  "data-is-only-empty-block": "true"
                })
              );
              const a2 = s2.$anchor, c = a2.parent;
              if (c.content.size === 0) {
                const l = a2.before();
                i.push(
                  Decoration.node(l, l + c.nodeSize, {
                    "data-is-empty-and-focused": "true"
                  })
                );
              }
              return DecorationSet.create(r, i);
            }
          }
        })
      );
    }
  };
  var tn = new PluginKey("previous-blocks"), ba = {
    // Numbered List Items
    index: "index",
    // Headings
    level: "level",
    // All Blocks
    type: "type",
    depth: "depth",
    "depth-change": "depth-change"
  };
  var ka = class extends L {
    static key() {
      return "previousBlockType";
    }
    constructor() {
      super();
      let n;
      this.addProsemirrorPlugin(
        new Plugin({
          key: tn,
          view(t2) {
            return {
              update: async (o, r) => {
                var s2;
                ((s2 = this.key) == null ? void 0 : s2.getState(o.state).updatedBlocks.size) > 0 && (n = setTimeout(() => {
                  o.dispatch(
                    o.state.tr.setMeta(tn, { clearUpdate: true })
                  );
                }, 0));
              },
              destroy: () => {
                n && clearTimeout(n);
              }
            };
          },
          state: {
            init() {
              return {
                // Block attributes, by block ID, from just before the previous transaction.
                prevTransactionOldBlockAttrs: {},
                // Block attributes, by block ID, from just before the current transaction.
                currentTransactionOldBlockAttrs: {},
                // Set of IDs of blocks whose attributes changed from the current transaction.
                updatedBlocks: /* @__PURE__ */ new Set()
              };
            },
            apply(t2, o, r, s2) {
              if (o.currentTransactionOldBlockAttrs = {}, o.updatedBlocks.clear(), !t2.docChanged || r.doc.eq(s2.doc))
                return o;
              const i = {}, a2 = findChildren(
                r.doc,
                (d) => d.attrs.id
              ), c = new Map(
                a2.map((d) => [d.node.attrs.id, d])
              ), l = findChildren(
                s2.doc,
                (d) => d.attrs.id
              );
              for (const d of l) {
                const u = c.get(d.node.attrs.id), h2 = u == null ? void 0 : u.node.firstChild, f = d.node.firstChild;
                if (u && h2 && f) {
                  const m = {
                    index: f.attrs.index,
                    level: f.attrs.level,
                    type: f.type.name,
                    depth: s2.doc.resolve(d.pos).depth
                  };
                  let g = {
                    index: h2.attrs.index,
                    level: h2.attrs.level,
                    type: h2.type.name,
                    depth: r.doc.resolve(u.pos).depth
                  };
                  i[d.node.attrs.id] = g, t2.getMeta("numberedListIndexing") && (d.node.attrs.id in o.prevTransactionOldBlockAttrs && (g = o.prevTransactionOldBlockAttrs[d.node.attrs.id]), m.type === "numberedListItem" && (g.index = m.index)), o.currentTransactionOldBlockAttrs[d.node.attrs.id] = g, JSON.stringify(g) !== JSON.stringify(m) && (g["depth-change"] = g.depth - m.depth, o.updatedBlocks.add(d.node.attrs.id));
                }
              }
              return o.prevTransactionOldBlockAttrs = i, o;
            }
          },
          props: {
            decorations(t2) {
              const o = this.getState(t2);
              if (o.updatedBlocks.size === 0)
                return;
              const r = [];
              return t2.doc.descendants((s2, i) => {
                if (!s2.attrs.id || !o.updatedBlocks.has(s2.attrs.id))
                  return;
                const a2 = o.currentTransactionOldBlockAttrs[s2.attrs.id], c = {};
                for (const [d, u] of Object.entries(a2))
                  c["data-prev-" + ba[d]] = u || "none";
                const l = Decoration.node(i, i + s2.nodeSize, {
                  ...c
                });
                r.push(l);
              }), DecorationSet.create(t2.doc, r);
            }
          }
        })
      );
    }
  };
  var nn = new PluginKey("blocknote-show-selection");
  var wa = class extends L {
    constructor(t2) {
      super();
      p4(this, "enabled", false);
      this.editor = t2, this.addProsemirrorPlugin(
        new Plugin({
          key: nn,
          props: {
            decorations: (o) => {
              const { doc: r, selection: s2 } = o;
              if (!this.enabled)
                return DecorationSet.empty;
              const i = Decoration.inline(s2.from, s2.to, {
                "data-show-selection": "true"
              });
              return DecorationSet.create(r, [i]);
            }
          }
        })
      );
    }
    static key() {
      return "showSelection";
    }
    setEnabled(t2) {
      this.enabled !== t2 && (this.enabled = t2, this.editor.transact((o) => o.setMeta(nn, {})));
    }
    getEnabled() {
      return this.enabled;
    }
  };
  function no(e, n) {
    var t2, o;
    for (; e && e.parentElement && e.parentElement !== n.dom && ((t2 = e.getAttribute) == null ? void 0 : t2.call(e, "data-node-type")) !== "blockContainer"; )
      e = e.parentElement;
    if (((o = e.getAttribute) == null ? void 0 : o.call(e, "data-node-type")) === "blockContainer")
      return { node: e, id: e.getAttribute("data-id") };
  }
  var ae = class _ae extends Selection {
    constructor(t2, o) {
      super(t2, o);
      p4(this, "nodes");
      const r = t2.node();
      this.nodes = [], t2.doc.nodesBetween(t2.pos, o.pos, (s2, i, a2) => {
        if (a2 !== null && a2.eq(r))
          return this.nodes.push(s2), false;
      });
    }
    static create(t2, o, r = o) {
      return new _ae(t2.resolve(o), t2.resolve(r));
    }
    content() {
      return new Slice(Fragment.from(this.nodes), 0, 0);
    }
    eq(t2) {
      if (!(t2 instanceof _ae) || this.nodes.length !== t2.nodes.length || this.from !== t2.from || this.to !== t2.to)
        return false;
      for (let o = 0; o < this.nodes.length; o++)
        if (!this.nodes[o].eq(t2.nodes[o]))
          return false;
      return true;
    }
    map(t2, o) {
      const r = o.mapResult(this.from), s2 = o.mapResult(this.to);
      return s2.deleted ? Selection.near(t2.resolve(r.pos)) : r.deleted ? Selection.near(t2.resolve(s2.pos)) : new _ae(
        t2.resolve(r.pos),
        t2.resolve(s2.pos)
      );
    }
    toJSON() {
      return { type: "multiple-node", anchor: this.anchor, head: this.head };
    }
  };
  Selection.jsonID("multiple-node", ae);
  var z;
  function ya(e, n) {
    let t2, o;
    const r = n.resolve(e.from).node().type.spec.group === "blockContent", s2 = n.resolve(e.to).node().type.spec.group === "blockContent", i = Math.min(e.$anchor.depth, e.$head.depth);
    if (r && s2) {
      const a2 = e.$from.start(i - 1), c = e.$to.end(i - 1);
      t2 = n.resolve(a2 - 1).pos, o = n.resolve(c + 1).pos;
    } else
      t2 = e.from, o = e.to;
    return { from: t2, to: o };
  }
  function on(e, n, t2 = n) {
    n === t2 && (t2 += e.state.doc.resolve(n + 1).node().nodeSize);
    const o = e.domAtPos(n).node.cloneNode(true), r = e.domAtPos(n).node, s2 = (u, h2) => Array.prototype.indexOf.call(u.children, h2), i = s2(
      r,
      // Expects from position to be just before the first selected block.
      e.domAtPos(n + 1).node.parentElement
    ), a2 = s2(
      r,
      // Expects to position to be just after the last selected block.
      e.domAtPos(t2 - 1).node.parentElement
    );
    for (let u = r.childElementCount - 1; u >= 0; u--)
      (u > a2 || u < i) && o.removeChild(o.children[u]);
    oo(e.root), z = o;
    const c = z.getElementsByTagName("iframe");
    for (let u = 0; u < c.length; u++) {
      const h2 = c[u], f = h2.parentElement;
      f && f.removeChild(h2);
    }
    const d = e.dom.className.split(" ").filter(
      (u) => u !== "ProseMirror" && u !== "bn-root" && u !== "bn-editor"
    ).join(" ");
    z.className = z.className + " bn-drag-preview " + d, e.root instanceof ShadowRoot ? e.root.appendChild(z) : e.root.body.appendChild(z);
  }
  function oo(e) {
    z !== void 0 && (e instanceof ShadowRoot ? e.removeChild(z) : e.body.removeChild(z), z = void 0);
  }
  function Ca(e, n, t2) {
    if (!e.dataTransfer)
      return;
    const o = t2.prosemirrorView;
    if (!o)
      return;
    const r = _(n.id, o.state.doc);
    if (!r)
      throw new Error(`Block with ID ${n.id} not found`);
    const s2 = r.posBeforeNode;
    if (s2 != null) {
      const i = o.state.selection, a2 = o.state.doc, { from: c, to: l } = ya(i, a2), d = c <= s2 && s2 < l, u = i.$anchor.node() !== i.$head.node() || i instanceof ae;
      d && u ? (o.dispatch(
        o.state.tr.setSelection(ae.create(a2, c, l))
      ), on(o, c, l)) : (o.dispatch(
        o.state.tr.setSelection(NodeSelection.create(o.state.doc, s2))
      ), on(o, s2));
      const h2 = o.state.selection.content(), f = t2.pmSchema, m = o.serializeForClipboard(h2).dom.innerHTML, g = Ke(f, t2), b = Zn(h2.content), k = g.exportBlocks(b, {}), w = Mt(k);
      e.dataTransfer.clearData(), e.dataTransfer.setData("blocknote/html", m), e.dataTransfer.setData("text/html", k), e.dataTransfer.setData("text/plain", w), e.dataTransfer.effectAllowed = "move", e.dataTransfer.setDragImage(z, 0, 0);
    }
  }
  var we = 0.1;
  function mt(e, n, t2, o = true) {
    const r = e.root.elementsFromPoint(
      // bit hacky - offset x position to right to account for the width of sidemenu itself
      n.left + (t2 === "editor" ? 50 : 0),
      n.top
    );
    for (const s2 of r)
      if (e.dom.contains(s2))
        return o && s2.closest("[data-node-type=columnList]") ? mt(
          e,
          {
            left: n.left + 50,
            // bit hacky, but if we're inside a column, offset x position to right to account for the width of sidemenu itself
            top: n.top
          },
          t2,
          false
        ) : no(s2, e);
  }
  function va(e, n, t2) {
    if (!n.dom.firstChild)
      return;
    const o = n.dom.firstChild.getBoundingClientRect(), r = {
      left: e.x,
      top: e.y
    }, s2 = r.left < o.left, i = r.left > o.right;
    t2 === "viewport" && (s2 && (r.left = o.left + 10), i && (r.left = o.right - 10));
    let a2 = mt(n, r, t2);
    if (!i && a2) {
      const c = a2.node.getBoundingClientRect();
      r.left = c.right - 10, a2 = mt(n, r, "viewport", false);
    }
    return a2;
  }
  var Ea = class {
    constructor(n, t2, o, r) {
      p4(this, "state");
      p4(this, "emitUpdate");
      p4(this, "mousePos");
      p4(this, "hoveredBlock");
      p4(this, "menuFrozen", false);
      p4(this, "isDragOrigin", false);
      p4(this, "updateState", (n2) => {
        this.state = n2, this.emitUpdate(this.state);
      });
      p4(this, "updateStateFromMousePos", () => {
        var o2, r2, s2, i;
        if (this.menuFrozen || !this.mousePos)
          return;
        const n2 = va(
          this.mousePos,
          this.pmView,
          this.sideMenuDetection
        );
        if (!n2 || !this.editor.isEditable) {
          (o2 = this.state) != null && o2.show && (this.state.show = false, this.updateState(this.state));
          return;
        }
        if ((r2 = this.state) != null && r2.show && ((s2 = this.hoveredBlock) != null && s2.hasAttribute("data-id")) && ((i = this.hoveredBlock) == null ? void 0 : i.getAttribute("data-id")) === n2.id)
          return;
        this.hoveredBlock = n2.node;
        const t3 = n2.node.firstChild;
        if (t3 && this.editor.isEditable) {
          const a2 = t3.getBoundingClientRect(), c = n2.node.closest("[data-node-type=column]");
          this.updateState({
            show: true,
            referencePos: new DOMRect(
              c ? (
                // We take the first child as column elements have some default
                // padding. This is a little weird since this child element will
                // be the first block, but since it's always non-nested and we
                // only take the x coordinate, it's ok.
                c.firstElementChild.getBoundingClientRect().x
              ) : this.pmView.dom.firstChild.getBoundingClientRect().x,
              a2.y,
              a2.width,
              a2.height
            ),
            block: this.editor.getBlock(
              this.hoveredBlock.getAttribute("data-id")
            )
          });
        }
      });
      p4(this, "onDrop", (n2) => {
        var r2, s2;
        if (this.pmView.dragging === null)
          return;
        this.editor._tiptapEditor.commands.blur();
        const t3 = n2.target instanceof Node && ((r2 = n2.target instanceof HTMLElement ? n2.target : n2.target.parentElement) == null ? void 0 : r2.closest(".bn-editor")) || null;
        if (t3 && (!this.isDragOrigin && this.pmView.dom === t3 ? this.pmView.dispatch(
          this.pmView.state.tr.setSelection(
            TextSelection.create(
              this.pmView.state.tr.doc,
              this.pmView.state.tr.selection.to
            )
          )
        ) : this.isDragOrigin && this.pmView.dom !== t3 && setTimeout(
          () => this.pmView.dispatch(this.pmView.state.tr.deleteSelection()),
          0
        )), this.sideMenuDetection === "editor" || n2.synthetic || !((s2 = n2.dataTransfer) != null && s2.types.includes("blocknote/html")))
          return;
        const o2 = this.pmView.posAtCoords({
          left: n2.clientX,
          top: n2.clientY
        });
        if (!o2 || o2.inside === -1) {
          const i = this.createSyntheticEvent(n2);
          this.pmView.dom.dispatchEvent(i);
        }
      });
      p4(this, "onDragEnd", () => {
        this.pmView.dragging = null;
      });
      p4(this, "onDragStart", (n2) => {
        var i;
        const t3 = (i = n2.dataTransfer) == null ? void 0 : i.getData("blocknote/html");
        if (!t3)
          return;
        if (this.pmView.dragging)
          throw new Error("New drag was started while an existing drag is ongoing");
        const o2 = document.createElement("div");
        o2.innerHTML = t3;
        const s2 = DOMParser2.fromSchema(this.pmView.state.schema).parse(o2, {
          topNode: this.pmView.state.schema.nodes.blockGroup.create()
        });
        this.pmView.dragging = {
          slice: new Slice(s2.content, 0, 0),
          move: true
        };
      });
      p4(this, "onDragOver", (n2) => {
        var o2;
        if (this.sideMenuDetection === "editor" || n2.synthetic || !((o2 = n2.dataTransfer) != null && o2.types.includes("blocknote/html")))
          return;
        const t3 = this.pmView.posAtCoords({
          left: n2.clientX,
          top: n2.clientY
        });
        if (!t3 || t3.inside === -1 && this.pmView.dom.firstChild) {
          const r2 = this.createSyntheticEvent(n2);
          this.pmView.dom.dispatchEvent(r2);
        }
      });
      p4(this, "onKeyDown", (n2) => {
        var t3;
        (t3 = this.state) != null && t3.show && this.editor.isFocused() && (this.state.show = false, this.emitUpdate(this.state));
      });
      p4(this, "onMouseMove", (n2) => {
        var s2;
        if (this.menuFrozen)
          return;
        this.mousePos = { x: n2.clientX, y: n2.clientY };
        const t3 = this.pmView.dom.getBoundingClientRect(), o2 = this.mousePos.x > t3.left && this.mousePos.x < t3.right && this.mousePos.y > t3.top && this.mousePos.y < t3.bottom, r2 = this.pmView.dom.parentElement;
        if (
          // Cursor is within the editor area
          o2 && // An element is hovered
          n2 && n2.target && // Element is outside the editor
          !(r2 === n2.target || r2.contains(n2.target))
        ) {
          (s2 = this.state) != null && s2.show && (this.state.show = false, this.emitUpdate(this.state));
          return;
        }
        this.updateStateFromMousePos();
      });
      p4(this, "onScroll", () => {
        var n2;
        (n2 = this.state) != null && n2.show && (this.state.referencePos = this.hoveredBlock.getBoundingClientRect(), this.emitUpdate(this.state));
      });
      this.editor = n, this.sideMenuDetection = t2, this.pmView = o, this.emitUpdate = () => {
        if (!this.state)
          throw new Error("Attempting to update uninitialized side menu");
        r(this.state);
      }, this.pmView.root.addEventListener(
        "dragstart",
        this.onDragStart
      ), this.pmView.root.addEventListener(
        "dragover",
        this.onDragOver
      ), this.pmView.root.addEventListener(
        "drop",
        this.onDrop,
        true
      ), this.pmView.root.addEventListener(
        "dragend",
        this.onDragEnd,
        true
      ), Tt(), this.pmView.root.addEventListener(
        "mousemove",
        this.onMouseMove,
        true
      ), this.pmView.root.addEventListener(
        "keydown",
        this.onKeyDown,
        true
      ), o.root.addEventListener("scroll", this.onScroll, true);
    }
    createSyntheticEvent(n) {
      const t2 = new Event(n.type, n), o = this.pmView.dom.firstChild.getBoundingClientRect();
      return t2.clientX = n.clientX, t2.clientY = n.clientY, n.clientX < o.left && n.clientX > o.left - o.width * we ? t2.clientX = o.left + o.width * we / 2 : n.clientX > o.right && n.clientX < o.right + o.width * we ? t2.clientX = o.right - o.width * we / 2 : (n.clientX < o.left || n.clientX > o.right) && (t2.clientX = o.left + we * o.width * 2), t2.clientY = Math.min(
        Math.max(n.clientY, o.top),
        o.top + o.height
      ), t2.dataTransfer = n.dataTransfer, t2.preventDefault = () => n.preventDefault(), t2.synthetic = true, t2;
    }
    // Needed in cases where the editor state updates without the mouse cursor
    // moving, as some state updates can require a side menu update. For example,
    // adding a button to the side menu which removes the block can cause the
    // block below to jump up into the place of the removed block when clicked,
    // allowing the user to click the button again without moving the cursor. This
    // would otherwise not update the side menu, and so clicking the button again
    // would attempt to remove the same block again, causing an error.
    update(n, t2) {
      var r;
      !t2.doc.eq(this.pmView.state.doc) && ((r = this.state) != null && r.show) && this.updateStateFromMousePos();
    }
    destroy() {
      var n;
      (n = this.state) != null && n.show && (this.state.show = false, this.emitUpdate(this.state)), this.pmView.root.removeEventListener(
        "mousemove",
        this.onMouseMove,
        true
      ), this.pmView.root.removeEventListener(
        "dragstart",
        this.onDragStart
      ), this.pmView.root.removeEventListener(
        "dragover",
        this.onDragOver
      ), this.pmView.root.removeEventListener(
        "drop",
        this.onDrop,
        true
      ), this.pmView.root.removeEventListener(
        "dragend",
        this.onDragEnd,
        true
      ), this.pmView.root.removeEventListener(
        "keydown",
        this.onKeyDown,
        true
      ), this.pmView.root.removeEventListener("scroll", this.onScroll, true);
    }
  };
  var Sa = new PluginKey("SideMenuPlugin");
  var Ba = class extends L {
    constructor(t2, o) {
      super();
      p4(this, "view");
      p4(this, "blockDragStart", (t3, o2) => {
        this.view && (this.view.isDragOrigin = true), Ca(t3, o2, this.editor);
      });
      p4(this, "blockDragEnd", () => {
        this.editor.prosemirrorView && oo(this.editor.prosemirrorView.root), this.view && (this.view.isDragOrigin = false);
      });
      p4(this, "freezeMenu", () => {
        this.view.menuFrozen = true, this.view.state.show = true, this.view.emitUpdate(this.view.state);
      });
      p4(this, "unfreezeMenu", () => {
        this.view.menuFrozen = false, this.view.state.show = false, this.view.emitUpdate(this.view.state);
      });
      this.editor = t2, this.addProsemirrorPlugin(
        new Plugin({
          key: Sa,
          view: (r) => (this.view = new Ea(
            t2,
            o,
            r,
            (s2) => {
              this.emit("update", s2);
            }
          ), this.view)
        })
      );
    }
    static key() {
      return "sideMenu";
    }
    onUpdate(t2) {
      return this.on("update", t2);
    }
  };
  var Ae = /* @__PURE__ */ new Map();
  function xa(e) {
    if (Ae.has(e))
      return Ae.get(e);
    const n = new Mapping();
    return e._tiptapEditor.on("transaction", ({ transaction: t2 }) => {
      n.appendMapping(t2.mapping);
    }), e._tiptapEditor.on("destroy", () => {
      Ae.delete(e);
    }), Ae.set(e, n), n;
  }
  function Ta(e, n, t2 = "left") {
    const o = ySyncPluginKey.getState(
      e._tiptapEditor.state
    );
    if (!o) {
      const s2 = xa(e), i = s2.maps.length;
      return () => s2.slice(i).map(n, t2 === "left" ? -1 : 1);
    }
    const r = absolutePositionToRelativePosition(
      // Track the position after the position if we are on the right side
      n + (t2 === "right" ? 1 : 0),
      o.binding.type,
      o.binding.mapping
    );
    return () => {
      const s2 = ySyncPluginKey.getState(
        e._tiptapEditor.state
      ), i = relativePositionToAbsolutePosition(
        s2.doc,
        s2.binding.type,
        r,
        s2.binding.mapping
      );
      if (i === null)
        throw new Error("Position not found, cannot track positions");
      return i + (t2 === "right" ? -1 : 0);
    };
  }
  var Ma = findParentNode((e) => e.type.name === "blockContainer");
  var Pa = class {
    constructor(n, t2) {
      p4(this, "state");
      p4(this, "emitUpdate");
      p4(this, "rootEl");
      p4(this, "pluginState");
      p4(this, "handleScroll", () => {
        var n2, t3;
        if ((n2 = this.state) != null && n2.show) {
          const o2 = (t3 = this.rootEl) == null ? void 0 : t3.querySelector(
            `[data-decoration-id="${this.pluginState.decorationId}"]`
          );
          if (!o2)
            return;
          this.state.referencePos = o2.getBoundingClientRect(), this.emitUpdate(this.pluginState.triggerCharacter);
        }
      });
      p4(this, "closeMenu", () => {
        this.editor.transact((n2) => n2.setMeta(me, null));
      });
      p4(this, "clearQuery", () => {
        this.pluginState !== void 0 && this.editor._tiptapEditor.chain().focus().deleteRange({
          from: this.pluginState.queryStartPos() - (this.pluginState.deleteTriggerCharacter ? this.pluginState.triggerCharacter.length : 0),
          to: this.editor.transact((n2) => n2.selection.from)
        }).run();
      });
      var o, r;
      this.editor = n, this.pluginState = void 0, this.emitUpdate = (s2) => {
        var i;
        if (!this.state)
          throw new Error("Attempting to update uninitialized suggestions menu");
        t2(s2, {
          ...this.state,
          ignoreQueryLength: (i = this.pluginState) == null ? void 0 : i.ignoreQueryLength
        });
      }, this.rootEl = (o = this.editor.prosemirrorView) == null ? void 0 : o.root, (r = this.rootEl) == null || r.addEventListener("scroll", this.handleScroll, true);
    }
    update(n, t2) {
      var l;
      const o = me.getState(t2), r = me.getState(
        n.state
      ), s2 = o === void 0 && r !== void 0, i = o !== void 0 && r === void 0;
      if (!s2 && !(o !== void 0 && r !== void 0) && !i)
        return;
      if (this.pluginState = i ? o : r, i || !this.editor.isEditable) {
        this.state && (this.state.show = false), this.emitUpdate(this.pluginState.triggerCharacter);
        return;
      }
      const c = (l = this.rootEl) == null ? void 0 : l.querySelector(
        `[data-decoration-id="${this.pluginState.decorationId}"]`
      );
      this.editor.isEditable && c && (this.state = {
        show: true,
        referencePos: c.getBoundingClientRect(),
        query: this.pluginState.query
      }, this.emitUpdate(this.pluginState.triggerCharacter));
    }
    destroy() {
      var n;
      (n = this.rootEl) == null || n.removeEventListener("scroll", this.handleScroll, true);
    }
  };
  var me = new PluginKey("SuggestionMenuPlugin");
  var Ia = class extends L {
    constructor(t2) {
      super();
      p4(this, "view");
      p4(this, "triggerCharacters", []);
      p4(this, "addTriggerCharacter", (t3) => {
        this.triggerCharacters.push(t3);
      });
      p4(this, "removeTriggerCharacter", (t3) => {
        this.triggerCharacters = this.triggerCharacters.filter(
          (o2) => o2 !== t3
        );
      });
      p4(this, "closeMenu", () => this.view.closeMenu());
      p4(this, "clearQuery", () => this.view.clearQuery());
      const o = this.triggerCharacters;
      this.addProsemirrorPlugin(
        new Plugin({
          key: me,
          view: () => (this.view = new Pa(
            t2,
            (r, s2) => {
              this.emit(`update ${r}`, s2);
            }
          ), this.view),
          state: {
            // Initialize the plugin's internal state.
            init() {
            },
            // Apply changes to the plugin state from an editor transaction.
            apply: (r, s2, i, a2) => {
              if (r.getMeta("orderedListIndexing") !== void 0 || r.selection.$from.parent.type.spec.code)
                return s2;
              const c = r.getMeta(me);
              if (typeof c == "object" && c !== null) {
                s2 && this.closeMenu();
                const d = Ta(
                  t2,
                  a2.selection.from - // Need to account for the trigger char that was inserted, so we offset the position by the length of the trigger character.
                  c.triggerCharacter.length
                );
                return {
                  triggerCharacter: c.triggerCharacter,
                  deleteTriggerCharacter: c.deleteTriggerCharacter !== false,
                  // When reading the queryStartPos, we offset the result by the length of the trigger character, to make it easy on the caller
                  queryStartPos: () => d() + c.triggerCharacter.length,
                  query: "",
                  decorationId: `id_${Math.floor(Math.random() * 4294967295)}`,
                  ignoreQueryLength: c == null ? void 0 : c.ignoreQueryLength
                };
              }
              if (s2 === void 0)
                return s2;
              if (
                // Highlighting text should hide the menu.
                a2.selection.from !== a2.selection.to || // Transactions with plugin metadata should hide the menu.
                c === null || // Certain mouse events should hide the menu.
                // TODO: Change to global mousedown listener.
                r.getMeta("focus") || r.getMeta("blur") || r.getMeta("pointer") || // Moving the caret before the character which triggered the menu should hide it.
                s2.triggerCharacter !== void 0 && a2.selection.from < s2.queryStartPos() || // Moving the caret to a new block should hide the menu.
                !a2.selection.$from.sameParent(
                  a2.doc.resolve(s2.queryStartPos())
                )
              )
                return;
              const l = { ...s2 };
              return l.query = a2.doc.textBetween(
                s2.queryStartPos(),
                a2.selection.from
              ), l;
            }
          },
          props: {
            handleTextInput(r, s2, i, a2) {
              if (s2 === i) {
                const c = r.state.doc;
                for (const l of o) {
                  const d = l.length > 1 ? c.textBetween(s2 - l.length, s2) + a2 : a2;
                  if (l === d)
                    return r.dispatch(r.state.tr.insertText(a2)), r.dispatch(
                      r.state.tr.setMeta(me, {
                        triggerCharacter: d
                      }).scrollIntoView()
                    ), true;
                }
              }
              return false;
            },
            // Setup decorator on the currently active suggestion.
            decorations(r) {
              const s2 = this.getState(r);
              if (s2 === void 0)
                return null;
              if (!s2.deleteTriggerCharacter) {
                const i = Ma(r.selection);
                if (i)
                  return DecorationSet.create(r.doc, [
                    Decoration.node(
                      i.pos,
                      i.pos + i.node.nodeSize,
                      {
                        nodeName: "span",
                        class: "bn-suggestion-decorator",
                        "data-decoration-id": s2.decorationId
                      }
                    )
                  ]);
              }
              return DecorationSet.create(r.doc, [
                Decoration.inline(
                  s2.queryStartPos() - s2.triggerCharacter.length,
                  s2.queryStartPos(),
                  {
                    nodeName: "span",
                    class: "bn-suggestion-decorator",
                    "data-decoration-id": s2.decorationId
                  }
                )
              ]);
            }
          }
        })
      );
    }
    static key() {
      return "suggestionMenu";
    }
    onUpdate(t2, o) {
      return this.triggerCharacters.includes(t2) || this.addTriggerCharacter(t2), this.on(`update ${t2}`, o);
    }
    get shown() {
      var t2, o;
      return ((o = (t2 = this.view) == null ? void 0 : t2.state) == null ? void 0 : o.show) || false;
    }
  };
  function zc(e, n) {
    e.suggestionMenus.addTriggerCharacter(n);
  }
  var La = Mark2.create({
    name: "insertion",
    inclusive: false,
    excludes: "deletion modification insertion",
    addAttributes() {
      return {
        id: { default: null, validate: "number" }
        // note: validate is supported in prosemirror but not in tiptap, so this doesn't actually work (considered not critical)
      };
    },
    extendMarkSchema(e) {
      return e.name !== "insertion" ? {} : {
        blocknoteIgnore: true,
        inclusive: false,
        toDOM(n, t2) {
          return [
            "ins",
            {
              "data-id": String(n.attrs.id),
              "data-inline": String(t2),
              ...!t2 && { style: "display: contents" }
              // changed to "contents" to make this work for table rows
            },
            0
          ];
        },
        parseDOM: [
          {
            tag: "ins",
            getAttrs(n) {
              return n.dataset.id ? {
                id: parseInt(n.dataset.id, 10)
              } : false;
            }
          }
        ]
      };
    }
  }), Aa = Mark2.create({
    name: "deletion",
    inclusive: false,
    excludes: "insertion modification deletion",
    addAttributes() {
      return {
        id: { default: null, validate: "number" }
        // note: validate is supported in prosemirror but not in tiptap
      };
    },
    extendMarkSchema(e) {
      return e.name !== "deletion" ? {} : {
        blocknoteIgnore: true,
        inclusive: false,
        // attrs: {
        //   id: { validate: "number" },
        // },
        toDOM(n, t2) {
          return [
            "del",
            {
              "data-id": String(n.attrs.id),
              "data-inline": String(t2),
              ...!t2 && { style: "display: contents" }
              // changed to "contents" to make this work for table rows
            },
            0
          ];
        },
        parseDOM: [
          {
            tag: "del",
            getAttrs(n) {
              return n.dataset.id ? {
                id: parseInt(n.dataset.id, 10)
              } : false;
            }
          }
        ]
      };
    }
  }), Na = Mark2.create({
    name: "modification",
    inclusive: false,
    excludes: "deletion insertion",
    addAttributes() {
      return {
        id: { default: null, validate: "number" },
        type: { validate: "string" },
        attrName: { default: null, validate: "string|null" },
        previousValue: { default: null },
        newValue: { default: null }
      };
    },
    extendMarkSchema(e) {
      return e.name !== "modification" ? {} : {
        blocknoteIgnore: true,
        inclusive: false,
        // attrs: {
        //   id: { validate: "number" },
        //   type: { validate: "string" },
        //   attrName: { default: null, validate: "string|null" },
        //   previousValue: { default: null },
        //   newValue: { default: null },
        // },
        toDOM(n, t2) {
          return [
            t2 ? "span" : "div",
            {
              "data-type": "modification",
              "data-id": String(n.attrs.id),
              "data-mod-type": n.attrs.type,
              "data-mod-prev-val": JSON.stringify(n.attrs.previousValue),
              // TODO: Try to serialize marks with toJSON?
              "data-mod-new-val": JSON.stringify(n.attrs.newValue)
            },
            0
          ];
        },
        parseDOM: [
          {
            tag: "span[data-type='modification']",
            getAttrs(n) {
              return n.dataset.id ? {
                id: parseInt(n.dataset.id, 10),
                type: n.dataset.modType,
                previousValue: n.dataset.modPrevVal,
                newValue: n.dataset.modNewVal
              } : false;
            }
          },
          {
            tag: "div[data-type='modification']",
            getAttrs(n) {
              return n.dataset.id ? {
                id: parseInt(n.dataset.id, 10),
                type: n.dataset.modType,
                previousValue: n.dataset.modPrevVal
              } : false;
            }
          }
        ]
      };
    }
  });
  var R;
  function rn(e) {
    R || (R = document.createElement("div"), R.innerHTML = "_", R.style.opacity = "0", R.style.height = "1px", R.style.width = "1px", e instanceof Document ? e.body.appendChild(R) : e.appendChild(R));
  }
  function Ha(e) {
    R && (e instanceof Document ? e.body.removeChild(R) : e.removeChild(R), R = void 0);
  }
  function Ne(e) {
    return Array.prototype.indexOf.call(e.parentElement.childNodes, e);
  }
  function Da(e) {
    let n = e;
    for (; n && n.nodeName !== "TD" && n.nodeName !== "TH" && !n.classList.contains("tableWrapper"); ) {
      if (n.classList.contains("ProseMirror"))
        return;
      const t2 = n.parentNode;
      if (!t2 || !(t2 instanceof Element))
        return;
      n = t2;
    }
    return n.nodeName === "TD" || n.nodeName === "TH" ? {
      type: "cell",
      domNode: n,
      tbodyNode: n.closest("tbody")
    } : {
      type: "wrapper",
      domNode: n,
      tbodyNode: n.querySelector("tbody")
    };
  }
  function Oa(e, n) {
    const t2 = n.querySelectorAll(e);
    for (let o = 0; o < t2.length; o++)
      t2[o].style.visibility = "hidden";
  }
  var Ra = class {
    constructor(n, t2, o) {
      p4(this, "state");
      p4(this, "emitUpdate");
      p4(this, "tableId");
      p4(this, "tablePos");
      p4(this, "tableElement");
      p4(this, "menuFrozen", false);
      p4(this, "mouseState", "up");
      p4(this, "prevWasEditable", null);
      p4(this, "viewMousedownHandler", () => {
        this.mouseState = "down";
      });
      p4(this, "mouseUpHandler", (n2) => {
        this.mouseState = "up", this.mouseMoveHandler(n2);
      });
      p4(this, "mouseMoveHandler", (n2) => {
        var l, d, u, h2, f, m, g;
        if (this.menuFrozen || this.mouseState === "selecting" || !(n2.target instanceof Element) || !this.pmView.dom.contains(n2.target))
          return;
        const t3 = Da(n2.target);
        if ((t3 == null ? void 0 : t3.type) === "cell" && this.mouseState === "down" && !((l = this.state) != null && l.draggingState)) {
          this.mouseState = "selecting", (d = this.state) != null && d.show && (this.state.show = false, this.state.showAddOrRemoveRowsButton = false, this.state.showAddOrRemoveColumnsButton = false, this.emitUpdate());
          return;
        }
        if (!t3 || !this.editor.isEditable) {
          (u = this.state) != null && u.show && (this.state.show = false, this.state.showAddOrRemoveRowsButton = false, this.state.showAddOrRemoveColumnsButton = false, this.emitUpdate());
          return;
        }
        if (!t3.tbodyNode)
          return;
        const o2 = t3.tbodyNode.getBoundingClientRect(), r = no(t3.domNode, this.pmView);
        if (!r)
          return;
        this.tableElement = r.node;
        let s2;
        const i = this.editor.transact(
          (b) => _(r.id, b.doc)
        );
        if (!i)
          throw new Error(`Block with ID ${r.id} not found`);
        const a2 = E(
          i.node,
          this.editor.pmSchema,
          this.editor.schema.blockSchema,
          this.editor.schema.inlineContentSchema,
          this.editor.schema.styleSchema
        );
        if (Ws("table", a2, this.editor) && (this.tablePos = i.posBeforeNode + 1, s2 = a2), !s2)
          return;
        this.tableId = r.id;
        const c = (h2 = t3.domNode.closest(".tableWrapper")) == null ? void 0 : h2.querySelector(".table-widgets-container");
        if ((t3 == null ? void 0 : t3.type) === "wrapper") {
          const b = n2.clientY >= o2.bottom - 1 && // -1 to account for fractions of pixels in "bottom"
          n2.clientY < o2.bottom + 20, k = n2.clientX >= o2.right - 1 && n2.clientX < o2.right + 20, w = n2.clientX > o2.right || n2.clientY > o2.bottom;
          this.state = {
            ...this.state,
            show: true,
            showAddOrRemoveRowsButton: b,
            showAddOrRemoveColumnsButton: k,
            referencePosTable: o2,
            block: s2,
            widgetContainer: c,
            colIndex: w || (f = this.state) == null ? void 0 : f.colIndex,
            rowIndex: w || (m = this.state) == null ? void 0 : m.rowIndex,
            referencePosCell: w || (g = this.state) == null ? void 0 : g.referencePosCell
          };
        } else {
          const b = Ne(t3.domNode), k = Ne(t3.domNode.parentElement), w = t3.domNode.getBoundingClientRect();
          if (this.state !== void 0 && this.state.show && this.tableId === r.id && this.state.rowIndex === k && this.state.colIndex === b)
            return;
          this.state = {
            show: true,
            showAddOrRemoveColumnsButton: b === s2.content.rows[0].cells.length - 1,
            showAddOrRemoveRowsButton: k === s2.content.rows.length - 1,
            referencePosTable: o2,
            block: s2,
            draggingState: void 0,
            referencePosCell: w,
            colIndex: b,
            rowIndex: k,
            widgetContainer: c
          };
        }
        return this.emitUpdate(), false;
      });
      p4(this, "dragOverHandler", (n2) => {
        var h2;
        if (((h2 = this.state) == null ? void 0 : h2.draggingState) === void 0)
          return;
        n2.preventDefault(), n2.dataTransfer.dropEffect = "move", Oa(
          ".prosemirror-dropcursor-block, .prosemirror-dropcursor-inline",
          this.pmView.root
        );
        const t3 = {
          left: Math.min(
            Math.max(n2.clientX, this.state.referencePosTable.left + 1),
            this.state.referencePosTable.right - 1
          ),
          top: Math.min(
            Math.max(n2.clientY, this.state.referencePosTable.top + 1),
            this.state.referencePosTable.bottom - 1
          )
        }, o2 = this.pmView.root.elementsFromPoint(t3.left, t3.top).filter(
          (f) => f.tagName === "TD" || f.tagName === "TH"
        );
        if (o2.length === 0)
          return;
        const r = o2[0];
        let s2 = false;
        const i = Ne(r.parentElement), a2 = Ne(r), c = this.state.draggingState.draggedCellOrientation === "row" ? this.state.rowIndex : this.state.colIndex, d = (this.state.draggingState.draggedCellOrientation === "row" ? i : a2) !== c;
        (this.state.rowIndex !== i || this.state.colIndex !== a2) && (this.state.rowIndex = i, this.state.colIndex = a2, this.state.referencePosCell = r.getBoundingClientRect(), s2 = true);
        const u = this.state.draggingState.draggedCellOrientation === "row" ? t3.top : t3.left;
        this.state.draggingState.mousePos !== u && (this.state.draggingState.mousePos = u, s2 = true), s2 && this.emitUpdate(), d && this.editor.transact((f) => f.setMeta(ye, true));
      });
      p4(this, "dropHandler", (n2) => {
        if (this.mouseState = "up", this.state === void 0 || this.state.draggingState === void 0)
          return false;
        if (this.state.rowIndex === void 0 || this.state.colIndex === void 0)
          throw new Error(
            "Attempted to drop table row or column, but no table block was hovered prior."
          );
        n2.preventDefault();
        const { draggingState: t3, colIndex: o2, rowIndex: r } = this.state, s2 = this.state.block.content.columnWidths;
        if (t3.draggedCellOrientation === "row") {
          if (!En(
            this.state.block,
            t3.originalIndex,
            r
          ))
            return false;
          const i = wr(
            this.state.block,
            t3.originalIndex,
            r
          );
          this.editor.updateBlock(this.state.block, {
            type: "table",
            content: {
              ...this.state.block.content,
              rows: i
            }
          });
        } else {
          if (!Sn(
            this.state.block,
            t3.originalIndex,
            o2
          ))
            return false;
          const i = kr(
            this.state.block,
            t3.originalIndex,
            o2
          ), [a2] = s2.splice(t3.originalIndex, 1);
          s2.splice(o2, 0, a2), this.editor.updateBlock(this.state.block, {
            type: "table",
            content: {
              ...this.state.block.content,
              columnWidths: s2,
              rows: i
            }
          });
        }
        return this.editor.setTextCursorPosition(this.state.block.id), true;
      });
      this.editor = n, this.pmView = t2, this.emitUpdate = () => {
        if (!this.state)
          throw new Error("Attempting to update uninitialized image toolbar");
        o(this.state);
      }, t2.dom.addEventListener("mousemove", this.mouseMoveHandler), t2.dom.addEventListener("mousedown", this.viewMousedownHandler), window.addEventListener("mouseup", this.mouseUpHandler), t2.root.addEventListener(
        "dragover",
        this.dragOverHandler
      ), t2.root.addEventListener(
        "drop",
        this.dropHandler
      );
    }
    // Updates drag handles when the table is modified or removed.
    update() {
      var r;
      if (!this.state || !this.state.show)
        return;
      if (this.state.block = this.editor.getBlock(this.state.block.id), !this.state.block || this.state.block.type !== "table" || // when collaborating, the table element might be replaced and out of date
      // because yjs replaces the element when for example you change the color via the side menu
      !((r = this.tableElement) != null && r.isConnected)) {
        this.state.show = false, this.state.showAddOrRemoveRowsButton = false, this.state.showAddOrRemoveColumnsButton = false, this.emitUpdate();
        return;
      }
      const { height: n, width: t2 } = vt(
        this.state.block
      );
      this.state.rowIndex !== void 0 && this.state.colIndex !== void 0 && (this.state.rowIndex >= n && (this.state.rowIndex = n - 1), this.state.colIndex >= t2 && (this.state.colIndex = t2 - 1));
      const o = this.tableElement.querySelector("tbody");
      if (!o)
        throw new Error(
          "Table block does not contain a 'tbody' HTML element. This should never happen."
        );
      if (this.state.rowIndex !== void 0 && this.state.colIndex !== void 0) {
        const i = o.children[this.state.rowIndex].children[this.state.colIndex];
        i ? this.state.referencePosCell = i.getBoundingClientRect() : (this.state.rowIndex = void 0, this.state.colIndex = void 0);
      }
      this.state.referencePosTable = o.getBoundingClientRect(), this.emitUpdate();
    }
    destroy() {
      this.pmView.dom.removeEventListener("mousemove", this.mouseMoveHandler), window.removeEventListener("mouseup", this.mouseUpHandler), this.pmView.dom.removeEventListener("mousedown", this.viewMousedownHandler), this.pmView.root.removeEventListener(
        "dragover",
        this.dragOverHandler
      ), this.pmView.root.removeEventListener(
        "drop",
        this.dropHandler
      );
    }
  };
  var ye = new PluginKey("TableHandlesPlugin");
  var Va = class extends L {
    constructor(t2) {
      super();
      p4(this, "view");
      p4(this, "colDragStart", (t3) => {
        if (this.view.state === void 0 || this.view.state.colIndex === void 0)
          throw new Error(
            "Attempted to drag table column, but no table block was hovered prior."
          );
        if (this.view.state.draggingState = {
          draggedCellOrientation: "col",
          originalIndex: this.view.state.colIndex,
          mousePos: t3.clientX
        }, this.view.emitUpdate(), this.editor.transact(
          (o) => o.setMeta(ye, {
            draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,
            originalIndex: this.view.state.colIndex,
            newIndex: this.view.state.colIndex,
            tablePos: this.view.tablePos
          })
        ), !this.editor.prosemirrorView)
          throw new Error("Editor view not initialized.");
        rn(this.editor.prosemirrorView.root), t3.dataTransfer.setDragImage(R, 0, 0), t3.dataTransfer.effectAllowed = "move";
      });
      p4(this, "rowDragStart", (t3) => {
        if (this.view.state === void 0 || this.view.state.rowIndex === void 0)
          throw new Error(
            "Attempted to drag table row, but no table block was hovered prior."
          );
        if (this.view.state.draggingState = {
          draggedCellOrientation: "row",
          originalIndex: this.view.state.rowIndex,
          mousePos: t3.clientY
        }, this.view.emitUpdate(), this.editor.transact(
          (o) => o.setMeta(ye, {
            draggedCellOrientation: this.view.state.draggingState.draggedCellOrientation,
            originalIndex: this.view.state.rowIndex,
            newIndex: this.view.state.rowIndex,
            tablePos: this.view.tablePos
          })
        ), !this.editor.prosemirrorView)
          throw new Error("Editor view not initialized.");
        rn(this.editor.prosemirrorView.root), t3.dataTransfer.setDragImage(R, 0, 0), t3.dataTransfer.effectAllowed = "copyMove";
      });
      p4(this, "dragEnd", () => {
        if (this.view.state === void 0)
          throw new Error(
            "Attempted to drag table row, but no table block was hovered prior."
          );
        if (this.view.state.draggingState = void 0, this.view.emitUpdate(), this.editor.transact((t3) => t3.setMeta(ye, null)), !this.editor.prosemirrorView)
          throw new Error("Editor view not initialized.");
        Ha(this.editor.prosemirrorView.root);
      });
      p4(this, "freezeHandles", () => {
        this.view.menuFrozen = true;
      });
      p4(this, "unfreezeHandles", () => {
        this.view.menuFrozen = false;
      });
      p4(this, "getCellsAtRowHandle", (t3, o) => at(t3, o));
      p4(this, "getCellsAtColumnHandle", (t3, o) => ct(t3, o));
      p4(this, "setCellSelection", (t3, o, r = o) => {
        const s2 = this.view;
        if (!s2)
          throw new Error("Table handles view not initialized");
        const i = t3.doc.resolve(s2.tablePos + 1), a2 = t3.doc.resolve(
          i.posAtIndex(o.row) + 1
        ), c = t3.doc.resolve(
          // No need for +1, since CellSelection expects the position before the cell
          a2.posAtIndex(o.col)
        ), l = t3.doc.resolve(
          i.posAtIndex(r.row) + 1
        ), d = t3.doc.resolve(
          // No need for +1, since CellSelection expects the position before the cell
          l.posAtIndex(r.col)
        ), u = t3.tr;
        return u.setSelection(
          new CellSelection(c, d)
        ), t3.apply(u);
      });
      p4(this, "addRowOrColumn", (t3, o) => {
        this.editor.exec((r, s2) => {
          const i = this.setCellSelection(
            r,
            o.orientation === "row" ? { row: t3, col: 0 } : { row: 0, col: t3 }
          );
          return o.orientation === "row" ? o.side === "above" ? addRowBefore(i, s2) : addRowAfter(i, s2) : o.side === "left" ? addColumnBefore(i, s2) : addColumnAfter(i, s2);
        });
      });
      p4(this, "removeRowOrColumn", (t3, o) => o === "row" ? this.editor.exec((r, s2) => {
        const i = this.setCellSelection(r, {
          row: t3,
          col: 0
        });
        return deleteRow(i, s2);
      }) : this.editor.exec((r, s2) => {
        const i = this.setCellSelection(r, {
          row: 0,
          col: t3
        });
        return deleteColumn(i, s2);
      }));
      p4(this, "mergeCells", (t3) => this.editor.exec((o, r) => {
        const s2 = t3 ? this.setCellSelection(
          o,
          t3.relativeStartCell,
          t3.relativeEndCell
        ) : o;
        return mergeCells(s2, r);
      }));
      p4(this, "splitCell", (t3) => this.editor.exec((o, r) => {
        const s2 = t3 ? this.setCellSelection(o, t3) : o;
        return splitCell(s2, r);
      }));
      p4(this, "getCellSelection", () => this.editor.transact((t3) => {
        const o = t3.selection;
        let r = o.$from, s2 = o.$to;
        if (Kt(o)) {
          const { ranges: m } = o;
          m.forEach((g) => {
            r = g.$from.min(r ?? g.$from), s2 = g.$to.max(s2 ?? g.$to);
          });
        } else if (r = t3.doc.resolve(
          o.$from.pos - o.$from.parentOffset - 1
        ), s2 = t3.doc.resolve(
          o.$to.pos - o.$to.parentOffset - 1
        ), r.pos === 0 || s2.pos === 0)
          return;
        const i = t3.doc.resolve(
          r.pos - r.parentOffset - 1
        ), a2 = t3.doc.resolve(s2.pos - s2.parentOffset - 1), c = t3.doc.resolve(i.pos - i.parentOffset - 1), l = r.index(i.depth), d = i.index(c.depth), u = s2.index(a2.depth), h2 = a2.index(c.depth), f = [];
        for (let m = d; m <= h2; m++)
          for (let g = l; g <= u; g++)
            f.push({ row: m, col: g });
        return {
          from: {
            row: d,
            col: l
          },
          to: {
            row: h2,
            col: u
          },
          cells: f
        };
      }));
      p4(this, "getMergeDirection", (t3) => this.editor.transact((o) => {
        const r = Kt(o.selection) ? o.selection : void 0;
        if (!r || !t3 || // Only offer the merge button if there is more than one cell selected.
        r.ranges.length <= 1)
          return;
        const s2 = this.getCellSelection();
        if (s2)
          return vr(s2.from, s2.to, t3) ? "vertical" : "horizontal";
      }));
      p4(this, "cropEmptyRowsOrColumns", (t3, o) => yr(t3, o));
      p4(this, "addRowsOrColumns", (t3, o, r) => Cr(t3, o, r));
      this.editor = t2, this.addProsemirrorPlugin(
        new Plugin({
          key: ye,
          view: (o) => (this.view = new Ra(t2, o, (r) => {
            this.emit("update", r);
          }), this.view),
          // We use decorations to render the drop cursor when dragging a table row
          // or column. The decorations are updated in the `dragOverHandler` method.
          props: {
            decorations: (o) => {
              if (this.view === void 0 || this.view.state === void 0 || this.view.state.draggingState === void 0 || this.view.tablePos === void 0)
                return;
              const r = this.view.state.draggingState.draggedCellOrientation === "row" ? this.view.state.rowIndex : this.view.state.colIndex;
              if (r === void 0)
                return;
              const s2 = [], { block: i, draggingState: a2 } = this.view.state, { originalIndex: c, draggedCellOrientation: l } = a2;
              if (r === c || !i || l === "row" && !En(i, c, r) || l === "col" && !Sn(i, c, r))
                return DecorationSet.create(o.doc, s2);
              const d = o.doc.resolve(this.view.tablePos + 1);
              return this.view.state.draggingState.draggedCellOrientation === "row" ? at(
                this.view.state.block,
                r
              ).forEach(({ row: h2, col: f }) => {
                const m = o.doc.resolve(
                  d.posAtIndex(h2) + 1
                ), g = o.doc.resolve(
                  m.posAtIndex(f) + 1
                ), b = g.node(), k = g.pos + (r > c ? b.nodeSize - 2 : 0);
                s2.push(
                  // The widget is a small bar which spans the width of the cell.
                  Decoration.widget(k, () => {
                    const w = document.createElement("div");
                    return w.className = "bn-table-drop-cursor", w.style.left = "0", w.style.right = "0", r > c ? w.style.bottom = "-2px" : w.style.top = "-3px", w.style.height = "4px", w;
                  })
                );
              }) : ct(
                this.view.state.block,
                r
              ).forEach(({ row: h2, col: f }) => {
                const m = o.doc.resolve(
                  d.posAtIndex(h2) + 1
                ), g = o.doc.resolve(
                  m.posAtIndex(f) + 1
                ), b = g.node(), k = g.pos + (r > c ? b.nodeSize - 2 : 0);
                s2.push(
                  // The widget is a small bar which spans the height of the cell.
                  Decoration.widget(k, () => {
                    const w = document.createElement("div");
                    return w.className = "bn-table-drop-cursor", w.style.top = "0", w.style.bottom = "0", r > c ? w.style.right = "-2px" : w.style.left = "-3px", w.style.width = "4px", w;
                  })
                );
              }), DecorationSet.create(o.doc, s2);
            }
          }
        })
      );
    }
    static key() {
      return "tableHandles";
    }
    onUpdate(t2) {
      return this.on("update", t2);
    }
  };
  var Ua = Extension.create({
    name: "textAlignment",
    addGlobalAttributes() {
      return [
        {
          // Attribute is applied to block content instead of container so that child blocks don't inherit the text
          // alignment styling.
          types: [
            "paragraph",
            "heading",
            "bulletListItem",
            "numberedListItem",
            "checkListItem",
            "tableCell",
            "tableHeader"
          ],
          attributes: {
            textAlignment: {
              default: "left",
              parseHTML: (e) => e.getAttribute("data-text-alignment"),
              renderHTML: (e) => e.textAlignment === "left" ? {} : {
                "data-text-alignment": e.textAlignment
              }
            }
          }
        }
      ];
    }
  }), _a2 = Extension.create({
    name: "blockTextColor",
    addGlobalAttributes() {
      return [
        {
          types: ["blockContainer", "tableCell", "tableHeader"],
          attributes: {
            textColor: {
              default: T.textColor.default,
              parseHTML: (e) => e.hasAttribute("data-text-color") ? e.getAttribute("data-text-color") : T.textColor.default,
              renderHTML: (e) => e.textColor === T.textColor.default ? {} : {
                "data-text-color": e.textColor
              }
            }
          }
        }
      ];
    }
  }), $a = Extension.create({
    name: "trailingNode",
    addProseMirrorPlugins() {
      const e = new PluginKey(this.name);
      return [
        new Plugin({
          key: e,
          appendTransaction: (n, t2, o) => {
            const { doc: r, tr: s2, schema: i } = o, a2 = e.getState(o), c = r.content.size - 2, l = i.nodes.blockContainer, d = i.nodes.paragraph;
            if (a2)
              return s2.insert(
                c,
                l.create(void 0, d.create())
              );
          },
          state: {
            init: (n, t2) => {
            },
            apply: (n, t2) => {
              if (!n.docChanged)
                return t2;
              let o = n.doc.lastChild;
              if (!o || o.type.name !== "blockGroup")
                throw new Error("Expected blockGroup");
              if (o = o.lastChild, !o || o.type.name !== "blockContainer")
                return true;
              const r = o.firstChild;
              if (!r)
                throw new Error("Expected blockContent");
              return o.nodeSize > 4 || r.type.spec.content !== "inline*";
            }
          }
        })
      ];
    }
  }), Fa = {
    blockColor: "data-block-color",
    blockStyle: "data-block-style",
    id: "data-id",
    depth: "data-depth",
    depthChange: "data-depth-change"
  }, za = Node3.create({
    name: "blockContainer",
    group: "blockGroupChild bnBlock",
    // A block always contains content, and optionally a blockGroup which contains nested blocks
    content: "blockContent blockGroup?",
    // Ensures content-specific keyboard handlers trigger first.
    priority: 50,
    defining: true,
    marks: "insertion modification deletion",
    parseHTML() {
      return [
        {
          tag: "div[data-node-type=" + this.name + "]",
          getAttrs: (e) => {
            if (typeof e == "string")
              return false;
            const n = {};
            for (const [t2, o] of Object.entries(Fa))
              e.getAttribute(o) && (n[t2] = e.getAttribute(o));
            return n;
          }
        },
        // Ignore `blockOuter` divs, but parse the `blockContainer` divs inside them.
        {
          tag: 'div[data-node-type="blockOuter"]',
          skip: true
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      var r;
      const n = document.createElement("div");
      n.className = "bn-block-outer", n.setAttribute("data-node-type", "blockOuter");
      for (const [s2, i] of Object.entries(e))
        s2 !== "class" && n.setAttribute(s2, i);
      const t2 = {
        ...((r = this.options.domAttributes) == null ? void 0 : r.block) || {},
        ...e
      }, o = document.createElement("div");
      o.className = Q("bn-block", t2.class), o.setAttribute("data-node-type", this.name);
      for (const [s2, i] of Object.entries(t2))
        s2 !== "class" && o.setAttribute(s2, i);
      return n.appendChild(o), {
        dom: n,
        contentDOM: o
      };
    }
  }), Wa = Node3.create({
    name: "blockGroup",
    group: "childContainer",
    content: "blockGroupChild+",
    marks: "deletion insertion modification",
    parseHTML() {
      return [
        {
          tag: "div",
          getAttrs: (e) => typeof e == "string" ? false : e.getAttribute("data-node-type") === "blockGroup" ? null : false
        }
      ];
    },
    renderHTML({ HTMLAttributes: e }) {
      var o;
      const n = {
        ...((o = this.options.domAttributes) == null ? void 0 : o.blockGroup) || {},
        ...e
      }, t2 = document.createElement("div");
      t2.className = Q(
        "bn-block-group",
        n.class
      ), t2.setAttribute("data-node-type", "blockGroup");
      for (const [r, s2] of Object.entries(n))
        r !== "class" && t2.setAttribute(r, s2);
      return {
        dom: t2,
        contentDOM: t2
      };
    }
  }), ja = Node3.create({
    name: "doc",
    topNode: true,
    content: "blockGroup",
    marks: "insertion modification deletion"
  });
  var Ga = class extends L {
    constructor({
      editor: t2,
      collaboration: o
    }) {
      super(t2);
      p4(this, "editor");
      p4(this, "collaboration");
      p4(this, "forkedState");
      this.editor = t2, this.collaboration = o;
    }
    static key() {
      return "ForkYDocPlugin";
    }
    /**
     * To find a fragment in another ydoc, we need to search for it.
     */
    findTypeInOtherYdoc(t2, o) {
      const r = t2.doc;
      if (t2._item === null) {
        const s2 = Array.from(r.share.keys()).find(
          (i) => r.share.get(i) === t2
        );
        if (s2 == null)
          throw new Error("type does not exist in other ydoc");
        return o.get(s2, t2.constructor);
      } else {
        const s2 = t2._item, i = o.store.clients.get(s2.id.client) ?? [], a2 = findIndexSS(i, s2.id.clock);
        return i[a2].content.type;
      }
    }
    /**
     * Whether the editor is editing a forked document,
     * preserving a reference to the original document and the forked document.
     */
    get isForkedFromRemote() {
      return this.forkedState !== void 0;
    }
    /**
     * Fork the Y.js document from syncing to the remote,
     * allowing modifications to the document without affecting the remote.
     * These changes can later be rolled back or applied to the remote.
     */
    fork() {
      if (this.isForkedFromRemote)
        return;
      const t2 = this.collaboration.fragment;
      if (!t2)
        throw new Error("No fragment to fork from");
      const o = new Doc();
      applyUpdate(o, encodeStateAsUpdate(t2.doc));
      const r = this.findTypeInOtherYdoc(t2, o);
      this.forkedState = {
        originalFragment: t2,
        forkedFragment: r
      }, this.editor._tiptapEditor.unregisterPlugin([
        yCursorPluginKey,
        yUndoPluginKey,
        ySyncPluginKey
      ]), this.editor._tiptapEditor.registerPlugin(
        new ht(r).plugins[0]
      ), this.editor._tiptapEditor.registerPlugin(new ft().plugins[0]), this.emit("forked", true);
    }
    /**
     * Resume syncing the Y.js document to the remote
     * If `keepChanges` is true, any changes that have been made to the forked document will be applied to the original document.
     * Otherwise, the original document will be restored and the changes will be discarded.
     */
    merge({ keepChanges: t2 }) {
      if (!this.forkedState)
        return;
      this.editor._tiptapEditor.unregisterPlugin(ySyncPluginKey), this.editor._tiptapEditor.unregisterPlugin(yUndoPluginKey);
      const { originalFragment: o, forkedFragment: r } = this.forkedState;
      if (t2) {
        const s2 = encodeStateAsUpdate(r.doc);
        applyUpdate(o.doc, s2);
      }
      this.editor.extensions.ySyncPlugin = new ht(o), this.editor.extensions.yCursorPlugin = new Ue(
        this.collaboration
      ), this.editor.extensions.yUndoPlugin = new ft(), this.editor._tiptapEditor.registerPlugin(
        this.editor.extensions.ySyncPlugin.plugins[0]
      ), this.editor._tiptapEditor.registerPlugin(
        this.editor.extensions.yCursorPlugin.plugins[0]
      ), this.editor._tiptapEditor.registerPlugin(
        this.editor.extensions.yUndoPlugin.plugins[0]
      ), this.forkedState = void 0, this.emit("forked", false);
    }
  };
  var qa = (e) => {
    var r;
    const n = {}, t2 = Ka(e);
    for (const s2 of t2)
      n[s2.name] = s2;
    e.collaboration && (n.ySyncPlugin = new ht(e.collaboration.fragment), n.yUndoPlugin = new ft(), (r = e.collaboration.provider) != null && r.awareness && (n.yCursorPlugin = new Ue(e.collaboration)), n.forkYDocPlugin = new Ga({
      editor: e.editor,
      collaboration: e.collaboration
    })), n.formattingToolbar = new oa(
      e.editor
    ), n.linkToolbar = new da(e.editor), n.sideMenu = new Ba(
      e.editor,
      e.sideMenuDetection
    ), n.suggestionMenus = new Ia(e.editor), n.filePanel = new ea(e.editor), n.placeholder = new ga(e.editor, e.placeholders), (e.animations ?? true) && (n.animations = new ka()), e.tableHandles && (n.tableHandles = new Va(e.editor)), n.nodeSelectionKeyboard = new fa(), n.showSelection = new wa(e.editor), e.comments && (n.comments = new Zi(
      e.editor,
      e.comments.threadStore,
      eo.name
    ));
    const o = e.disableExtensions || [];
    for (const s2 of o)
      delete n[s2];
    return n;
  };
  var sn = false;
  var Ka = (e) => {
    const n = [
      index2.ClipboardTextSerializer,
      index2.Commands,
      index2.Editable,
      index2.FocusEvents,
      index2.Tabindex,
      // DevTools,
      Gapcursor,
      // DropCursor,
      Extension.create({
        name: "dropCursor",
        addProseMirrorPlugins: () => [
          e.dropCursor({
            width: 5,
            color: "#ddeeff",
            editor: e.editor
          })
        ]
      }),
      We.configure({
        // everything from bnBlock group (nodes that represent a BlockNote block should have an id)
        types: ["blockContainer", "columnList", "column"],
        setIdAttribute: e.setIdAttribute
      }),
      ra,
      // Comments,
      // basics:
      Text2,
      // marks:
      La,
      Aa,
      Na,
      Link.extend({
        inclusive: false
      }).configure({
        defaultProtocol: pa,
        // only call this once if we have multiple editors installed. Or fix https://github.com/ueberdosis/tiptap/issues/5450
        protocols: sn ? [] : ua
      }),
      ...Object.values(e.styleSpecs).map((t2) => t2.implementation.mark.configure({
        editor: e.editor
      })),
      _a2,
      Ki,
      Ua,
      // make sure escape blurs editor, so that we can tab to other elements in the host page (accessibility)
      Extension.create({
        name: "OverrideEscape",
        addKeyboardShortcuts() {
          return {
            Escape: () => e.editor.suggestionMenus.shown ? false : this.editor.commands.blur()
          };
        }
      }),
      // nodes
      ja,
      za.configure({
        editor: e.editor,
        domAttributes: e.domAttributes
      }),
      aa.configure({
        editor: e.editor,
        tabBehavior: e.tabBehavior
      }),
      Wa.configure({
        domAttributes: e.domAttributes
      }),
      ...Object.values(e.inlineContentSpecs).filter((t2) => t2.config !== "link" && t2.config !== "text").map((t2) => t2.implementation.node.configure({
        editor: e.editor
      })),
      ...Object.values(e.blockSpecs).flatMap((t2) => [
        // dependent nodes (e.g.: tablecell / row)
        ...(t2.implementation.requiredExtensions || []).map(
          (o) => o.configure({
            editor: e.editor,
            domAttributes: e.domAttributes
          })
        ),
        // the actual node itself
        t2.implementation.node.configure({
          editor: e.editor,
          domAttributes: e.domAttributes
        })
      ]),
      qi(e.editor),
      ji(
        e.editor,
        e.pasteHandler || ((t2) => t2.defaultPasteHandler())
      ),
      Mi(e.editor),
      // This needs to be at the bottom of this list, because Key events (such as enter, when selecting a /command),
      // should be handled before Enter handlers in other components like splitListItem
      ...e.trailingBlock === void 0 || e.trailingBlock ? [$a] : [],
      ...e.comments ? [eo] : []
    ];
    return sn = true, e.collaboration || n.push(History), n;
  };
  function Ja(e, n) {
    const t2 = [];
    return e.forEach((o, r, s2) => {
      s2 !== n && t2.push(o);
    }), Fragment.from(t2);
  }
  function Xa(e, n) {
    const t2 = [];
    for (let o = 0; o < e.childCount; o++)
      if (e.child(o).type.name === "tableRow")
        if (t2.length > 0 && t2[t2.length - 1].type.name === "table") {
          const r = t2[t2.length - 1], s2 = r.copy(r.content.addToEnd(e.child(o)));
          t2[t2.length - 1] = s2;
        } else {
          const r = n.nodes.table.createChecked(
            void 0,
            e.child(o)
          );
          t2.push(r);
        }
      else
        t2.push(e.child(o));
    return e = Fragment.from(t2), e;
  }
  function Ya(e, n) {
    let t2 = Fragment.from(e.content);
    if (t2 = Xa(t2, n.state.schema), !Za(t2, n))
      return new Slice(t2, e.openStart, e.openEnd);
    for (let o = 0; o < t2.childCount; o++)
      if (t2.child(o).type.spec.group === "blockContent") {
        const r = [t2.child(o)];
        if (o + 1 < t2.childCount && t2.child(o + 1).type.name === "blockGroup") {
          const i = t2.child(o + 1).child(0).child(0);
          (i.type.name === "bulletListItem" || i.type.name === "numberedListItem" || i.type.name === "checkListItem") && (r.push(t2.child(o + 1)), t2 = Ja(t2, o + 1));
        }
        const s2 = n.state.schema.nodes.blockContainer.createChecked(
          void 0,
          r
        );
        t2 = t2.replaceChild(o, s2);
      }
    return new Slice(t2, e.openStart, e.openEnd);
  }
  function Za(e, n) {
    var s2, i;
    const t2 = e.childCount === 1, o = ((s2 = e.firstChild) == null ? void 0 : s2.type.spec.content) === "inline*", r = ((i = e.firstChild) == null ? void 0 : i.type.spec.content) === "tableRow+";
    if (t2) {
      if (o)
        return false;
      if (r) {
        const a2 = v(n.state);
        if (a2.isBlockContainer)
          return !(a2.blockContent.node.type.spec.content === "tableRow+");
      }
    }
    return true;
  }
  var Fe = class Fe2 extends Editor {
    constructor(t2, o) {
      super({ ...t2, content: void 0 });
      p4(this, "_state");
      p4(this, "mount", (t3, o2, r2) => {
        o2 ? (this.options.element = o2, this.createViewAlternative(t3, r2)) : this.destroy();
      });
      const r = this.schema;
      let s2;
      const i = r.nodes.doc.createAndFill;
      r.nodes.doc.createAndFill = (...c) => {
        if (s2)
          return s2;
        const l = i.apply(r.nodes.doc, c), d = JSON.parse(JSON.stringify(l.toJSON()));
        return d.content[0].content[0].attrs.id = "initialBlockId", s2 = Node2.fromJSON(r, d), s2;
      };
      let a2;
      try {
        const c = t2 == null ? void 0 : t2.content.map(
          (l) => pe(l, this.schema, o).toJSON()
        );
        a2 = createDocument(
          {
            type: "doc",
            content: [
              {
                type: "blockGroup",
                content: c
              }
            ]
          },
          this.schema,
          this.options.parseOptions
        );
      } catch (c) {
        throw console.error(
          "Error creating document from blocks passed as `initialContent`. Caused by exception: ",
          c
        ), new Error(
          "Error creating document from blocks passed as `initialContent`:\n" + +JSON.stringify(t2.content)
        );
      }
      this._state = EditorState.create({
        doc: a2,
        schema: this.schema
        // selection: selection || undefined,
      });
    }
    get state() {
      return this.view && (this._state = this.view.state), this._state;
    }
    dispatch(t2) {
      if (!this.view) {
        this._state = this.state.apply(t2), this.emit("transaction", {
          editor: this,
          transaction: t2
        });
        return;
      }
      if (this.view.isDestroyed)
        return;
      if (this.isCapturingTransaction) {
        this.dispatchTransaction(t2);
        return;
      }
      const { state: o, transactions: r } = this.state.applyTransaction(t2), s2 = !this.state.selection.eq(o.selection);
      this.emit("beforeTransaction", {
        editor: this,
        transaction: t2,
        nextState: o
      }), this.view.updateState(o), this.emit("transaction", {
        editor: this,
        transaction: t2
      }), s2 && this.emit("selectionUpdate", {
        editor: this,
        transaction: t2
      });
      const i = t2.getMeta("focus"), a2 = t2.getMeta("blur");
      i && this.emit("focus", {
        editor: this,
        event: i.event,
        transaction: t2
      }), a2 && this.emit("blur", {
        editor: this,
        event: a2.event,
        transaction: t2
      }), !(!t2.docChanged || t2.getMeta("preventUpdate")) && (this.emit("update", {
        editor: this,
        transaction: t2
      }), this.emit("v3-update", {
        editor: this,
        transaction: t2,
        appendedTransactions: r.slice(1)
      }));
    }
    // a helper method that can enable plugins before the view has been initialized
    // currently only used for testing
    forceEnablePlugins() {
      if (this.view)
        throw new Error(
          "forcePluginsEnabled called after view has been initialized"
        );
      this._state = this.state.reconfigure({
        plugins: this.extensionManager.plugins
      });
    }
    /**
     * Replace the default `createView` method with a custom one - which we call on mount
     */
    createViewAlternative(t2, o) {
      this.contentComponent = o;
      const r = {};
      this.extensionManager.extensions.forEach((i) => {
        i.type === "mark" && i.config.addMarkView && (r[i.name] = i.config.addMarkView(t2));
      }), this.view = new EditorView(
        { mount: this.options.element },
        // use mount option so that we reuse the existing element instead of creating a new one
        {
          ...this.options.editorProps,
          // @ts-ignore
          dispatchTransaction: this.dispatch.bind(this),
          state: this.state,
          markViews: r,
          nodeViews: this.extensionManager.nodeViews
        }
      );
      const s2 = this.state.reconfigure({
        plugins: this.extensionManager.plugins
      });
      this.view.updateState(s2), this.commands.focus(
        this.options.autofocus || this.options.element.getAttribute("data-bn-autofocus") === "true",
        { scrollIntoView: false }
      ), this.emit("create", { editor: this }), this.isInitialized = true;
    }
  };
  p4(Fe, "create", (t2, o) => {
    var s2, i;
    const r = (s2 = globalThis == null ? void 0 : globalThis.window) == null ? void 0 : s2.setTimeout;
    typeof ((i = globalThis == null ? void 0 : globalThis.window) == null ? void 0 : i.setTimeout) < "u" && (globalThis.window.setTimeout = () => 0);
    try {
      return new Fe(t2, o);
    } finally {
      r && (globalThis.window.setTimeout = r);
    }
  });
  var _e = Fe;
  _e.prototype.createView = function() {
    this.options.onPaste = this.options.onDrop = void 0;
  };
  var Qa = {
    enableInputRules: true,
    enablePasteRules: true,
    enableCoreExtensions: false
  };
  var ro = class _ro extends It {
    constructor(t2) {
      var l, d, u, h2, f, m, g, b, k, w, C, B, P, $2, S;
      super();
      p4(this, "pmSchema");
      p4(this, "extensions", {});
      p4(this, "headless", false);
      p4(this, "_tiptapEditor");
      p4(this, "elementRenderer", null);
      p4(this, "blockCache", /* @__PURE__ */ new WeakMap());
      p4(this, "dictionary");
      p4(this, "schema");
      p4(this, "blockImplementations");
      p4(this, "inlineContentImplementations");
      p4(this, "styleImplementations");
      p4(this, "formattingToolbar");
      p4(this, "linkToolbar");
      p4(this, "sideMenu");
      p4(this, "suggestionMenus");
      p4(this, "filePanel");
      p4(this, "tableHandles");
      p4(this, "comments");
      p4(this, "showSelectionPlugin");
      p4(this, "forkYDocPlugin");
      p4(this, "uploadFile");
      p4(this, "onUploadStartCallbacks", []);
      p4(this, "onUploadEndCallbacks", []);
      p4(this, "resolveFileUrl");
      p4(this, "resolveUsers");
      p4(this, "settings");
      p4(this, "activeTransaction", null);
      p4(this, "mount", (t3, o2) => {
        this._tiptapEditor.mount(this, t3, o2);
      });
      this.options = t2;
      const o = t2;
      if (o.onEditorContentChange)
        throw new Error(
          "onEditorContentChange initialization option is deprecated, use <BlockNoteView onChange={...} />, the useEditorChange(...) hook, or editor.onChange(...)"
        );
      if (o.onTextCursorPositionChange)
        throw new Error(
          "onTextCursorPositionChange initialization option is deprecated, use <BlockNoteView onSelectionChange={...} />, the useEditorSelectionChange(...) hook, or editor.onSelectionChange(...)"
        );
      if (o.onEditorReady)
        throw new Error(
          "onEditorReady is deprecated. Editor is immediately ready for use after creation."
        );
      if (o.editable)
        throw new Error(
          "editable initialization option is deprecated, use <BlockNoteView editable={true/false} />, or alternatively editor.isEditable = true/false"
        );
      this.dictionary = t2.dictionary || t, this.settings = {
        tables: {
          splitCells: ((l = t2 == null ? void 0 : t2.tables) == null ? void 0 : l.splitCells) ?? false,
          cellBackgroundColor: ((d = t2 == null ? void 0 : t2.tables) == null ? void 0 : d.cellBackgroundColor) ?? false,
          cellTextColor: ((u = t2 == null ? void 0 : t2.tables) == null ? void 0 : u.cellTextColor) ?? false,
          headers: ((h2 = t2 == null ? void 0 : t2.tables) == null ? void 0 : h2.headers) ?? false
        },
        codeBlock: {
          indentLineWithTab: ((f = t2 == null ? void 0 : t2.codeBlock) == null ? void 0 : f.indentLineWithTab) ?? true,
          defaultLanguage: ((m = t2 == null ? void 0 : t2.codeBlock) == null ? void 0 : m.defaultLanguage) ?? "text",
          supportedLanguages: ((g = t2 == null ? void 0 : t2.codeBlock) == null ? void 0 : g.supportedLanguages) ?? {},
          createHighlighter: ((b = t2 == null ? void 0 : t2.codeBlock) == null ? void 0 : b.createHighlighter) ?? void 0
        }
      };
      const r = {
        defaultStyles: true,
        schema: t2.schema || Pe.create(),
        _headless: false,
        ...t2,
        placeholders: {
          ...this.dictionary.placeholders,
          ...t2.placeholders
        }
      };
      if (r.comments && !r.resolveUsers)
        throw new Error("resolveUsers is required when using comments");
      this.resolveUsers = r.resolveUsers, this.schema = r.schema, this.blockImplementations = r.schema.blockSpecs, this.inlineContentImplementations = r.schema.inlineContentSpecs, this.styleImplementations = r.schema.styleSpecs, this.extensions = qa({
        editor: this,
        domAttributes: r.domAttributes || {},
        blockSpecs: this.schema.blockSpecs,
        styleSpecs: this.schema.styleSpecs,
        inlineContentSpecs: this.schema.inlineContentSpecs,
        collaboration: r.collaboration,
        trailingBlock: r.trailingBlock,
        disableExtensions: r.disableExtensions,
        setIdAttribute: r.setIdAttribute,
        animations: r.animations ?? true,
        tableHandles: O("table", this),
        dropCursor: this.options.dropCursor ?? dropCursor,
        placeholders: r.placeholders,
        tabBehavior: r.tabBehavior,
        sideMenuDetection: r.sideMenuDetection || "viewport",
        comments: r.comments,
        pasteHandler: r.pasteHandler
      }), (((k = r._tiptapOptions) == null ? void 0 : k.extensions) || []).forEach((y) => {
        this.extensions[y.name] = y;
      });
      for (let y of r.extensions || []) {
        typeof y == "function" && (y = y(this));
        const x = y.constructor.key();
        if (!x)
          throw new Error(
            `Extension ${y.constructor.name} does not have a key method`
          );
        if (this.extensions[x])
          throw new Error(
            `Extension ${y.constructor.name} already exists with key ${x}`
          );
        this.extensions[x] = y;
      }
      if (Object.entries(r._extensions || {}).forEach(([y, x]) => {
        const Y = typeof x == "function" ? x(this) : x;
        if (!("plugin" in Y)) {
          this.extensions[y] = Y;
          return;
        }
        this.extensions[y] = new class extends L {
          static key() {
            return y;
          }
          constructor() {
            super(), this.addProsemirrorPlugin(Y.plugin);
          }
          get priority() {
            return Y.priority;
          }
        }();
      }), this.formattingToolbar = this.extensions.formattingToolbar, this.linkToolbar = this.extensions.linkToolbar, this.sideMenu = this.extensions.sideMenu, this.suggestionMenus = this.extensions.suggestionMenus, this.filePanel = this.extensions.filePanel, this.tableHandles = this.extensions.tableHandles, this.comments = this.extensions.comments, this.showSelectionPlugin = this.extensions.showSelection, this.forkYDocPlugin = this.extensions.forkYDocPlugin, r.uploadFile) {
        const y = r.uploadFile;
        this.uploadFile = async (x, se) => {
          this.onUploadStartCallbacks.forEach(
            (Y) => Y.apply(this, [se])
          );
          try {
            return await y(x, se);
          } finally {
            this.onUploadEndCallbacks.forEach(
              (Y) => Y.apply(this, [se])
            );
          }
        };
      }
      this.resolveFileUrl = r.resolveFileUrl, this.headless = r._headless;
      const s2 = "ySyncPlugin" in this.extensions || "liveblocksExtension" in this.extensions;
      s2 && r.initialContent && console.warn(
        "When using Collaboration, initialContent might cause conflicts, because changes should come from the collaboration provider"
      );
      const i = r.initialContent || (s2 ? [
        {
          type: "paragraph",
          id: "initialBlockId"
        }
      ] : [
        {
          type: "paragraph",
          id: We.options.generateID()
        }
      ]);
      if (!Array.isArray(i) || i.length === 0)
        throw new Error(
          "initialContent must be a non-empty array of blocks, received: " + i
        );
      const a2 = [
        ...Object.entries(this.extensions).map(([y, x]) => {
          if (x instanceof Extension || x instanceof Node3 || x instanceof Mark2)
            return x;
          if (!(x instanceof L && !x.plugins.length))
            return Extension.create({
              name: y,
              priority: x.priority,
              addProseMirrorPlugins: () => x.plugins
            });
        })
      ].filter((y) => y !== void 0), c = {
        ...Qa,
        ...r._tiptapOptions,
        content: i,
        extensions: a2,
        editorProps: {
          ...(w = r._tiptapOptions) == null ? void 0 : w.editorProps,
          attributes: {
            // As of TipTap v2.5.0 the tabIndex is removed when the editor is not
            // editable, so you can't focus it. We want to revert this as we have
            // UI behaviour that relies on it.
            tabIndex: "0",
            ...(B = (C = r._tiptapOptions) == null ? void 0 : C.editorProps) == null ? void 0 : B.attributes,
            ...(P = r.domAttributes) == null ? void 0 : P.editor,
            class: Q(
              "bn-editor",
              r.defaultStyles ? "bn-default-styles" : "",
              ((S = ($2 = r.domAttributes) == null ? void 0 : $2.editor) == null ? void 0 : S.class) || ""
            )
          },
          transformPasted: Ya
        }
      };
      this.headless ? this.pmSchema = getSchema(c.extensions) : (this._tiptapEditor = _e.create(
        c,
        this.schema.styleSchema
      ), this.pmSchema = this._tiptapEditor.schema), this.pmSchema.cached.blockNoteEditor = this, this.emit("create");
    }
    static create(t2 = {}) {
      return new _ro(t2);
    }
    /**
     * Execute a prosemirror command. This is mostly for backwards compatibility with older code.
     *
     * @note You should prefer the {@link transact} method when possible, as it will automatically handle the dispatching of the transaction and work across blocknote transactions.
     *
     * @example
     * ```ts
     * editor.exec((state, dispatch, view) => {
     *   dispatch(state.tr.insertText("Hello, world!"));
     * });
     * ```
     */
    exec(t2) {
      if (this.activeTransaction)
        throw new Error(
          "`exec` should not be called within a `transact` call, move the `exec` call outside of the `transact` call"
        );
      const o = this._tiptapEditor.state, r = this._tiptapEditor.view;
      return t2(o, (i) => this._tiptapEditor.dispatch(i), r);
    }
    /**
     * Check if a command can be executed. A command should return `false` if it is not valid in the current state.
     *
     * @example
     * ```ts
     * if (editor.canExec(command)) {
     *   // show button
     * } else {
     *   // hide button
     * }
     * ```
     */
    canExec(t2) {
      if (this.activeTransaction)
        throw new Error(
          "`canExec` should not be called within a `transact` call, move the `canExec` call outside of the `transact` call"
        );
      const o = this._tiptapEditor.state, r = this._tiptapEditor.view;
      return t2(o, void 0, r);
    }
    /**
     * Execute a function within a "blocknote transaction".
     * All changes to the editor within the transaction will be grouped together, so that
     * we can dispatch them as a single operation (thus creating only a single undo step)
     *
     * @note There is no need to dispatch the transaction, as it will be automatically dispatched when the callback is complete.
     *
     * @example
     * ```ts
     * // All changes to the editor will be grouped together
     * editor.transact((tr) => {
     *   tr.insertText("Hello, world!");
     * // These two operations will be grouped together in a single undo step
     *   editor.transact((tr) => {
     *     tr.insertText("Hello, world!");
     *   });
     * });
     * ```
     */
    transact(t2) {
      if (this.activeTransaction)
        return t2(this.activeTransaction);
      try {
        this.activeTransaction = this._tiptapEditor.state.tr;
        const o = t2(this.activeTransaction), r = this.activeTransaction;
        return this.activeTransaction = null, r && // Only dispatch if the transaction was actually modified in some way
        (r.docChanged || r.selectionSet || r.scrolledIntoView || r.storedMarksSet || !r.isGeneric) && this._tiptapEditor.dispatch(r), o;
      } finally {
        this.activeTransaction = null;
      }
    }
    // TO DISCUSS
    /**
     * Shorthand to get a typed extension from the editor, by
     * just passing in the extension class.
     *
     * @param ext - The extension class to get
     * @param key - optional, the key of the extension in the extensions object (defaults to the extension name)
     * @returns The extension instance
     */
    extension(t2, o = t2.key()) {
      const r = this.extensions[o];
      if (!r)
        throw new Error(`Extension ${o} not found`);
      return r;
    }
    /**
     * Get the underlying prosemirror state
     * @note Prefer using `editor.transact` to read the current editor state, as that will ensure the state is up to date
     * @see https://prosemirror.net/docs/ref/#state.EditorState
     */
    get prosemirrorState() {
      if (this.activeTransaction)
        throw new Error(
          "`prosemirrorState` should not be called within a `transact` call, move the `prosemirrorState` call outside of the `transact` call or use `editor.transact` to read the current editor state"
        );
      return this._tiptapEditor.state;
    }
    /**
     * Get the underlying prosemirror view
     * @see https://prosemirror.net/docs/ref/#view.EditorView
     */
    get prosemirrorView() {
      return this._tiptapEditor.view;
    }
    get domElement() {
      var t2;
      return (t2 = this.prosemirrorView) == null ? void 0 : t2.dom;
    }
    isFocused() {
      var t2;
      return ((t2 = this.prosemirrorView) == null ? void 0 : t2.hasFocus()) || false;
    }
    focus() {
      var t2;
      (t2 = this.prosemirrorView) == null || t2.focus();
    }
    onUploadStart(t2) {
      return this.onUploadStartCallbacks.push(t2), () => {
        const o = this.onUploadStartCallbacks.indexOf(t2);
        o > -1 && this.onUploadStartCallbacks.splice(o, 1);
      };
    }
    onUploadEnd(t2) {
      return this.onUploadEndCallbacks.push(t2), () => {
        const o = this.onUploadEndCallbacks.indexOf(t2);
        o > -1 && this.onUploadEndCallbacks.splice(o, 1);
      };
    }
    /**
     * @deprecated, use `editor.document` instead
     */
    get topLevelBlocks() {
      return this.document;
    }
    /**
     * Gets a snapshot of all top-level (non-nested) blocks in the editor.
     * @returns A snapshot of all top-level (non-nested) blocks in the editor.
     */
    get document() {
      return this.transact((t2) => lr(t2.doc, this.pmSchema));
    }
    /**
     * Gets a snapshot of an existing block from the editor.
     * @param blockIdentifier The identifier of an existing block that should be
     * retrieved.
     * @returns The block that matches the identifier, or `undefined` if no
     * matching block was found.
     */
    getBlock(t2) {
      return this.transact((o) => ai(o.doc, t2));
    }
    /**
     * Gets a snapshot of the previous sibling of an existing block from the
     * editor.
     * @param blockIdentifier The identifier of an existing block for which the
     * previous sibling should be retrieved.
     * @returns The previous sibling of the block that matches the identifier.
     * `undefined` if no matching block was found, or it's the first child/block
     * in the document.
     */
    getPrevBlock(t2) {
      return this.transact((o) => ci(o.doc, t2));
    }
    /**
     * Gets a snapshot of the next sibling of an existing block from the editor.
     * @param blockIdentifier The identifier of an existing block for which the
     * next sibling should be retrieved.
     * @returns The next sibling of the block that matches the identifier.
     * `undefined` if no matching block was found, or it's the last child/block in
     * the document.
     */
    getNextBlock(t2) {
      return this.transact((o) => li3(o.doc, t2));
    }
    /**
     * Gets a snapshot of the parent of an existing block from the editor.
     * @param blockIdentifier The identifier of an existing block for which the
     * parent should be retrieved.
     * @returns The parent of the block that matches the identifier. `undefined`
     * if no matching block was found, or the block isn't nested.
     */
    getParentBlock(t2) {
      return this.transact((o) => di(o.doc, t2));
    }
    /**
     * Traverses all blocks in the editor depth-first, and executes a callback for each.
     * @param callback The callback to execute for each block. Returning `false` stops the traversal.
     * @param reverse Whether the blocks should be traversed in reverse order.
     */
    forEachBlock(t2, o = false) {
      const r = this.document.slice();
      o && r.reverse();
      function s2(i) {
        for (const a2 of i) {
          if (t2(a2) === false)
            return false;
          const c = o ? a2.children.slice().reverse() : a2.children;
          if (!s2(c))
            return false;
        }
        return true;
      }
      s2(r);
    }
    /**
     * Executes a callback whenever the editor's contents change.
     * @param callback The callback to execute.
     *
     * @deprecated use {@link BlockNoteEditor.onChange} instead
     */
    onEditorContentChange(t2) {
      this._tiptapEditor.on("update", t2);
    }
    /**
     * Executes a callback whenever the editor's selection changes.
     * @param callback The callback to execute.
     *
     * @deprecated use `onSelectionChange` instead
     */
    onEditorSelectionChange(t2) {
      this._tiptapEditor.on("selectionUpdate", t2);
    }
    /**
     * Gets a snapshot of the current text cursor position.
     * @returns A snapshot of the current text cursor position.
     */
    getTextCursorPosition() {
      return this.transact((t2) => mi(t2));
    }
    /**
     * Sets the text cursor position to the start or end of an existing block. Throws an error if the target block could
     * not be found.
     * @param targetBlock The identifier of an existing block that the text cursor should be moved to.
     * @param placement Whether the text cursor should be placed at the start or end of the block.
     */
    setTextCursorPosition(t2, o = "start") {
      return this.transact(
        (r) => qn(r, t2, o)
      );
    }
    /**
     * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
     * that the selection spans across.
     *
     * If the selection starts / ends halfway through a block, the returned data will contain the entire block.
     */
    getSelection() {
      return this.transact((t2) => pi(t2));
    }
    /**
     * Gets a snapshot of the current selection. This contains all blocks (included nested blocks)
     * that the selection spans across.
     *
     * If the selection starts / ends halfway through a block, the returned block will be
     * only the part of the block that is included in the selection.
     */
    getSelectionCutBlocks() {
      return this.transact((t2) => fi(t2));
    }
    /**
     * Sets the selection to a range of blocks.
     * @param startBlock The identifier of the block that should be the start of the selection.
     * @param endBlock The identifier of the block that should be the end of the selection.
     */
    setSelection(t2, o) {
      return this.transact((r) => hi(r, t2, o));
    }
    /**
     * Checks if the editor is currently editable, or if it's locked.
     * @returns True if the editor is editable, false otherwise.
     */
    get isEditable() {
      if (!this._tiptapEditor) {
        if (!this.headless)
          throw new Error("no editor, but also not headless?");
        return false;
      }
      return this._tiptapEditor.isEditable === void 0 ? true : this._tiptapEditor.isEditable;
    }
    /**
     * Makes the editor editable or locks it, depending on the argument passed.
     * @param editable True to make the editor editable, or false to lock it.
     */
    set isEditable(t2) {
      if (!this._tiptapEditor) {
        if (!this.headless)
          throw new Error("no editor, but also not headless?");
        return;
      }
      this._tiptapEditor.options.editable !== t2 && this._tiptapEditor.setEditable(t2);
    }
    /**
     * Inserts new blocks into the editor. If a block's `id` is undefined, BlockNote generates one automatically. Throws an
     * error if the reference block could not be found.
     * @param blocksToInsert An array of partial blocks that should be inserted.
     * @param referenceBlock An identifier for an existing block, at which the new blocks should be inserted.
     * @param placement Whether the blocks should be inserted just before, just after, or nested inside the
     * `referenceBlock`.
     */
    insertBlocks(t2, o, r = "before") {
      return this.transact(
        (s2) => xr(s2, t2, o, r)
      );
    }
    /**
     * Updates an existing block in the editor. Since updatedBlock is a PartialBlock object, some fields might not be
     * defined. These undefined fields are kept as-is from the existing block. Throws an error if the block to update could
     * not be found.
     * @param blockToUpdate The block that should be updated.
     * @param update A partial block which defines how the existing block should be changed.
     */
    updateBlock(t2, o) {
      return this.transact((r) => Mr(r, t2, o));
    }
    /**
     * Removes existing blocks from the editor. Throws an error if any of the blocks could not be found.
     * @param blocksToRemove An array of identifiers for existing blocks that should be removed.
     */
    removeBlocks(t2) {
      return this.transact(
        (o) => _t(o, t2, []).removedBlocks
      );
    }
    /**
     * Replaces existing blocks in the editor with new blocks. If the blocks that should be removed are not adjacent or
     * are at different nesting levels, `blocksToInsert` will be inserted at the position of the first block in
     * `blocksToRemove`. Throws an error if any of the blocks to remove could not be found.
     * @param blocksToRemove An array of blocks that should be replaced.
     * @param blocksToInsert An array of partial blocks to replace the old ones with.
     */
    replaceBlocks(t2, o) {
      return this.transact(
        (r) => _t(r, t2, o)
      );
    }
    /**
     * Undo the last action.
     */
    undo() {
      return this.options.collaboration ? this.exec(undoCommand) : this.exec(undo);
    }
    /**
     * Redo the last action.
     */
    redo() {
      return this.options.collaboration ? this.exec(redoCommand) : this.exec(redo);
    }
    /**
     * Insert a piece of content at the current cursor position.
     *
     * @param content can be a string, or array of partial inline content elements
     */
    insertInlineContent(t2, { updateSelection: o = false } = {}) {
      const r = F(t2, this.pmSchema);
      this.transact((s2) => {
        ui(
          s2,
          {
            from: s2.selection.from,
            to: s2.selection.to
          },
          r,
          {
            updateSelection: o
          }
        );
      });
    }
    /**
     * Gets the active text styles at the text cursor position or at the end of the current selection if it's active.
     */
    getActiveStyles() {
      return this.transact((t2) => {
        const o = {}, r = t2.selection.$to.marks();
        for (const s2 of r) {
          const i = this.schema.styleSchema[s2.type.name];
          if (!i) {
            s2.type.name !== "link" && // "blocknoteIgnore" tagged marks (such as comments) are also not considered BlockNote "styles"
            !s2.type.spec.blocknoteIgnore && console.warn("mark not found in styleschema", s2.type.name);
            continue;
          }
          i.propSchema === "boolean" ? o[i.type] = true : o[i.type] = s2.attrs.stringValue;
        }
        return o;
      });
    }
    /**
     * Adds styles to the currently selected content.
     * @param styles The styles to add.
     */
    addStyles(t2) {
      for (const [o, r] of Object.entries(t2)) {
        const s2 = this.schema.styleSchema[o];
        if (!s2)
          throw new Error(`style ${o} not found in styleSchema`);
        if (s2.propSchema === "boolean")
          this._tiptapEditor.commands.setMark(o);
        else if (s2.propSchema === "string")
          this._tiptapEditor.commands.setMark(o, { stringValue: r });
        else
          throw new j(s2.propSchema);
      }
    }
    /**
     * Removes styles from the currently selected content.
     * @param styles The styles to remove.
     */
    removeStyles(t2) {
      for (const o of Object.keys(t2))
        this._tiptapEditor.commands.unsetMark(o);
    }
    /**
     * Toggles styles on the currently selected content.
     * @param styles The styles to toggle.
     */
    toggleStyles(t2) {
      for (const [o, r] of Object.entries(t2)) {
        const s2 = this.schema.styleSchema[o];
        if (!s2)
          throw new Error(`style ${o} not found in styleSchema`);
        if (s2.propSchema === "boolean")
          this._tiptapEditor.commands.toggleMark(o);
        else if (s2.propSchema === "string")
          this._tiptapEditor.commands.toggleMark(o, { stringValue: r });
        else
          throw new j(s2.propSchema);
      }
    }
    /**
     * Gets the currently selected text.
     */
    getSelectedText() {
      return this.transact((t2) => t2.doc.textBetween(t2.selection.from, t2.selection.to));
    }
    /**
     * Gets the URL of the last link in the current selection, or `undefined` if there are no links in the selection.
     */
    getSelectedLinkUrl() {
      return this._tiptapEditor.getAttributes("link").href;
    }
    /**
     * Creates a new link to replace the selected content.
     * @param url The link URL.
     * @param text The text to display the link with.
     */
    createLink(t2, o) {
      if (t2 === "")
        return;
      const r = this.pmSchema.mark("link", { href: t2 });
      this.transact((s2) => {
        const { from: i, to: a2 } = s2.selection;
        o ? s2.insertText(o, i, a2).addMark(i, i + o.length, r) : s2.setSelection(TextSelection.create(s2.doc, a2)).addMark(
          i,
          a2,
          r
        );
      });
    }
    /**
     * Checks if the block containing the text cursor can be nested.
     */
    canNestBlock() {
      return si(this);
    }
    /**
     * Nests the block containing the text cursor into the block above it.
     */
    nestBlock() {
      Gn(this);
    }
    /**
     * Checks if the block containing the text cursor is nested.
     */
    canUnnestBlock() {
      return ii(this);
    }
    /**
     * Lifts the block containing the text cursor out of its parent.
     */
    unnestBlock() {
      ri(this);
    }
    /**
     * Moves the selected blocks up. If the previous block has children, moves
     * them to the end of its children. If there is no previous block, but the
     * current blocks share a common parent, moves them out of & before it.
     */
    moveBlocksUp() {
      return ti(this);
    }
    /**
     * Moves the selected blocks down. If the next block has children, moves
     * them to the start of its children. If there is no next block, but the
     * current blocks share a common parent, moves them out of & after it.
     */
    moveBlocksDown() {
      return ni(this);
    }
    /**
     * Exports blocks into a simplified HTML string. To better conform to HTML standards, children of blocks which aren't list
     * items are un-nested in the output HTML.
     *
     * @param blocks An array of blocks that should be serialized into HTML.
     * @returns The blocks, serialized as an HTML string.
     */
    async blocksToHTMLLossy(t2 = this.document) {
      return Ke(this.pmSchema, this).exportBlocks(t2, {});
    }
    /**
     * Serializes blocks into an HTML string in the format that would normally be rendered by the editor.
     *
     * Use this method if you want to server-side render HTML (for example, a blog post that has been edited in BlockNote)
     * and serve it to users without loading the editor on the client (i.e.: displaying the blog post)
     *
     * @param blocks An array of blocks that should be serialized into HTML.
     * @returns The blocks, serialized as an HTML string.
     */
    async blocksToFullHTML(t2) {
      return Nr(this.pmSchema, this).serializeBlocks(t2, {});
    }
    /**
     * Parses blocks from an HTML string. Tries to create `Block` objects out of any HTML block-level elements, and
     * `InlineNode` objects from any HTML inline elements, though not all element types are recognized. If BlockNote
     * doesn't recognize an HTML element's tag, it will parse it as a paragraph or plain text.
     * @param html The HTML string to parse blocks from.
     * @returns The blocks parsed from the HTML string.
     */
    async tryParseHTMLToBlocks(t2) {
      return Jn(t2, this.pmSchema);
    }
    /**
     * Serializes blocks into a Markdown string. The output is simplified as Markdown does not support all features of
     * BlockNote - children of blocks which aren't list items are un-nested and certain styles are removed.
     * @param blocks An array of blocks that should be serialized into Markdown.
     * @returns The blocks, serialized as a Markdown string.
     */
    async blocksToMarkdownLossy(t2 = this.document) {
      return ki(t2, this.pmSchema, this, {});
    }
    /**
     * Creates a list of blocks from a Markdown string. Tries to create `Block` and `InlineNode` objects based on
     * Markdown syntax, though not all symbols are recognized. If BlockNote doesn't recognize a symbol, it will parse it
     * as text.
     * @param markdown The Markdown string to parse blocks from.
     * @returns The blocks parsed from the Markdown string.
     */
    async tryParseMarkdownToBlocks(t2) {
      return Bi(t2, this.pmSchema);
    }
    /**
     * Updates the user info for the current user that's shown to other collaborators.
     */
    updateCollaborationUserInfo(t2) {
      if (!this.options.collaboration)
        throw new Error(
          "Cannot update collaboration user info when collaboration is disabled."
        );
      this.extensions.yCursorPlugin.updateUser(t2);
    }
    /**
     * A callback function that runs whenever the editor's contents change.
     *
     * @param callback The callback to execute.
     * @returns A function to remove the callback.
     */
    onChange(t2) {
      if (this.headless)
        return;
      const o = ({
        transaction: r,
        appendedTransactions: s2
      }) => {
        t2(this, {
          getChanges: () => Br(r, s2)
        });
      };
      return this._tiptapEditor.on("v3-update", o), () => {
        this._tiptapEditor.off("v3-update", o);
      };
    }
    /**
     * A callback function that runs whenever the text cursor position or selection changes.
     *
     * @param callback The callback to execute.
     * @returns A function to remove the callback.
     */
    onSelectionChange(t2, o) {
      if (this.headless)
        return;
      const r = (s2) => {
        s2.transaction.getMeta(ySyncPluginKey) && !o || t2(this);
      };
      return this._tiptapEditor.on("selectionUpdate", r), () => {
        this._tiptapEditor.off("selectionUpdate", r);
      };
    }
    /**
     * A callback function that runs when the editor has been initialized.
     *
     * This can be useful for plugins to initialize themselves after the editor has been initialized.
     */
    onCreate(t2) {
      return this.on("create", t2), () => {
        this.off("create", t2);
      };
    }
    getSelectionBoundingBox() {
      if (!this.prosemirrorView)
        return;
      const { selection: t2 } = this.prosemirrorState, { ranges: o } = t2, r = Math.min(...o.map((i) => i.$from.pos)), s2 = Math.max(...o.map((i) => i.$to.pos));
      if (isNodeSelection(t2)) {
        const i = this.prosemirrorView.nodeDOM(r);
        if (i)
          return i.getBoundingClientRect();
      }
      return posToDOMRect(this.prosemirrorView, r, s2);
    }
    get isEmpty() {
      const t2 = this.document;
      return t2.length === 0 || t2.length === 1 && t2[0].type === "paragraph" && t2[0].content.length === 0;
    }
    openSuggestionMenu(t2, o) {
      this.prosemirrorView && (this.focus(), this.transact((r) => {
        o != null && o.deleteTriggerCharacter && r.insertText(t2), r.scrollIntoView().setMeta(this.suggestionMenus.plugins[0], {
          triggerCharacter: t2,
          deleteTriggerCharacter: (o == null ? void 0 : o.deleteTriggerCharacter) || false,
          ignoreQueryLength: (o == null ? void 0 : o.ignoreQueryLength) || false
        });
      }));
    }
    // `forceSelectionVisible` determines whether the editor selection is shows
    // even when the editor is not focused. This is useful for e.g. creating new
    // links, so the user still sees the affected content when an input field is
    // focused.
    // TODO: Reconsider naming?
    getForceSelectionVisible() {
      return this.showSelectionPlugin.getEnabled();
    }
    setForceSelectionVisible(t2) {
      this.showSelectionPlugin.setEnabled(t2);
    }
    /**
     * This will convert HTML into a format that is compatible with BlockNote.
     */
    convertHtmlToBlockNoteHtml(t2) {
      return Kn(t2.trim()).innerHTML;
    }
    /**
     * Paste HTML into the editor. Defaults to converting HTML to BlockNote HTML.
     * @param html The HTML to paste.
     * @param raw Whether to paste the HTML as is, or to convert it to BlockNote HTML.
     */
    pasteHTML(t2, o = false) {
      var s2;
      let r = t2;
      o || (r = this.convertHtmlToBlockNoteHtml(t2)), r && ((s2 = this.prosemirrorView) == null || s2.pasteHTML(r));
    }
    /**
     * Paste text into the editor. Defaults to interpreting text as markdown.
     * @param text The text to paste.
     */
    pasteText(t2) {
      var o;
      return (o = this.prosemirrorView) == null ? void 0 : o.pasteText(t2);
    }
    /**
     * Paste markdown into the editor.
     * @param markdown The markdown to paste.
     */
    async pasteMarkdown(t2) {
      return this.pasteHTML(await Xn(t2));
    }
  };
  var Wc = {
    gray: {
      text: "#9b9a97",
      background: "#ebeced"
    },
    brown: {
      text: "#64473a",
      background: "#e9e5e3"
    },
    red: {
      text: "#e03e3e",
      background: "#fbe4e4"
    },
    orange: {
      text: "#d9730d",
      background: "#f6e9d9"
    },
    yellow: {
      text: "#dfab01",
      background: "#fbf3db"
    },
    green: {
      text: "#4d6461",
      background: "#ddedea"
    },
    blue: {
      text: "#0b6e99",
      background: "#ddebf1"
    },
    purple: {
      text: "#6940a5",
      background: "#eae4f2"
    },
    pink: {
      text: "#ad1a72",
      background: "#f4dfeb"
    }
  }, jc = {
    gray: {
      text: "#bebdb8",
      background: "#9b9a97"
    },
    brown: {
      text: "#8e6552",
      background: "#64473a"
    },
    red: {
      text: "#ec4040",
      background: "#be3434"
    },
    orange: {
      text: "#e3790d",
      background: "#b7600a"
    },
    yellow: {
      text: "#dfab01",
      background: "#b58b00"
    },
    green: {
      text: "#6b8b87",
      background: "#4d6461"
    },
    blue: {
      text: "#0e87bc",
      background: "#0b6e99"
    },
    purple: {
      text: "#8552d7",
      background: "#6940a5"
    },
    pink: {
      text: "#da208f",
      background: "#ad1a72"
    }
  };
  var Gc = class {
    constructor(n, t2, o) {
      this.mappings = t2, this.options = o;
    }
    async resolveFile(n) {
      var o;
      if (!((o = this.options) != null && o.resolveFileUrl))
        return (await fetch(n)).blob();
      const t2 = await this.options.resolveFileUrl(n);
      return t2 instanceof Blob ? t2 : (await fetch(t2)).blob();
    }
    mapStyles(n) {
      return Object.entries(n).map(([o, r]) => this.mappings.styleMapping[o](r, this));
    }
    mapInlineContent(n) {
      return this.mappings.inlineContentMapping[n.type](
        n,
        this
      );
    }
    transformInlineContent(n) {
      return n.map((t2) => this.mapInlineContent(t2));
    }
    async mapBlock(n, t2, o) {
      return this.mappings.blockMapping[n.type](
        n,
        this,
        t2,
        o
      );
    }
  };
  function qc(e) {
    return {
      createBlockMapping: (n) => n,
      createInlineContentMapping: (n) => n,
      createStyleMapping: (n) => n
    };
  }
  var He;
  async function ec() {
    return He || (He = (async () => {
      const [e, n] = await Promise.all([
        Promise.resolve().then(() => (init_module(), module_exports)),
        // use a dynamic import to encourage bundle-splitting
        // and a smaller initial client bundle size
        Promise.resolve().then(() => __toESM(require_native(), 1))
      ]), t2 = "default" in e ? e.default : e, o = "default" in n ? n.default : n;
      return await t2.init({ data: o }), { emojiMart: t2, emojiData: o };
    })(), He);
  }
  async function Kc(e, n) {
    if (!zs("text", e))
      return [];
    const { emojiData: t2, emojiMart: o } = await ec();
    return (n.trim() === "" ? Object.values(t2.emojis) : await o.SearchIndex.search(n)).map((s2) => ({
      id: s2.skins[0].native,
      onItemClick: () => e.insertInlineContent(s2.skins[0].native + " ")
    }));
  }
  function Jc(e, ...n) {
    const t2 = [...e];
    for (const o of n)
      for (const r of o) {
        const s2 = t2.findLastIndex(
          (i) => i.group === r.group
        );
        s2 === -1 ? t2.push(r) : t2.splice(s2 + 1, 0, r);
      }
    return t2;
  }

  // src/index.js
  window.BlockNoteEditor = ro;
})();
